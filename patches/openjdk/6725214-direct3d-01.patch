diff -Nru openjdk.orig/jdk/make/common/shared/Platform.gmk openjdk/jdk/make/common/shared/Platform.gmk
--- openjdk.orig/jdk/make/common/shared/Platform.gmk	2011-01-08 01:00:26.000000000 +0000
+++ openjdk/jdk/make/common/shared/Platform.gmk	2011-01-08 01:26:50.431201774 +0000
@@ -421,7 +421,7 @@
   # ISHIELD_TEMP_MIN is the difference of an empty C:\TEMP vs. one after a
   #     bundles build on windows.
   ISHIELD_TEMP_MIN=250000
-  REQUIRED_DXSDK_VER = 0x0700
+  REQUIRED_DXSDK_VER = 0x0900
   # How much RAM does this machine have:
   MB_OF_MEMORY := $(shell \
     if [ -f "C:/cygwin/bin/free.exe" ] ; then \
diff -Nru openjdk.orig/jdk/make/common/shared/Sanity.gmk openjdk/jdk/make/common/shared/Sanity.gmk
--- openjdk.orig/jdk/make/common/shared/Sanity.gmk	2011-01-08 01:00:26.000000000 +0000
+++ openjdk/jdk/make/common/shared/Sanity.gmk	2011-01-08 01:26:50.431201774 +0000
@@ -97,7 +97,7 @@
     _WINDOWS_VERSION := Windows 2000 or Unknown (no systeminfo utility)
   endif
   WINDOWS_VERSION := $(strip $(_WINDOWS_VERSION))
-  DXSDK_VER := $(shell $(EGREP) DIRECTDRAW_VERSION $(DXSDK_INCLUDE_PATH)/ddraw.h 2>&1 | \
+  DXSDK_VER := $(shell $(EGREP) DIRECT3D_VERSION $(DXSDK_INCLUDE_PATH)/d3d9.h 2>&1 | \
     $(EGREP) "\#define" | $(NAWK) '{print $$3}')
 endif
 
@@ -1236,7 +1236,7 @@
 ######################################################
 sane-dxsdk:
 ifeq ($(PLATFORM), windows)
-	@if [ ! -r $(DXSDK_INCLUDE_PATH)/ddraw.h  ]; then \
+	@if [ ! -r $(DXSDK_INCLUDE_PATH)/d3d9.h  ]; then \
 	$(ECHO) "ERROR: You do not have access to a valid DirectX SDK Include dir.\n" \
 	  "      The value of DXSDK_INCLUDE_PATH must point a valid DX SDK dir.\n" \
 	  "      Please check your access to \n" \
@@ -1265,7 +1265,7 @@
 		"      This may result in a build failure.\n" \
 		"      The DirectX SDK Include dir was obtained from the following location:\n" \
 		" 	  $(DXSDK_INCLUDE_PATH) \n" \
-		"      Please change your DirectX SDK to version 7 or 9 (Summer 2004 Update or newer).\n" \
+		"      Please change your DirectX SDK to version 9 (Summer 2004 Update or newer).\n" \
 	        "      Microsoft DirectX 9 SDK can be downloaded from the following location:\n" \
 	        "          http://msdn.microsoft.com/library/default.asp?url=/downloads/list/directx.asp\n" \
 		"      Or  http://www.microsoft.com/directx\n" \
diff -Nru openjdk.orig/jdk/make/sun/awt/FILES_c_windows.gmk openjdk/jdk/make/sun/awt/FILES_c_windows.gmk
--- openjdk.orig/jdk/make/sun/awt/FILES_c_windows.gmk	2011-01-07 21:32:51.000000000 +0000
+++ openjdk/jdk/make/sun/awt/FILES_c_windows.gmk	2011-01-08 01:26:50.431201774 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -112,29 +112,11 @@
 	GDIHashtable.cpp \
 	Devices.cpp \
 	ObjectList.cpp \
-	DDBlitLoops.cpp \
-	DDRenderer.cpp \
 	GDIBlitLoops.cpp \
 	GDIRenderer.cpp \
-	Win32OffScreenSurfaceData.cpp \
-	Win32SurfaceData.cpp \
-	WinBackBufferSurfaceData.cpp \
+	GDIWindowSurfaceData.cpp \
 	WindowsFlags.cpp \
-	WBufferStrategy.cpp \
 	WPrinterJob.cpp \
-	ddrawUtils.cpp \
-	dxCapabilities.cpp \
-	dxInit.cpp \
-	RegistryKey.cpp \
-	D3DBlitLoops.cpp \
-	D3DContext.cpp \
-	D3DMaskFill.cpp \
-	D3DRenderer.cpp \
-	D3DRuntimeTest.cpp \
-	D3DSurfaceData.cpp \
-	D3DTextRenderer_md.cpp \
-	D3DUtils.cpp \
-	ddrawObject.cpp \
 	awt_AWTEvent.cpp \
 	awt_BitmapUtil.cpp \
 	awt_Brush.cpp \
@@ -199,6 +181,23 @@
 	awt_Mlib.cpp \
 	awt_new.cpp \
 	awt_TrayIcon.cpp \
+	ShaderList.cpp \
+	D3DBlitLoops.cpp \
+	D3DBufImgOps.cpp \
+	D3DContext.cpp \
+	D3DGlyphCache.cpp \
+	D3DGraphicsDevice.cpp \
+	D3DMaskBlit.cpp \
+	D3DMaskCache.cpp \
+	D3DMaskFill.cpp \
+	D3DPipelineManager.cpp \
+	D3DPaints.cpp \
+	D3DRenderer.cpp \
+	D3DRenderQueue.cpp \
+	D3DResourceManager.cpp \
+	D3DSurfaceData.cpp \
+	D3DTextRenderer.cpp \
+	D3DVertexCacher.cpp \
 	ShellFolder2.cpp \
 	ThemeReader.cpp \
 	ComCtl32Util.cpp \
diff -Nru openjdk.orig/jdk/make/sun/awt/FILES_export_unix.gmk openjdk/jdk/make/sun/awt/FILES_export_unix.gmk
--- openjdk.orig/jdk/make/sun/awt/FILES_export_unix.gmk	2011-01-08 01:00:22.000000000 +0000
+++ openjdk/jdk/make/sun/awt/FILES_export_unix.gmk	2011-01-08 01:26:50.439201862 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -49,6 +49,9 @@
 	sun/java2d/loops/TransformHelper.java \
 	sun/java2d/loops/GraphicsPrimitiveMgr.java \
         sun/java2d/loops/GraphicsPrimitive.java \
+        sun/java2d/pipe/hw/AccelSurface.java \
+	sun/java2d/pipe/hw/AccelDeviceEventNotifier.java \
+        sun/java2d/pipe/hw/ContextCapabilities.java \
         sun/awt/image/ImagingLib.java \
 	sun/java2d/SurfaceData.java \
 	sun/java2d/SunGraphics2D.java \
@@ -74,6 +77,7 @@
 	sun/java2d/pipe/BufferedContext.java \
 	sun/java2d/pipe/BufferedMaskBlit.java \
 	sun/java2d/pipe/BufferedOpCodes.java \
+	sun/java2d/pipe/BufferedMaskBlit.java \
 	sun/java2d/pipe/BufferedPaints.java \
 	sun/java2d/pipe/BufferedRenderPipe.java \
 	sun/java2d/pipe/BufferedTextPipe.java \
diff -Nru openjdk.orig/jdk/make/sun/awt/FILES_export_windows.gmk openjdk/jdk/make/sun/awt/FILES_export_windows.gmk
--- openjdk.orig/jdk/make/sun/awt/FILES_export_windows.gmk	2011-01-07 21:32:51.000000000 +0000
+++ openjdk/jdk/make/sun/awt/FILES_export_windows.gmk	2011-01-08 01:26:50.439201862 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -125,14 +125,9 @@
 	sun/awt/image/BufImgSurfaceData.java \
 	sun/awt/image/DataBufferNative.java \
         sun/awt/shell/Win32ShellFolder2.java \
-	sun/java2d/windows/DDBlitLoops.java \
-	sun/java2d/windows/DDRenderer.java \
-	sun/java2d/windows/DDScaleLoops.java \
 	sun/java2d/windows/GDIBlitLoops.java \
 	sun/java2d/windows/GDIRenderer.java \
-	sun/java2d/windows/Win32OffScreenSurfaceData.java \
-	sun/java2d/windows/Win32SurfaceData.java \
-	sun/java2d/windows/WinBackBufferSurfaceData.java \
+	sun/java2d/windows/GDIWindowSurfaceData.java \
         sun/java2d/windows/WindowsFlags.java \
 	sun/java2d/loops/Blit.java \
 	sun/java2d/loops/BlitBg.java \
@@ -219,6 +214,9 @@
 	sun/awt/windows/WBufferStrategy.java \
 	sun/awt/windows/WTrayIconPeer.java \
 	sun/awt/image/ImagingLib.java \
+        sun/java2d/pipe/hw/AccelSurface.java \
+        sun/java2d/pipe/hw/AccelDeviceEventNotifier.java \
+        sun/java2d/pipe/hw/ContextCapabilities.java \
         sun/java2d/pipe/BufferedContext.java \
         sun/java2d/pipe/BufferedMaskBlit.java \
         sun/java2d/pipe/BufferedOpCodes.java \
@@ -229,13 +227,6 @@
 	sun/java2d/pipe/ShapeSpanIterator.java \
 	sun/java2d/pipe/SpanClipRenderer.java \
 	sun/java2d/pipe/RegionIterator.java \
- 	sun/java2d/d3d/D3DBlitLoops.java \
- 	sun/java2d/d3d/D3DMaskFill.java \
- 	sun/java2d/d3d/D3DRenderer.java \
- 	sun/java2d/d3d/D3DContext.java \
- 	sun/java2d/d3d/D3DSurfaceData.java \
- 	sun/java2d/d3d/D3DBackBufferSurfaceData.java \
- 	sun/java2d/d3d/D3DTextRenderer.java \
 	sun/java2d/opengl/OGLBlitLoops.java \
 	sun/java2d/opengl/OGLContext.java \
 	sun/java2d/opengl/OGLMaskFill.java \
@@ -245,4 +236,13 @@
 	sun/java2d/opengl/OGLSurfaceData.java \
 	sun/java2d/opengl/OGLTextRenderer.java \
 	sun/java2d/opengl/WGLGraphicsConfig.java \
-	sun/java2d/opengl/WGLSurfaceData.java
+	sun/java2d/opengl/WGLSurfaceData.java \
+	sun/java2d/d3d/D3DBlitLoops.java \
+	sun/java2d/d3d/D3DGraphicsDevice.java \
+	sun/java2d/d3d/D3DSurfaceData.java \
+	sun/java2d/d3d/D3DMaskFill.java \
+	sun/java2d/d3d/D3DPaints.java \
+	sun/java2d/d3d/D3DRenderQueue.java \
+	sun/java2d/d3d/D3DRenderer.java \
+	sun/java2d/d3d/D3DTextRenderer.java \
+	sun/java2d/d3d/D3DContext.java
diff -Nru openjdk.orig/jdk/make/sun/awt/make.depend openjdk/jdk/make/sun/awt/make.depend
--- openjdk.orig/jdk/make/sun/awt/make.depend	2011-01-07 21:32:51.000000000 +0000
+++ openjdk/jdk/make/sun/awt/make.depend	2011-01-08 01:26:50.443201905 +0000
@@ -1,4 +1,4 @@
-$(OBJDIR)/AccelGlyphCache.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h
+$(OBJDIR)/AccelGlyphCache.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h
 
 $(OBJDIR)/AlphaMacros.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
@@ -14,149 +14,151 @@
 
 $(OBJDIR)/AnyShort.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/AnyShort.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/LoopMacros.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/awt_AWTEvent.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_AWTEvent.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_BitmapUtil.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_BitmapUtil.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_BitmapUtil.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_BitmapUtil.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Brush.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Brush.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Button.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Button.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WButtonPeer.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Button.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Button.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Button.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WButtonPeer.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Button.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Canvas.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsConfig.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Canvas.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsConfig.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Checkbox.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Checkbox.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WCheckboxPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Checkbox.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Checkbox.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Checkbox.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WCheckboxPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Checkbox.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Choice.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Choice.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Toolkit.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WChoicePeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Choice.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dimension.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Choice.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Choice.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Toolkit.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WChoicePeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Choice.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dimension.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Clipboard.obj::	$(CLASSHDRDIR)/sun_awt_windows_WClipboard.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Clipboard.h ../../../src/windows/native/sun/windows/awt_DataTransferer.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Clipboard.obj::	$(CLASSHDRDIR)/sun_awt_windows_WClipboard.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Clipboard.h ../../../src/windows/native/sun/windows/awt_DataTransferer.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Color.obj::	$(CLASSHDRDIR)/sun_awt_windows_WColor.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Color.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Color.obj::	$(CLASSHDRDIR)/sun_awt_windows_WColor.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Color.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Component.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Color.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_InputMethodEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_MouseWheelEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Insets.h $(CLASSHDRDIR)/java_awt_KeyboardFocusManager.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Toolkit.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WInputMethod.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPanelPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jawt.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Cursor.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dimension.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_InputEvent.h ../../../src/windows/native/sun/windows/awt_InputTextInfor.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_KeyEvent.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_MouseEvent.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Component.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Color.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_InputMethodEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_MouseWheelEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Insets.h $(CLASSHDRDIR)/java_awt_KeyboardFocusManager.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Toolkit.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WInputMethod.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPanelPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jawt.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Cursor.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dimension.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_InputEvent.h ../../../src/windows/native/sun/windows/awt_InputTextInfor.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_KeyEvent.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_MouseEvent.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Container.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Container.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Cursor.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Cursor.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WCustomCursor.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WGlobalCursorManager.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Cursor.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_IconCursor.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Cursor.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Cursor.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WCustomCursor.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WGlobalCursorManager.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Cursor.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_IconCursor.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_DataTransferer.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_TextComponent.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_datatransfer_DataTransferer.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDataTransferer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/locale_str.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_DataTransferer.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_TextComponent.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_DataTransferer.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_TextComponent.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_datatransfer_DataTransferer.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDataTransferer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/common/locale_str.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_DataTransferer.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_TextComponent.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Debug.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Debug.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
 $(OBJDIR)/awt_Desktop.obj::	../../../src/share/javavm/export/jni.h ../../../src/windows/javavm/export/jni_md.h
 
-$(OBJDIR)/awt_DesktopProperties.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDesktopProperties.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DesktopProperties.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_DesktopProperties.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDesktopProperties.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DesktopProperties.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Dialog.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Dialog.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Dimension.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dimension.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Dimension.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dimension.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_dlls.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_dlls.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_DnDDS.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_dnd_DnDConstants.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_dnd_SunDragSourceContextPeer.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDragSourceContextPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Cursor.h ../../../src/windows/native/sun/windows/awt_DataTransferer.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DnDDS.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_DnDDS.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_dnd_DnDConstants.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_dnd_SunDragSourceContextPeer.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDragSourceContextPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Cursor.h ../../../src/windows/native/sun/windows/awt_DataTransferer.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DnDDS.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_DnDDT.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_dnd_DnDConstants.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDropTargetContextPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_DataTransferer.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_DnDDS.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_DnDDT.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_dnd_DnDConstants.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDropTargetContextPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_DataTransferer.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_DnDDS.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_DrawingSurface.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jawt.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jawt_md.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DrawingSurface.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_DrawingSurface.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jawt.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jawt_md.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DrawingSurface.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Event.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Event.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Event.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Event.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_FileDialog.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_FileDialog.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Font.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDefaultFontCharset.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFontPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/Disposer.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Font.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDefaultFontCharset.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFontPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/Disposer.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Frame.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/java_lang_Integer.h $(CLASSHDRDIR)/sun_awt_EmbeddedFrame.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WEmbeddedFrame.h $(CLASSHDRDIR)/sun_awt_windows_WEmbeddedFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_IconCursor.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Frame.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/java_lang_Integer.h $(CLASSHDRDIR)/sun_awt_EmbeddedFrame.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WEmbeddedFrame.h $(CLASSHDRDIR)/sun_awt_windows_WEmbeddedFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_IconCursor.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_GDIObject.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_GDIObject.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_IconCursor.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_IconCursor.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_IconCursor.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_IconCursor.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_ImageRep.obj::	$(CLASSHDRDIR)/sun_awt_image_ImageRepresentation.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/image/awt_parseImage.h ../../../src/share/native/sun/awt/image/imageInitIDs.h ../../../src/windows/javavm/export/jni_md.h
+$(OBJDIR)/awt_ImageRep.obj::	$(CLASSHDRDIR)/sun_awt_image_ImageRepresentation.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/image/awt_parseImage.h ../../../src/share/native/sun/awt/image/imageInitIDs.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/awt_ImagingLib.obj::	$(CLASSHDRDIR)/java_awt_color_ColorSpace.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_image_BufferedImage.h $(CLASSHDRDIR)/java_awt_image_ConvolveOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_image_ImagingLib.h $(CLASSHDRDIR)/sun_awt_image_IntegerComponentRaster.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/image/awt_parseImage.h ../../../src/share/native/sun/awt/image/imageInitIDs.h ../../../src/share/native/sun/awt/medialib/awt_ImagingLib.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_types.h ../../../src/share/native/sun/awt/medialib/safe_alloc.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/windows/awt_Mlib.h
+$(OBJDIR)/awt_ImagingLib.obj::	$(CLASSHDRDIR)/java_awt_color_ColorSpace.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_image_BufferedImage.h $(CLASSHDRDIR)/java_awt_image_ConvolveOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_image_ImagingLib.h $(CLASSHDRDIR)/sun_awt_image_IntegerComponentRaster.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/image/awt_parseImage.h ../../../src/share/native/sun/awt/image/imageInitIDs.h ../../../src/share/native/sun/awt/medialib/awt_ImagingLib.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_types.h ../../../src/share/native/sun/awt/medialib/safe_alloc.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/windows/awt_Mlib.h
 
-$(OBJDIR)/awt_InputEvent.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_InputEvent.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_InputEvent.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_InputEvent.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_InputMethod.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputMethodEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WInputMethod.h $(CLASSHDRDIR)/sun_awt_windows_WInputMethodDescriptor.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/common/locale_str.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_InputMethod.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputMethodEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WInputMethod.h $(CLASSHDRDIR)/sun_awt_windows_WInputMethodDescriptor.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/common/locale_str.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_InputTextInfor.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_InputTextInfor.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_InputTextInfor.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_InputTextInfor.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Insets.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Insets.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_KeyboardFocusManager.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_KeyboardFocusManager.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_KeyboardFocusManager.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_KeyboardFocusManager.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_KeyEvent.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_KeyEvent.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_KeyEvent.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_KeyEvent.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Label.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Label.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WLabelPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Label.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Label.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Label.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WLabelPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Label.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_List.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_List.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WListPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dimension.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_List.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_List.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_List.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WListPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dimension.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_List.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Menu.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Menu.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_MenuBar.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_MenuBar.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_MenuItem.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_CheckboxMenuItem.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Toolkit.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCheckboxMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DesktopProperties.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_MenuItem.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_CheckboxMenuItem.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Toolkit.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCheckboxMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DesktopProperties.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Mlib.obj::	$(CLASSHDRDIR)/java_awt_image_BufferedImage.h ../../../src/share/javavm/export/jni.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/sun/windows/awt_Mlib.h
+$(OBJDIR)/awt_Mlib.obj::	$(CLASSHDRDIR)/java_awt_image_BufferedImage.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/medialib/awt_ImagingLib.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_types.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt_Mlib.h ../../../src/windows/native/sun/windows/stdhdrs.h
 
 $(OBJDIR)/awt_MMStub.obj::	../../../src/windows/native/sun/windows/awt_MMStub.h
 
-$(OBJDIR)/awt_MouseEvent.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MouseEvent.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_MouseEvent.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MouseEvent.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_new.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_new.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_new.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_new.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Object.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Object.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Palette.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_CustomPaletteDef.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/img_util_md.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Palette.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_CustomPaletteDef.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/img_util_md.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Panel.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Panel.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Panel.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Panel.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_parseImage.obj::	$(CLASSHDRDIR)/java_awt_color_ColorSpace.h $(CLASSHDRDIR)/java_awt_image_BufferedImage.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_image_ImagingLib.h $(CLASSHDRDIR)/sun_awt_image_IntegerComponentRaster.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/image/awt_parseImage.h ../../../src/share/native/sun/awt/image/imageInitIDs.h ../../../src/share/native/sun/awt/medialib/safe_alloc.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/windows/awt_Mlib.h
+$(OBJDIR)/awt_parseImage.obj::	$(CLASSHDRDIR)/java_awt_color_ColorSpace.h $(CLASSHDRDIR)/java_awt_image_BufferedImage.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_image_ImagingLib.h $(CLASSHDRDIR)/sun_awt_image_IntegerComponentRaster.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/image/awt_parseImage.h ../../../src/share/native/sun/awt/image/imageInitIDs.h ../../../src/share/native/sun/awt/medialib/awt_ImagingLib.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_types.h ../../../src/share/native/sun/awt/medialib/safe_alloc.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/windows/awt_Mlib.h
 
-$(OBJDIR)/awt_Pen.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Pen.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_PopupMenu.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_PopupMenu.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPopupMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Event.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PopupMenu.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_PopupMenu.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_PopupMenu.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPopupMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Event.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PopupMenu.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_PrintControl.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintControl.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_PrintControl.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintControl.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_PrintDialog.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPrintDialog.h $(CLASSHDRDIR)/sun_awt_windows_WPrintDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintControl.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_PrintDialog.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPrintDialog.h $(CLASSHDRDIR)/sun_awt_windows_WPrintDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintControl.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_PrintJob.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPrinterJob.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintControl.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_PrintJob.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPrinterJob.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintControl.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Rectangle.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Rectangle.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Rectangle.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Rectangle.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Robot.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WRobotPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Robot.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Robot.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WRobotPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Robot.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Scrollbar.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Scrollbar.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WScrollbarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Scrollbar.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Scrollbar.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Scrollbar.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WScrollbarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Scrollbar.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_ScrollPane.obj::	$(CLASSHDRDIR)/java_awt_Adjustable.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_AdjustmentEvent.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Insets.h $(CLASSHDRDIR)/java_awt_Scrollbar.h $(CLASSHDRDIR)/java_awt_ScrollPane.h $(CLASSHDRDIR)/java_awt_ScrollPaneAdjustable.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WScrollbarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WScrollPanePeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Panel.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Scrollbar.h ../../../src/windows/native/sun/windows/awt_ScrollPane.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_ScrollPane.obj::	$(CLASSHDRDIR)/java_awt_Adjustable.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_AdjustmentEvent.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Insets.h $(CLASSHDRDIR)/java_awt_Scrollbar.h $(CLASSHDRDIR)/java_awt_ScrollPane.h $(CLASSHDRDIR)/java_awt_ScrollPaneAdjustable.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WScrollbarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WScrollPanePeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Panel.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Scrollbar.h ../../../src/windows/native/sun/windows/awt_ScrollPane.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_TextArea.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_TextArea.h $(CLASSHDRDIR)/java_awt_TextComponent.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextAreaPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_TextArea.h ../../../src/windows/native/sun/windows/awt_TextComponent.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_TextArea.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_TextArea.h $(CLASSHDRDIR)/java_awt_TextComponent.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextAreaPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_TextArea.h ../../../src/windows/native/sun/windows/awt_TextComponent.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_TextComponent.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_TextComponent.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_TextComponent.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_TextComponent.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_TextComponent.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_TextComponent.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_TextField.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_TextComponent.h $(CLASSHDRDIR)/java_awt_TextField.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextFieldPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_TextComponent.h ../../../src/windows/native/sun/windows/awt_TextField.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_TextField.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_TextComponent.h $(CLASSHDRDIR)/java_awt_TextField.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WTextFieldPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_KeyboardFocusManager.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_TextComponent.h ../../../src/windows/native/sun/windows/awt_TextField.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Toolkit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputMethodEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_List.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_ComponentPeer.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_PopupMenu.h $(CLASSHDRDIR)/java_awt_Toolkit.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WListPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPopupMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jawt.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jawt_md.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Clipboard.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Cursor.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DesktopProperties.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_DnDDS.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_DrawingSurface.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_InputEvent.h ../../../src/windows/native/sun/windows/awt_KeyEvent.h ../../../src/windows/native/sun/windows/awt_List.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_new.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PopupMenu.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/CmdIDList.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Toolkit.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputMethodEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_List.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_ComponentPeer.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_PopupMenu.h $(CLASSHDRDIR)/java_awt_Toolkit.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WListPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WPopupMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jawt.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jawt_md.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DPipelineManager.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Clipboard.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Cursor.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DesktopProperties.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_DnDDS.h ../../../src/windows/native/sun/windows/awt_DnDDT.h ../../../src/windows/native/sun/windows/awt_DrawingSurface.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_InputEvent.h ../../../src/windows/native/sun/windows/awt_KeyEvent.h ../../../src/windows/native/sun/windows/awt_List.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_new.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PopupMenu.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/CmdIDList.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_TrayIcon.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_ActionEvent.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_TrayIcon.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WTrayIconPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_TrayIcon.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_TrayIcon.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_ActionEvent.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_InputEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_TrayIcon.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WTrayIconPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_AWTEvent.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_TrayIcon.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Unicode.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Unicode.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Win32GraphicsConfig.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_image_DataBuffer.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_Win32GraphicsConfig.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsConfig.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Win32GraphicsConfig.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_image_DataBuffer.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_Win32GraphicsConfig.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsConfig.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Win32GraphicsDevice.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_color_ColorSpace.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_image_DataBuffer.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_Win32GraphicsDevice.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/awt/image/dither.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/img_util_md.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Win32GraphicsDevice.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_color_ColorSpace.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_image_DataBuffer.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_Win32GraphicsDevice.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/awt/image/dither.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/img_util_md.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Win32GraphicsEnv.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_Win32GraphicsEnvironment.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/dxInit.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Win32GraphicsEnv.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_Win32GraphicsEnvironment.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/awt_Window.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Container.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_ComponentEvent.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Insets.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_BitmapUtil.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_IconCursor.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Panel.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/awt_Window.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Container.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_ComponentEvent.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Insets.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_BitmapUtil.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Container.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_IconCursor.h ../../../src/windows/native/sun/windows/awt_Insets.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Panel.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
 $(OBJDIR)/Blit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_Blit.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
 $(OBJDIR)/BlitBg.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_BlitBg.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
+$(OBJDIR)/BufferedMaskBlit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedMaskBlit.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedOpCodes.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntBgr.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+
 $(OBJDIR)/BufferedRenderPipe.obj::	$(CLASSHDRDIR)/sun_java2d_pipe_BufferedOpCodes.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedRenderPipe.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/BufImgSurfaceData.obj::	$(CLASSHDRDIR)/sun_awt_image_BufImgSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/image/BufImgSurfaceData.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/img_util_md.h
+$(OBJDIR)/BufImgSurfaceData.obj::	$(CLASSHDRDIR)/sun_awt_image_BufImgSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/image/BufImgSurfaceData.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/img_util_md.h
 
 $(OBJDIR)/ByteBinary1Bit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/AnyByteBinary.h ../../../src/share/native/sun/java2d/loops/ByteBinary1Bit.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/LoopMacros.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
@@ -168,45 +170,53 @@
 
 $(OBJDIR)/ByteIndexed.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/AnyByte.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/ByteIndexed.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/Index12Gray.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntArgbBm.h ../../../src/share/native/sun/java2d/loops/IntArgbPre.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/LoopMacros.h ../../../src/share/native/sun/java2d/loops/ThreeByteBgr.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/CmdIDList.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/CmdIDList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/CmdIDList.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/CmdIDList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+
+$(OBJDIR)/ComCtl32Util.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+
+$(OBJDIR)/D3DBlitLoops.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DBlitLoops.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/ByteIndexed.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntArgbPre.h ../../../src/share/native/sun/java2d/loops/IntBgr.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/Ushort555Rgb.h ../../../src/share/native/sun/java2d/loops/Ushort565Rgb.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DBlitLoops.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
+
+$(OBJDIR)/D3DBufImgOps.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DBufImgOps.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
+
+$(OBJDIR)/D3DContext.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedTextPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DBufImgOps.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DGlyphCache.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPaints.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DPipelineManager.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DShaders.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DTextRenderer.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/ComCtl32Util.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/ComCtl32Util.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DGlyphCache.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedTextPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DGlyphCache.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DTextRenderer.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/D3DBlitLoops.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DBlitLoops.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DUtils.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DGraphicsDevice.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DGraphicsDevice.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DGraphicsDevice.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DPipelineManager.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/D3DContext.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DRuntimeTest.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DUtils.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DMaskBlit.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskBlit.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/D3DMaskFill.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DMaskFill.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DUtils.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DMaskCache.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/D3DRenderer.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DRenderer.h $(CLASSHDRDIR)/sun_java2d_windows_DDRenderer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DUtils.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DMaskFill.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DMaskFill.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskFill.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/D3DRuntimeTest.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DRuntimeTest.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DTestRaster.h ../../../src/windows/native/sun/java2d/d3d/D3DUtils.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/dxInit.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DPaints.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPaints.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/D3DSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DBackBufferSurfaceData.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DPipelineManager.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DBadHardware.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DPipelineManager.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/D3DTextRenderer_md.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DTextRenderer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DUtils.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DRenderer.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DRenderer.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedRenderPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderer.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/D3DUtils.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DUtils.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DRenderQueue.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DBlitLoops.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedOpCodes.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedRenderPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedTextPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DBlitLoops.h ../../../src/windows/native/sun/java2d/d3d/D3DBufImgOps.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskBlit.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskFill.h ../../../src/windows/native/sun/java2d/d3d/D3DPaints.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DPipelineManager.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderer.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DTextRenderer.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/DataBufferNative.obj::	$(CLASSHDRDIR)/sun_awt_image_DataBufferNative.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h
+$(OBJDIR)/D3DResourceManager.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedTextPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPaints.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DTextRenderer.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/DDBlitLoops.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_DDBlitLoops.h $(CLASSHDRDIR)/sun_java2d_windows_DDScaleLoops.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DPipelineManager.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_BitmapUtil.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/ddrawObject.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_DisplayMode.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DTextRenderer.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DTextRenderer.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedTextPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DGlyphCache.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DRenderQueue.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DTextRenderer.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/ddrawUtils.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/dxInit.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/D3DVertexCacher.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPaints.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/DDRenderer.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_DDRenderer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/DataBufferNative.obj::	$(CLASSHDRDIR)/sun_awt_image_DataBufferNative.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/debug_assert.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h
+$(OBJDIR)/debug_assert.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/debug_mem.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h
+$(OBJDIR)/debug_mem.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/debug_trace.obj::     ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h
+$(OBJDIR)/debug_trace.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/debug_util.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h
+$(OBJDIR)/debug_util.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/Devices.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/Devices.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelDeviceEventNotifier.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/ShaderList.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DMaskCache.h ../../../src/windows/native/sun/java2d/d3d/D3DPipeline.h ../../../src/windows/native/sun/java2d/d3d/D3DPipelineManager.h ../../../src/windows/native/sun/java2d/d3d/D3DResourceManager.h ../../../src/windows/native/sun/java2d/d3d/D3DSurfaceData.h ../../../src/windows/native/sun/java2d/d3d/D3DVertexCacher.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
 $(OBJDIR)/Disposer.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/Disposer.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
@@ -214,17 +224,13 @@
 
 $(OBJDIR)/DrawLine.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_DrawLine.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/DrawPath.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_DrawPath.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/DrawPath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/ProcessPath.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/DrawPath.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_DrawPath.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/DrawPath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/ProcessPath.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/DrawPolygons.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_DrawPolygons.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/DrawPolygons.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_DrawPolygons.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
 $(OBJDIR)/DrawRect.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_DrawRect.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/dxCapabilities.obj::	../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h
-
-$(OBJDIR)/dxInit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/d3d/D3DRuntimeTest.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/dxInit.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
-
-$(OBJDIR)/FillPath.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_FillPath.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/DrawPath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/ProcessPath.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/FillPath.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_FillPath.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/DrawPath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/ProcessPath.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
 $(OBJDIR)/FillRect.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_FillRect.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
@@ -234,21 +240,23 @@
 
 $(OBJDIR)/FourByteAbgrPre.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/Any4Byte.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/ByteIndexed.h ../../../src/share/native/sun/java2d/loops/FourByteAbgrPre.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntArgbBm.h ../../../src/share/native/sun/java2d/loops/IntArgbPre.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/LoopMacros.h ../../../src/share/native/sun/java2d/loops/ThreeByteBgr.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/GDIBlitLoops.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_GDIBlitLoops.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/GDIBlitLoops.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_GDIBlitLoops.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/GDIHashtable.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/GDIHashtable.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/GDIRenderer.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_geom_PathIterator.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_GDIRenderer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/GDIRenderer.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_geom_PathIterator.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_GDIRenderer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/gifdecoder.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h
+$(OBJDIR)/GDIWindowSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_GDIWindowSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/Disposer.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+
+$(OBJDIR)/gifdecoder.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
 $(OBJDIR)/GraphicsPrimitiveMgr.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_GraphicsPrimitiveMgr.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/Hashtable.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/Hashtable.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/imageInitIDs.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/image/imageInitIDs.h ../../../src/windows/javavm/export/jni_md.h
+$(OBJDIR)/imageInitIDs.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/image/imageInitIDs.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/img_colors.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h
+$(OBJDIR)/img_colors.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h
 
 $(OBJDIR)/img_globals.obj::	$(CLASSHDRDIR)/java_awt_image_DirectColorModel.h $(CLASSHDRDIR)/java_awt_image_IndexColorModel.h $(CLASSHDRDIR)/java_awt_Transparency.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/windows/javavm/export/jni_md.h
 
@@ -256,7 +264,7 @@
 
 $(OBJDIR)/Index8Gray.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/AnyByte.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/ByteIndexed.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/Index12Gray.h ../../../src/share/native/sun/java2d/loops/Index8Gray.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntArgbPre.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/LoopMacros.h ../../../src/share/native/sun/java2d/loops/ThreeByteBgr.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/initIDs.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h
+$(OBJDIR)/initIDs.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
 $(OBJDIR)/IntArgb.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/AnyInt.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/ByteIndexed.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/Index12Gray.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntArgbBm.h ../../../src/share/native/sun/java2d/loops/IntArgbPre.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/LoopMacros.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
@@ -274,171 +282,59 @@
 
 $(OBJDIR)/MaskFill.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_MaskFill.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/mlib_c_ImageAffineIndex_BC.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageColormap.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageAffineIndex_BL.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageColormap.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageAffine_BC.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageAffine_BC_S16.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageAffine_BC_U16.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageAffine_BL.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageAffine_BL_S16.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageAffine_BL_U16.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageAffine_NN.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageConvClearEdge.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConvEdge.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageConvCopyEdge.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConvEdge.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageConvVersion.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageConv_f.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageCopy.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCheck.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCopy.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageLookUp.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageLookUp.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCheck.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCopy.h ../../../src/share/native/sun/awt/medialib/mlib_ImageLookUp.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageLookUp_f.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageLookUp.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCopy.h ../../../src/share/native/sun/awt/medialib/mlib_ImageLookUp.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_c_ImageThresh1_U8.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageThresh1.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCheck.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageAffine.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCheck.h ../../../src/share/native/sun/awt/medialib/mlib_ImageColormap.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageAffineEdge.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageColormap.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageAffine_BC_D64.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageAffine_BC_F32.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageAffine_BC_S32.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageAffine_BL_D64.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageAffine_BL_F32.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageAffine_BL_S32.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageAffine_NN.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageAffine_NN_Bit.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/MouseInfo.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/mlib_ImageClipping.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCheck.h ../../../src/share/native/sun/awt/medialib/mlib_ImageClipping.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCreate.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/ObjectList.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/mlib_ImageColorTrue2Index.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCheck.h ../../../src/share/native/sun/awt/medialib/mlib_ImageColormap.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLBlitLoops.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLBlitLoops.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLBlitLoops.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConv2x2_f.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLBufImgOps.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLBufImgOps.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConvClearEdge_Bit.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConvEdge.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLContext.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConvClearEdge_Fp.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConvEdge.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLFuncs.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConvCopyEdge_Bit.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConvEdge.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLMaskBlit.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLMaskBlit.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConvKernelConvert.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_SysMath.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLMaskFill.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLMaskFill.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLMaskFill.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/opengl/OGLVertexCache.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConvMxN.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCheck.h ../../../src/share/native/sun/awt/medialib/mlib_ImageClipping.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConvEdge.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCreate.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLPaints.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedPaints.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLPaints.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConvMxN_ext.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLRenderer.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLRenderer.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedRenderPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderer.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConvMxN_Fp.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCheck.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_SysMath.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLRenderQueue.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLBlitLoops.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedOpCodes.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedRenderPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedTextPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLBlitLoops.h ../../../src/share/native/sun/java2d/opengl/OGLBufImgOps.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLMaskBlit.h ../../../src/share/native/sun/java2d/opengl/OGLMaskFill.h ../../../src/share/native/sun/java2d/opengl/OGLPaints.h ../../../src/share/native/sun/java2d/opengl/OGLRenderer.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/opengl/OGLTextRenderer.h ../../../src/share/native/sun/java2d/opengl/OGLVertexCache.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConv_16ext.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConv_16nw.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLTextRenderer.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLTextRenderer.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedTextPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/opengl/OGLTextRenderer.h ../../../src/share/native/sun/java2d/opengl/OGLVertexCache.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConv_32nw.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/OGLVertexCache.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLPaints.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/opengl/OGLVertexCache.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
 
-$(OBJDIR)/mlib_ImageConv_8ext.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
+$(OBJDIR)/ProcessPath.obj::	$(CLASSHDRDIR)/java_awt_geom_PathIterator.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/ProcessPath.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/mlib_ImageConv_8nw.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageConv_D64nw.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageConv_F32nw.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageConv_u16ext.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageConv_u16nw.obj::	../../../src/share/native/sun/awt/medialib/mlib_c_ImageConv.h ../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageCopy_Bit.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCopy.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageCreate.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCreate.h ../../../src/share/native/sun/awt/medialib/mlib_ImageRowTable.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageDivTables.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageFilters.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageLookUp_64.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCopy.h ../../../src/share/native/sun/awt/medialib/mlib_ImageLookUp.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageLookUp_Bit.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageCopy.h ../../../src/share/native/sun/awt/medialib/mlib_ImageLookUp.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageScanPoly.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_ImageAffine.h ../../../src/share/native/sun/awt/medialib/mlib_ImageDivTables.h ../../../src/share/native/sun/awt/medialib/mlib_ImageFilters.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_SysMath.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_ImageUtils.obj::	../../../src/share/native/sun/awt/medialib/mlib_image.h ../../../src/share/native/sun/awt/medialib/mlib_image_blend_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_get.h ../../../src/share/native/sun/awt/medialib/mlib_image_proto.h ../../../src/share/native/sun/awt/medialib/mlib_image_types.h ../../../src/share/native/sun/awt/medialib/mlib_status.h ../../../src/share/native/sun/awt/medialib/mlib_sys.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/mlib_sys.obj::	../../../src/share/native/sun/awt/medialib/mlib_SysMath.h ../../../src/share/native/sun/awt/medialib/mlib_sys_proto.h ../../../src/share/native/sun/awt/medialib/mlib_types.h
-
-$(OBJDIR)/MouseInfo.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
-
-$(OBJDIR)/ObjectList.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
-
-$(OBJDIR)/OGLBlitLoops.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLBlitLoops.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLBlitLoops.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLBufImgOps.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLBufImgOps.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLContext.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLFuncs.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLMaskBlit.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLMaskBlit.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLMaskFill.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLMaskFill.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLMaskFill.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/opengl/OGLVertexCache.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLPaints.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedPaints.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLPaints.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLRenderer.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLRenderer.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedRenderPipe.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderer.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLRenderQueue.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLBlitLoops.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedOpCodes.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedRenderPipe.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedTextPipe.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLBlitLoops.h ../../../src/share/native/sun/java2d/opengl/OGLBufImgOps.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLMaskBlit.h ../../../src/share/native/sun/java2d/opengl/OGLMaskFill.h ../../../src/share/native/sun/java2d/opengl/OGLPaints.h ../../../src/share/native/sun/java2d/opengl/OGLRenderer.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/opengl/OGLTextRenderer.h ../../../src/share/native/sun/java2d/opengl/OGLVertexCache.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLTextRenderer.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLTextRenderer.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedTextPipe.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/opengl/OGLTextRenderer.h ../../../src/share/native/sun/java2d/opengl/OGLVertexCache.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/OGLVertexCache.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_SunGraphics2D.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLPaints.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/opengl/OGLVertexCache.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h
-
-$(OBJDIR)/ProcessPath.obj::	$(CLASSHDRDIR)/java_awt_geom_PathIterator.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/ProcessPath.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
-
-$(OBJDIR)/Region.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h
-
-$(OBJDIR)/RegistryKey.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h
+$(OBJDIR)/Region.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
 $(OBJDIR)/RenderBuffer.obj::	$(CLASSHDRDIR)/sun_java2d_pipe_RenderBuffer.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/ScaledBlit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_ScaledBlit.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/ScaledBlit.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/sun_java2d_loops_ScaledBlit.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
 $(OBJDIR)/ShapeSpanIterator.obj::	$(CLASSHDRDIR)/java_awt_geom_PathIterator.h $(CLASSHDRDIR)/sun_java2d_pipe_ShapeSpanIterator.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/pipe/PathConsumer2D.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
 $(OBJDIR)/ShellFolder2.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/SpanClipRenderer.obj::	$(CLASSHDRDIR)/sun_java2d_pipe_RegionIterator.h $(CLASSHDRDIR)/sun_java2d_pipe_SpanClipRenderer.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h
+$(OBJDIR)/SpanClipRenderer.obj::	$(CLASSHDRDIR)/sun_java2d_pipe_RegionIterator.h $(CLASSHDRDIR)/sun_java2d_pipe_SpanClipRenderer.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
 $(OBJDIR)/SurfaceData.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/Disposer.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/ThemeReader.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_ThemeReader.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/ThemeReader.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_ThemeReader.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
 $(OBJDIR)/ThreeByteBgr.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/Any3Byte.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/ByteIndexed.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntArgbBm.h ../../../src/share/native/sun/java2d/loops/IntArgbPre.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/LoopMacros.h ../../../src/share/native/sun/java2d/loops/ThreeByteBgr.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/Trace.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h
+$(OBJDIR)/Trace.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h
 
-$(OBJDIR)/TransformHelper.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_loops_TransformHelper.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
+$(OBJDIR)/TransformHelper.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_loops_TransformHelper.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/UnicowsLoader.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/UnicowsLoader.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
 $(OBJDIR)/Ushort4444Argb.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/AnyShort.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/ByteIndexed.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntArgbBm.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/LoopMacros.h ../../../src/share/native/sun/java2d/loops/ThreeByteBgr.h ../../../src/share/native/sun/java2d/loops/Ushort4444Argb.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
@@ -452,18 +348,10 @@
 
 $(OBJDIR)/UshortIndexed.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/sun/java2d/loops/AlphaMacros.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/AnyByte.h ../../../src/share/native/sun/java2d/loops/ByteGray.h ../../../src/share/native/sun/java2d/loops/ByteIndexed.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/loops/Index12Gray.h ../../../src/share/native/sun/java2d/loops/IntArgb.h ../../../src/share/native/sun/java2d/loops/IntArgbBm.h ../../../src/share/native/sun/java2d/loops/IntArgbPre.h ../../../src/share/native/sun/java2d/loops/IntDcm.h ../../../src/share/native/sun/java2d/loops/IntRgb.h ../../../src/share/native/sun/java2d/loops/LineUtils.h ../../../src/share/native/sun/java2d/loops/LoopMacros.h ../../../src/share/native/sun/java2d/loops/ThreeByteBgr.h ../../../src/share/native/sun/java2d/loops/UshortGray.h ../../../src/share/native/sun/java2d/loops/UshortIndexed.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h
 
-$(OBJDIR)/WBufferStrategy.obj::	$(CLASSHDRDIR)/sun_awt_windows_WBufferStrategy.h ../../../src/share/javavm/export/jni.h ../../../src/share/native/common/jni_util.h ../../../src/windows/javavm/export/jni_md.h
-
-$(OBJDIR)/WGLGraphicsConfig.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_opengl_WGLGraphicsConfig.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h ../../../src/windows/native/sun/java2d/opengl/WGLGraphicsConfig.h ../../../src/windows/native/sun/java2d/opengl/WGLSurfaceData.h
-
-$(OBJDIR)/WGLSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_opengl_WGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h ../../../src/windows/native/sun/java2d/opengl/WGLGraphicsConfig.h ../../../src/windows/native/sun/java2d/opengl/WGLSurfaceData.h
-
-$(OBJDIR)/Win32OffScreenSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_windows_Win32OffScreenSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
-
-$(OBJDIR)/Win32SurfaceData.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_Transparency.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_d3d_D3DContext.h $(CLASSHDRDIR)/sun_java2d_windows_Win32SurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/font/AccelGlyphCache.h ../../../src/share/native/sun/font/fontscalerdefs.h ../../../src/share/native/sun/font/glyphblitting.h ../../../src/share/native/sun/font/sunfontids.h ../../../src/share/native/sun/java2d/Disposer.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/Region.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/d3d/D3DContext.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/WGLGraphicsConfig.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_opengl_WGLGraphicsConfig.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h ../../../src/windows/native/sun/java2d/opengl/WGLGraphicsConfig.h ../../../src/windows/native/sun/java2d/opengl/WGLSurfaceData.h
 
-$(OBJDIR)/WinBackBufferSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_AlphaComposite.h $(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_java2d_windows_WinBackBufferSurfaceData.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/ddrawUtils.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/WGLSurfaceData.obj::	$(CLASSHDRDIR)/java_awt_image_AffineTransformOp.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLContext.h $(CLASSHDRDIR)/sun_java2d_opengl_OGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_opengl_WGLSurfaceData.h $(CLASSHDRDIR)/sun_java2d_pipe_BufferedContext.h $(CLASSHDRDIR)/sun_java2d_pipe_hw_AccelSurface.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/gl.h ../../../src/share/native/sun/java2d/opengl/J2D_GL/glext.h ../../../src/share/native/sun/java2d/opengl/OGLContext.h ../../../src/share/native/sun/java2d/opengl/OGLFuncMacros.h ../../../src/share/native/sun/java2d/opengl/OGLFuncs.h ../../../src/share/native/sun/java2d/opengl/OGLRenderQueue.h ../../../src/share/native/sun/java2d/opengl/OGLSurfaceData.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/opengl/J2D_GL/wglext.h ../../../src/windows/native/sun/java2d/opengl/OGLFuncs_md.h ../../../src/windows/native/sun/java2d/opengl/WGLGraphicsConfig.h ../../../src/windows/native/sun/java2d/opengl/WGLSurfaceData.h
 
-$(OBJDIR)/WindowsFlags.obj::	$(CLASSHDRDIR)/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/dxInit.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/WindowsFlags.obj::	../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/WindowsFlags.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
 
-$(OBJDIR)/WPrinterJob.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintControl.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/WPrinterJob.obj::	$(CLASSHDRDIR)/java_awt_AWTEvent.h $(CLASSHDRDIR)/java_awt_Component.h $(CLASSHDRDIR)/java_awt_Dialog.h $(CLASSHDRDIR)/java_awt_Dimension.h $(CLASSHDRDIR)/java_awt_Event.h $(CLASSHDRDIR)/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/java_awt_FileDialog.h $(CLASSHDRDIR)/java_awt_Font.h $(CLASSHDRDIR)/java_awt_FontMetrics.h $(CLASSHDRDIR)/java_awt_Frame.h $(CLASSHDRDIR)/java_awt_Menu.h $(CLASSHDRDIR)/java_awt_MenuBar.h $(CLASSHDRDIR)/java_awt_MenuComponent.h $(CLASSHDRDIR)/java_awt_MenuItem.h $(CLASSHDRDIR)/java_awt_peer_MenuComponentPeer.h $(CLASSHDRDIR)/java_awt_Window.h $(CLASSHDRDIR)/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/sun_awt_PlatformFont.h $(CLASSHDRDIR)/sun_awt_windows_WCanvasPeer.h $(CLASSHDRDIR)/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/sun_awt_windows_WDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFileDialogPeer.h $(CLASSHDRDIR)/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/sun_awt_windows_WFramePeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuBarPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuItemPeer.h $(CLASSHDRDIR)/sun_awt_windows_WMenuPeer.h $(CLASSHDRDIR)/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/sun_awt_windows_WToolkit.h $(CLASSHDRDIR)/sun_awt_windows_WWindowPeer.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Canvas.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_Dialog.h ../../../src/windows/native/sun/windows/awt_dlls.h ../../../src/windows/native/sun/windows/awt_FileDialog.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_Frame.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_Menu.h ../../../src/windows/native/sun/windows/awt_MenuBar.h ../../../src/windows/native/sun/windows/awt_MenuItem.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_PrintControl.h ../../../src/windows/native/sun/windows/awt_PrintDialog.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awt_Window.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
diff -Nru openjdk.orig/jdk/make/sun/awt/Makefile openjdk/jdk/make/sun/awt/Makefile
--- openjdk.orig/jdk/make/sun/awt/Makefile	2011-01-08 01:00:26.000000000 +0000
+++ openjdk/jdk/make/sun/awt/Makefile	2011-01-08 01:26:50.443201905 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1995, 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1995, 2008, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -69,7 +69,6 @@
 #
 AUTO_JAVA_PRUNE += RemoteOffScreenImage.java
 
-OTHER_CXXFLAGS += -DD3D_OVERLOADS
 OTHER_CFLAGS += $(GX_OPTION) -DMLIB_NO_LIBSUNMATH -DUNICODE -D_UNICODE
 OTHER_CXXFLAGS += $(GX_OPTION) -DUNICODE -D_UNICODE
 
@@ -486,7 +485,7 @@
 	-I$(SHARE_SRC)/native/sun/dc/path \
 	-I$(SHARE_SRC)/native/sun/dc/doe \
 	-I$(SHARE_SRC)/native/sun/awt/debug \
-	-I$(PLATFORM_SRC)/native/sun/awt \
+	-I$(PLATFORM_SRC)/native/sun/awt
 #	-I$(WINAWT_COMMON_native)
 
 # this is only required for compiling )/native/sun/awt/medialib/*.c files
diff -Nru openjdk.orig/jdk/make/sun/awt/mapfile-mawt-vers openjdk/jdk/make/sun/awt/mapfile-mawt-vers
--- openjdk.orig/jdk/make/sun/awt/mapfile-mawt-vers	2011-01-08 01:00:22.000000000 +0000
+++ openjdk/jdk/make/sun/awt/mapfile-mawt-vers	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2001, 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -417,12 +417,14 @@
                 Java_sun_java2d_x11_X11SurfaceData_XSetForeground;
                 Java_sun_java2d_x11_X11SurfaceData_XSetGraphicsExposures;
 
+                Java_sun_java2d_opengl_OGLContext_getOGLIdString;
                 Java_sun_java2d_opengl_OGLMaskFill_maskFill;
                 Java_sun_java2d_opengl_OGLRenderer_drawPoly;
                 Java_sun_java2d_opengl_OGLRenderQueue_flushBuffer;
                 Java_sun_java2d_opengl_OGLSurfaceData_initTexture;
                 Java_sun_java2d_opengl_OGLSurfaceData_initFBObject;
                 Java_sun_java2d_opengl_OGLSurfaceData_initFlipBackbuffer;
+                Java_sun_java2d_opengl_OGLSurfaceData_getTextureID;
                 Java_sun_java2d_opengl_OGLSurfaceData_getTextureTarget;
                 Java_sun_java2d_opengl_OGLTextRenderer_drawGlyphList;
                 Java_sun_java2d_opengl_GLXGraphicsConfig_getGLXConfigInfo;
@@ -511,6 +513,7 @@
                 AWTCharAscent;
                 AWTCharDescent;
                 AWTDrawGlyphList;
+                AccelGlyphCache_RemoveAllCellInfos;
 
 	local:
 		*;
diff -Nru openjdk.orig/jdk/make/sun/awt/mapfile-vers openjdk/jdk/make/sun/awt/mapfile-vers
--- openjdk.orig/jdk/make/sun/awt/mapfile-vers	2011-01-07 21:32:51.000000000 +0000
+++ openjdk/jdk/make/sun/awt/mapfile-vers	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -136,7 +136,6 @@
 		RegionToYXBandedRectangles;
 		GrPrim_CompGetXorInfo;
 		GrPrim_CompGetAlphaInfo;
-                GrPrim_ColorGetRGB;
                 J2dTraceImpl;
                 J2dTraceInit;
 		img_makePalette;
diff -Nru openjdk.orig/jdk/make/sun/awt/mapfile-vers-linux openjdk/jdk/make/sun/awt/mapfile-vers-linux
--- openjdk.orig/jdk/make/sun/awt/mapfile-vers-linux	2011-01-08 01:00:22.000000000 +0000
+++ openjdk/jdk/make/sun/awt/mapfile-vers-linux	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2002, 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -567,6 +567,7 @@
                 AWTCharAscent;
                 AWTCharDescent;
                 AWTDrawGlyphList;
+                AccelGlyphCache_RemoveAllCellInfos;
 
 	local:
 		*;
diff -Nru openjdk.orig/jdk/make/sun/font/FILES_c.gmk openjdk/jdk/make/sun/font/FILES_c.gmk
--- openjdk.orig/jdk/make/sun/font/FILES_c.gmk	2011-01-07 21:32:51.000000000 +0000
+++ openjdk/jdk/make/sun/font/FILES_c.gmk	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -114,7 +114,7 @@
 
 ifeq ($(PLATFORM),windows)
 FILES_c_platform = fontpath.c
-FILES_cpp_platform = D3DTextRenderer.cpp
+FILES_cpp_platform =
 else
 FILES_c_platform = X11FontScaler.c \
                    X11TextRenderer.c
diff -Nru openjdk.orig/jdk/make/sun/font/Makefile openjdk/jdk/make/sun/font/Makefile
--- openjdk.orig/jdk/make/sun/font/Makefile	2011-01-08 01:00:22.000000000 +0000
+++ openjdk/jdk/make/sun/font/Makefile	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -84,8 +84,6 @@
   OTHER_CFLAGS += -DCC_NOEX
   OTHER_CXXFLAGS += -DCC_NOEX
 
-  FILES_export += sun/java2d/d3d/D3DTextRenderer.java
-
 else # PLATFORM unix
 
   FILES_export += \
@@ -173,7 +171,6 @@
 
 ifeq ($(PLATFORM), windows)
 vpath %.cpp   $(PLATFORM_SRC)/native/sun/windows
-vpath %.cpp   $(PLATFORM_SRC)/native/sun/java2d/d3d
 else # PLATFORM
 
 #
@@ -208,7 +205,6 @@
 	    -I$(TEMPDIR)/../../sun.awt/awt/CClassHeaders
 
 ifeq ($(PLATFORM), windows)
-CPPFLAGS += -I$(PLATFORM_SRC)/native/sun/windows \
-	    -I$(PLATFORM_SRC)/native/sun/java2d/d3d
+CPPFLAGS += -I$(PLATFORM_SRC)/native/sun/windows
 endif
 
diff -Nru openjdk.orig/jdk/make/sun/headless/mapfile-vers openjdk/jdk/make/sun/headless/mapfile-vers
--- openjdk.orig/jdk/make/sun/headless/mapfile-vers	2011-01-07 21:32:51.000000000 +0000
+++ openjdk/jdk/make/sun/headless/mapfile-vers	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2001, 2006, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -98,6 +98,7 @@
                 AWTCharAscent;
                 AWTCharDescent;
                 AWTDrawGlyphList;
+                AccelGlyphCache_RemoveAllCellInfos;
 
 
 	local:
diff -Nru openjdk.orig/jdk/make/sun/jawt/make.depend openjdk/jdk/make/sun/jawt/make.depend
--- openjdk.orig/jdk/make/sun/jawt/make.depend	2011-01-07 21:32:51.000000000 +0000
+++ openjdk/jdk/make/sun/jawt/make.depend	2011-01-08 01:26:50.447201948 +0000
@@ -1 +1 @@
-$(OBJDIR)/jawt.obj::	$(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_AlphaComposite.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_AWTEvent.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_Component.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_Dimension.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_Event.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_Font.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_PlatformFont.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jawt.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/gdefs.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/loops/AlphaMath.h ../../../src/share/native/sun/java2d/loops/GlyphImageRef.h ../../../src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h ../../../src/share/native/sun/java2d/pipe/SpanIterator.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jawt_md.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/gdefs_md.h ../../../src/windows/native/sun/java2d/j2d_md.h ../../../src/windows/native/sun/java2d/windows/ddrawObject.h ../../../src/windows/native/sun/java2d/windows/dxCapabilities.h ../../../src/windows/native/sun/java2d/windows/RegistryKey.h ../../../src/windows/native/sun/java2d/windows/Win32SurfaceData.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DrawingSurface.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/stdhdrs.h ../../../src/windows/native/sun/windows/UnicowsLoader.h
+$(OBJDIR)/jawt.obj::	$(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_AWTEvent.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_Component.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_Dimension.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_Event.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_Font.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_event_FocusEvent.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_event_KeyEvent.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_event_MouseEvent.h $(CLASSHDRDIR)/../../awt/CClassHeaders/java_awt_event_WindowEvent.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_FontDescriptor.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_PlatformFont.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_windows_WComponentPeer.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_windows_WFontMetrics.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_windows_WObjectPeer.h $(CLASSHDRDIR)/../../awt/CClassHeaders/sun_awt_windows_WToolkit.h ../../../src/share/javavm/export/jawt.h ../../../src/share/javavm/export/jni.h ../../../src/share/javavm/export/jvm.h ../../../src/share/native/common/jlong.h ../../../src/share/native/common/jni_util.h ../../../src/share/native/sun/awt/debug/debug_assert.h ../../../src/share/native/sun/awt/debug/debug_mem.h ../../../src/share/native/sun/awt/debug/debug_trace.h ../../../src/share/native/sun/awt/debug/debug_util.h ../../../src/share/native/sun/awt/image/cvutils/img_globals.h ../../../src/share/native/sun/java2d/SurfaceData.h ../../../src/share/native/sun/java2d/Trace.h ../../../src/windows/javavm/export/jawt_md.h ../../../src/windows/javavm/export/jni_md.h ../../../src/windows/javavm/export/jvm_md.h ../../../src/windows/native/common/jlong_md.h ../../../src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h ../../../src/windows/native/sun/windows/Devices.h ../../../src/windows/native/sun/windows/GDIHashtable.h ../../../src/windows/native/sun/windows/Hashtable.h ../../../src/windows/native/sun/windows/ObjectList.h ../../../src/windows/native/sun/windows/UnicowsLoader.h ../../../src/windows/native/sun/windows/alloc.h ../../../src/windows/native/sun/windows/awt.h ../../../src/windows/native/sun/windows/awt_Brush.h ../../../src/windows/native/sun/windows/awt_Component.h ../../../src/windows/native/sun/windows/awt_Debug.h ../../../src/windows/native/sun/windows/awt_DrawingSurface.h ../../../src/windows/native/sun/windows/awt_Font.h ../../../src/windows/native/sun/windows/awt_GDIObject.h ../../../src/windows/native/sun/windows/awt_MMStub.h ../../../src/windows/native/sun/windows/awt_Multimon.h ../../../src/windows/native/sun/windows/awt_Object.h ../../../src/windows/native/sun/windows/awt_Palette.h ../../../src/windows/native/sun/windows/awt_Pen.h ../../../src/windows/native/sun/windows/awt_Toolkit.h ../../../src/windows/native/sun/windows/awt_Unicode.h ../../../src/windows/native/sun/windows/awt_Win32GraphicsDevice.h ../../../src/windows/native/sun/windows/awtmsg.h ../../../src/windows/native/sun/windows/colordata.h ../../../src/windows/native/sun/windows/stdhdrs.h
diff -Nru openjdk.orig/jdk/make/sun/xawt/mapfile-vers openjdk/jdk/make/sun/xawt/mapfile-vers
--- openjdk.orig/jdk/make/sun/xawt/mapfile-vers	2011-01-07 21:32:51.000000000 +0000
+++ openjdk/jdk/make/sun/xawt/mapfile-vers	2011-01-08 01:26:50.447201948 +0000
@@ -242,6 +242,7 @@
         AWTCharAscent;
         AWTCharDescent;
         AWTDrawGlyphList;
+        AccelGlyphCache_RemoveAllCellInfos;
 
         Java_sun_awt_X11_XToolkit_waitForEvents;
         Java_java_awt_Event_initIDs;
diff -Nru openjdk.orig/jdk/src/share/classes/java/awt/Component.java openjdk/jdk/src/share/classes/java/awt/Component.java
--- openjdk.orig/jdk/src/share/classes/java/awt/Component.java	2011-01-07 21:32:53.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/awt/Component.java	2011-01-08 01:26:50.447201948 +0000
@@ -73,7 +73,11 @@
 import sun.awt.im.CompositionArea;
 import sun.java2d.SunGraphics2D;
 import sun.java2d.pipe.Region;
+import sun.awt.image.VSyncedBSManager;
+import sun.java2d.pipe.hw.ExtendedBufferCapabilities;
+import static sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType.*;
 import sun.awt.RequestFocusController;
+import sun.java2d.SunGraphicsEnvironment;
 
 /**
  * A <em>component</em> is an object having a graphical representation
@@ -3500,6 +3504,11 @@
         if (numBuffers == 1) {
             bufferStrategy = new SingleBufferStrategy(caps);
         } else {
+            SunGraphicsEnvironment sge = (SunGraphicsEnvironment)
+                GraphicsEnvironment.getLocalGraphicsEnvironment();
+            if (!caps.isPageFlipping() && sge.isFlipStrategyPreferred(peer)) {
+                caps = new ProxyCapabilities(caps);
+            }
             // assert numBuffers > 1;
             if (caps.isPageFlipping()) {
                 bufferStrategy = new FlipSubRegionBufferStrategy(numBuffers, caps);
@@ -3510,6 +3519,25 @@
     }
 
     /**
+     * This is a proxy capabilities class used when a FlipBufferStrategy
+     * is created instead of the requested Blit strategy.
+     *
+     * @see sun.awt.SunGraphicsEnvironment#isFlipStrategyPreferred(ComponentPeer)
+     */
+    private class ProxyCapabilities extends ExtendedBufferCapabilities {
+        private BufferCapabilities orig;
+        private ProxyCapabilities(BufferCapabilities orig) {
+            super(orig.getFrontBufferCapabilities(),
+                  orig.getBackBufferCapabilities(),
+                  orig.getFlipContents() ==
+                      BufferCapabilities.FlipContents.BACKGROUND ?
+                      BufferCapabilities.FlipContents.BACKGROUND :
+                      BufferCapabilities.FlipContents.COPIED);
+            this.orig = orig;
+        }
+    }
+
+    /**
      * @return the buffer strategy used by this component
      * @see Window#createBufferStrategy
      * @see Canvas#createBufferStrategy
@@ -3638,16 +3666,30 @@
             width = getWidth();
             height = getHeight();
 
-            if (drawBuffer == null) {
-                peer.createBuffers(numBuffers, caps);
-            } else {
+            if (drawBuffer != null) {
                 // dispose the existing backbuffers
                 drawBuffer = null;
                 drawVBuffer = null;
                 destroyBuffers();
                 // ... then recreate the backbuffers
-                peer.createBuffers(numBuffers, caps);
             }
+
+            if (caps instanceof ExtendedBufferCapabilities) {
+                ExtendedBufferCapabilities ebc =
+                    (ExtendedBufferCapabilities)caps;
+                if (ebc.getVSync() == VSYNC_ON) {
+                    // if this buffer strategy is not allowed to be v-synced,
+                    // change the caps that we pass to the peer but keep on
+                    // trying to create v-synced buffers;
+                    // do not throw IAE here in case it is disallowed, see
+                    // ExtendedBufferCapabilities for more info
+                    if (!VSyncedBSManager.vsyncAllowed(this)) {
+                        caps = ebc.derive(VSYNC_DEFAULT);
+                    }
+                }
+            }
+
+            peer.createBuffers(numBuffers, caps);
             updateInternalBuffers();
         }
 
@@ -3692,7 +3734,23 @@
          */
         protected void flip(BufferCapabilities.FlipContents flipAction) {
             if (peer != null) {
-                peer.flip(flipAction);
+                Image backBuffer = getBackBuffer();
+                if (backBuffer != null) {
+                    peer.flip(0, 0,
+                              backBuffer.getWidth(null),
+                              backBuffer.getHeight(null), flipAction);
+                }
+            } else {
+                throw new IllegalStateException(
+                    "Component must have a valid peer");
+            }
+        }
+
+        void flipSubRegion(int x1, int y1, int x2, int y2,
+                      BufferCapabilities.FlipContents flipAction)
+        {
+            if (peer != null) {
+                peer.flip(x1, y1, x2, y2, flipAction);
             } else {
                 throw new IllegalStateException(
                     "Component must have a valid peer");
@@ -3703,6 +3761,7 @@
          * Destroys the buffers created through this object
          */
         protected void destroyBuffers() {
+            VSyncedBSManager.releaseVsync(this);
             if (peer != null) {
                 peer.destroyBuffers();
             } else {
@@ -3715,7 +3774,11 @@
          * @return the buffering capabilities of this strategy
          */
         public BufferCapabilities getCapabilities() {
-            return caps;
+            if (caps instanceof ProxyCapabilities) {
+                return ((ProxyCapabilities)caps).orig;
+            } else {
+                return caps;
+            }
         }
 
         /**
@@ -3803,6 +3866,14 @@
         }
 
         /**
+         * Makes specified region of the the next available buffer visible
+         * by either blitting or flipping.
+         */
+        void showSubRegion(int x1, int y1, int x2, int y2) {
+            flipSubRegion(x1, y1, x2, y2, caps.getFlipContents());
+        }
+
+        /**
          * {@inheritDoc}
          * @since 1.6
          */
@@ -4072,8 +4143,6 @@
 
     /**
      * Private class to perform sub-region flipping.
-     * REMIND: this subclass currently punts on subregions and
-     * flips the entire buffer.
      */
     private class FlipSubRegionBufferStrategy extends FlipBufferStrategy
         implements SubRegionShowable
@@ -4087,14 +4156,13 @@
         }
 
         public void show(int x1, int y1, int x2, int y2) {
-            show();
+            showSubRegion(x1, y1, x2, y2);
         }
 
         // This is invoked by Swing on the toolkit thread.
-        public boolean validateAndShow(int x1, int y1, int x2, int y2) {
-            revalidate(false);
-            if (!contentsRestored() && !contentsLost()) {
-                show();
+        public boolean showIfNotLost(int x1, int y1, int x2, int y2) {
+            if (!contentsLost()) {
+                showSubRegion(x1, y1, x2, y2);
                 return !contentsLost();
             }
             return false;
@@ -4122,9 +4190,8 @@
         }
 
         // This method is called by Swing on the toolkit thread.
-        public boolean validateAndShow(int x1, int y1, int x2, int y2) {
-            revalidate(false);
-            if (!contentsRestored() && !contentsLost()) {
+        public boolean showIfNotLost(int x1, int y1, int x2, int y2) {
+            if (!contentsLost()) {
                 showSubRegion(x1, y1, x2, y2);
                 return !contentsLost();
             }
diff -Nru openjdk.orig/jdk/src/share/classes/java/awt/GraphicsDevice.java openjdk/jdk/src/share/classes/java/awt/GraphicsDevice.java
--- openjdk.orig/jdk/src/share/classes/java/awt/GraphicsDevice.java	2011-01-07 21:32:53.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/awt/GraphicsDevice.java	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -236,6 +236,10 @@
      */
     public void setFullScreenWindow(Window w) {
         if (fullScreenWindow != null && windowedModeBounds != null) {
+            // if the window went into fs mode before it was realized it may
+            // have (0,0) dimensions
+            if (windowedModeBounds.width  == 0) windowedModeBounds.width  = 1;
+            if (windowedModeBounds.height == 0) windowedModeBounds.height = 1;
             fullScreenWindow.setBounds(windowedModeBounds);
         }
         // Set the full screen window
diff -Nru openjdk.orig/jdk/src/share/classes/java/awt/image/DataBuffer.java openjdk/jdk/src/share/classes/java/awt/image/DataBuffer.java
--- openjdk.orig/jdk/src/share/classes/java/awt/image/DataBuffer.java	2011-01-07 21:32:53.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/awt/image/DataBuffer.java	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -530,6 +530,12 @@
             public StateTrackableDelegate getTrackable(DataBuffer db) {
                 return db.theTrackable;
             }
+
+            public void setTrackable(DataBuffer db,
+                                     StateTrackableDelegate trackable)
+            {
+                db.theTrackable = trackable;
+            }
         });
     }
 }
diff -Nru openjdk.orig/jdk/src/share/classes/java/awt/peer/ComponentPeer.java openjdk/jdk/src/share/classes/java/awt/peer/ComponentPeer.java
--- openjdk.orig/jdk/src/share/classes/java/awt/peer/ComponentPeer.java	2011-01-07 21:32:53.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/awt/peer/ComponentPeer.java	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -88,7 +88,7 @@
     boolean     handlesWheelScrolling();
     void createBuffers(int numBuffers, BufferCapabilities caps) throws AWTException;
     Image getBackBuffer();
-    void flip(BufferCapabilities.FlipContents flipAction);
+    void flip(int x1, int y1, int x2, int y2, BufferCapabilities.FlipContents flipAction);
     void destroyBuffers();
 
     /**
diff -Nru openjdk.orig/jdk/src/share/classes/java/awt/Robot.java openjdk/jdk/src/share/classes/java/awt/Robot.java
--- openjdk.orig/jdk/src/share/classes/java/awt/Robot.java	2011-01-07 21:32:53.000000000 +0000
+++ openjdk/jdk/src/share/classes/java/awt/Robot.java	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,12 +25,18 @@
 
 package java.awt;
 
-import java.awt.peer.*;
-import java.awt.image.*;
-import java.awt.event.*;
+import java.awt.event.InputEvent;
+import java.awt.event.KeyEvent;
+import java.awt.image.BufferedImage;
+import java.awt.image.DataBufferInt;
+import java.awt.image.DirectColorModel;
+import java.awt.image.Raster;
+import java.awt.image.WritableRaster;
+import java.awt.peer.RobotPeer;
 import java.lang.reflect.InvocationTargetException;
 import sun.awt.ComponentFactory;
 import sun.awt.SunToolkit;
+import sun.awt.image.SunWritableRaster;
 import sun.security.util.SecurityConstants;
 
 /**
@@ -335,6 +341,10 @@
                                                /* blue mask */   0x000000FF);
         }
 
+        // need to sync the toolkit prior to grabbing the pixels since in some
+        // cases rendering to the screen may be delayed
+        Toolkit.getDefaultToolkit().sync();
+
         int pixels[];
         int[] bandmasks = new int[3];
 
@@ -346,6 +356,7 @@
         bandmasks[2] = screenCapCM.getBlueMask();
 
         raster = Raster.createPackedRaster(buffer, translatedRect.width, translatedRect.height, translatedRect.width, bandmasks, null);
+        SunWritableRaster.makeTrackable(buffer);
 
         image = new BufferedImage(screenCapCM, raster, false, null);
 
diff -Nru openjdk.orig/jdk/src/share/classes/javax/swing/BufferStrategyPaintManager.java openjdk/jdk/src/share/classes/javax/swing/BufferStrategyPaintManager.java
--- openjdk.orig/jdk/src/share/classes/javax/swing/BufferStrategyPaintManager.java	2011-01-07 21:32:57.000000000 +0000
+++ openjdk/jdk/src/share/classes/javax/swing/BufferStrategyPaintManager.java	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -263,7 +263,7 @@
                         (SubRegionShowable)bufferStrategy;
                 boolean paintAllOnExpose = info.getPaintAllOnExpose();
                 info.setPaintAllOnExpose(false);
-                if (bsSubRegion.validateAndShow(x, y, (x + w), (y + h))) {
+                if (bsSubRegion.showIfNotLost(x, y, (x + w), (y + h))) {
                     return !paintAllOnExpose;
                 }
                 // Mark the buffer as needing to be repainted.  We don't
diff -Nru openjdk.orig/jdk/src/share/classes/sun/awt/image/SunVolatileImage.java openjdk/jdk/src/share/classes/sun/awt/image/SunVolatileImage.java
--- openjdk.orig/jdk/src/share/classes/sun/awt/image/SunVolatileImage.java	2011-01-07 21:32:58.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/awt/image/SunVolatileImage.java	2011-01-08 01:26:50.447201948 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,19 +29,18 @@
 import java.awt.Color;
 import java.awt.Component;
 import java.awt.Font;
-import java.awt.Graphics;
 import java.awt.Graphics2D;
 import java.awt.GraphicsConfiguration;
 import java.awt.ImageCapabilities;
 import java.awt.Transparency;
 import java.awt.image.BufferedImage;
-import java.awt.image.ColorModel;
 import java.awt.image.ImageObserver;
 import java.awt.image.VolatileImage;
-import java.awt.image.WritableRaster;
 import sun.java2d.SunGraphics2D;
-import sun.java2d.SurfaceData;
 import sun.java2d.SurfaceManagerFactory;
+import sun.java2d.DestSurfaceProvider;
+import sun.java2d.Surface;
+import static sun.java2d.pipe.hw.AccelSurface.*;
 
 /**
  * This class is the base implementation of the VolatileImage
@@ -52,23 +51,28 @@
  * appropriate VolatileSurfaceManager for the GraphicsConfiguration
  * under which this SunVolatileImage was created.
  */
-public class SunVolatileImage extends VolatileImage {
+public class SunVolatileImage extends VolatileImage
+    implements DestSurfaceProvider
+{
 
     protected VolatileSurfaceManager volSurfaceManager;
     protected Component comp;
     private GraphicsConfiguration graphicsConfig;
     private Font defaultFont;
     private int width, height;
+    private int forcedAccelSurfaceType;
 
-    private SunVolatileImage(Component comp,
-                             GraphicsConfiguration graphicsConfig,
-                             int width, int height, Object context,
-                             int transparency, ImageCapabilities caps)
+    protected SunVolatileImage(Component comp,
+                               GraphicsConfiguration graphicsConfig,
+                               int width, int height, Object context,
+                               int transparency, ImageCapabilities caps,
+                               int accType)
     {
         this.comp = comp;
         this.graphicsConfig = graphicsConfig;
         this.width = width;
         this.height = height;
+        this.forcedAccelSurfaceType = accType;
         if (!(transparency == Transparency.OPAQUE ||
             transparency == Transparency.BITMASK ||
             transparency == Transparency.TRANSLUCENT))
@@ -92,7 +96,7 @@
                              ImageCapabilities caps)
     {
         this(comp, graphicsConfig,
-             width, height, context, Transparency.OPAQUE, caps);
+             width, height, context, Transparency.OPAQUE, caps, UNDEFINED);
     }
 
     public SunVolatileImage(Component comp, int width, int height) {
@@ -110,7 +114,8 @@
                             int width, int height, int transparency,
                             ImageCapabilities caps)
     {
-        this(null, graphicsConfig, width, height, null, transparency, caps);
+        this(null, graphicsConfig, width, height, null, transparency,
+             caps, UNDEFINED);
     }
 
     public int getWidth() {
@@ -144,6 +149,10 @@
         return comp;
     }
 
+    public int getForcedAccelSurfaceType() {
+        return forcedAccelSurfaceType;
+    }
+
     protected VolatileSurfaceManager createSurfaceManager(Object context,
                                                           ImageCapabilities caps)
     {
@@ -247,4 +256,14 @@
     public ImageCapabilities getCapabilities() {
         return volSurfaceManager.getCapabilities(graphicsConfig);
     }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.DestSurfaceProvider#getDestSurface
+     */
+    @Override
+    public Surface getDestSurface() {
+        return volSurfaceManager.getPrimarySurfaceData();
+    }
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/awt/image/SunWritableRaster.java openjdk/jdk/src/share/classes/sun/awt/image/SunWritableRaster.java
--- openjdk.orig/jdk/src/share/classes/sun/awt/image/SunWritableRaster.java	2011-01-07 21:32:58.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/awt/image/SunWritableRaster.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,6 +35,7 @@
 import java.awt.image.SampleModel;
 import java.awt.image.WritableRaster;
 
+import sun.java2d.StateTrackable.State;
 import sun.java2d.SurfaceData;
 import sun.java2d.StateTrackableDelegate;
 
@@ -54,6 +55,7 @@
         public short[] getData(DataBufferUShort dbus, int bank);
         public int[] getData(DataBufferInt dbi, int bank);
         public StateTrackableDelegate getTrackable(DataBuffer db);
+        public void setTrackable(DataBuffer db, StateTrackableDelegate trackable);
     }
 
     public static void setDataStealer(DataStealer ds) {
@@ -79,6 +81,14 @@
         return stealer.getTrackable(db);
     }
 
+    public static void setTrackable(DataBuffer db, StateTrackableDelegate trackable) {
+        stealer.setTrackable(db, trackable);
+    }
+
+    public static void makeTrackable(DataBuffer db) {
+        stealer.setTrackable(db, StateTrackableDelegate.createInstance(State.STABLE));
+    }
+
     public static void markDirty(DataBuffer db) {
         stealer.getTrackable(db).markDirty();
     }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/awt/image/VolatileSurfaceManager.java openjdk/jdk/src/share/classes/sun/awt/image/VolatileSurfaceManager.java
--- openjdk.orig/jdk/src/share/classes/sun/awt/image/VolatileSurfaceManager.java	2011-01-07 21:32:58.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/awt/image/VolatileSurfaceManager.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,7 @@
 import sun.java2d.SunGraphicsEnvironment;
 import sun.java2d.SurfaceData;
 import sun.java2d.loops.CompositeType;
+import static sun.java2d.pipe.hw.AccelSurface.*;
 
 /**
  * This SurfaceManager variant manages an accelerated volatile surface, if it
@@ -117,7 +118,11 @@
                 sdCurrent = sdAccel;
             }
         }
-        if (sdCurrent == null) {
+        // only initialize the backup surface for images with unforced
+        // acceleration type
+        if (sdCurrent == null &&
+            vImg.getForcedAccelSurfaceType() == UNDEFINED)
+        {
             sdCurrent = getBackupSurface();
         }
     }
@@ -270,9 +275,13 @@
      * the background).
      */
     public void initContents() {
-        Graphics g = vImg.createGraphics();
-        g.clearRect(0, 0, vImg.getWidth(), vImg.getHeight());
-        g.dispose();
+        // images with forced acceleration type may have a null sdCurrent
+        // because we do not create a backup surface for them
+        if (sdCurrent != null) {
+            Graphics g = vImg.createGraphics();
+            g.clearRect(0, 0, vImg.getWidth(), vImg.getHeight());
+            g.dispose();
+        }
     }
 
     /**
diff -Nru openjdk.orig/jdk/src/share/classes/sun/awt/image/VSyncedBSManager.java openjdk/jdk/src/share/classes/sun/awt/image/VSyncedBSManager.java
--- openjdk.orig/jdk/src/share/classes/sun/awt/image/VSyncedBSManager.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/awt/image/VSyncedBSManager.java	2011-01-08 01:26:50.451201991 +0000
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.awt.image;
+
+import java.awt.image.BufferStrategy;
+import java.lang.ref.WeakReference;
+
+/**
+ * Manages v-synced buffer strategies.
+ */
+public abstract class VSyncedBSManager {
+
+    private static VSyncedBSManager theInstance;
+
+    private static final boolean vSyncLimit =
+        Boolean.valueOf((String)java.security.AccessController.doPrivileged(
+                new sun.security.action.GetPropertyAction(
+                    "sun.java2d.vsynclimit", "true")));
+
+    private static VSyncedBSManager getInstance(boolean create) {
+        if (theInstance == null && create) {
+            theInstance =
+                vSyncLimit ? new SingleVSyncedBSMgr() : new NoLimitVSyncBSMgr();
+        }
+        return theInstance;
+    }
+
+    abstract boolean checkAllowed(BufferStrategy bs);
+    abstract void relinquishVsync(BufferStrategy bs);
+
+    /**
+     * Returns true if the buffer strategy is allowed to be created
+     * v-synced.
+     *
+     * @return true if the bs is allowed to be v-synced, false otherwise
+     */
+    public static boolean vsyncAllowed(BufferStrategy bs) {
+        VSyncedBSManager bsm = getInstance(true);
+        return bsm.checkAllowed(bs);
+    }
+
+    /**
+     * Lets the manager know that this buffer strategy is no longer interested
+     * in being v-synced.
+     */
+    public static synchronized void releaseVsync(BufferStrategy bs) {
+        VSyncedBSManager bsm = getInstance(false);
+        if (bsm != null) {
+            bsm.relinquishVsync(bs);
+        }
+    }
+
+    /**
+     * An instance of the manager which allows any buffer strategy to be
+     * v-synced.
+     */
+    private static final class NoLimitVSyncBSMgr extends VSyncedBSManager {
+        @Override
+        boolean checkAllowed(BufferStrategy bs) {
+            return true;
+        }
+
+        @Override
+        void relinquishVsync(BufferStrategy bs) {
+        }
+    }
+
+    /**
+     * An instance of the manager which allows only one buffer strategy to
+     * be v-synced at any give moment in the vm.
+     */
+    private static final class SingleVSyncedBSMgr extends VSyncedBSManager {
+        private WeakReference<BufferStrategy> strategy;
+
+        @Override
+        public synchronized boolean checkAllowed(BufferStrategy bs) {
+            if (strategy != null) {
+                BufferStrategy current = strategy.get();
+                if (current != null) {
+                    return (current == bs);
+                }
+            }
+            strategy = new WeakReference<BufferStrategy>(bs);
+            return true;
+        }
+
+        @Override
+        public synchronized void relinquishVsync(BufferStrategy bs) {
+            if (strategy != null) {
+                BufferStrategy b = strategy.get();
+                if (b == bs) {
+                    strategy.clear();
+                    strategy = null;
+                }
+            }
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/awt/NullComponentPeer.java openjdk/jdk/src/share/classes/sun/awt/NullComponentPeer.java
--- openjdk.orig/jdk/src/share/classes/sun/awt/NullComponentPeer.java	2011-01-07 21:32:58.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/awt/NullComponentPeer.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -255,7 +255,9 @@
         throw new IllegalStateException(
             "Page-flipping is not allowed on a lightweight component");
     }
-    public void flip(BufferCapabilities.FlipContents flipAction) {
+    public void flip(int x1, int y1, int x2, int y2,
+                     BufferCapabilities.FlipContents flipAction)
+    {
         throw new IllegalStateException(
             "Page-flipping is not allowed on a lightweight component");
     }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/awt/SubRegionShowable.java openjdk/jdk/src/share/classes/sun/awt/SubRegionShowable.java
--- openjdk.orig/jdk/src/share/classes/sun/awt/SubRegionShowable.java	2011-01-07 21:32:58.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/awt/SubRegionShowable.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,10 +39,11 @@
     public void show(int x1, int y1, int x2, int y2);
 
     /**
-     * Validates the buffer and if successful shows the specified region.
+     * Shows the specified region if the buffer is not lost and the dimensions
+     * of the back-buffer match those of the component.
      *
      * @return true if successful
      */
     // NOTE: this is invoked by swing on the toolkit thread!
-    public boolean validateAndShow(int x1, int y1, int x2, int y2);
+    public boolean showIfNotLost(int x1, int y1, int x2, int y2);
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/font/StrikeCache.java openjdk/jdk/src/share/classes/sun/font/StrikeCache.java
--- openjdk.orig/jdk/src/share/classes/sun/font/StrikeCache.java	2011-01-07 21:32:58.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/font/StrikeCache.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,16 +25,17 @@
 
 package sun.font;
 
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsEnvironment;
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.SoftReference;
 import java.lang.ref.WeakReference;
-import java.awt.Font;
-import java.awt.FontFormatException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 import sun.java2d.Disposer;
+import sun.java2d.pipe.BufferedContext;
+import sun.java2d.pipe.RenderQueue;
+import sun.java2d.pipe.hw.AccelGraphicsConfig;
 import sun.misc.Unsafe;
 
 /**
@@ -192,13 +193,13 @@
         recentStrikeIndex = index;
     }
 
-    static void disposeStrike(FontStrikeDisposer disposer) {
+    private static final void doDispose(FontStrikeDisposer disposer) {
         if (disposer.intGlyphImages != null) {
             freeIntMemory(disposer.intGlyphImages,
-                          disposer.pScalerContext);
+                    disposer.pScalerContext);
         } else if (disposer.longGlyphImages != null) {
             freeLongMemory(disposer.longGlyphImages,
-                           disposer.pScalerContext);
+                    disposer.pScalerContext);
         } else if (disposer.segIntGlyphImages != null) {
             /* NB Now making multiple JNI calls in this case.
              * But assuming that there's a reasonable amount of locality
@@ -207,7 +208,7 @@
             for (int i=0; i<disposer.segIntGlyphImages.length; i++) {
                 if (disposer.segIntGlyphImages[i] != null) {
                     freeIntMemory(disposer.segIntGlyphImages[i],
-                                  disposer.pScalerContext);
+                            disposer.pScalerContext);
                     /* native will only free the scaler context once */
                     disposer.pScalerContext = 0L;
                     disposer.segIntGlyphImages[i] = null;
@@ -223,7 +224,7 @@
             for (int i=0; i<disposer.segLongGlyphImages.length; i++) {
                 if (disposer.segLongGlyphImages[i] != null) {
                     freeLongMemory(disposer.segLongGlyphImages[i],
-                                   disposer.pScalerContext);
+                            disposer.pScalerContext);
                     disposer.pScalerContext = 0L;
                     disposer.segLongGlyphImages[i] = null;
                 }
@@ -234,6 +235,44 @@
         }
     }
 
+    static void disposeStrike(final FontStrikeDisposer disposer) {
+        // we need to execute the strike disposal on the rendering thread
+        // because they may be accessed on that thread at the time of the
+        // disposal (for example, when the accel. cache is invalidated)
+
+        // REMIND: this look a bit heavyweight, but should be ok
+        // because strike disposal is a relatively infrequent operation,
+        // more worrisome is the necessity of getting a GC here.
+        RenderQueue rq = null;
+        GraphicsEnvironment ge =
+            GraphicsEnvironment.getLocalGraphicsEnvironment();
+        if (!ge.isHeadless()) {
+            GraphicsConfiguration gc =
+                ge.getDefaultScreenDevice().getDefaultConfiguration();
+            if (gc instanceof AccelGraphicsConfig) {
+                AccelGraphicsConfig agc = (AccelGraphicsConfig)gc;
+                BufferedContext bc = agc.getContext();
+                if (bc != null) {
+                    rq = bc.getRenderQueue();
+                }
+            }
+        }
+        if (rq != null) {
+            rq.lock();
+            try {
+                rq.flushAndInvokeNow(new Runnable() {
+                    public void run() {
+                        doDispose(disposer);
+                    }
+                });
+            } finally {
+                rq.unlock();
+            }
+        } else {
+            doDispose(disposer);
+        }
+    }
+
     static native void freeIntPointer(int ptr);
     static native void freeLongPointer(long ptr);
     private static native void freeIntMemory(int[] glyphPtrs, long pContext);
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/DestSurfaceProvider.java openjdk/jdk/src/share/classes/sun/java2d/DestSurfaceProvider.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/DestSurfaceProvider.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/DestSurfaceProvider.java	2011-01-08 01:26:50.451201991 +0000
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d;
+
+import sun.java2d.pipe.hw.*;
+
+/**
+ * Classes implementing this interface provide access to their
+ * destination surfaces.
+ */
+public interface DestSurfaceProvider {
+    /**
+     * Returns a surface currently used as a destination surface for rendering.
+     *
+     * @return destination surface
+     */
+    public Surface getDestSurface();
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/loops/BlitBg.java openjdk/jdk/src/share/classes/sun/java2d/loops/BlitBg.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/loops/BlitBg.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/loops/BlitBg.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -109,7 +109,7 @@
      */
     public native void BlitBg(SurfaceData src, SurfaceData dst,
                               Composite comp, Region clip,
-                              Color bgColor,
+                              int bgColor,
                               int srcx, int srcy,
                               int dstx, int dsty,
                               int width, int height);
@@ -142,19 +142,19 @@
             compositeType = comptype;
         }
 
+        @Override
         public void BlitBg(SurfaceData srcData,
                            SurfaceData dstData,
                            Composite comp,
                            Region clip,
-                           Color bgColor,
+                           int bgArgb,
                            int srcx, int srcy,
                            int dstx, int dsty,
                            int width, int height)
         {
             ColorModel dstModel = dstData.getColorModel();
-            if (!dstModel.hasAlpha() &&
-                bgColor.getTransparency() != Transparency.OPAQUE)
-            {
+            boolean bgHasAlpha = (bgArgb >>> 24) != 0xff;
+            if (!dstModel.hasAlpha() && bgHasAlpha) {
                 dstModel = ColorModel.getRGBdefault();
             }
             WritableRaster wr =
@@ -163,6 +163,7 @@
             BufferedImage bimg =
                 new BufferedImage(dstModel, wr, isPremult, null);
             SurfaceData tmpData = BufImgSurfaceData.createData(bimg);
+            Color bgColor = new Color(bgArgb, bgHasAlpha);
             SunGraphics2D sg2d = new SunGraphics2D(tmpData, bgColor, bgColor,
                                                    defaultFont);
             FillRect fillop = FillRect.locate(SurfaceType.AnyColor,
@@ -201,9 +202,10 @@
             return this;
         }
 
+        @Override
         public void BlitBg(SurfaceData src, SurfaceData dst,
                            Composite comp, Region clip,
-                           Color bgColor,
+                           int bgColor,
                            int srcx, int srcy, int dstx, int dsty,
                            int width, int height)
         {
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/loops/GeneralRenderer.java openjdk/jdk/src/share/classes/sun/java2d/loops/GeneralRenderer.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/loops/GeneralRenderer.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/loops/GeneralRenderer.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -159,6 +159,10 @@
     {
         int mx, my, x1, y1;
         int[] tmp = null;
+
+        if (nPoints <= 0) {
+            return;
+        }
         mx = x1 = xPoints[off] + transx;
         my = y1 = yPoints[off] + transy;
         while (--nPoints > 0) {
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLBufImgOps.java openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLBufImgOps.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLBufImgOps.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLBufImgOps.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,6 +35,7 @@
 import sun.java2d.SurfaceData;
 import sun.java2d.loops.CompositeType;
 import sun.java2d.pipe.BufferedBufImgOps;
+import static sun.java2d.opengl.OGLContext.OGLContextCaps.*;
 
 class OGLBufImgOps extends BufferedBufImgOps {
 
@@ -94,7 +95,7 @@
         OGLSurfaceData oglSrc = (OGLSurfaceData)srcData;
         OGLGraphicsConfig gc = oglSrc.getOGLGraphicsConfig();
         if (oglSrc.getType() != OGLSurfaceData.TEXTURE ||
-            !gc.isCapPresent(OGLContext.CAPS_EXT_BIOP_SHADER))
+            !gc.isCapPresent(CAPS_EXT_BIOP_SHADER))
         {
             return false;
         }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLContext.java openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLContext.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLContext.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLContext.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,91 +25,24 @@
 
 package sun.java2d.opengl;
 
-import java.awt.AlphaComposite;
-import java.awt.Composite;
-import java.awt.Paint;
-import java.awt.geom.AffineTransform;
-import sun.java2d.SunGraphics2D;
 import sun.java2d.pipe.BufferedContext;
-import sun.java2d.pipe.Region;
 import sun.java2d.pipe.RenderBuffer;
 import sun.java2d.pipe.RenderQueue;
+import sun.java2d.pipe.hw.ContextCapabilities;
 import static sun.java2d.pipe.BufferedOpCodes.*;
+import static sun.java2d.pipe.hw.ContextCapabilities.*;
 
 /**
  * Note that the RenderQueue lock must be acquired before calling any of
  * the methods in this class.
  */
-class OGLContext extends BufferedContext {
+public class OGLContext extends BufferedContext {
 
-    /** Indicates that the context has no capabilities. */
-    static final int CAPS_EMPTY            = (0 << 0);
-    /** Indicates that the context is doublebuffered. */
-    static final int CAPS_DOUBLEBUFFERED   = (1 << 0);
-    /** Indicates that the context supports a stored alpha channel. */
-    static final int CAPS_STORED_ALPHA     = (1 << 1);
-    /** Indicates the presence of the GL_ARB_multitexture extension. */
-    static final int CAPS_EXT_MULTITEXTURE = (1 << 2);
-    /** Indicates the presence of the GL_ARB_texture_non_power_of_two ext. */
-    static final int CAPS_EXT_TEXNONPOW2   = (1 << 3);
-    /**
-     * Indicates the presence of the GL_EXT_framebuffer_object extension.
-     * This cap will only be set if the fbobject system property has been
-     * enabled and we are able to create an FBO with depth buffer.
-     */
-    static final int CAPS_EXT_FBOBJECT     = (1 << 4);
-    /**
-     * Indicates the presence of the GL_ARB_fragment_shader extension.
-     * This cap will only be set if the lcdshader system property has been
-     * enabled and the hardware supports the minimum number of texture units.
-     */
-    static final int CAPS_EXT_LCD_SHADER   = (1 << 5);
-    /** Indicates the presence of the GL_ARB_texture_rectangle extension. */
-    static final int CAPS_EXT_TEXRECT      = (1 << 6);
-    /**
-     * Indicates the presence of the GL_ARB_fragment_shader extension.
-     * This cap will only be set if the biopshader system property has been
-     * enabled and the hardware meets our minimum requirements.
-     */
-    static final int CAPS_EXT_BIOP_SHADER  = (1 << 7);
-    /**
-     * Indicates the presence of the GL_ARB_fragment_shader extension.
-     * This cap will only be set if the gradshader system property has been
-     * enabled and the hardware meets our minimum requirements.
-     */
-    static final int CAPS_EXT_GRAD_SHADER  = (1 << 8);
+    private final OGLGraphicsConfig config;
 
-    OGLContext(RenderQueue rq) {
+    OGLContext(RenderQueue rq, OGLGraphicsConfig config) {
         super(rq);
-    }
-
-    /**
-     * Fetches the OGLContext associated with the current GraphicsConfig
-     * and validates the context using the given parameters.  Most rendering
-     * operations will call this method first in order to set the necessary
-     * state before issuing rendering commands.
-     */
-    static void validateContext(OGLSurfaceData srcData,
-                                OGLSurfaceData dstData,
-                                Region clip, Composite comp,
-                                AffineTransform xform,
-                                Paint paint, SunGraphics2D sg2d,
-                                int flags)
-    {
-        // assert rq.lock.isHeldByCurrentThread();
-        OGLContext oglc = dstData.getContext();
-        oglc.validate(srcData, dstData,
-                      clip, comp, xform, paint, sg2d, flags);
-    }
-
-    /**
-     * Simplified version of validateContext() that disables all context
-     * state settings.
-     */
-    static void validateContext(OGLSurfaceData dstData) {
-        // assert rq.lock.isHeldByCurrentThread();
-        validateContext(dstData, dstData,
-                        null, null, null, null, null, NO_CONTEXT_FLAGS);
+        this.config = config;
     }
 
     /**
@@ -160,19 +93,128 @@
     static void invalidateCurrentContext() {
         // assert OGLRenderQueue.getInstance().lock.isHeldByCurrentThread();
 
-        // first invalidate the context reference at the native level, and
+        // invalidate the current Java-level context so that we
+        // revalidate everything the next time around
+        if (currentContext != null) {
+            currentContext.invalidateContext();
+            currentContext = null;
+        }
+
+        // invalidate the context reference at the native level, and
         // then flush the queue so that we have no pending operations
         // dependent on the current context
         OGLRenderQueue rq = OGLRenderQueue.getInstance();
         rq.ensureCapacity(4);
         rq.getBuffer().putInt(INVALIDATE_CONTEXT);
         rq.flushNow();
+    }
 
-        // then invalidate the current Java-level context so that we
-        // revalidate everything the next time around
-        if (currentContext != null) {
-            currentContext.invalidateSurfaces();
-            currentContext = null;
+    public RenderQueue getRenderQueue() {
+        return OGLRenderQueue.getInstance();
+    }
+
+    /**
+     * Returns a string representing adapter id (vendor, renderer, version).
+     * Must be called on the rendering thread.
+     *
+     * @return an id string for the adapter
+     */
+    static final native String getOGLIdString();
+
+    @Override
+    public void saveState() {
+        // assert rq.lock.isHeldByCurrentThread();
+
+        // reset all attributes of this and current contexts
+        invalidateContext();
+        invalidateCurrentContext();
+
+        setScratchSurface(config);
+
+        // save the state on the native level
+        rq.ensureCapacity(4);
+        buf.putInt(SAVE_STATE);
+        rq.flushNow();
+    }
+
+    @Override
+    public void restoreState() {
+        // assert rq.lock.isHeldByCurrentThread();
+
+        // reset all attributes of this and current contexts
+        invalidateContext();
+        invalidateCurrentContext();
+
+        setScratchSurface(config);
+
+        // restore the state on the native level
+        rq.ensureCapacity(4);
+        buf.putInt(RESTORE_STATE);
+        rq.flushNow();
+    }
+
+    static class OGLContextCaps extends ContextCapabilities {
+        /**
+         * Indicates the presence of the GL_EXT_framebuffer_object extension.
+         * This cap will only be set if the fbobject system property has been
+         * enabled and we are able to create an FBO with depth buffer.
+         */
+        static final int CAPS_EXT_FBOBJECT     =
+                (CAPS_RT_TEXTURE_ALPHA | CAPS_RT_TEXTURE_OPAQUE);
+        /** Indicates that the context supports a stored alpha channel. */
+        static final int CAPS_STORED_ALPHA     = CAPS_RT_PLAIN_ALPHA;
+        /** Indicates that the context is doublebuffered. */
+        static final int CAPS_DOUBLEBUFFERED   = (FIRST_PRIVATE_CAP << 0);
+        /**
+         * Indicates the presence of the GL_ARB_fragment_shader extension.
+         * This cap will only be set if the lcdshader system property has been
+         * enabled and the hardware supports the minimum number of texture units
+         */
+        static final int CAPS_EXT_LCD_SHADER   = (FIRST_PRIVATE_CAP << 1);
+        /**
+         * Indicates the presence of the GL_ARB_fragment_shader extension.
+         * This cap will only be set if the biopshader system property has been
+         * enabled and the hardware meets our minimum requirements.
+         */
+        static final int CAPS_EXT_BIOP_SHADER  = (FIRST_PRIVATE_CAP << 2);
+        /**
+         * Indicates the presence of the GL_ARB_fragment_shader extension.
+         * This cap will only be set if the gradshader system property has been
+         * enabled and the hardware meets our minimum requirements.
+         */
+        static final int CAPS_EXT_GRAD_SHADER  = (FIRST_PRIVATE_CAP << 3);
+        /** Indicates the presence of the GL_ARB_texture_rectangle extension. */
+        static final int CAPS_EXT_TEXRECT      = (FIRST_PRIVATE_CAP << 4);
+
+        OGLContextCaps(int caps, String adapterId) {
+            super(caps, adapterId);
+        }
+
+        @Override
+        public String toString() {
+            StringBuffer buf = new StringBuffer(super.toString());
+            if ((caps & CAPS_EXT_FBOBJECT) != 0) {
+                buf.append("CAPS_EXT_FBOBJECT|");
+            }
+            if ((caps & CAPS_STORED_ALPHA) != 0) {
+                buf.append("CAPS_STORED_ALPHA|");
+            }
+            if ((caps & CAPS_DOUBLEBUFFERED) != 0) {
+                buf.append("CAPS_DOUBLEBUFFERED|");
+            }
+            if ((caps & CAPS_EXT_LCD_SHADER) != 0) {
+                buf.append("CAPS_EXT_LCD_SHADER|");
+            }
+            if ((caps & CAPS_EXT_BIOP_SHADER) != 0) {
+                buf.append("CAPS_BIOP_SHADER|");
+            }
+            if ((caps & CAPS_EXT_GRAD_SHADER) != 0) {
+                buf.append("CAPS_EXT_GRAD_SHADER|");
+            }
+            if ((caps & CAPS_EXT_TEXRECT) != 0) {
+                buf.append("CAPS_EXT_TEXRECT|");
+            }
+            return buf.toString();
         }
     }
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLGraphicsConfig.java openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLGraphicsConfig.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLGraphicsConfig.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLGraphicsConfig.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,13 +27,16 @@
 
 import sun.java2d.SurfaceData;
 import sun.awt.image.SurfaceManager;
+import sun.java2d.pipe.hw.AccelGraphicsConfig;
 
 /**
  * This interface collects the methods that are provided by both
  * GLXGraphicsConfig and WGLGraphicsConfig, making it easier to invoke these
  * methods directly from OGLSurfaceData.
  */
-interface OGLGraphicsConfig extends SurfaceManager.ProxiedGraphicsConfig {
+interface OGLGraphicsConfig extends
+    AccelGraphicsConfig, SurfaceManager.ProxiedGraphicsConfig
+{
     OGLContext getContext();
     long getNativeConfigInfo();
     boolean isCapPresent(int cap);
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLPaints.java openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLPaints.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLPaints.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLPaints.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,6 +39,7 @@
 import sun.java2d.SurfaceData;
 import sun.java2d.loops.CompositeType;
 import static sun.java2d.pipe.BufferedPaints.*;
+import static sun.java2d.opengl.OGLContext.OGLContextCaps.*;
 
 abstract class OGLPaints {
 
@@ -170,7 +171,7 @@
 
             OGLSurfaceData dstData = (OGLSurfaceData)sg2d.surfaceData;
             OGLGraphicsConfig gc = dstData.getOGLGraphicsConfig();
-            if (!gc.isCapPresent(OGLContext.CAPS_EXT_GRAD_SHADER)) {
+            if (!gc.isCapPresent(CAPS_EXT_GRAD_SHADER)) {
                 return false;
             }
 
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLRenderer.java openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLRenderer.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLRenderer.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLRenderer.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,6 +30,7 @@
 import sun.java2d.SunGraphics2D;
 import sun.java2d.loops.GraphicsPrimitive;
 import sun.java2d.pipe.BufferedRenderPipe;
+import sun.java2d.pipe.ParallelogramPipe;
 import sun.java2d.pipe.RenderQueue;
 import sun.java2d.pipe.SpanIterator;
 import static sun.java2d.pipe.BufferedOpCodes.*;
@@ -51,6 +52,15 @@
                                    null, sg2d.paint, sg2d, ctxflags);
     }
 
+    @Override
+    protected void validateContextAA(SunGraphics2D sg2d) {
+        int ctxflags = OGLContext.NO_CONTEXT_FLAGS;
+        OGLSurfaceData dstData = (OGLSurfaceData)sg2d.surfaceData;
+        OGLContext.validateContext(dstData, dstData,
+                                   sg2d.getCompClip(), sg2d.composite,
+                                   null, sg2d.paint, sg2d, ctxflags);
+    }
+
     void copyArea(SunGraphics2D sg2d,
                   int x, int y, int w, int h, int dx, int dy)
     {
@@ -88,6 +98,31 @@
             super(oglr.rq);
             this.oglr = oglr;
         }
+        public ParallelogramPipe getAAParallelogramPipe() {
+            final ParallelogramPipe realpipe = oglr.getAAParallelogramPipe();
+            return new ParallelogramPipe() {
+                public void fillParallelogram(SunGraphics2D sg2d,
+                                              double x, double y,
+                                              double dx1, double dy1,
+                                              double dx2, double dy2)
+                {
+                    GraphicsPrimitive.tracePrimitive("OGLFillAAParallelogram");
+                    realpipe.fillParallelogram(sg2d,
+                                               x, y, dx1, dy1, dx2, dy2);
+                }
+                public void drawParallelogram(SunGraphics2D sg2d,
+                                              double x, double y,
+                                              double dx1, double dy1,
+                                              double dx2, double dy2,
+                                              double lw1, double lw2)
+                {
+                    GraphicsPrimitive.tracePrimitive("OGLDrawAAParallelogram");
+                    realpipe.drawParallelogram(sg2d,
+                                               x, y, dx1, dy1, dx2, dy2,
+                                               lw1, lw2);
+                }
+            };
+        }
         protected void validateContext(SunGraphics2D sg2d) {
             oglr.validateContext(sg2d);
         }
@@ -130,6 +165,23 @@
             GraphicsPrimitive.tracePrimitive("OGLFillSpans");
             oglr.fillSpans(sg2d, si, transx, transy);
         }
+        public void fillParallelogram(SunGraphics2D sg2d,
+                                      double x, double y,
+                                      double dx1, double dy1,
+                                      double dx2, double dy2)
+        {
+            GraphicsPrimitive.tracePrimitive("OGLFillParallelogram");
+            oglr.fillParallelogram(sg2d, x, y, dx1, dy1, dx2, dy2);
+        }
+        public void drawParallelogram(SunGraphics2D sg2d,
+                                      double x, double y,
+                                      double dx1, double dy1,
+                                      double dx2, double dy2,
+                                      double lw1, double lw2)
+        {
+            GraphicsPrimitive.tracePrimitive("OGLDrawParallelogram");
+            oglr.drawParallelogram(sg2d, x, y, dx1, dy1, dx2, dy2, lw1, lw2);
+        }
         public void copyArea(SunGraphics2D sg2d,
                              int x, int y, int w, int h, int dx, int dy)
         {
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLSurfaceData.java openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLSurfaceData.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/opengl/OGLSurfaceData.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/opengl/OGLSurfaceData.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,23 +27,26 @@
 
 import java.awt.AlphaComposite;
 import java.awt.GraphicsEnvironment;
+import java.awt.Rectangle;
 import java.awt.Transparency;
 import java.awt.image.ColorModel;
 import java.awt.image.Raster;
 import sun.awt.SunHints;
 import sun.awt.image.PixelConverter;
+import sun.java2d.pipe.hw.AccelSurface;
 import sun.java2d.SunGraphics2D;
 import sun.java2d.SurfaceData;
 import sun.java2d.SurfaceDataProxy;
+import sun.java2d.loops.CompositeType;
 import sun.java2d.loops.GraphicsPrimitive;
 import sun.java2d.loops.MaskFill;
 import sun.java2d.loops.SurfaceType;
-import sun.java2d.pipe.PixelToShapeConverter;
+import sun.java2d.pipe.ParallelogramPipe;
+import sun.java2d.pipe.PixelToParallelogramConverter;
 import sun.java2d.pipe.RenderBuffer;
-import sun.java2d.pipe.RenderQueue;
 import sun.java2d.pipe.TextPipe;
 import static sun.java2d.pipe.BufferedOpCodes.*;
-import static sun.java2d.opengl.OGLContext.*;
+import static sun.java2d.opengl.OGLContext.OGLContextCaps.*;
 
 /**
  * This class describes an OpenGL "surface", that is, a region of pixels
@@ -92,17 +95,16 @@
  * FLIP_BACKBUFFER   OpenGLSurface
  * FBOBJECT          OpenGLSurfaceRTT
  */
-public abstract class OGLSurfaceData extends SurfaceData {
+public abstract class OGLSurfaceData extends SurfaceData
+    implements AccelSurface {
 
     /**
      * OGL-specific surface types
+     *
+     * @see sun.java2d.pipe.hw.AccelSurface
      */
-    public static final int UNDEFINED       = 0;
-    public static final int WINDOW          = 1;
-    public static final int PBUFFER         = 2;
-    public static final int TEXTURE         = 3;
-    public static final int FLIP_BACKBUFFER = 4;
-    public static final int FBOBJECT        = 5;
+    public static final int PBUFFER         = RT_PLAIN;
+    public static final int FBOBJECT        = RT_TEXTURE;
 
     /**
      * Pixel formats
@@ -148,11 +150,14 @@
     private static boolean isGradShaderEnabled;
 
     private OGLGraphicsConfig graphicsConfig;
-    private int textureTarget;
     protected int type;
+    // these fields are set from the native code when the surface is
+    // initialized
+    private int nativeWidth, nativeHeight;
 
     protected static OGLRenderer oglRenderPipe;
-    protected static PixelToShapeConverter oglTxRenderPipe;
+    protected static PixelToParallelogramConverter oglTxRenderPipe;
+    protected static ParallelogramPipe oglAAPgramPipe;
     protected static OGLTextRenderer oglTextPipe;
     protected static OGLDrawImage oglImagePipe;
 
@@ -170,6 +175,7 @@
                                            int width, int height);
 
     private native int getTextureTarget(long pData);
+    private native int getTextureID(long pData);
 
     static {
         if (!GraphicsEnvironment.isHeadless()) {
@@ -203,9 +209,14 @@
             oglRenderPipe = new OGLRenderer(rq);
             if (GraphicsPrimitive.tracingEnabled()) {
                 oglTextPipe = oglTextPipe.traceWrap();
-                oglRenderPipe = oglRenderPipe.traceWrap();
+                //The wrapped oglRenderPipe will wrap the AA pipe as well...
+                //oglAAPgramPipe = oglRenderPipe.traceWrap();
             }
-            oglTxRenderPipe = new PixelToShapeConverter(oglRenderPipe);
+            oglAAPgramPipe = oglRenderPipe.getAAParallelogramPipe();
+            oglTxRenderPipe =
+                new PixelToParallelogramConverter(oglRenderPipe,
+                                                  oglRenderPipe,
+                                                  1.0, 0.25, true);
 
             OGLBlitLoops.register();
             OGLMaskFill.register();
@@ -282,9 +293,7 @@
             break;
         }
 
-        if (success) {
-            textureTarget = getTextureTarget(getNativeOps());
-        } else {
+        if (!success) {
             throw new OutOfMemoryError("can't create offscreen surface");
         }
     }
@@ -323,7 +332,7 @@
      * Returns the OGLContext for the GraphicsConfig associated with this
      * surface.
      */
-    final OGLContext getContext() {
+    public final OGLContext getContext() {
         return graphicsConfig.getContext();
     }
 
@@ -337,7 +346,7 @@
     /**
      * Returns one of the surface type constants defined above.
      */
-    final int getType() {
+    public final int getType() {
         return type;
     }
 
@@ -346,8 +355,41 @@
      * for that texture (either GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB).
      * Otherwise, this method will return zero.
      */
-    final int getTextureTarget() {
-        return textureTarget;
+    public final int getTextureTarget() {
+        return getTextureTarget(getNativeOps());
+    }
+
+    /**
+     * If this surface is backed by a texture object, returns the texture ID
+     * for that texture.
+     * Otherwise, this method will return zero.
+     */
+    public final int getTextureID() {
+        return getTextureID(getNativeOps());
+    }
+
+    /**
+     * Returns native resource of specified {@code resType} associated with
+     * this surface.
+     *
+     * Specifically, for {@code OGLSurfaceData} this method returns the
+     * the following:
+     * <pre>
+     * TEXTURE              - texture id
+     * </pre>
+     *
+     * Note: the resource returned by this method is only valid on the rendering
+     * thread.
+     *
+     * @return native resource of specified type or 0L if
+     * such resource doesn't exist or can not be retrieved.
+     * @see sun.java2d.pipe.hw.AccelSurface#getNativeResource
+     */
+    public long getNativeResource(int resType) {
+        if (resType == TEXTURE) {
+            return getTextureID();
+        }
+        return 0L;
     }
 
     public Raster getRaster(int x, int y, int w, int h) {
@@ -366,7 +408,7 @@
      */
     public boolean canRenderLCDText(SunGraphics2D sg2d) {
         return
-            graphicsConfig.isCapPresent(OGLContext.CAPS_EXT_LCD_SHADER) &&
+            graphicsConfig.isCapPresent(CAPS_EXT_LCD_SHADER) &&
             sg2d.compositeState <= SunGraphics2D.COMP_ISCOPY &&
             sg2d.paintState <= SunGraphics2D.PAINT_OPAQUECOLOR;
     }
@@ -405,7 +447,7 @@
             validated = true;
         }
 
-        PixelToShapeConverter txPipe = null;
+        PixelToParallelogramConverter txPipe = null;
         OGLRenderer nonTxPipe = null;
 
         if (sg2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON) {
@@ -422,12 +464,28 @@
                 // custom paints handled by super.validatePipe() below
             }
         } else {
-            if (sg2d.paintState <= sg2d.PAINT_ALPHACOLOR &&
-                sg2d.compositeState == sg2d.COMP_XOR)
-            {
-                // install the solid pipes when AA and XOR are both enabled
-                txPipe = oglTxRenderPipe;
-                nonTxPipe = oglRenderPipe;
+            if (sg2d.paintState <= sg2d.PAINT_ALPHACOLOR) {
+                if (graphicsConfig.isCapPresent(CAPS_PS30) &&
+                    (sg2d.imageComp == CompositeType.SrcOverNoEa ||
+                     sg2d.imageComp == CompositeType.SrcOver))
+                {
+                    if (!validated) {
+                        super.validatePipe(sg2d);
+                        validated = true;
+                    }
+                    PixelToParallelogramConverter aaConverter =
+                        new PixelToParallelogramConverter(sg2d.shapepipe,
+                                                          oglAAPgramPipe,
+                                                          1.0/8.0, 0.499,
+                                                          false);
+                    sg2d.drawpipe = aaConverter;
+                    sg2d.fillpipe = aaConverter;
+                    sg2d.shapepipe = aaConverter;
+                } else if (sg2d.compositeState == sg2d.COMP_XOR) {
+                    // install the solid pipes when AA and XOR are both enabled
+                    txPipe = oglTxRenderPipe;
+                    nonTxPipe = oglRenderPipe;
+                }
             }
             // other cases handled by super.validatePipe() below
         }
@@ -443,7 +501,11 @@
                 sg2d.drawpipe = nonTxPipe;
                 sg2d.fillpipe = nonTxPipe;
             }
-            sg2d.shapepipe = nonTxPipe;
+            // Note that we use the transforming pipe here because it
+            // will examine the shape and possibly perform an optimized
+            // operation if it can be simplified.  The simplifications
+            // will be valid for all STROKE and TRANSFORM types.
+            sg2d.shapepipe = txPipe;
         } else {
             if (!validated) {
                 super.validatePipe(sg2d);
@@ -472,7 +534,7 @@
              * validation code will choose a more general software-based loop.
              */
             if (!OGLPaints.isValid(sg2d) ||
-                !graphicsConfig.isCapPresent(CAPS_EXT_MULTITEXTURE))
+                !graphicsConfig.isCapPresent(CAPS_MULTITEXTURE))
             {
                 return null;
             }
@@ -564,7 +626,7 @@
      * when using the basic GL_TEXTURE_2D target.
      */
     boolean isTexNonPow2Available() {
-        return graphicsConfig.isCapPresent(OGLContext.CAPS_EXT_TEXNONPOW2);
+        return graphicsConfig.isCapPresent(CAPS_TEXNONPOW2);
     }
 
     /**
@@ -573,6 +635,16 @@
      * GL_ARB_texture_rectangle extension is present).
      */
     boolean isTexRectAvailable() {
-        return graphicsConfig.isCapPresent(OGLContext.CAPS_EXT_TEXRECT);
+        return graphicsConfig.isCapPresent(CAPS_EXT_TEXRECT);
+    }
+
+    public Rectangle getNativeBounds() {
+        OGLRenderQueue rq = OGLRenderQueue.getInstance();
+        rq.lock();
+        try {
+            return new Rectangle(nativeWidth, nativeHeight);
+        } finally {
+            rq.unlock();
+        }
     }
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/BufferedContext.java openjdk/jdk/src/share/classes/sun/java2d/pipe/BufferedContext.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/BufferedContext.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/BufferedContext.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,12 +26,13 @@
 package sun.java2d.pipe;
 
 import java.awt.AlphaComposite;
+import java.awt.Color;
 import java.awt.Composite;
 import java.awt.Paint;
 import java.awt.geom.AffineTransform;
+import sun.java2d.pipe.hw.AccelSurface;
 import sun.java2d.InvalidPipeException;
 import sun.java2d.SunGraphics2D;
-import sun.java2d.SurfaceData;
 import sun.java2d.loops.XORComposite;
 import static sun.java2d.pipe.BufferedOpCodes.*;
 import static sun.java2d.pipe.BufferedRenderPipe.BYTES_PER_SPAN;
@@ -43,8 +44,10 @@
  * single thread.  Note that the RenderQueue lock must be acquired before
  * calling the validate() method (or any other method in this class).  See
  * the RenderQueue class comments for a sample usage scenario.
+ *
+ * @see RenderQueue
  */
-public class BufferedContext {
+public abstract class BufferedContext {
 
     /*
      * The following flags help the internals of validate() determine
@@ -82,13 +85,17 @@
      */
     protected static BufferedContext currentContext;
 
-    private SurfaceData     validatedSrcData;
-    private SurfaceData     validatedDstData;
+    private AccelSurface    validatedSrcData;
+    private AccelSurface    validatedDstData;
     private Region          validatedClip;
     private Composite       validatedComp;
     private Paint           validatedPaint;
+    private boolean         isValidatedPaintAColor;
+    private int             validatedRGB;
     private int             validatedFlags;
     private boolean         xformInUse;
+    private int             transX;
+    private int             transY;
 
     protected BufferedContext(RenderQueue rq) {
         this.rq = rq;
@@ -96,6 +103,49 @@
     }
 
     /**
+     * Fetches the BufferedContextContext associated with the dst. surface
+     * and validates the context using the given parameters.  Most rendering
+     * operations will call this method first in order to set the necessary
+     * state before issuing rendering commands.
+     *
+     * Note: must be called while the RenderQueue lock is held.
+     *
+     * @throws InvalidPipeException if either src or dest surface is not valid
+     * or lost
+     * @see RenderQueue#lock
+     * @see RenderQueue#unlock
+     */
+    public static void validateContext(AccelSurface srcData,
+                                       AccelSurface dstData,
+                                       Region clip, Composite comp,
+                                       AffineTransform xform,
+                                       Paint paint, SunGraphics2D sg2d,
+                                       int flags)
+    {
+        // assert rq.lock.isHeldByCurrentThread();
+        BufferedContext d3dc = dstData.getContext();
+        d3dc.validate(srcData, dstData,
+                      clip, comp, xform, paint, sg2d, flags);
+    }
+
+    /**
+     * Fetches the BufferedContextassociated with the surface
+     * and disables all context state settings.
+     *
+     * Note: must be called while the RenderQueue lock is held.
+     *
+     * @throws InvalidPipeException if the surface is not valid
+     * or lost
+     * @see RenderQueue#lock
+     * @see RenderQueue#unlock
+     */
+    public static void validateContext(AccelSurface surface) {
+        // assert rt.lock.isHeldByCurrentThread();
+        validateContext(surface, surface,
+                        null, null, null, null, null, NO_CONTEXT_FLAGS);
+    }
+
+    /**
      * Validates the given parameters against the current state for this
      * context.  If this context is not current, it will be made current
      * for the given source and destination surfaces, and the viewport will
@@ -106,19 +156,47 @@
      * Note that the SunGraphics2D parameter is only used for the purposes
      * of validating a (non-null) Paint parameter.  In all other cases it
      * is safe to pass a null SunGraphics2D and it will be ignored.
+     *
+     * Note: must be called while the RenderQueue lock is held.
+     *
+     * @throws InvalidPipeException if either src or dest surface is not valid
+     * or lost
      */
-    public void validate(SurfaceData srcData, SurfaceData dstData,
+    public void validate(AccelSurface srcData, AccelSurface dstData,
                          Region clip, Composite comp,
                          AffineTransform xform,
                          Paint paint, SunGraphics2D sg2d, int flags)
     {
         // assert rq.lock.isHeldByCurrentThread();
 
-        boolean updateClip = (clip != validatedClip);
-        boolean updatePaint = (paint != validatedPaint);
+        boolean updateClip = false;
+        boolean updatePaint = false;
 
-        if (!dstData.isValid()) {
-            throw new InvalidPipeException("bounds changed");
+        if (!dstData.isValid() ||
+            dstData.isSurfaceLost() || srcData.isSurfaceLost())
+        {
+            invalidateContext();
+            throw new InvalidPipeException("bounds changed or surface lost");
+        }
+
+        if (paint instanceof Color) {
+            // REMIND: not 30-bit friendly
+            int newRGB = ((Color)paint).getRGB();
+            if (isValidatedPaintAColor) {
+                if (newRGB != validatedRGB) {
+                    validatedRGB = newRGB;
+                    updatePaint = true;
+                }
+            } else {
+                validatedRGB = newRGB;
+                updatePaint = true;
+                isValidatedPaintAColor = true;
+            }
+        } else if (validatedPaint != paint) {
+            updatePaint = true;
+            // this should be set when we are switching from paint to color
+            // in which case this condition will be true
+            isValidatedPaintAColor = false;
         }
 
         if ((currentContext != this) ||
@@ -147,9 +225,18 @@
         }
 
         // validate clip
-        if (updateClip) {
+        if ((clip != validatedClip) || updateClip) {
             if (clip != null) {
-                setClip(clip);
+                if (updateClip ||
+                    validatedClip == null ||
+                    !(validatedClip.isRectangular() && clip.isRectangular()) ||
+                    ((clip.getLoX() != validatedClip.getLoX() ||
+                      clip.getLoY() != validatedClip.getLoY() ||
+                      clip.getHiX() != validatedClip.getHiX() ||
+                      clip.getHiY() != validatedClip.getHiY())))
+                {
+                    setClip(clip);
+                }
             } else {
                 resetClip();
             }
@@ -173,14 +260,29 @@
         }
 
         // validate transform
+        boolean txChanged = false;
         if (xform == null) {
             if (xformInUse) {
                 resetTransform();
                 xformInUse = false;
+                txChanged = true;
+            } else if (sg2d != null) {
+                if (transX != sg2d.transX || transY != sg2d.transY) {
+                    txChanged = true;
+                }
+            }
+            if (sg2d != null) {
+                transX = sg2d.transX;
+                transY = sg2d.transY;
             }
         } else {
             setTransform(xform);
             xformInUse = true;
+            txChanged = true;
+        }
+        // non-Color paints may require paint revalidation
+        if (!isValidatedPaintAColor && txChanged) {
+            updatePaint = true;
         }
 
         // validate paint
@@ -194,6 +296,7 @@
         }
 
         // mark dstData dirty
+        // REMIND: is this really needed now? we do it in SunGraphics2D..
         dstData.markDirty();
     }
 
@@ -201,13 +304,20 @@
      * Invalidates the surfaces associated with this context.  This is
      * useful when the context is no longer needed, and we want to break
      * the chain caused by these surface references.
+     *
+     * Note: must be called while the RenderQueue lock is held.
+     *
+     * @see RenderQueue#lock
+     * @see RenderQueue#unlock
      */
     public void invalidateSurfaces() {
         validatedSrcData = null;
         validatedDstData = null;
     }
 
-    private void setSurfaces(SurfaceData srcData, SurfaceData dstData) {
+    private void setSurfaces(AccelSurface srcData,
+                             AccelSurface dstData)
+    {
         // assert rq.lock.isHeldByCurrentThread();
         rq.ensureCapacityAndAlignment(20, 4);
         buf.putInt(SET_SURFACES);
@@ -304,4 +414,54 @@
         buf.putDouble(xform.getTranslateX());
         buf.putDouble(xform.getTranslateY());
     }
+
+    /**
+     * Resets this context's surfaces and all attributes.
+     *
+     * Note: must be called while the RenderQueue lock is held.
+     *
+     * @see RenderQueue#lock
+     * @see RenderQueue#unlock
+     */
+    public void invalidateContext() {
+        resetTransform();
+        resetComposite();
+        resetClip();
+        invalidateSurfaces();
+        validatedComp = null;
+        validatedClip = null;
+        validatedPaint = null;
+        xformInUse = false;
+    }
+
+    /**
+     * Returns a singleton {@code RenderQueue} object used by the rendering
+     * pipeline.
+     *
+     * @return a render queue
+     * @see RenderQueue
+     */
+    public abstract RenderQueue getRenderQueue();
+
+    /**
+     * Saves the the state of this context.
+     * It may reset the current context.
+     *
+     * Note: must be called while the RenderQueue lock is held.
+     *
+     * @see RenderQueue#lock
+     * @see RenderQueue#unlock
+     */
+    public abstract void saveState();
+
+    /**
+     * Restores the native state of this context.
+     * It may reset the current context.
+     *
+     * Note: must be called while the RenderQueue lock is held.
+     *
+     * @see RenderQueue#lock
+     * @see RenderQueue#unlock
+     */
+    public abstract void restoreState();
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/BufferedOpCodes.java openjdk/jdk/src/share/classes/sun/java2d/pipe/BufferedOpCodes.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/BufferedOpCodes.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/BufferedOpCodes.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,10 +32,14 @@
     public static final int DRAW_POLY            = 12;
     public static final int DRAW_PIXEL           = 13;
     public static final int DRAW_SCANLINES       = 14;
+    public static final int DRAW_PARALLELOGRAM   = 15;
+    public static final int DRAW_AAPARALLELOGRAM = 16;
 
     // fill ops
     public static final int FILL_RECT            = 20;
     public static final int FILL_SPANS           = 21;
+    public static final int FILL_PARALLELOGRAM   = 22;
+    public static final int FILL_AAPARALLELOGRAM = 23;
 
     // copy-related ops
     public static final int COPY_AREA            = 30;
@@ -67,6 +71,9 @@
     public static final int DISPOSE_CONFIG       = 74;
     public static final int INVALIDATE_CONTEXT   = 75;
     public static final int SYNC                 = 76;
+    public static final int RESTORE_DEVICES      = 77;
+    public static final int SAVE_STATE           = 78;
+    public static final int RESTORE_STATE        = 79;
 
     // multibuffering ops
     public static final int SWAP_BUFFERS         = 80;
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/BufferedRenderPipe.java openjdk/jdk/src/share/classes/sun/java2d/pipe/BufferedRenderPipe.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/BufferedRenderPipe.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/BufferedRenderPipe.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,7 @@
 
 package sun.java2d.pipe;
 
+import java.awt.BasicStroke;
 import java.awt.Polygon;
 import java.awt.Shape;
 import java.awt.geom.AffineTransform;
@@ -33,6 +34,7 @@
 import java.awt.geom.Path2D;
 import java.awt.geom.IllegalPathStateException;
 import java.awt.geom.PathIterator;
+import java.awt.geom.Rectangle2D;
 import java.awt.geom.RoundRectangle2D;
 import sun.java2d.SunGraphics2D;
 import sun.java2d.loops.ProcessPath;
@@ -51,8 +53,10 @@
  * simply delegate to draw(Shape) and fill(Shape), respectively.
  */
 public abstract class BufferedRenderPipe
-    implements PixelDrawPipe, PixelFillPipe, ShapeDrawPipe
+    implements PixelDrawPipe, PixelFillPipe, ShapeDrawPipe, ParallelogramPipe
 {
+    ParallelogramPipe aapgrampipe = new AAParallelogramPipe();
+
     static final int BYTES_PER_POLY_POINT = 8;
     static final int BYTES_PER_SCANLINE = 12;
     static final int BYTES_PER_SPAN = 16;
@@ -67,12 +71,17 @@
         this.drawHandler = new BufferedDrawHandler();
     }
 
+    public ParallelogramPipe getAAParallelogramPipe() {
+        return aapgrampipe;
+    }
+
     /**
      * Validates the state in the provided SunGraphics2D object and sets up
      * any special resources for this operation (e.g. enabling gradient
      * shading).
      */
     protected abstract void validateContext(SunGraphics2D sg2d);
+    protected abstract void validateContextAA(SunGraphics2D sg2d);
 
     public void drawLine(SunGraphics2D sg2d,
                          int x1, int y1, int x2, int y2)
@@ -398,6 +407,98 @@
         }
     }
 
+    public void fillParallelogram(SunGraphics2D sg2d,
+                                  double x, double y,
+                                  double dx1, double dy1,
+                                  double dx2, double dy2)
+    {
+        rq.lock();
+        try {
+            validateContext(sg2d);
+            rq.ensureCapacity(28);
+            buf.putInt(FILL_PARALLELOGRAM);
+            buf.putFloat((float) x);
+            buf.putFloat((float) y);
+            buf.putFloat((float) dx1);
+            buf.putFloat((float) dy1);
+            buf.putFloat((float) dx2);
+            buf.putFloat((float) dy2);
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    public void drawParallelogram(SunGraphics2D sg2d,
+                                  double x, double y,
+                                  double dx1, double dy1,
+                                  double dx2, double dy2,
+                                  double lw1, double lw2)
+    {
+        rq.lock();
+        try {
+            validateContext(sg2d);
+            rq.ensureCapacity(36);
+            buf.putInt(DRAW_PARALLELOGRAM);
+            buf.putFloat((float) x);
+            buf.putFloat((float) y);
+            buf.putFloat((float) dx1);
+            buf.putFloat((float) dy1);
+            buf.putFloat((float) dx2);
+            buf.putFloat((float) dy2);
+            buf.putFloat((float) lw1);
+            buf.putFloat((float) lw2);
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    private class AAParallelogramPipe implements ParallelogramPipe {
+        public void fillParallelogram(SunGraphics2D sg2d,
+                                      double x, double y,
+                                      double dx1, double dy1,
+                                      double dx2, double dy2)
+        {
+            rq.lock();
+            try {
+                validateContextAA(sg2d);
+                rq.ensureCapacity(28);
+                buf.putInt(FILL_AAPARALLELOGRAM);
+                buf.putFloat((float) x);
+                buf.putFloat((float) y);
+                buf.putFloat((float) dx1);
+                buf.putFloat((float) dy1);
+                buf.putFloat((float) dx2);
+                buf.putFloat((float) dy2);
+            } finally {
+                rq.unlock();
+            }
+        }
+
+        public void drawParallelogram(SunGraphics2D sg2d,
+                                      double x, double y,
+                                      double dx1, double dy1,
+                                      double dx2, double dy2,
+                                      double lw1, double lw2)
+        {
+            rq.lock();
+            try {
+                validateContextAA(sg2d);
+                rq.ensureCapacity(36);
+                buf.putInt(DRAW_AAPARALLELOGRAM);
+                buf.putFloat((float) x);
+                buf.putFloat((float) y);
+                buf.putFloat((float) dx1);
+                buf.putFloat((float) dy1);
+                buf.putFloat((float) dx2);
+                buf.putFloat((float) dy2);
+                buf.putFloat((float) lw1);
+                buf.putFloat((float) lw2);
+            } finally {
+                rq.unlock();
+            }
+        }
+    }
+
     public void draw(SunGraphics2D sg2d, Shape s) {
         if (sg2d.strokeState == sg2d.STROKE_THIN) {
             if (s instanceof Polygon) {
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/DrawImage.java openjdk/jdk/src/share/classes/sun/java2d/pipe/DrawImage.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/DrawImage.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/DrawImage.java	2011-01-08 01:26:50.451201991 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -955,7 +955,7 @@
         } else {
             BlitBg blit = BlitBg.getFromCache(srcType, comp, dstType);
             blit.BlitBg(srcData, dstData, sg.composite, clipRegion,
-                        bgColor, sx, sy, dx, dy, w, h);
+                        bgColor.getRGB(), sx, sy, dx, dy, w, h);
         }
     }
 
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/AccelDeviceEventListener.java openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/AccelDeviceEventListener.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/AccelDeviceEventListener.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/AccelDeviceEventListener.java	2011-01-08 01:26:50.451201991 +0000
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.pipe.hw;
+
+/**
+ * An interface for receiving notifications about imminent accelerated device's
+ * events. Upon receiving such event appropriate actions can be taken (for
+ * example, resources associated with the device can be freed).
+ */
+public interface AccelDeviceEventListener {
+    /**
+     * Called when the device is about to be reset.
+     *
+     * One must release all native resources associated with the device which
+     * prevent the device from being reset (such as Default Pool resources for
+     * the D3D pipeline).
+     *
+     * It is safe to remove the listener while in the call back.
+     *
+     * Note: this method is called on the rendering thread,
+     * do not call into user code, do not take RQ lock!
+     */
+    public void onDeviceReset();
+
+    /**
+     * Called when the device is about to be disposed of.
+     *
+     * One must release all native resources associated with the device.
+     *
+     * It is safe to remove the listener while in the call back.
+     *
+     * Note: this method is called on the rendering thread,
+     * do not call into user code, do not take RQ lock!
+     */
+    public void onDeviceDispose();
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/AccelDeviceEventNotifier.java openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/AccelDeviceEventNotifier.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/AccelDeviceEventNotifier.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/AccelDeviceEventNotifier.java	2011-01-08 01:26:50.451201991 +0000
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.pipe.hw;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * This class is used to notify listeners about accelerated device's
+ * events such as device reset or dispose that are about to occur.
+ */
+public class AccelDeviceEventNotifier {
+
+    private static AccelDeviceEventNotifier theInstance;
+
+    /**
+     * A device is about to be reset. The listeners have to release all
+     * resources associated with the device which are required for the device
+     * to be reset.
+     */
+    public static final int DEVICE_RESET = 0;
+
+    /**
+     * A device is about to be disposed. The listeners have to release all
+     * resources associated with the device.
+     */
+    public static final int DEVICE_DISPOSED = 1;
+
+    private final Map<AccelDeviceEventListener, Integer> listeners;
+
+    private AccelDeviceEventNotifier() {
+        listeners = Collections.synchronizedMap(
+            new HashMap<AccelDeviceEventListener, Integer>(1));
+    }
+
+    /**
+     * Returns a singleton of AccelDeviceEventNotifier if it exists. If the
+     * passed boolean is false and singleton doesn't exist yet, null is
+     * returned. If the passed boolean is {@code true} and singleton doesn't
+     * exist it will be created and returned.
+     *
+     * @param create whether to create a singleton instance if doesn't yet
+     * exist
+     * @return a singleton instance or null
+     */
+    private static synchronized
+        AccelDeviceEventNotifier getInstance(boolean create)
+    {
+        if (theInstance == null && create) {
+            theInstance = new AccelDeviceEventNotifier();
+        }
+        return theInstance;
+    }
+
+    /**
+     * Called to indicate that a device event had occured.
+     * If a singleton exists, the listeners (those associated with
+     * the device) will be notified.
+     *
+     * @param screen a screen number of the device which is a source of
+     * the event
+     * @param eventType a type of the event
+     * @see #DEVICE_DISPOSED
+     * @see #DEVICE_RESET
+     */
+    public static final void eventOccured(int screen, int eventType) {
+        AccelDeviceEventNotifier notifier = getInstance(false);
+        if (notifier != null) {
+            notifier.notifyListeners(eventType, screen);
+        }
+    }
+
+    /**
+     * Adds the listener associated with a device on particular screen.
+     *
+     * Note: the listener must be removed as otherwise it will forever
+     * be referenced by the notifier.
+     *
+     * @param l the listener
+     * @param screen the screen number indicating which device the listener is
+     * interested in.
+     */
+    public static final void addListener(AccelDeviceEventListener l,int screen){
+        getInstance(true).add(l, screen);
+    }
+
+    /**
+     * Removes the listener.
+     *
+     * @param l the listener
+     */
+    public static final void removeListener(AccelDeviceEventListener l) {
+        getInstance(true).remove(l);
+    }
+
+    private final void add(AccelDeviceEventListener theListener, int screen) {
+        listeners.put(theListener, screen);
+    }
+    private final void remove(AccelDeviceEventListener theListener) {
+        listeners.remove(theListener);
+    }
+
+    /**
+     * Notifies the listeners associated with the screen's device about the
+     * event.
+     *
+     * Implementation note: the current list of listeners is first duplicated
+     * which allows the listeners to remove themselves during the iteration.
+     *
+     * @param screen a screen number with which the device which is a source of
+     * the event is associated with
+     * @param eventType a type of the event
+     * @see #DEVICE_DISPOSED
+     * @see #DEVICE_RESET
+     */
+    private final void notifyListeners(int deviceEventType, int screen) {
+        HashMap<AccelDeviceEventListener, Integer> listClone;
+        Set<AccelDeviceEventListener> cloneSet;
+
+        synchronized(listeners) {
+            listClone =
+                new HashMap<AccelDeviceEventListener, Integer>(listeners);
+        }
+
+        cloneSet = listClone.keySet();
+        Iterator<AccelDeviceEventListener> itr = cloneSet.iterator();
+        while (itr.hasNext()) {
+            AccelDeviceEventListener current = itr.next();
+            Integer i = listClone.get(current);
+            // only notify listeners which are interested in this device
+            if (i != null && i.intValue() != screen) {
+                continue;
+            }
+            if (deviceEventType == DEVICE_RESET) {
+                current.onDeviceReset();
+            } else if (deviceEventType == DEVICE_DISPOSED) {
+                current.onDeviceDispose();
+            }
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/AccelGraphicsConfig.java openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/AccelGraphicsConfig.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/AccelGraphicsConfig.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/AccelGraphicsConfig.java	2011-01-08 01:26:50.451201991 +0000
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.pipe.hw;
+
+import java.awt.image.VolatileImage;
+
+/**
+ * Implementors of this interface provida a way to create a
+ * {@code VolatileImage} whose destination surface is an
+ * {@link AccelSurface} of specified type.
+ *
+ * @see AccelSurface
+ */
+public interface AccelGraphicsConfig extends BufferedContextProvider {
+    /**
+     * Returns a VolatileImage with specified width, height, transparency
+     * and guaranteed accelerated surface type. If such image can not be created
+     * (out of vram error, specific surface type is not supported) null
+     * is returned.
+     *
+     * Note: if {@link AccelSurface#TEXTURE} type is requested, rendering
+     * to the image will be denied by throwing
+     * {@code UnsupportedOperationException }
+     * from {@link java.awt.image.VolatileImage#getGraphics} and
+     * {@link java.awt.image.VolatileImage#createGraphics}
+     *
+     * @param width the width of the returned {@code VolatileImage}
+     * @param height the height of the returned {@code VolatileImage}
+     * @param transparency the specified transparency mode
+     * @param type requested accelerated surface type as specified by constants
+     * in AccelSurface interface
+     * @return a {@code VolatileImage} backed up by requested accelerated
+     * surface type or null
+     * @throws IllegalArgumentException if the transparency is not a valid value
+     * @see AccelSurface#TEXTURE
+     * @see AccelSurface#RT_PLAIN
+     * @see AccelSurface#RT_TEXTURE
+     */
+    public VolatileImage createCompatibleVolatileImage(int width, int height,
+                                                       int transparency,
+                                                       int type);
+    /**
+     * Returns object representing capabilities of the context associated
+     * with this {@code AccelGraphicsConfig}.
+     *
+     * @return ContextCapabilities object representing caps
+     * @see ContextCapabilities
+     */
+    public ContextCapabilities getContextCapabilities();
+
+    /**
+     * Adds an {@code AccelDeviceEventListener} to listen to accelerated
+     * device's (which is associated with this {@code AccelGraphicsConfig})
+     * events.
+     *
+     * Note: a hard link to the listener may be kept so it must be explicitly
+     * removed via {@link #removeDeviceEventListener()}.
+     *
+     * @param l the listener
+     * @see AccelDeviceEventListener
+     */
+    public void addDeviceEventListener(AccelDeviceEventListener l);
+
+    /**
+     * Removes an {@code AccelDeviceEventListener} from the list of listeners
+     * for this device's events.
+     *
+     * @param l the listener
+     * @see AccelDeviceEventListener
+     */
+    public void removeDeviceEventListener(AccelDeviceEventListener l);
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/AccelSurface.java openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/AccelSurface.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/AccelSurface.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/AccelSurface.java	2011-01-08 01:26:50.455202035 +0000
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.pipe.hw;
+
+import java.awt.Rectangle;
+import sun.java2d.Surface;
+
+/**
+ * Abstraction for a hardware accelerated surface.
+ */
+public interface AccelSurface extends BufferedContextProvider, Surface {
+    /**
+     * Undefined
+     */
+    public static final int UNDEFINED       = 0;
+    /**
+     * Window (or window substitute) surface
+     */
+    public static final int WINDOW          = 1;
+    /**
+     * Render-To Plain surface (pbuffer for OpenGL, Render Target surface
+     * for Direct3D)
+     */
+    public static final int RT_PLAIN        = 2;
+    /**
+     * Texture surface
+     */
+    public static final int TEXTURE         = 3;
+    /**
+     * A back-buffer surface (SwapChain surface for Direct3D, backbuffer for
+     * OpenGL)
+     */
+    public static final int FLIP_BACKBUFFER = 4;
+    /**
+     * Render-To Texture surface (fbobject for OpenGL, texture with render-to
+     * attribute for Direct3D)
+     */
+    public static final int RT_TEXTURE      = 5;
+
+    /**
+     * Returns {@code int} representing surface's type as defined by constants
+     * in this interface.
+     *
+     * @return an integer representing this surface's type
+     * @see AccelSurface#UNDEFINED
+     * @see AccelSurface#WINDOW
+     * @see AccelSurface#RT_PLAIN
+     * @see AccelSurface#TEXTURE
+     * @see AccelSurface#FLIP_BACKBUFFER
+     * @see AccelSurface#RT_TEXTURE
+     */
+    public int getType();
+
+    /**
+     * Returns a pointer to the native surface data associated with this
+     * surface.
+     * Note: this pointer is only valid on the rendering thread.
+     *
+     * @return pointer to the native surface's data
+     */
+    public long getNativeOps();
+
+    /**
+     * Returns a pointer to the real native resource
+     * of the specified type associated with this AccelSurface.
+     * Note: this pointer is only valid on the rendering thread.
+     *
+     * @param resType the type of the requested resource
+     * @return a long containing a pointer to the native resource of the
+     * specified type or 0L if such resource doesn't exist for this surface
+     */
+    public long getNativeResource(int resType);
+
+    /**
+     * Marks this surface dirty.
+     */
+    public void markDirty();
+
+    /**
+     * Returns whether the pipeline considers this surface valid. A surface
+     * may become invalid if it is disposed of, or resized.
+     *
+     * @return true if valid, false otherwise
+     */
+    public boolean isValid();
+
+    /**
+     * Returns whether this surface is lost. The return value is only valid
+     * on the render thread, meaning that even if this method returns
+     * {@code true} it could be lost in the next moment unless it is called
+     * on the rendering thread.
+     *
+     * @return true if the surface is known to be lost, false otherwise
+     */
+    public boolean isSurfaceLost();
+
+    /**
+     * Returns the requested bounds of the destination surface. The real bounds
+     * of the native accelerated surface may differ. Use
+     * {@link #getNativeBounds} to get the bounds of the native surface.
+     *
+     * @return Rectangle representing java surface's bounds
+     */
+    public Rectangle getBounds();
+
+    /**
+     * Returns real bounds of the native surface, which may differ from those
+     * returned by {@link #getBounds}.
+     *
+     * @return Rectangle representing native surface's bounds
+     */
+    public Rectangle getNativeBounds();
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/AccelTypedVolatileImage.java openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/AccelTypedVolatileImage.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/AccelTypedVolatileImage.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/AccelTypedVolatileImage.java	2011-01-08 01:26:50.455202035 +0000
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.pipe.hw;
+
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import sun.awt.image.SunVolatileImage;
+import static sun.java2d.pipe.hw.AccelSurface.*;
+
+/**
+ * This is an image with forced type of the accelerated surface.
+ */
+public class AccelTypedVolatileImage extends SunVolatileImage {
+
+    /**
+     * Creates a volatile image with specified type of accelerated surface.
+     *
+     * @param graphicsConfig a GraphicsConfiguration for which this image should
+     *        be created.
+     * @param width width
+     * @param height width
+     * @param transparency type of {@link java.awt.Transparency transparency}
+     *        requested for the image
+     * @param accType type of the desired accelerated surface as defined in
+     *        AccelSurface interface
+     * @see sun.java2d.pipe.hw.AccelSurface
+     */
+    public AccelTypedVolatileImage(GraphicsConfiguration graphicsConfig,
+                                   int width, int height, int transparency,
+                                   int accType)
+    {
+        super(null, graphicsConfig, width, height, null, transparency,
+              null, accType);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * This method will throw {@code UnsupportedOperationException} if it this
+     * image's destination surface can not be rendered to.
+     */
+    @Override
+    public Graphics2D createGraphics() {
+        if (getForcedAccelSurfaceType() == TEXTURE) {
+            throw new UnsupportedOperationException("Can't render " +
+                                                    "to a non-RT Texture");
+        }
+        return super.createGraphics();
+    }
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/BufferedContextProvider.java openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/BufferedContextProvider.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/BufferedContextProvider.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/BufferedContextProvider.java	2011-01-08 01:26:50.455202035 +0000
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.pipe.hw;
+
+import sun.java2d.pipe.BufferedContext;
+
+/**
+ * Classes implementing this interface can provide the {@code BufferedContext}
+ * associated with or used by them.
+ *
+ * @see sun.java2d.pipe.BufferedContext
+ */
+public interface BufferedContextProvider {
+    /**
+     * Retrieves a context associated with object implementing this
+     * interface.
+     *
+     * @return associated context
+     * @see sun.java2d.pipe.BufferedContext
+     */
+    public BufferedContext getContext();
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/ContextCapabilities.java openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/ContextCapabilities.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/ContextCapabilities.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/ContextCapabilities.java	2011-01-08 01:26:50.455202035 +0000
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.pipe.hw;
+
+/**
+ * Represents a set of capabilities of a BufferedContext and associated
+ * AccelGraphicsConfig.
+ *
+ * @see AccelGraphicsConfig
+ */
+public class ContextCapabilities {
+    /** Indicates that the context has no capabilities. */
+    public static final int CAPS_EMPTY             = (0 << 0);
+    /** Indicates that the context supports RT surfaces with alpha channel. */
+    public static final int CAPS_RT_PLAIN_ALPHA    = (1 << 1);
+    /** Indicates that the context supports RT textures with alpha channel. */
+    public static final int CAPS_RT_TEXTURE_ALPHA  = (1 << 2);
+    /** Indicates that the context supports opaque RT textures. */
+    public static final int CAPS_RT_TEXTURE_OPAQUE = (1 << 3);
+    /** Indicates that the context supports multitexturing. */
+    public static final int CAPS_MULTITEXTURE      = (1 << 4);
+    /** Indicates that the context supports non-pow2 texture dimensions. */
+    public static final int CAPS_TEXNONPOW2        = (1 << 5);
+    /** Indicates that the context supports non-square textures. */
+    public static final int CAPS_TEXNONSQUARE      = (1 << 6);
+    /** Indicates that the context supports pixel shader 2.0 or better. */
+    public static final int CAPS_PS20              = (1 << 7);
+    /** Indicates that the context supports pixel shader 3.0 or better. */
+    public static final int CAPS_PS30              = (1 << 8);
+    /*
+     *  Pipeline contexts should use this for defining pipeline-specific
+     *  capabilities, for example:
+     *    int CAPS_D3D_1 = (FIRST_PRIVATE_CAP << 0);
+     *    int CAPS_D3D_2 = (FIRST_PRIVATE_CAP << 1);
+     */
+    protected static final int FIRST_PRIVATE_CAP   = (1 << 16);
+
+    protected final int caps;
+    protected final String adapterId;
+
+    /**
+     * Constructs a {@code ContextCapabilities} object.
+     * @param caps an {@code int} representing the capabilities
+     * @param a {@code String} representing the name of the adapter, or null,
+     * in which case the adapterId will be set to "unknown adapter".
+     */
+    protected ContextCapabilities(int caps, String adapterId) {
+        this.caps = caps;
+        this.adapterId = adapterId != null ? adapterId : "unknown adapter";
+    }
+
+    /**
+     * Returns a string representing the name of the graphics adapter if such
+     * could be determined. It is guaranteed to never return {@code null}.
+     * @return string representing adapter id
+     */
+    public String getAdapterId() {
+        return adapterId;
+    }
+
+    /**
+     * Returns an {@code int} with capabilities (OR-ed constants defined in
+     * this class and its pipeline-specific subclasses).
+     * @return capabilities as {@code int}
+     */
+    public int getCaps() {
+        return caps;
+    }
+
+    @Override
+    public String toString() {
+        StringBuffer buf =
+            new StringBuffer("ContextCapabilities: adapter=" +
+                             adapterId+", caps=");
+        if (caps == CAPS_EMPTY) {
+            buf.append("CAPS_EMPTY");
+        } else {
+            if ((caps & CAPS_RT_PLAIN_ALPHA) != 0) {
+                buf.append("CAPS_RT_PLAIN_ALPHA|");
+            }
+            if ((caps & CAPS_RT_TEXTURE_ALPHA) != 0) {
+                buf.append("CAPS_RT_TEXTURE_ALPHA|");
+            }
+            if ((caps & CAPS_RT_TEXTURE_OPAQUE) != 0) {
+                buf.append("CAPS_RT_TEXTURE_OPAQUE|");
+            }
+            if ((caps & CAPS_MULTITEXTURE) != 0) {
+                buf.append("CAPS_MULTITEXTURE|");
+            }
+            if ((caps & CAPS_TEXNONPOW2) != 0) {
+                buf.append("CAPS_TEXNONPOW2|");
+            }
+            if ((caps & CAPS_TEXNONSQUARE) != 0) {
+                buf.append("CAPS_TEXNONSQUARE|");
+            }
+            if ((caps & CAPS_PS20) != 0) {
+                buf.append("CAPS_PS20|");
+            }
+            if ((caps & CAPS_PS30) != 0) {
+                buf.append("CAPS_PS30|");
+            }
+        }
+        return buf.toString();
+    }
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/ExtendedBufferCapabilities.java openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/ExtendedBufferCapabilities.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/hw/ExtendedBufferCapabilities.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/hw/ExtendedBufferCapabilities.java	2011-01-08 01:26:50.455202035 +0000
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.pipe.hw;
+
+import java.awt.BufferCapabilities;
+import java.awt.ImageCapabilities;
+
+/**
+ * Provides extended BufferStrategy capabilities, allowing to specify
+ * the type of vertical refresh synchronization for a buffer strategy.
+ *
+ * This BS capability is always page flipping because v-sync is only relevant
+ * to flipping buffer strategies.
+ *
+ * Note that asking for a v-synced BS doesn't necessarily guarantee that it will
+ * be v-synced since the vsync capability may be disabled in the driver, or
+ * there may be other restriction (like a number of v-synced buffer strategies
+ * allowed per vm). Because of this {@code createBufferStrategy} doesn't
+ * throw {@code AWTException} when a v-synced BS could not be created when
+ * requested.
+ *
+ * @see java.awt.Canvas#createBufferStrategy(int, BufferCapabilities)
+ * @see java.awt.Window#createBufferStrategy(int, BufferCapabilities)
+ */
+public class ExtendedBufferCapabilities extends BufferCapabilities {
+
+    /**
+     * Type of synchronization on vertical retrace.
+     */
+    public static enum VSyncType {
+        /**
+         * Use the default v-sync mode appropriate for given BufferStrategy
+         * and situation.
+         */
+        VSYNC_DEFAULT(0),
+
+        /**
+         * Synchronize flip on vertical retrace.
+         */
+        VSYNC_ON(1),
+
+        /**
+         * Do not synchronize flip on vertical retrace.
+         */
+        VSYNC_OFF(2);
+
+        /**
+         * Used to identify the v-sync type (independent of the constants
+         * order as opposed to {@code ordinal()}).
+         */
+        public int id() {
+            return id;
+        }
+
+        private VSyncType(int id) {
+            this.id = id;
+        }
+        private int id;
+    }
+
+    private VSyncType vsync;
+
+    /**
+     * Creates an ExtendedBufferCapabilities object with front/back/flip caps
+     * from the passed cap, and VSYNC_DEFAULT v-sync mode.
+     */
+    public ExtendedBufferCapabilities(BufferCapabilities caps) {
+        super(caps.getFrontBufferCapabilities(),
+              caps.getBackBufferCapabilities(),
+              caps.getFlipContents());
+
+        this.vsync = VSyncType.VSYNC_DEFAULT;
+    }
+
+    /**
+     * Creates an ExtendedBufferCapabilities instance with front/back/flip caps
+     * from the passed caps, and VSYNC_DEFAULT v-sync mode.
+     */
+    public ExtendedBufferCapabilities(ImageCapabilities front,
+                                      ImageCapabilities back, FlipContents flip)
+    {
+        super(front, back, flip);
+
+        this.vsync = VSyncType.VSYNC_DEFAULT;
+    }
+
+    /**
+     * Creates an ExtendedBufferCapabilities instance with front/back/flip caps
+     * from the passed image/flip caps, and the v-sync type.
+     */
+    public ExtendedBufferCapabilities(ImageCapabilities front,
+                                      ImageCapabilities back, FlipContents flip,
+                                      VSyncType t)
+    {
+        super(front, back, flip);
+
+        this.vsync = t;
+    }
+
+    /**
+     * Creates an ExtendedBufferCapabilities instance with front/back/flip caps
+     * from the passed cap, and the passed v-sync mode.
+     */
+    public ExtendedBufferCapabilities(BufferCapabilities caps, VSyncType t) {
+        super(caps.getFrontBufferCapabilities(),
+              caps.getBackBufferCapabilities(),
+              caps.getFlipContents());
+
+        this.vsync = t;
+    }
+
+    /**
+     * Creates an ExtendedBufferCapabilities instance with front/back/flip caps
+     * from the object, and passed v-sync mode.
+     */
+    public ExtendedBufferCapabilities derive(VSyncType t) {
+        return new ExtendedBufferCapabilities(this, t);
+    }
+
+    /**
+     * Returns the type of v-sync requested by this capabilities instance.
+     */
+    public VSyncType getVSync() {
+        return vsync;
+    }
+
+    @Override
+    public final boolean isPageFlipping() {
+        return true;
+    }
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/ParallelogramPipe.java openjdk/jdk/src/share/classes/sun/java2d/pipe/ParallelogramPipe.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/ParallelogramPipe.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/ParallelogramPipe.java	2011-01-08 01:26:50.455202035 +0000
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.pipe;
+
+import sun.java2d.SunGraphics2D;
+
+/**
+ * This interface defines the set of calls that pipeline objects
+ * can use to pass on responsibility for drawing arbitrary
+ * parallelogram shapes.
+ * Six floating point numbers are provided and the parallelogram
+ * is defined as the quadrilateral with the following vertices:
+ * <pre>
+ *     origin: (x, y)
+ *          => (x+dx1, y+dy1)
+ *          => (x+dx1+dx2, y+dy1+dy2)
+ *          => (x+dx2, y+dy2)
+ *          => origin
+ * </pre>
+ */
+public interface ParallelogramPipe {
+    public void fillParallelogram(SunGraphics2D sg,
+                                  double x, double y,
+                                  double dx1, double dy1,
+                                  double dx2, double dy2);
+
+    /**
+     * Draw a Parallelogram with the indicated line widths
+     * assuming a standard BasicStroke with MITER joins.
+     * lw1 specifies the width of the stroke along the dx1,dy1
+     * vector and lw2 specifies the width of the stroke along
+     * the dx2,dy2 vector.
+     * This is equivalent to outsetting the indicated
+     * parallelogram by lw/2 pixels, then insetting the
+     * same parallelogram by lw/2 pixels and filling the
+     * difference between the outer and inner parallelograms.
+     */
+    public void drawParallelogram(SunGraphics2D sg,
+                                  double x, double y,
+                                  double dx1, double dy1,
+                                  double dx2, double dy2,
+                                  double lw1, double lw2);
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/PixelToParallelogramConverter.java openjdk/jdk/src/share/classes/sun/java2d/pipe/PixelToParallelogramConverter.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/pipe/PixelToParallelogramConverter.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/pipe/PixelToParallelogramConverter.java	2011-01-08 01:26:50.455202035 +0000
@@ -0,0 +1,417 @@
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.pipe;
+
+import java.awt.Shape;
+import java.awt.BasicStroke;
+import java.awt.geom.Line2D;
+import java.awt.geom.Rectangle2D;
+import java.awt.geom.AffineTransform;
+import sun.java2d.SunGraphics2D;
+import sun.awt.SunHints;
+
+/**
+ * This class converts calls to the basic pixel rendering methods
+ * into calls to the methods on a ParallelogramPipe.
+ * Most calls are transformed into calls to the fill(Shape) method
+ * by the parent PixelToShapeConverter class, but some calls are
+ * transformed into calls to fill/drawParallelogram().
+ */
+public class PixelToParallelogramConverter extends PixelToShapeConverter
+    implements ShapeDrawPipe
+{
+    ParallelogramPipe outrenderer;
+    double minPenSize;
+    double normPosition;
+    double normRoundingBias;
+    boolean adjustfill;
+
+    /**
+     * @param shapepipe pipeline to forward shape calls to
+     * @param pgrampipe pipeline to forward parallelogram calls to
+     *                  (and drawLine calls if possible)
+     * @param minPenSize minimum pen size for dropout control
+     * @param normPosition sub-pixel location to normalize endpoints
+     *                     for STROKE_NORMALIZE cases
+     * @param adjustFill boolean to control whethere normalization
+     *                   constants are also applied to fill operations
+     *                   (normally true for non-AA, false for AA)
+     */
+    public PixelToParallelogramConverter(ShapeDrawPipe shapepipe,
+                                         ParallelogramPipe pgrampipe,
+                                         double minPenSize,
+                                         double normPosition,
+                                         boolean adjustfill)
+    {
+        super(shapepipe);
+        outrenderer = pgrampipe;
+        this.minPenSize = minPenSize;
+        this.normPosition = normPosition;
+        this.normRoundingBias = 0.5 - normPosition;
+        this.adjustfill = adjustfill;
+    }
+
+    public void drawLine(SunGraphics2D sg2d,
+                         int x1, int y1, int x2, int y2)
+    {
+        if (!drawGeneralLine(sg2d, x1, y1, x2, y2)) {
+            super.drawLine(sg2d, x1, y1, x2, y2);
+        }
+    }
+
+    public void drawRect(SunGraphics2D sg2d,
+                         int x, int y, int w, int h)
+    {
+        if (w >= 0 && h >= 0) {
+            if (sg2d.strokeState < SunGraphics2D.STROKE_CUSTOM) {
+                BasicStroke bs = ((BasicStroke) sg2d.stroke);
+                if (w > 0 && h > 0) {
+                    if (bs.getLineJoin() == BasicStroke.JOIN_MITER &&
+                        bs.getDashArray() == null)
+                    {
+                        double lw = bs.getLineWidth();
+                        drawRectangle(sg2d, x, y, w, h, lw);
+                        return;
+                    }
+                } else {
+                    // Note: This calls the integer version which
+                    // will verify that the local drawLine optimizations
+                    // work and call super.drawLine(), if not.
+                    drawLine(sg2d, x, y, x+w, y+h);
+                    return;
+                }
+            }
+            super.drawRect(sg2d, x, y, w, h);
+        }
+    }
+
+    public void fillRect(SunGraphics2D sg2d,
+                         int x, int y, int w, int h)
+    {
+        if (w > 0 && h > 0) {
+            fillRectangle(sg2d, x, y, w, h);
+        }
+    }
+
+    public void draw(SunGraphics2D sg2d, Shape s) {
+        if (sg2d.strokeState < SunGraphics2D.STROKE_CUSTOM) {
+            BasicStroke bs = ((BasicStroke) sg2d.stroke);
+            if (s instanceof Rectangle2D) {
+                if (bs.getLineJoin() == BasicStroke.JOIN_MITER &&
+                    bs.getDashArray() == null)
+                {
+                    Rectangle2D r2d = (Rectangle2D) s;
+                    double w = r2d.getWidth();
+                    double h = r2d.getHeight();
+                    double x = r2d.getX();
+                    double y = r2d.getY();
+                    if (w >= 0 && h >= 0) {
+                        double lw = bs.getLineWidth();
+                        drawRectangle(sg2d, x, y, w, h, lw);
+                    }
+                    return;
+                }
+            } else if (s instanceof Line2D) {
+                Line2D l2d = (Line2D) s;
+                if (drawGeneralLine(sg2d,
+                                    l2d.getX1(), l2d.getY1(),
+                                    l2d.getX2(), l2d.getY2()))
+                {
+                    return;
+                }
+            }
+        }
+
+        outpipe.draw(sg2d, s);
+    }
+
+    public void fill(SunGraphics2D sg2d, Shape s) {
+        if (s instanceof Rectangle2D) {
+            Rectangle2D r2d = (Rectangle2D) s;
+            double w = r2d.getWidth();
+            double h = r2d.getHeight();
+            if (w > 0 && h > 0) {
+                double x = r2d.getX();
+                double y = r2d.getY();
+                fillRectangle(sg2d, x, y, w, h);
+            }
+            return;
+        }
+
+        outpipe.fill(sg2d, s);
+    }
+
+    static double len(double x, double y) {
+        return ((x == 0) ? Math.abs(y)
+                : ((y == 0) ? Math.abs(x)
+                   : Math.sqrt(x * x + y * y)));
+    }
+
+    double normalize(double v) {
+        return Math.floor(v + normRoundingBias) + normPosition;
+    }
+
+    public boolean drawGeneralLine(SunGraphics2D sg2d,
+                                   double x1, double y1,
+                                   double x2, double y2)
+    {
+        if (sg2d.strokeState == SunGraphics2D.STROKE_CUSTOM ||
+            sg2d.strokeState == SunGraphics2D.STROKE_THINDASHED)
+        {
+            return false;
+        }
+        BasicStroke bs = (BasicStroke) sg2d.stroke;
+        int cap = bs.getEndCap();
+        if (cap == BasicStroke.CAP_ROUND || bs.getDashArray() != null) {
+            // TODO: we could construct the GeneralPath directly
+            // for CAP_ROUND and save a lot of processing in that case...
+            // And again, we would need to deal with dropout control...
+            return false;
+        }
+        double lw = bs.getLineWidth();
+        // Save the original dx, dy in case we need it to transform
+        // the linewidth as a perpendicular vector below
+        double dx = x2 - x1;
+        double dy = y2 - y1;
+        switch (sg2d.transformState) {
+        case SunGraphics2D.TRANSFORM_GENERIC:
+        case SunGraphics2D.TRANSFORM_TRANSLATESCALE:
+            {
+                double coords[] = {x1, y1, x2, y2};
+                sg2d.transform.transform(coords, 0, coords, 0, 2);
+                x1 = coords[0];
+                y1 = coords[1];
+                x2 = coords[2];
+                y2 = coords[3];
+            }
+            break;
+        case SunGraphics2D.TRANSFORM_ANY_TRANSLATE:
+        case SunGraphics2D.TRANSFORM_INT_TRANSLATE:
+            {
+                double tx = sg2d.transform.getTranslateX();
+                double ty = sg2d.transform.getTranslateY();
+                x1 += tx;
+                y1 += ty;
+                x2 += tx;
+                y2 += ty;
+            }
+            break;
+        case SunGraphics2D.TRANSFORM_ISIDENT:
+            break;
+        default:
+            throw new InternalError("unknown TRANSFORM state...");
+        }
+        if (sg2d.strokeHint != SunHints.INTVAL_STROKE_PURE) {
+            if (sg2d.strokeState == SunGraphics2D.STROKE_THIN &&
+                outrenderer instanceof PixelDrawPipe)
+            {
+                // PixelDrawPipes will add sg2d.transXY so we need to factor
+                // that out...
+                int ix1 = (int) Math.floor(x1 - sg2d.transX);
+                int iy1 = (int) Math.floor(y1 - sg2d.transY);
+                int ix2 = (int) Math.floor(x2 - sg2d.transX);
+                int iy2 = (int) Math.floor(y2 - sg2d.transY);
+                ((PixelDrawPipe)outrenderer).drawLine(sg2d, ix1, iy1, ix2, iy2);
+                return true;
+            }
+            x1 = normalize(x1);
+            y1 = normalize(y1);
+            x2 = normalize(x2);
+            y2 = normalize(y2);
+        }
+        if (sg2d.transformState >= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {
+            // Transform the linewidth...
+            // calculate the scaling factor for a unit vector
+            // perpendicular to the original user space line.
+            double len = len(dx, dy);
+            if (len == 0) {
+                dx = len = 1;
+                // dy = 0; already
+            }
+            // delta transform the transposed (90 degree rotated) unit vector
+            double unitvector[] = {dy/len, -dx/len};
+            sg2d.transform.deltaTransform(unitvector, 0, unitvector, 0, 1);
+            lw *= len(unitvector[0], unitvector[1]);
+        }
+        lw = Math.max(lw, minPenSize);
+        dx = x2 - x1;
+        dy = y2 - y1;
+        double len = len(dx, dy);
+        double udx, udy;
+        if (len == 0) {
+            if (cap == BasicStroke.CAP_BUTT) {
+                return true;
+            }
+            udx = lw;
+            udy = 0;
+        } else {
+            udx = lw * dx / len;
+            udy = lw * dy / len;
+        }
+        double px = x1 + udy / 2.0;
+        double py = y1 - udx / 2.0;
+        if (cap == BasicStroke.CAP_SQUARE) {
+            px -= udx / 2.0;
+            py -= udy / 2.0;
+            dx += udx;
+            dy += udy;
+        }
+        outrenderer.fillParallelogram(sg2d, px, py, -udy, udx, dx, dy);
+        return true;
+    }
+
+    public void fillRectangle(SunGraphics2D sg2d,
+                              double rx, double ry,
+                              double rw, double rh)
+    {
+        double px, py;
+        double dx1, dy1, dx2, dy2;
+        AffineTransform txform = sg2d.transform;
+        dx1 = txform.getScaleX();
+        dy1 = txform.getShearY();
+        dx2 = txform.getShearX();
+        dy2 = txform.getScaleY();
+        px = rx * dx1 + ry * dx2 + txform.getTranslateX();
+        py = rx * dy1 + ry * dy2 + txform.getTranslateY();
+        dx1 *= rw;
+        dy1 *= rw;
+        dx2 *= rh;
+        dy2 *= rh;
+        if (adjustfill &&
+            sg2d.strokeState < SunGraphics2D.STROKE_CUSTOM &&
+            sg2d.strokeHint != SunHints.INTVAL_STROKE_PURE)
+        {
+            double newx = normalize(px);
+            double newy = normalize(py);
+            dx1 = normalize(px + dx1) - newx;
+            dy1 = normalize(py + dy1) - newy;
+            dx2 = normalize(px + dx2) - newx;
+            dy2 = normalize(py + dy2) - newy;
+            px = newx;
+            py = newy;
+        }
+        outrenderer.fillParallelogram(sg2d, px, py, dx1, dy1, dx2, dy2);
+    }
+
+    public void drawRectangle(SunGraphics2D sg2d,
+                              double rx, double ry,
+                              double rw, double rh,
+                              double lw)
+    {
+        double px, py;
+        double dx1, dy1, dx2, dy2;
+        double lw1, lw2;
+        AffineTransform txform = sg2d.transform;
+        dx1 = txform.getScaleX();
+        dy1 = txform.getShearY();
+        dx2 = txform.getShearX();
+        dy2 = txform.getScaleY();
+        px = rx * dx1 + ry * dx2 + txform.getTranslateX();
+        py = rx * dy1 + ry * dy2 + txform.getTranslateY();
+        // lw along dx1,dy1 scale by transformed length of dx2,dy2 vectors
+        // and vice versa
+        lw1 = len(dx1, dy1) * lw;
+        lw2 = len(dx2, dy2) * lw;
+        dx1 *= rw;
+        dy1 *= rw;
+        dx2 *= rh;
+        dy2 *= rh;
+        if (sg2d.strokeState < SunGraphics2D.STROKE_CUSTOM &&
+            sg2d.strokeHint != SunHints.INTVAL_STROKE_PURE)
+        {
+            double newx = normalize(px);
+            double newy = normalize(py);
+            dx1 = normalize(px + dx1) - newx;
+            dy1 = normalize(py + dy1) - newy;
+            dx2 = normalize(px + dx2) - newx;
+            dy2 = normalize(py + dy2) - newy;
+            px = newx;
+            py = newy;
+        }
+        lw1 = Math.max(lw1, minPenSize);
+        lw2 = Math.max(lw2, minPenSize);
+        double len1 = len(dx1, dy1);
+        double len2 = len(dx2, dy2);
+        if (lw1 >= len1 || lw2 >= len2) {
+            // The line widths are large enough to consume the
+            // entire hole in the middle of the parallelogram
+            // so we can just fill the outer parallelogram.
+            fillOuterParallelogram(sg2d,
+                                   px, py, dx1, dy1, dx2, dy2,
+                                   len1, len2, lw1, lw2);
+        } else {
+            outrenderer.drawParallelogram(sg2d,
+                                          px, py, dx1, dy1, dx2, dy2,
+                                          lw1 / len1, lw2 / len2);
+        }
+    }
+
+    /**
+     * This utility function handles the case where a drawRectangle
+     * operation discovered that the interior hole in the rectangle
+     * or parallelogram has been completely filled in by the stroke
+     * width.  It calculates the outer parallelogram of the stroke
+     * and issues a single fillParallelogram request to fill it.
+     */
+    public void fillOuterParallelogram(SunGraphics2D sg2d,
+                                       double px, double py,
+                                       double dx1, double dy1,
+                                       double dx2, double dy2,
+                                       double len1, double len2,
+                                       double lw1, double lw2)
+    {
+        double udx1 = dx1 / len1;
+        double udy1 = dy1 / len1;
+        double udx2 = dx2 / len2;
+        double udy2 = dy2 / len2;
+        if (len1 == 0) {
+            // len1 is 0, replace udxy1 with perpendicular of udxy2
+            if (len2 == 0) {
+                // both are 0, use a unit Y vector for udxy2
+                udx2 = 0;
+                udy2 = 1;
+            }
+            udx1 = udy2;
+            udy1 = -udx2;
+        } else if (len2 == 0) {
+            // len2 is 0, replace udxy2 with perpendicular of udxy1
+            udx2 = udy1;
+            udy2 = -udx1;
+        }
+        udx1 *= lw1;
+        udy1 *= lw1;
+        udx2 *= lw2;
+        udy2 *= lw2;
+        px -= (udx1 + udx2) / 2;
+        py -= (udy1 + udy2) / 2;
+        dx1 += udx1;
+        dy1 += udy1;
+        dx2 += udx2;
+        dy2 += udy2;
+
+        outrenderer.fillParallelogram(sg2d, px, py, dx1, dy1, dx2, dy2);
+    }
+}
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/SunGraphics2D.java openjdk/jdk/src/share/classes/sun/java2d/SunGraphics2D.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/SunGraphics2D.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/SunGraphics2D.java	2011-01-08 01:26:50.455202035 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -41,24 +41,17 @@
 import java.awt.image.renderable.RenderContext;
 import java.awt.image.AffineTransformOp;
 import java.awt.image.Raster;
-import java.awt.image.SampleModel;
-import java.awt.image.VolatileImage;
 import java.awt.image.WritableRaster;
 import java.awt.Image;
 import java.awt.Composite;
 import java.awt.Color;
-import java.awt.color.ColorSpace;
-import java.awt.image.DataBuffer;
 import java.awt.image.ColorModel;
-import java.awt.image.IndexColorModel;
-import java.awt.image.DirectColorModel;
 import java.awt.GraphicsConfiguration;
 import java.awt.Paint;
 import java.awt.GradientPaint;
 import java.awt.LinearGradientPaint;
 import java.awt.RadialGradientPaint;
 import java.awt.TexturePaint;
-import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
 import java.awt.geom.PathIterator;
 import java.awt.geom.GeneralPath;
@@ -69,19 +62,16 @@
 import java.text.AttributedCharacterIterator;
 import java.awt.Font;
 import java.awt.image.ImageObserver;
-import java.awt.image.ColorConvertOp;
 import java.awt.Transparency;
 import java.awt.font.GlyphVector;
 import java.awt.font.TextLayout;
 import sun.font.FontDesignMetrics;
-import sun.font.StandardGlyphVector;
 import sun.java2d.pipe.PixelDrawPipe;
 import sun.java2d.pipe.PixelFillPipe;
 import sun.java2d.pipe.ShapeDrawPipe;
 import sun.java2d.pipe.ValidatePipe;
 import sun.java2d.pipe.ShapeSpanIterator;
 import sun.java2d.pipe.Region;
-import sun.java2d.pipe.RegionIterator;
 import sun.java2d.pipe.TextPipe;
 import sun.java2d.pipe.DrawImagePipe;
 import sun.java2d.pipe.LoopPipe;
@@ -90,7 +80,6 @@
 import sun.java2d.loops.CompositeType;
 import sun.java2d.loops.SurfaceType;
 import sun.java2d.loops.Blit;
-import sun.java2d.loops.BlitBg;
 import sun.java2d.loops.MaskFill;
 import sun.font.FontManager;
 import java.awt.font.FontRenderContext;
@@ -99,7 +88,7 @@
 import sun.awt.SunHints;
 import java.util.Map;
 import java.util.Iterator;
-import sun.awt.image.OffScreenImage;
+import sun.java2d.DestSurfaceProvider;
 import sun.misc.PerformanceLogger;
 
 /**
@@ -113,7 +102,7 @@
  */
 public final class SunGraphics2D
     extends Graphics2D
-    implements ConstrainableGraphics, Cloneable
+    implements ConstrainableGraphics, Cloneable, DestSurfaceProvider
 {
     /*
      * Attribute States
@@ -3288,4 +3277,14 @@
     public Object getDestination() {
         return surfaceData.getDestination();
     }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.DestSurfaceProvider#getDestSurface
+     */
+    @Override
+    public Surface getDestSurface() {
+        return surfaceData;
+    }
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java openjdk/jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java	2011-01-08 01:26:50.455202035 +0000
@@ -36,6 +36,7 @@
 import java.awt.Toolkit;
 import java.awt.font.TextAttribute;
 import java.awt.image.BufferedImage;
+import java.awt.peer.ComponentPeer;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
@@ -1276,4 +1277,18 @@
     /*
      * ----END DISPLAY CHANGE SUPPORT----
      */
+
+    /**
+     * Returns true if FlipBufferStrategy with COPIED buffer contents
+     * is preferred for this peer's GraphicsConfiguration over
+     * BlitBufferStrategy, false otherwise.
+     *
+     * The reason FlipBS could be preferred is that in some configurations
+     * an accelerated copy to the screen is supported (like Direct3D 9)
+     *
+     * @return true if flip strategy should be used, false otherwise
+     */
+    public boolean isFlipStrategyPreferred(ComponentPeer peer) {
+        return false;
+    }
 }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/SurfaceData.java openjdk/jdk/src/share/classes/sun/java2d/SurfaceData.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/SurfaceData.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/SurfaceData.java	2011-01-08 01:26:50.455202035 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -93,7 +93,7 @@
  * retrieved the tracker.
  */
 public abstract class SurfaceData
-    implements Transparency, DisposerTarget, StateTrackable
+    implements Transparency, DisposerTarget, StateTrackable, Surface
 {
     private long pData;
     private boolean valid;
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/SurfaceDataProxy.java openjdk/jdk/src/share/classes/sun/java2d/SurfaceDataProxy.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/SurfaceDataProxy.java	2011-01-07 21:33:02.000000000 +0000
+++ openjdk/jdk/src/share/classes/sun/java2d/SurfaceDataProxy.java	2011-01-08 01:26:50.455202035 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -521,7 +521,7 @@
                                             CompositeType.SrcNoEa,
                                             dstType);
         blitbg.BlitBg(srcData, dstData,
-                      AlphaComposite.Src, null, bgColor,
+                      AlphaComposite.Src, null, bgColor.getRGB(),
                       0, 0, 0, 0, w, h);
         dstData.markDirty();
     }
diff -Nru openjdk.orig/jdk/src/share/classes/sun/java2d/Surface.java openjdk/jdk/src/share/classes/sun/java2d/Surface.java
--- openjdk.orig/jdk/src/share/classes/sun/java2d/Surface.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/classes/sun/java2d/Surface.java	2011-01-08 01:26:50.455202035 +0000
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d;
+
+/**
+ * This is a tag interface for a surface.
+ * @see sun.java2d.SurfaceData
+ * @see sun.java2d.pipe.hw.AccelSurface
+ */
+public interface Surface {
+}
diff -Nru openjdk.orig/jdk/src/share/native/sun/font/AccelGlyphCache.c openjdk/jdk/src/share/native/sun/font/AccelGlyphCache.c
--- openjdk.orig/jdk/src/share/native/sun/font/AccelGlyphCache.c	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/font/AccelGlyphCache.c	2011-01-08 01:26:50.455202035 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -45,6 +45,19 @@
  * list describing the cache as new glyphs are added.  Platform specific
  * glyph caching code is responsible for actually creating the accelerated
  * memory surface that will contain the individual glyph images.
+ *
+ * Each glyph contains a reference to a list of cell infos - one per glyph
+ * cache. There may be multiple glyph caches (for example, one per graphics
+ * adapter), so if the glyph is cached on two devices its cell list will
+ * consists of two elements corresponding to different glyph caches.
+ *
+ * The platform-specific glyph caching code is supposed to use
+ * GetCellInfoForCache method for retrieving cache infos from the glyph's list.
+ *
+ * Note that if it is guaranteed that there will be only one global glyph
+ * cache then it one does not have to use AccelGlyphCache_GetCellInfoForCache
+ * for retrieving cell info for the glyph, but instead just use the struct's
+ * field directly.
  */
 GlyphCacheInfo *
 AccelGlyphCache_Init(jint width, jint height,
@@ -86,8 +99,11 @@
  * "virtual" glyph cache is available for the glyph image.  Platform specific
  * glyph caching code is responsible for actually caching the glyph image
  * in the associated accelerated memory surface.
+ *
+ * Returns created cell info if it was successfully created and added to the
+ * cache and glyph's cell lists, NULL otherwise.
  */
-void
+CacheCellInfo *
 AccelGlyphCache_AddGlyph(GlyphCacheInfo *cache, GlyphInfo *glyph)
 {
     CacheCellInfo *cellinfo = NULL;
@@ -99,7 +115,7 @@
     if ((glyph->width > cache->cellWidth) ||
         (glyph->height > cache->cellHeight))
     {
-        return;
+        return NULL;
     }
 
     if (!cache->isFull) {
@@ -126,9 +142,8 @@
             // create new CacheCellInfo
             cellinfo = (CacheCellInfo *)malloc(sizeof(CacheCellInfo));
             if (cellinfo == NULL) {
-                glyph->cellInfo = NULL;
                 J2dTraceLn(J2D_TRACE_ERROR, "could not allocate CellInfo");
-                return;
+                return NULL;
             }
 
             cellinfo->cacheInfo = cache;
@@ -136,6 +151,8 @@
             cellinfo->timesRendered = 0;
             cellinfo->x = x;
             cellinfo->y = y;
+            cellinfo->leftOff = 0;
+            cellinfo->rightOff = 0;
             cellinfo->tx1 = (jfloat)cellinfo->x / cache->width;
             cellinfo->ty1 = (jfloat)cellinfo->y / cache->height;
             cellinfo->tx2 = cellinfo->tx1 + ((jfloat)w / cache->width);
@@ -152,6 +169,7 @@
             // add the new cell to the end of the list
             cache->tail = cellinfo;
             cellinfo->next = NULL;
+            cellinfo->nextGCI = NULL;
         }
     }
 
@@ -210,9 +228,9 @@
                 cache->Flush();
             }
 
-            // if the cell is occupied, notify the base glyph that its
-            // cached version is about to be kicked out
-            cellinfo->glyphInfo->cellInfo = NULL;
+            // if the cell is occupied, notify the base glyph that the
+            // cached version for this cache is about to be kicked out
+            AccelGlyphCache_RemoveCellInfo(cellinfo->glyphInfo, cellinfo);
         }
 
         // update cellinfo with glyph's occupied region information
@@ -221,8 +239,9 @@
         cellinfo->ty2 = cellinfo->ty1 + ((jfloat)h / cache->height);
     }
 
-    // update the glyph's reference to its cache cell
-    glyph->cellInfo = cellinfo;
+    // add cache cell to the glyph's cells list
+    AccelGlyphCache_AddCellInfo(glyph, cellinfo);
+    return cellinfo;
 }
 
 /**
@@ -251,10 +270,145 @@
     while (cellinfo != NULL) {
         if (cellinfo->glyphInfo != NULL) {
             // if the cell is occupied, notify the base glyph that its
-            // cached version is about to be invalidated
-            cellinfo->glyphInfo->cellInfo = NULL;
-            cellinfo->glyphInfo = NULL;
+            // cached version for this cache is about to be invalidated
+            AccelGlyphCache_RemoveCellInfo(cellinfo->glyphInfo, cellinfo);
         }
         cellinfo = cellinfo->next;
     }
 }
+
+/**
+ * Invalidates and frees all cells and the cache itself. The "cache" pointer
+ * becomes invalid after this function returns.
+ */
+void
+AccelGlyphCache_Free(GlyphCacheInfo *cache)
+{
+    CacheCellInfo *cellinfo;
+
+    J2dTraceLn(J2D_TRACE_INFO, "AccelGlyphCache_Free");
+
+    if (cache == NULL) {
+        return;
+    }
+
+    // flush any pending vertices that may be depending on the current
+    // glyph cache
+    if (cache->Flush != NULL) {
+        cache->Flush();
+    }
+
+    while (cache->head != NULL) {
+        cellinfo = cache->head;
+        if (cellinfo->glyphInfo != NULL) {
+            // if the cell is occupied, notify the base glyph that its
+            // cached version for this cache is about to be invalidated
+            AccelGlyphCache_RemoveCellInfo(cellinfo->glyphInfo, cellinfo);
+        }
+        cache->head = cellinfo->next;
+        free(cellinfo);
+    }
+    free(cache);
+}
+
+/**
+ * Add cell info to the head of the glyph's list of cached cells.
+ */
+void
+AccelGlyphCache_AddCellInfo(GlyphInfo *glyph, CacheCellInfo *cellInfo)
+{
+    // assert (glyph != NULL && cellInfo != NULL)
+    J2dTraceLn(J2D_TRACE_INFO, "AccelGlyphCache_AddCellInfo");
+    J2dTraceLn2(J2D_TRACE_VERBOSE, "  glyph 0x%x: adding cell 0x%x to the list",
+                glyph, cellInfo);
+
+    cellInfo->glyphInfo = glyph;
+    cellInfo->nextGCI = glyph->cellInfo;
+    glyph->cellInfo = cellInfo;
+}
+
+/**
+ * Removes cell info from the glyph's list of cached cells.
+ */
+void
+AccelGlyphCache_RemoveCellInfo(GlyphInfo *glyph, CacheCellInfo *cellInfo)
+{
+    CacheCellInfo *currCellInfo = glyph->cellInfo;
+    CacheCellInfo *prevInfo = NULL;
+    // assert (glyph!= NULL && glyph->cellInfo != NULL && cellInfo != NULL)
+    J2dTraceLn(J2D_TRACE_INFO, "AccelGlyphCache_RemoveCellInfo");
+    do {
+        if (currCellInfo == cellInfo) {
+            J2dTraceLn2(J2D_TRACE_VERBOSE,
+                        "  glyph 0x%x: removing cell 0x%x from glyph's list",
+                        glyph, currCellInfo);
+            if (prevInfo == NULL) { // it's the head, chop-chop
+                glyph->cellInfo = currCellInfo->nextGCI;
+            } else {
+                prevInfo->nextGCI = currCellInfo->nextGCI;
+            }
+            currCellInfo->glyphInfo = NULL;
+            currCellInfo->nextGCI = NULL;
+            return;
+        }
+        prevInfo = currCellInfo;
+        currCellInfo = currCellInfo->nextGCI;
+    } while (currCellInfo != NULL);
+    J2dTraceLn2(J2D_TRACE_WARNING, "AccelGlyphCache_RemoveCellInfo: "\
+                "no cell 0x%x in glyph 0x%x's cell list",
+                cellInfo, glyph);
+}
+
+/**
+ * Removes cell info from the glyph's list of cached cells.
+ */
+JNIEXPORT void
+AccelGlyphCache_RemoveAllCellInfos(GlyphInfo *glyph)
+{
+    CacheCellInfo *currCell, *prevCell;
+
+    J2dTraceLn(J2D_TRACE_INFO, "AccelGlyphCache_RemoveAllCellInfos");
+
+    if (glyph == NULL || glyph->cellInfo == NULL) {
+        return;
+    }
+
+    // invalidate all of this glyph's accelerated cache cells
+    currCell = glyph->cellInfo;
+    do {
+        currCell->glyphInfo = NULL;
+        prevCell = currCell;
+        currCell = currCell->nextGCI;
+        prevCell->nextGCI = NULL;
+    } while (currCell != NULL);
+
+    glyph->cellInfo = NULL;
+}
+
+/**
+ * Returns cell info associated with particular cache from the glyph's list of
+ * cached cells.
+ */
+CacheCellInfo *
+AccelGlyphCache_GetCellInfoForCache(GlyphInfo *glyph, GlyphCacheInfo *cache)
+{
+    // assert (glyph != NULL && cache != NULL)
+    J2dTraceLn(J2D_TRACE_VERBOSE2, "AccelGlyphCache_GetCellInfoForCache");
+
+    if (glyph->cellInfo != NULL) {
+        CacheCellInfo *cellInfo = glyph->cellInfo;
+        do {
+            if (cellInfo->cacheInfo == cache) {
+                J2dTraceLn3(J2D_TRACE_VERBOSE2,
+                            "  glyph 0x%x: found cell 0x%x for cache 0x%x",
+                            glyph, cellInfo, cache);
+                return cellInfo;
+            }
+            cellInfo = cellInfo->nextGCI;
+        } while (cellInfo != NULL);
+    }
+    J2dTraceLn2(J2D_TRACE_VERBOSE2, "  glyph 0x%x: no cell for cache 0x%x",
+                glyph, cache);
+    return NULL;
+}
+
diff -Nru openjdk.orig/jdk/src/share/native/sun/font/AccelGlyphCache.h openjdk/jdk/src/share/native/sun/font/AccelGlyphCache.h
--- openjdk.orig/jdk/src/share/native/sun/font/AccelGlyphCache.h	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/font/AccelGlyphCache.h	2011-01-08 01:26:50.455202035 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,6 +26,10 @@
 #ifndef AccelGlyphCache_h_Included
 #define AccelGlyphCache_h_Included
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #include "jni.h"
 #include "fontscalerdefs.h"
 
@@ -48,10 +52,18 @@
 struct _CacheCellInfo {
     GlyphCacheInfo   *cacheInfo;
     struct GlyphInfo *glyphInfo;
+    // next cell info in the cache's list
     CacheCellInfo    *next;
+    // REMIND: find better name?
+    // next cell info in the glyph's cell list (next Glyph Cache Info)
+    CacheCellInfo    *nextGCI;
     jint             timesRendered;
     jint             x;
     jint             y;
+    // number of pixels from the left or right edge not considered touched
+    // by the glyph
+    jint             leftOff;
+    jint             rightOff;
     jfloat           tx1;
     jfloat           ty1;
     jfloat           tx2;
@@ -62,9 +74,24 @@
 AccelGlyphCache_Init(jint width, jint height,
                      jint cellWidth, jint cellHeight,
                      FlushFunc *func);
-void
+CacheCellInfo *
 AccelGlyphCache_AddGlyph(GlyphCacheInfo *cache, struct GlyphInfo *glyph);
 void
 AccelGlyphCache_Invalidate(GlyphCacheInfo *cache);
+void
+AccelGlyphCache_AddCellInfo(struct GlyphInfo *glyph, CacheCellInfo *cellInfo);
+void
+AccelGlyphCache_RemoveCellInfo(struct GlyphInfo *glyph, CacheCellInfo *cellInfo);
+CacheCellInfo *
+AccelGlyphCache_GetCellInfoForCache(struct GlyphInfo *glyph,
+                                    GlyphCacheInfo *cache);
+JNIEXPORT void
+AccelGlyphCache_RemoveAllCellInfos(struct GlyphInfo *glyph);
+void
+AccelGlyphCache_Free(GlyphCacheInfo *cache);
+
+#ifdef __cplusplus
+};
+#endif
 
 #endif /* AccelGlyphCache_h_Included */
diff -Nru openjdk.orig/jdk/src/share/native/sun/font/sunFont.c openjdk/jdk/src/share/native/sun/font/sunFont.c
--- openjdk.orig/jdk/src/share/native/sun/font/sunFont.c	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/font/sunFont.c	2011-01-08 01:26:50.455202035 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,6 +35,8 @@
 #include "sun_font_StrikeCache.h"
 
 static void *theNullScalerContext = NULL;
+extern void AccelGlyphCache_RemoveAllCellInfos(GlyphInfo *glyph);
+
 
 JNIEXPORT jlong JNICALL
 Java_sun_font_NullFontScaler_getNullScalerContext
@@ -294,7 +296,7 @@
                 GlyphInfo *ginfo = (GlyphInfo *)ptrs[i];
                 if (ginfo->cellInfo != NULL) {
                     // invalidate this glyph's accelerated cache cell
-                    ginfo->cellInfo->glyphInfo = NULL;
+                    AccelGlyphCache_RemoveAllCellInfos(ginfo);
                 }
                 free((void*)ginfo);
             }
@@ -324,8 +326,7 @@
             if (ptrs[i] != 0L) {
                 GlyphInfo *ginfo = (GlyphInfo *) jlong_to_ptr(ptrs[i]);
                 if (ginfo->cellInfo != NULL) {
-                    // invalidate this glyph's accelerated cache cell
-                    ginfo->cellInfo->glyphInfo = NULL;
+                    AccelGlyphCache_RemoveAllCellInfos(ginfo);
                 }
                 free((void*)ginfo);
             }
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/loops/BlitBg.c openjdk/jdk/src/share/native/sun/java2d/loops/BlitBg.c
--- openjdk.orig/jdk/src/share/native/sun/java2d/loops/BlitBg.c	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/loops/BlitBg.c	2011-01-08 01:26:50.455202035 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,12 +31,12 @@
 /*
  * Class:     sun_java2d_loops_BlitBg
  * Method:    BlitBg
- * Signature: (Lsun/java2d/SurfaceData;Lsun/java2d/SurfaceData;Ljava/awt/Composite;Ljava/awt/Color;IIIIII)V
+ * Signature: (Lsun/java2d/SurfaceData;Lsun/java2d/SurfaceData;Ljava/awt/Composite;IIIIIII)V
  */
 JNIEXPORT void JNICALL Java_sun_java2d_loops_BlitBg_BlitBg
     (JNIEnv *env, jobject self,
      jobject srcData, jobject dstData,
-     jobject comp, jobject clip, jobject bgColor,
+     jobject comp, jobject clip, jint bgColor,
      jint srcx, jint srcy, jint dstx, jint dsty, jint width, jint height)
 {
     SurfaceDataOps *srcOps;
@@ -93,7 +93,7 @@
     Region_IntersectBounds(&clipInfo, &dstInfo.bounds);
 
     if (!Region_IsEmpty(&clipInfo)) {
-        jint bgpixel = GrPrim_ColorGetRGB(env, bgColor);
+        jint bgpixel = bgColor;
         srcOps->GetRasInfo(env, srcOps, &srcInfo);
         dstOps->GetRasInfo(env, dstOps, &dstInfo);
         if (pPrim->pDstType->pixelFor) {
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.c openjdk/jdk/src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.c
--- openjdk.orig/jdk/src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.c	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.c	2011-01-08 01:26:50.455202035 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -50,7 +50,6 @@
 static jfieldID clipRegionID;
 static jfieldID compositeID;
 static jfieldID lcdTextContrastID;
-static jfieldID valueID;
 static jfieldID xorPixelID;
 static jfieldID xorColorID;
 static jfieldID alphaMaskID;
@@ -64,6 +63,8 @@
 static jfieldID m11ID;
 static jfieldID m12ID;
 
+static jmethodID getRgbID;
+
 static jboolean InitPrimTypes(JNIEnv *env);
 static jboolean InitSurfaceTypes(JNIEnv *env, jclass SurfaceType);
 static jboolean InitCompositeTypes(JNIEnv *env, jclass CompositeType);
@@ -114,7 +115,7 @@
                                      "Ljava/awt/Composite;");
     lcdTextContrastID =
         (*env)->GetFieldID(env, SG2D, "lcdTextContrast", "I");
-    valueID = (*env)->GetFieldID(env, Color, "value", "I");
+    getRgbID = (*env)->GetMethodID(env, Color, "getRGB", "()I");
     xorPixelID = (*env)->GetFieldID(env, XORComp, "xorPixel", "I");
     xorColorID = (*env)->GetFieldID(env, XORComp, "xorColor",
                                     "Ljava/awt/Color;");
@@ -138,7 +139,6 @@
     sg2dStrokeHintID = (*env)->GetFieldID(env, SG2D, "strokeHint", "I");
     fid = (*env)->GetStaticFieldID(env, SHints, "INTVAL_STROKE_PURE", "I");
     sunHints_INTVAL_STROKE_PURE = (*env)->GetStaticIntField(env, SHints, fid);
-
 }
 
 void GrPrim_RefineBounds(SurfaceDataBounds *bounds, jint transX, jint transY,
@@ -467,7 +467,7 @@
     jint rgb;
 
     color = (*env)->GetObjectField(env, comp, xorColorID);
-    rgb = (*env)->GetIntField(env, color, valueID);
+    rgb = (*env)->CallIntMethod(env, color, getRgbID);
     (*env)->DeleteLocalRef(env, color);
 
     return rgb;
@@ -492,11 +492,6 @@
     return (*env)->GetIntField(env, sg2d, eargbID);
 }
 
-jint GrPrim_ColorGetRGB(JNIEnv *env, jobject color)
-{
-    return (*env)->GetIntField(env, color, valueID);
-}
-
 JNIEXPORT jint JNICALL
 GrPrim_Sg2dGetLCDTextContrast(JNIEnv *env, jobject sg2d)
 {
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h openjdk/jdk/src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h
--- openjdk.orig/jdk/src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/loops/GraphicsPrimitiveMgr.h	2011-01-08 01:26:50.455202035 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -501,7 +501,6 @@
 GrPrim_Sg2dGetEaRGB(JNIEnv *env, jobject sg2d);
 extern JNIEXPORT jint JNICALL
 GrPrim_Sg2dGetLCDTextContrast(JNIEnv *env, jobject sg2d);
-extern jint GrPrim_ColorGetRGB(JNIEnv *env, jobject color);
 
 /*
  * Data structure and functions to retrieve and use
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLContext.c openjdk/jdk/src/share/native/sun/java2d/opengl/OGLContext.c
--- openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLContext.c	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/opengl/OGLContext.c	2011-01-08 01:26:50.455202035 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -852,28 +852,58 @@
 
     J2dTraceLn(J2D_TRACE_INFO, "OGLContext_GetExtensionInfo");
 
+    *caps |= CAPS_TEXNONSQUARE;
     if (OGLContext_IsExtensionAvailable(e, "GL_ARB_multitexture")) {
-        *caps |= sun_java2d_opengl_OGLContext_CAPS_EXT_MULTITEXTURE;
+        *caps |= CAPS_MULTITEXTURE;
     }
     if (OGLContext_IsExtensionAvailable(e, "GL_ARB_texture_non_power_of_two")){
-        *caps |= sun_java2d_opengl_OGLContext_CAPS_EXT_TEXNONPOW2;
+        *caps |= CAPS_TEXNONPOW2;
     }
-    if (OGLContext_IsExtensionAvailable(e, "GL_ARB_texture_rectangle")) {
-        *caps |= sun_java2d_opengl_OGLContext_CAPS_EXT_TEXRECT;
+    // 6656574: Use of the GL_ARB_texture_rectangle extension by Java 2D
+    // complicates any third-party libraries that try to interact with
+    // the OGL pipeline (and we've run into driver bugs in the past related
+    // to this extension), so for now we will disable its use by default (unless
+    // forced). We will still make use of the GL_ARB_texture_non_power_of_two
+    // extension when available, which is the better choice going forward
+    // anyway.
+    if (OGLContext_IsExtensionAvailable(e, "GL_ARB_texture_rectangle") &&
+        getenv("J2D_OGL_TEXRECT") != NULL)
+    {
+        *caps |= CAPS_EXT_TEXRECT;
     }
     if (OGLContext_IsFBObjectExtensionAvailable(env, e)) {
-        *caps |= sun_java2d_opengl_OGLContext_CAPS_EXT_FBOBJECT;
+        *caps |= CAPS_EXT_FBOBJECT;
     }
     if (OGLContext_IsLCDShaderSupportAvailable(env, fragShaderAvail)) {
-        *caps |= sun_java2d_opengl_OGLContext_CAPS_EXT_LCD_SHADER;
+        *caps |= CAPS_EXT_LCD_SHADER | CAPS_PS20;
     }
     if (OGLContext_IsBIOpShaderSupportAvailable(env, fragShaderAvail)) {
-        *caps |= sun_java2d_opengl_OGLContext_CAPS_EXT_BIOP_SHADER;
+        *caps |= CAPS_EXT_BIOP_SHADER | CAPS_PS20;
     }
     if (OGLContext_IsGradShaderSupportAvailable(env, fragShaderAvail)) {
-        *caps |= sun_java2d_opengl_OGLContext_CAPS_EXT_GRAD_SHADER;
+        *caps |= CAPS_EXT_GRAD_SHADER | CAPS_PS20;
+    }
+    if (OGLContext_IsExtensionAvailable(e, "GL_NV_fragment_program")) {
+        // this is an Nvidia board, at least PS 2.0, but we can't
+        // use the "max instructions" heuristic since GeForce FX
+        // boards report 1024 even though they're only PS 2.0,
+        // so we'll check the following, which does imply PS 3.0
+        if (OGLContext_IsExtensionAvailable(e, "GL_NV_fragment_program2")) {
+            *caps |= CAPS_PS30;
+        }
+    } else {
+        // for all other boards, we look at the "max instructions"
+        // count reported by the GL_ARB_fragment_program extension
+        // as a heuristic for detecting PS 3.0 compatible hardware
+        if (OGLContext_IsExtensionAvailable(e, "GL_ARB_fragment_program")) {
+            GLint instr;
+            j2d_glGetProgramivARB(GL_FRAGMENT_PROGRAM_ARB,
+                                  GL_MAX_PROGRAM_INSTRUCTIONS_ARB, &instr);
+            if (instr > 512) {
+                *caps |= CAPS_PS30;
+            }
+        }
     }
-
     // stuff vendor descriptor in the upper bits of the caps
     if (vendor != NULL) {
         if (strncmp(vendor, "ATI", 3) == 0) {
@@ -883,8 +913,10 @@
         } else if (strncmp(vendor, "Sun", 3) == 0) {
             vcap = OGLC_VENDOR_SUN;
         }
+        // REMIND: new in 7 - check if needs fixing
+        *caps |= ((vcap & OGLC_VCAP_MASK) << OGLC_VCAP_OFFSET);
     }
-    *caps |= ((vcap & OGLC_VCAP_MASK) << OGLC_VCAP_OFFSET);
+
 }
 
 /**
@@ -983,4 +1015,49 @@
     return fragmentProgram;
 }
 
+/*
+ * Class:     sun_java2d_opengl_OGLContext
+ * Method:    getOGLIdString
+ * Signature: ()Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_sun_java2d_opengl_OGLContext_getOGLIdString
+  (JNIEnv *env, jclass oglcc)
+{
+    char *vendor, *renderer, *version;
+    char *pAdapterId;
+    jobject ret = NULL;
+    int len;
+
+    J2dTraceLn(J2D_TRACE_INFO, "OGLContext_getOGLIdString");
+
+    vendor = (char*)j2d_glGetString(GL_VENDOR);
+    if (vendor == NULL) {
+        vendor = "Unknown Vendor";
+    }
+    renderer = (char*)j2d_glGetString(GL_RENDERER);
+    if (renderer == NULL) {
+        renderer = "Unknown Renderer";
+    }
+    version = (char*)j2d_glGetString(GL_VERSION);
+    if (version == NULL) {
+        version = "unknown version";
+    }
+
+    // 'vendor renderer (version)0'
+    len = strlen(vendor) + 1 + strlen(renderer) + 1 + 1+strlen(version)+1 + 1;
+    pAdapterId = malloc(len);
+    if (pAdapterId != NULL) {
+
+        jio_snprintf(pAdapterId, len, "%s %s (%s)", vendor, renderer, version);
+
+        J2dTraceLn1(J2D_TRACE_VERBOSE, "  id=%s", pAdapterId);
+
+        ret = JNU_NewStringPlatform(env, pAdapterId);
+
+        free(pAdapterId);
+    }
+
+    return ret;
+}
+
 #endif /* !HEADLESS */
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLContext.h openjdk/jdk/src/share/native/sun/java2d/opengl/OGLContext.h
--- openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLContext.h	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/opengl/OGLContext.h	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,7 @@
 
 #include "sun_java2d_pipe_BufferedContext.h"
 #include "sun_java2d_opengl_OGLContext.h"
+#include "sun_java2d_opengl_OGLContext_OGLContextCaps.h"
 
 #include "j2d_md.h"
 #include "J2D_GL/gl.h"
@@ -96,13 +97,50 @@
     sun_java2d_pipe_BufferedContext_USE_MASK
 
 /**
+ * See OGLContext.java for more on these flags.
+ */
+#define CAPS_EMPTY           \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_EMPTY
+#define CAPS_RT_PLAIN_ALPHA  \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_RT_PLAIN_ALPHA
+#define CAPS_RT_TEXTURE_ALPHA       \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_RT_TEXTURE_ALPHA
+#define CAPS_RT_TEXTURE_OPAQUE      \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_RT_TEXTURE_OPAQUE
+#define CAPS_MULTITEXTURE    \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_MULTITEXTURE
+#define CAPS_TEXNONPOW2      \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_TEXNONPOW2
+#define CAPS_TEXNONSQUARE    \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_TEXNONSQUARE
+#define CAPS_PS20            \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_PS20
+#define CAPS_PS30            \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_PS30
+#define LAST_SHARED_CAP      \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_LAST_SHARED_CAP
+#define CAPS_EXT_FBOBJECT    \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_EXT_FBOBJECT
+#define CAPS_STORED_ALPHA    \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_STORED_ALPHA
+#define CAPS_DOUBLEBUFFERED  \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_DOUBLEBUFFERED
+#define CAPS_EXT_LCD_SHADER  \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_EXT_LCD_SHADER
+#define CAPS_EXT_BIOP_SHADER \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_EXT_BIOP_SHADER
+#define CAPS_EXT_GRAD_SHADER \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_EXT_GRAD_SHADER
+#define CAPS_EXT_TEXRECT     \
+    sun_java2d_opengl_OGLContext_OGLContextCaps_CAPS_EXT_TEXRECT
+
+/**
  * Evaluates to true if the given capability bitmask is present for the
  * given OGLContext.  Note that only the constant name needs to be passed as
  * a parameter, as this macro will automatically prepend the full package
  * and class name to the constant name.
  */
-#define OGLC_IS_CAP_PRESENT(oglc, cap) \
-    (((oglc)->caps & (sun_java2d_opengl_OGLContext_##cap)) != 0)
+#define OGLC_IS_CAP_PRESENT(oglc, cap) (((oglc)->caps & (cap)) != 0)
 
 /**
  * At startup we will embed one of the following values in the caps field
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h openjdk/jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h
--- openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -91,8 +91,12 @@
 typedef void (GLAPIENTRY *glPixelTransferfType)(GLenum pname, GLfloat param);
 typedef void (GLAPIENTRY *glPixelZoomType)(GLfloat xfactor, GLfloat yfactor);
 typedef void (GLAPIENTRY *glPolygonOffsetType)(GLfloat factor, GLfloat units);
+typedef void (GLAPIENTRY *glPopAttribType)(void);
+typedef void (GLAPIENTRY *glPopClientAttribType)(void);
 typedef void (GLAPIENTRY *glPopMatrixType)(void);
 typedef void (GLAPIENTRY *glPrioritizeTexturesType)(GLsizei n, const GLuint *textures, const GLclampf *priorities);
+typedef void (GLAPIENTRY *glPushAttribType)(GLbitfield);
+typedef void (GLAPIENTRY *glPushClientAttribType)(GLbitfield);
 typedef void (GLAPIENTRY *glPushMatrixType)(void);
 typedef void (GLAPIENTRY *glRasterPos2iType)(GLint x, GLint y);
 typedef void (GLAPIENTRY *glReadBufferType)(GLenum mode);
@@ -155,8 +159,10 @@
 typedef void (GLAPIENTRY *glUniform3fARBType)(GLint, GLfloat, GLfloat, GLfloat);
 typedef void (GLAPIENTRY *glUniform3fvARBType)(GLint, GLsizei, const GLfloat *);
 typedef void (GLAPIENTRY *glUniform4fARBType)(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
+typedef void (GLAPIENTRY *glUniform4fvARBType)(GLint, GLsizei, const GLfloat *);
 typedef GLint (GLAPIENTRY *glGetUniformLocationARBType)(GLhandleARB, const GLcharARB *);
 typedef void (GLAPIENTRY *glGetInfoLogARBType)(GLhandleARB, GLsizei, GLsizei *, GLcharARB *);
+typedef void (GLAPIENTRY *glGetProgramivARBType)(GLenum, GLenum, GLint *);
 typedef void (GLAPIENTRY *glGetObjectParameterivARBType)(GLhandleARB, GLenum, GLint *);
 typedef GLhandleARB (GLAPIENTRY *glCreateProgramObjectARBType)(void);
 typedef void (GLAPIENTRY *glAttachObjectARBType)(GLhandleARB, GLhandleARB);
@@ -243,8 +249,12 @@
     OGL_##action##_FUNC(glPixelTransferf); \
     OGL_##action##_FUNC(glPixelZoom); \
     OGL_##action##_FUNC(glPolygonOffset); \
+    OGL_##action##_FUNC(glPopAttrib); \
+    OGL_##action##_FUNC(glPopClientAttrib); \
     OGL_##action##_FUNC(glPopMatrix); \
     OGL_##action##_FUNC(glPrioritizeTextures); \
+    OGL_##action##_FUNC(glPushAttrib); \
+    OGL_##action##_FUNC(glPushClientAttrib); \
     OGL_##action##_FUNC(glPushMatrix); \
     OGL_##action##_FUNC(glRasterPos2i); \
     OGL_##action##_FUNC(glReadBuffer); \
@@ -298,7 +308,9 @@
     OGL_##action##_EXT_FUNC(glUniform3fARB); \
     OGL_##action##_EXT_FUNC(glUniform3fvARB); \
     OGL_##action##_EXT_FUNC(glUniform4fARB); \
+    OGL_##action##_EXT_FUNC(glUniform4fvARB); \
     OGL_##action##_EXT_FUNC(glGetUniformLocationARB); \
+    OGL_##action##_EXT_FUNC(glGetProgramivARB); \
     OGL_##action##_EXT_FUNC(glGetInfoLogARB); \
     OGL_##action##_EXT_FUNC(glGetObjectParameterivARB); \
     OGL_##action##_EXT_FUNC(glDeleteObjectARB);
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLRenderer.c openjdk/jdk/src/share/native/sun/java2d/opengl/OGLRenderer.c
--- openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLRenderer.c	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/opengl/OGLRenderer.c	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
 
 #include <jlong.h>
 #include <jni_util.h>
+#include <math.h>
 
 #include "sun_java2d_opengl_OGLRenderer.h"
 
@@ -326,4 +327,486 @@
     }
 }
 
+#define FILL_PGRAM(fx11, fy11, dx21, dy21, dx12, dy12) \
+    do { \
+        j2d_glVertex2f(fx11,               fy11); \
+        j2d_glVertex2f(fx11 + dx21,        fy11 + dy21); \
+        j2d_glVertex2f(fx11 + dx21 + dx12, fy11 + dy21 + dy12); \
+        j2d_glVertex2f(fx11 + dx12,        fy11 + dy12); \
+    } while (0)
+
+void
+OGLRenderer_FillParallelogram(OGLContext *oglc,
+                              jfloat fx11, jfloat fy11,
+                              jfloat dx21, jfloat dy21,
+                              jfloat dx12, jfloat dy12)
+{
+    J2dTraceLn6(J2D_TRACE_INFO,
+                "OGLRenderer_FillParallelogram "
+                "(x=%6.2f y=%6.2f "
+                "dx1=%6.2f dy1=%6.2f "
+                "dx2=%6.2f dy2=%6.2f)",
+                fx11, fy11,
+                dx21, dy21,
+                dx12, dy12);
+
+    RETURN_IF_NULL(oglc);
+
+    CHECK_PREVIOUS_OP(GL_QUADS);
+
+    FILL_PGRAM(fx11, fy11, dx21, dy21, dx12, dy12);
+}
+
+void
+OGLRenderer_DrawParallelogram(OGLContext *oglc,
+                              jfloat fx11, jfloat fy11,
+                              jfloat dx21, jfloat dy21,
+                              jfloat dx12, jfloat dy12,
+                              jfloat lwr21, jfloat lwr12)
+{
+    // dx,dy for line width in the "21" and "12" directions.
+    jfloat ldx21 = dx21 * lwr21;
+    jfloat ldy21 = dy21 * lwr21;
+    jfloat ldx12 = dx12 * lwr12;
+    jfloat ldy12 = dy12 * lwr12;
+
+    // calculate origin of the outer parallelogram
+    jfloat ox11 = fx11 - (ldx21 + ldx12) / 2.0f;
+    jfloat oy11 = fy11 - (ldy21 + ldy12) / 2.0f;
+
+    J2dTraceLn8(J2D_TRACE_INFO,
+                "OGLRenderer_DrawParallelogram "
+                "(x=%6.2f y=%6.2f "
+                "dx1=%6.2f dy1=%6.2f lwr1=%6.2f "
+                "dx2=%6.2f dy2=%6.2f lwr2=%6.2f)",
+                fx11, fy11,
+                dx21, dy21, lwr21,
+                dx12, dy12, lwr12);
+
+    RETURN_IF_NULL(oglc);
+
+    CHECK_PREVIOUS_OP(GL_QUADS);
+
+    // Only need to generate 4 quads if the interior still
+    // has a hole in it (i.e. if the line width ratio was
+    // less than 1.0)
+    if (lwr21 < 1.0f && lwr12 < 1.0f) {
+        // Note: "TOP", "BOTTOM", "LEFT" and "RIGHT" here are
+        // relative to whether the dxNN variables are positive
+        // and negative.  The math works fine regardless of
+        // their signs, but for conceptual simplicity the
+        // comments will refer to the sides as if the dxNN
+        // were all positive.  "TOP" and "BOTTOM" segments
+        // are defined by the dxy21 deltas.  "LEFT" and "RIGHT"
+        // segments are defined by the dxy12 deltas.
+
+        // Each segment includes its starting corner and comes
+        // to just short of the following corner.  Thus, each
+        // corner is included just once and the only lengths
+        // needed are the original parallelogram delta lengths
+        // and the "line width deltas".  The sides will cover
+        // the following relative territories:
+        //
+        //     T T T T T R
+        //      L         R
+        //       L         R
+        //        L         R
+        //         L         R
+        //          L B B B B B
+
+        // TOP segment, to left side of RIGHT edge
+        // "width" of original pgram, "height" of hor. line size
+        fx11 = ox11;
+        fy11 = oy11;
+        FILL_PGRAM(fx11, fy11, dx21, dy21, ldx12, ldy12);
+
+        // RIGHT segment, to top of BOTTOM edge
+        // "width" of vert. line size , "height" of original pgram
+        fx11 = ox11 + dx21;
+        fy11 = oy11 + dy21;
+        FILL_PGRAM(fx11, fy11, ldx21, ldy21, dx12, dy12);
+
+        // BOTTOM segment, from right side of LEFT edge
+        // "width" of original pgram, "height" of hor. line size
+        fx11 = ox11 + dx12 + ldx21;
+        fy11 = oy11 + dy12 + ldy21;
+        FILL_PGRAM(fx11, fy11, dx21, dy21, ldx12, ldy12);
+
+        // LEFT segment, from bottom of TOP edge
+        // "width" of vert. line size , "height" of inner pgram
+        fx11 = ox11 + ldx12;
+        fy11 = oy11 + ldy12;
+        FILL_PGRAM(fx11, fy11, ldx21, ldy21, dx12, dy12);
+    } else {
+        // The line width ratios were large enough to consume
+        // the entire hole in the middle of the parallelogram
+        // so we can just issue one large quad for the outer
+        // parallelogram.
+        dx21 += ldx21;
+        dy21 += ldy21;
+        dx12 += ldx12;
+        dy12 += ldy12;
+        FILL_PGRAM(ox11, oy11, dx21, dy21, dx12, dy12);
+    }
+}
+
+static GLhandleARB aaPgramProgram = 0;
+
+/*
+ * This shader fills the space between an outer and inner parallelogram.
+ * It can be used to draw an outline by specifying both inner and outer
+ * values.  It fills pixels by estimating what portion falls inside the
+ * outer shape, and subtracting an estimate of what portion falls inside
+ * the inner shape.  Specifying both inner and outer values produces a
+ * standard "wide outline".  Specifying an inner shape that falls far
+ * outside the outer shape allows the same shader to fill the outer
+ * shape entirely since pixels that fall within the outer shape are never
+ * inside the inner shape and so they are filled based solely on their
+ * coverage of the outer shape.
+ *
+ * The setup code renders this shader over the bounds of the outer
+ * shape (or the only shape in the case of a fill operation) and
+ * sets the texture 0 coordinates so that 0,0=>0,1=>1,1=>1,0 in those
+ * texture coordinates map to the four corners of the parallelogram.
+ * Similarly the texture 1 coordinates map the inner shape to the
+ * unit square as well, but in a different coordinate system.
+ *
+ * When viewed in the texture coordinate systems the parallelograms
+ * we are filling are unit squares, but the pixels have then become
+ * tiny parallelograms themselves.  Both of the texture coordinate
+ * systems are affine transforms so the rate of change in X and Y
+ * of the texture coordinates are essentially constants and happen
+ * to correspond to the size and direction of the slanted sides of
+ * the distorted pixels relative to the "square mapped" boundary
+ * of the parallelograms.
+ *
+ * The shader uses the dFdx() and dFdy() functions to measure the "rate
+ * of change" of these texture coordinates and thus gets an accurate
+ * measure of the size and shape of a pixel relative to the two
+ * parallelograms.  It then uses the bounds of the size and shape
+ * of a pixel to intersect with the unit square to estimate the
+ * coverage of the pixel.  Unfortunately, without a lot more work
+ * to calculate the exact area of intersection between a unit
+ * square (the original parallelogram) and a parallelogram (the
+ * distorted pixel), this shader only approximates the pixel
+ * coverage, but emperically the estimate is very useful and
+ * produces visually pleasing results, if not theoretically accurate.
+ */
+static const char *aaPgramShaderSource =
+    "void main() {"
+    // Calculate the vectors for the "legs" of the pixel parallelogram
+    // for the outer parallelogram.
+    "    vec2 oleg1 = dFdx(gl_TexCoord[0].st);"
+    "    vec2 oleg2 = dFdy(gl_TexCoord[0].st);"
+    // Calculate the bounds of the distorted pixel parallelogram.
+    "    vec2 corner = gl_TexCoord[0].st - (oleg1+oleg2)/2.0;"
+    "    vec2 omin = min(corner, corner+oleg1);"
+    "    omin = min(omin, corner+oleg2);"
+    "    omin = min(omin, corner+oleg1+oleg2);"
+    "    vec2 omax = max(corner, corner+oleg1);"
+    "    omax = max(omax, corner+oleg2);"
+    "    omax = max(omax, corner+oleg1+oleg2);"
+    // Calculate the vectors for the "legs" of the pixel parallelogram
+    // for the inner parallelogram.
+    "    vec2 ileg1 = dFdx(gl_TexCoord[1].st);"
+    "    vec2 ileg2 = dFdy(gl_TexCoord[1].st);"
+    // Calculate the bounds of the distorted pixel parallelogram.
+    "    corner = gl_TexCoord[1].st - (ileg1+ileg2)/2.0;"
+    "    vec2 imin = min(corner, corner+ileg1);"
+    "    imin = min(imin, corner+ileg2);"
+    "    imin = min(imin, corner+ileg1+ileg2);"
+    "    vec2 imax = max(corner, corner+ileg1);"
+    "    imax = max(imax, corner+ileg2);"
+    "    imax = max(imax, corner+ileg1+ileg2);"
+    // Clamp the bounds of the parallelograms to the unit square to
+    // estimate the intersection of the pixel parallelogram with
+    // the unit square.  The ratio of the 2 rectangle areas is a
+    // reasonable estimate of the proportion of coverage.
+    "    vec2 o1 = clamp(omin, 0.0, 1.0);"
+    "    vec2 o2 = clamp(omax, 0.0, 1.0);"
+    "    float oint = (o2.y-o1.y)*(o2.x-o1.x);"
+    "    float oarea = (omax.y-omin.y)*(omax.x-omin.x);"
+    "    vec2 i1 = clamp(imin, 0.0, 1.0);"
+    "    vec2 i2 = clamp(imax, 0.0, 1.0);"
+    "    float iint = (i2.y-i1.y)*(i2.x-i1.x);"
+    "    float iarea = (imax.y-imin.y)*(imax.x-imin.x);"
+    // Proportion of pixel in outer shape minus the proportion
+    // of pixel in the inner shape == the coverage of the pixel
+    // in the area between the two.
+    "    float coverage = oint/oarea - iint / iarea;"
+    "    gl_FragColor = gl_Color * coverage;"
+    "}";
+
+#define ADJUST_PGRAM(V1, DV, V2) \
+    do { \
+        if ((DV) >= 0) { \
+            (V2) += (DV); \
+        } else { \
+            (V1) += (DV); \
+        } \
+    } while (0)
+
+// Invert the following transform:
+// DeltaT(0, 0) == (0,       0)
+// DeltaT(1, 0) == (DX1,     DY1)
+// DeltaT(0, 1) == (DX2,     DY2)
+// DeltaT(1, 1) == (DX1+DX2, DY1+DY2)
+// TM00 = DX1,   TM01 = DX2,   (TM02 = X11)
+// TM10 = DY1,   TM11 = DY2,   (TM12 = Y11)
+// Determinant = TM00*TM11 - TM01*TM10
+//             =  DX1*DY2  -  DX2*DY1
+// Inverse is:
+// IM00 =  TM11/det,   IM01 = -TM01/det
+// IM10 = -TM10/det,   IM11 =  TM00/det
+// IM02 = (TM01 * TM12 - TM11 * TM02) / det,
+// IM12 = (TM10 * TM02 - TM00 * TM12) / det,
+
+#define DECLARE_MATRIX(MAT) \
+    jfloat MAT ## 00, MAT ## 01, MAT ## 02, MAT ## 10, MAT ## 11, MAT ## 12
+
+#define GET_INVERTED_MATRIX(MAT, X11, Y11, DX1, DY1, DX2, DY2, RET_CODE) \
+    do { \
+        jfloat det = DX1*DY2 - DX2*DY1; \
+        if (det == 0) { \
+            RET_CODE; \
+        } \
+        MAT ## 00 = DY2/det; \
+        MAT ## 01 = -DX2/det; \
+        MAT ## 10 = -DY1/det; \
+        MAT ## 11 = DX1/det; \
+        MAT ## 02 = (DX2 * Y11 - DY2 * X11) / det; \
+        MAT ## 12 = (DY1 * X11 - DX1 * Y11) / det; \
+    } while (0)
+
+#define TRANSFORM(MAT, TX, TY, X, Y) \
+    do { \
+        TX = (X) * MAT ## 00 + (Y) * MAT ## 01 + MAT ## 02; \
+        TY = (X) * MAT ## 10 + (Y) * MAT ## 11 + MAT ## 12; \
+    } while (0)
+
+void
+OGLRenderer_FillAAParallelogram(OGLContext *oglc, OGLSDOps *dstOps,
+                                jfloat fx11, jfloat fy11,
+                                jfloat dx21, jfloat dy21,
+                                jfloat dx12, jfloat dy12)
+{
+    DECLARE_MATRIX(om);
+    // parameters for parallelogram bounding box
+    jfloat bx11, by11, bx22, by22;
+    // parameters for uv texture coordinates of parallelogram corners
+    jfloat u11, v11, u12, v12, u21, v21, u22, v22;
+
+    J2dTraceLn6(J2D_TRACE_INFO,
+                "OGLRenderer_FillAAParallelogram "
+                "(x=%6.2f y=%6.2f "
+                "dx1=%6.2f dy1=%6.2f "
+                "dx2=%6.2f dy2=%6.2f)",
+                fx11, fy11,
+                dx21, dy21,
+                dx12, dy12);
+
+    RETURN_IF_NULL(oglc);
+    RETURN_IF_NULL(dstOps);
+
+    GET_INVERTED_MATRIX(om, fx11, fy11, dx21, dy21, dx12, dy12,
+                        return);
+
+    CHECK_PREVIOUS_OP(OGL_STATE_PGRAM_OP);
+
+    bx11 = bx22 = fx11;
+    by11 = by22 = fy11;
+    ADJUST_PGRAM(bx11, dx21, bx22);
+    ADJUST_PGRAM(by11, dy21, by22);
+    ADJUST_PGRAM(bx11, dx12, bx22);
+    ADJUST_PGRAM(by11, dy12, by22);
+    bx11 = (jfloat) floor(bx11);
+    by11 = (jfloat) floor(by11);
+    bx22 = (jfloat) ceil(bx22);
+    by22 = (jfloat) ceil(by22);
+
+    TRANSFORM(om, u11, v11, bx11, by11);
+    TRANSFORM(om, u21, v21, bx22, by11);
+    TRANSFORM(om, u12, v12, bx11, by22);
+    TRANSFORM(om, u22, v22, bx22, by22);
+
+    j2d_glBegin(GL_QUADS);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE0_ARB, u11, v11);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE1_ARB, 5.f, 5.f);
+    j2d_glVertex2f(bx11, by11);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE0_ARB, u21, v21);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE1_ARB, 6.f, 5.f);
+    j2d_glVertex2f(bx22, by11);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE0_ARB, u22, v22);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE1_ARB, 6.f, 6.f);
+    j2d_glVertex2f(bx22, by22);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE0_ARB, u12, v12);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE1_ARB, 5.f, 6.f);
+    j2d_glVertex2f(bx11, by22);
+    j2d_glEnd();
+}
+
+void
+OGLRenderer_FillAAParallelogramInnerOuter(OGLContext *oglc, OGLSDOps *dstOps,
+                                          jfloat ox11, jfloat oy11,
+                                          jfloat ox21, jfloat oy21,
+                                          jfloat ox12, jfloat oy12,
+                                          jfloat ix11, jfloat iy11,
+                                          jfloat ix21, jfloat iy21,
+                                          jfloat ix12, jfloat iy12)
+{
+    DECLARE_MATRIX(om);
+    DECLARE_MATRIX(im);
+    // parameters for parallelogram bounding box
+    jfloat bx11, by11, bx22, by22;
+    // parameters for uv texture coordinates of outer parallelogram corners
+    jfloat ou11, ov11, ou12, ov12, ou21, ov21, ou22, ov22;
+    // parameters for uv texture coordinates of inner parallelogram corners
+    jfloat iu11, iv11, iu12, iv12, iu21, iv21, iu22, iv22;
+
+    RETURN_IF_NULL(oglc);
+    RETURN_IF_NULL(dstOps);
+
+    GET_INVERTED_MATRIX(im, ix11, iy11, ix21, iy21, ix12, iy12,
+                        // inner parallelogram is degenerate
+                        // therefore it encloses no area
+                        // fill outer
+                        OGLRenderer_FillAAParallelogram(oglc, dstOps,
+                                                        ox11, oy11,
+                                                        ox21, oy21,
+                                                        ox12, oy12);
+                        return);
+    GET_INVERTED_MATRIX(om, ox11, oy11, ox21, oy21, ox12, oy12,
+                        return);
+
+    CHECK_PREVIOUS_OP(OGL_STATE_PGRAM_OP);
+
+    bx11 = bx22 = ox11;
+    by11 = by22 = oy11;
+    ADJUST_PGRAM(bx11, ox21, bx22);
+    ADJUST_PGRAM(by11, oy21, by22);
+    ADJUST_PGRAM(bx11, ox12, bx22);
+    ADJUST_PGRAM(by11, oy12, by22);
+    bx11 = (jfloat) floor(bx11);
+    by11 = (jfloat) floor(by11);
+    bx22 = (jfloat) ceil(bx22);
+    by22 = (jfloat) ceil(by22);
+
+    TRANSFORM(om, ou11, ov11, bx11, by11);
+    TRANSFORM(om, ou21, ov21, bx22, by11);
+    TRANSFORM(om, ou12, ov12, bx11, by22);
+    TRANSFORM(om, ou22, ov22, bx22, by22);
+
+    TRANSFORM(im, iu11, iv11, bx11, by11);
+    TRANSFORM(im, iu21, iv21, bx22, by11);
+    TRANSFORM(im, iu12, iv12, bx11, by22);
+    TRANSFORM(im, iu22, iv22, bx22, by22);
+
+    j2d_glBegin(GL_QUADS);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE0_ARB, ou11, ov11);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE1_ARB, iu11, iv11);
+    j2d_glVertex2f(bx11, by11);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE0_ARB, ou21, ov21);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE1_ARB, iu21, iv21);
+    j2d_glVertex2f(bx22, by11);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE0_ARB, ou22, ov22);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE1_ARB, iu22, iv22);
+    j2d_glVertex2f(bx22, by22);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE0_ARB, ou12, ov12);
+    j2d_glMultiTexCoord2fARB(GL_TEXTURE1_ARB, iu12, iv12);
+    j2d_glVertex2f(bx11, by22);
+    j2d_glEnd();
+}
+
+void
+OGLRenderer_DrawAAParallelogram(OGLContext *oglc, OGLSDOps *dstOps,
+                                jfloat fx11, jfloat fy11,
+                                jfloat dx21, jfloat dy21,
+                                jfloat dx12, jfloat dy12,
+                                jfloat lwr21, jfloat lwr12)
+{
+    // dx,dy for line width in the "21" and "12" directions.
+    jfloat ldx21, ldy21, ldx12, ldy12;
+    // parameters for "outer" parallelogram
+    jfloat ofx11, ofy11, odx21, ody21, odx12, ody12;
+    // parameters for "inner" parallelogram
+    jfloat ifx11, ify11, idx21, idy21, idx12, idy12;
+
+    J2dTraceLn8(J2D_TRACE_INFO,
+                "OGLRenderer_DrawAAParallelogram "
+                "(x=%6.2f y=%6.2f "
+                "dx1=%6.2f dy1=%6.2f lwr1=%6.2f "
+                "dx2=%6.2f dy2=%6.2f lwr2=%6.2f)",
+                fx11, fy11,
+                dx21, dy21, lwr21,
+                dx12, dy12, lwr12);
+
+    RETURN_IF_NULL(oglc);
+    RETURN_IF_NULL(dstOps);
+
+    // calculate true dx,dy for line widths from the "line width ratios"
+    ldx21 = dx21 * lwr21;
+    ldy21 = dy21 * lwr21;
+    ldx12 = dx12 * lwr12;
+    ldy12 = dy12 * lwr12;
+
+    // calculate coordinates of the outer parallelogram
+    ofx11 = fx11 - (ldx21 + ldx12) / 2.0f;
+    ofy11 = fy11 - (ldy21 + ldy12) / 2.0f;
+    odx21 = dx21 + ldx21;
+    ody21 = dy21 + ldy21;
+    odx12 = dx12 + ldx12;
+    ody12 = dy12 + ldy12;
+
+    // Only process the inner parallelogram if the line width ratio
+    // did not consume the entire interior of the parallelogram
+    // (i.e. if the width ratio was less than 1.0)
+    if (lwr21 < 1.0f && lwr12 < 1.0f) {
+        // calculate coordinates of the inner parallelogram
+        ifx11 = fx11 + (ldx21 + ldx12) / 2.0f;
+        ify11 = fy11 + (ldy21 + ldy12) / 2.0f;
+        idx21 = dx21 - ldx21;
+        idy21 = dy21 - ldy21;
+        idx12 = dx12 - ldx12;
+        idy12 = dy12 - ldy12;
+
+        OGLRenderer_FillAAParallelogramInnerOuter(oglc, dstOps,
+                                                  ofx11, ofy11,
+                                                  odx21, ody21,
+                                                  odx12, ody12,
+                                                  ifx11, ify11,
+                                                  idx21, idy21,
+                                                  idx12, idy12);
+    } else {
+        OGLRenderer_FillAAParallelogram(oglc, dstOps,
+                                        ofx11, ofy11,
+                                        odx21, ody21,
+                                        odx12, ody12);
+    }
+}
+
+void
+OGLRenderer_EnableAAParallelogramProgram()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "OGLRenderer_EnableAAParallelogramProgram");
+
+    if (aaPgramProgram == 0) {
+        aaPgramProgram = OGLContext_CreateFragmentProgram(aaPgramShaderSource);
+        if (aaPgramProgram == 0) {
+            J2dRlsTraceLn(J2D_TRACE_ERROR,
+                          "OGLRenderer_EnableAAParallelogramProgram: "
+                          "error creating program");
+            return;
+        }
+    }
+    j2d_glUseProgramObjectARB(aaPgramProgram);
+}
+
+void
+OGLRenderer_DisableAAParallelogramProgram()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "OGLRenderer_DisableAAParallelogramProgram");
+
+    j2d_glUseProgramObjectARB(0);
+}
+
 #endif /* !HEADLESS */
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLRenderer.h openjdk/jdk/src/share/native/sun/java2d/opengl/OGLRenderer.h
--- openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLRenderer.h	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/opengl/OGLRenderer.h	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -46,9 +46,31 @@
                           jint *xPoints, jint *yPoints);
 void OGLRenderer_DrawScanlines(OGLContext *oglc,
                                jint count, jint *scanlines);
+void OGLRenderer_DrawParallelogram(OGLContext *oglc,
+                                   jfloat fx11, jfloat fy11,
+                                   jfloat dx21, jfloat dy21,
+                                   jfloat dx12, jfloat dy12,
+                                   jfloat lw21, jfloat lw12);
+void OGLRenderer_DrawAAParallelogram(OGLContext *oglc, OGLSDOps *dstOps,
+                                     jfloat fx11, jfloat fy11,
+                                     jfloat dx21, jfloat dy21,
+                                     jfloat dx12, jfloat dy12,
+                                     jfloat lw21, jfloat lw12);
+
 void OGLRenderer_FillRect(OGLContext *oglc,
                           jint x, jint y, jint w, jint h);
 void OGLRenderer_FillSpans(OGLContext *oglc,
                            jint count, jint *spans);
+void OGLRenderer_FillParallelogram(OGLContext *oglc,
+                                   jfloat fx11, jfloat fy11,
+                                   jfloat dx21, jfloat dy21,
+                                   jfloat dx12, jfloat dy12);
+void OGLRenderer_FillAAParallelogram(OGLContext *oglc, OGLSDOps *dstOps,
+                                     jfloat fx11, jfloat fy11,
+                                     jfloat dx21, jfloat dy21,
+                                     jfloat dx12, jfloat dy12);
+
+void OGLRenderer_EnableAAParallelogramProgram();
+void OGLRenderer_DisableAAParallelogramProgram();
 
 #endif /* OGLRenderer_h_Included */
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c openjdk/jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c
--- openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -88,8 +88,9 @@
     while (b < end) {
         jint opcode = NEXT_INT(b);
 
-        J2dTraceLn1(J2D_TRACE_VERBOSE,
-                    "OGLRenderQueue_flushBuffer: opcode=%d", opcode);
+        J2dTraceLn2(J2D_TRACE_VERBOSE,
+                    "OGLRenderQueue_flushBuffer: opcode=%d, rem=%d",
+                    opcode, (end-b));
 
         switch (opcode) {
 
@@ -148,6 +149,40 @@
                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
             }
             break;
+        case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
+            {
+                jfloat x11 = NEXT_FLOAT(b);
+                jfloat y11 = NEXT_FLOAT(b);
+                jfloat dx21 = NEXT_FLOAT(b);
+                jfloat dy21 = NEXT_FLOAT(b);
+                jfloat dx12 = NEXT_FLOAT(b);
+                jfloat dy12 = NEXT_FLOAT(b);
+                jfloat lwr21 = NEXT_FLOAT(b);
+                jfloat lwr12 = NEXT_FLOAT(b);
+                OGLRenderer_DrawParallelogram(oglc,
+                                              x11, y11,
+                                              dx21, dy21,
+                                              dx12, dy12,
+                                              lwr21, lwr12);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
+            {
+                jfloat x11 = NEXT_FLOAT(b);
+                jfloat y11 = NEXT_FLOAT(b);
+                jfloat dx21 = NEXT_FLOAT(b);
+                jfloat dy21 = NEXT_FLOAT(b);
+                jfloat dx12 = NEXT_FLOAT(b);
+                jfloat dy12 = NEXT_FLOAT(b);
+                jfloat lwr21 = NEXT_FLOAT(b);
+                jfloat lwr12 = NEXT_FLOAT(b);
+                OGLRenderer_DrawAAParallelogram(oglc, dstOps,
+                                                x11, y11,
+                                                dx21, dy21,
+                                                dx12, dy12,
+                                                lwr21, lwr12);
+            }
+            break;
 
         // fill ops
         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
@@ -166,6 +201,34 @@
                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
             }
             break;
+        case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
+            {
+                jfloat x11 = NEXT_FLOAT(b);
+                jfloat y11 = NEXT_FLOAT(b);
+                jfloat dx21 = NEXT_FLOAT(b);
+                jfloat dy21 = NEXT_FLOAT(b);
+                jfloat dx12 = NEXT_FLOAT(b);
+                jfloat dy12 = NEXT_FLOAT(b);
+                OGLRenderer_FillParallelogram(oglc,
+                                              x11, y11,
+                                              dx21, dy21,
+                                              dx12, dy12);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
+            {
+                jfloat x11 = NEXT_FLOAT(b);
+                jfloat y11 = NEXT_FLOAT(b);
+                jfloat dx21 = NEXT_FLOAT(b);
+                jfloat dy21 = NEXT_FLOAT(b);
+                jfloat dx12 = NEXT_FLOAT(b);
+                jfloat dy12 = NEXT_FLOAT(b);
+                OGLRenderer_FillAAParallelogram(oglc, dstOps,
+                                                x11, y11,
+                                                dx21, dy21,
+                                                dx12, dy12);
+            }
+            break;
 
         // text-related ops
         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
@@ -438,6 +501,31 @@
                 dstOps = NULL;
             }
             break;
+        case sun_java2d_pipe_BufferedOpCodes_SAVE_STATE:
+            {
+                j2d_glPushAttrib(GL_ALL_ATTRIB_BITS);
+                j2d_glPushClientAttrib(GL_CLIENT_ALL_ATTRIB_BITS);
+                j2d_glMatrixMode(GL_MODELVIEW);
+                j2d_glPushMatrix();
+                j2d_glMatrixMode(GL_PROJECTION);
+                j2d_glPushMatrix();
+                j2d_glMatrixMode(GL_TEXTURE);
+                j2d_glPushMatrix();
+            }
+            break;
+
+        case sun_java2d_pipe_BufferedOpCodes_RESTORE_STATE:
+            {
+                j2d_glPopAttrib();
+                j2d_glPopClientAttrib();
+                j2d_glMatrixMode(GL_MODELVIEW);
+                j2d_glPopMatrix();
+                j2d_glMatrixMode(GL_PROJECTION);
+                j2d_glPopMatrix();
+                j2d_glMatrixMode(GL_TEXTURE);
+                j2d_glPopMatrix();
+            }
+            break;
         case sun_java2d_pipe_BufferedOpCodes_SYNC:
             {
                 sync = JNI_TRUE;
@@ -691,6 +779,9 @@
         return;
     }
 
+    J2dTraceLn1(J2D_TRACE_VERBOSE,
+                "OGLRenderQueue_CheckPreviousOp: new op=%d", op);
+
     switch (previousOp) {
     case GL_TEXTURE_2D:
     case GL_TEXTURE_RECTANGLE_ARB:
@@ -718,6 +809,9 @@
     case OGL_STATE_GLYPH_OP:
         OGLTR_DisableGlyphVertexCache(oglc);
         break;
+    case OGL_STATE_PGRAM_OP:
+        OGLRenderer_DisableAAParallelogramProgram();
+        break;
     case OGL_STATE_RESET:
     case OGL_STATE_CHANGE:
         // No-op
@@ -745,6 +839,9 @@
     case OGL_STATE_GLYPH_OP:
         OGLTR_EnableGlyphVertexCache(oglc);
         break;
+    case OGL_STATE_PGRAM_OP:
+        OGLRenderer_EnableAAParallelogramProgram();
+        break;
     case OGL_STATE_RESET:
     case OGL_STATE_CHANGE:
         // No-op
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.h openjdk/jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.h
--- openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.h	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.h	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -90,6 +90,13 @@
 #define OGL_STATE_GLYPH_OP -4
 
 /*
+ * Parameter passed to the CHECK_PREVIOUS_OP() macro to indicate that the
+ * following operation represents an operation that renders a
+ * parallelogram via a fragment program (see OGLRenderer).
+ */
+#define OGL_STATE_PGRAM_OP -5
+
+/*
  * Initializes the "previous operation" state to its default value.
  */
 #define INIT_PREVIOUS_OP() previousOp = OGL_STATE_RESET
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLSurfaceData.c openjdk/jdk/src/share/native/sun/java2d/opengl/OGLSurfaceData.c
--- openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLSurfaceData.c	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/opengl/OGLSurfaceData.c	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -41,6 +41,8 @@
 extern jboolean OGLSD_InitOGLWindow(JNIEnv *env, OGLSDOps *oglsdo);
 extern void OGLSD_DestroyOGLSurface(JNIEnv *env, OGLSDOps *oglsdo);
 
+void OGLSD_SetNativeDimensions(JNIEnv *env, OGLSDOps *oglsdo, jint w, jint h);
+
 /**
  * This table contains the "pixel formats" for all system memory surfaces
  * that OpenGL is capable of handling, indexed by the "PF_" constants defined
@@ -269,6 +271,9 @@
         return JNI_FALSE;
     }
 
+    OGLSD_SetNativeDimensions(env, oglsdo,
+                              oglsdo->textureWidth, oglsdo->textureHeight);
+
     oglsdo->drawableType = OGLSD_TEXTURE;
     // other fields (e.g. width, height) are set in OGLSD_InitTextureObject()
 
@@ -427,6 +432,9 @@
     oglsdo->fbobjectID = fbobjectID;
     oglsdo->depthID = depthID;
 
+    OGLSD_SetNativeDimensions(env, oglsdo,
+                              oglsdo->textureWidth, oglsdo->textureHeight);
+
     // framebuffer objects differ from other OpenGL surfaces in that the
     // value passed to glRead/DrawBuffer() must be GL_COLOR_ATTACHMENTn_EXT,
     // rather than GL_FRONT (or GL_BACK)
@@ -476,6 +484,8 @@
     //         explicitly use BACK_LEFT rather than BACK...
     oglsdo->activeBuffer = GL_BACK_LEFT;
 
+    OGLSD_SetNativeDimensions(env, oglsdo, oglsdo->width, oglsdo->height);
+
     return JNI_TRUE;
 }
 
@@ -497,6 +507,45 @@
     return (jint)oglsdo->textureTarget;
 }
 
+JNIEXPORT jint JNICALL
+Java_sun_java2d_opengl_OGLSurfaceData_getTextureID
+    (JNIEnv *env, jobject oglsd,
+     jlong pData)
+{
+    OGLSDOps *oglsdo = (OGLSDOps *)jlong_to_ptr(pData);
+
+    J2dTraceLn(J2D_TRACE_INFO, "OGLSurfaceData_getTextureID");
+
+    if (oglsdo == NULL) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+            "OGLSurfaceData_getTextureID: ops are null");
+        return 0L;
+    }
+
+    return (jint)oglsdo->textureID;
+}
+
+/**
+ * Initializes nativeWidth/Height fields of the surfaceData object with
+ * passed arguments.
+ */
+void
+OGLSD_SetNativeDimensions(JNIEnv *env, OGLSDOps *oglsdo,
+                          jint width, jint height)
+{
+    jobject sdObject;
+
+    sdObject = (*env)->NewLocalRef(env, oglsdo->sdOps.sdObject);
+    if (sdObject == NULL) {
+        return;
+    }
+
+    JNU_SetFieldByName(env, NULL, sdObject, "nativeWidth", "I", width);
+    JNU_SetFieldByName(env, NULL, sdObject, "nativeHeight", "I", height);
+
+    (*env)->DeleteLocalRef(env, sdObject);
+}
+
 /**
  * Disposes of all native resources associated with this surface.
  */
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLSurfaceData.h openjdk/jdk/src/share/native/sun/java2d/opengl/OGLSurfaceData.h
--- openjdk.orig/jdk/src/share/native/sun/java2d/opengl/OGLSurfaceData.h	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/opengl/OGLSurfaceData.h	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,7 @@
 
 #include "java_awt_image_AffineTransformOp.h"
 #include "sun_java2d_opengl_OGLSurfaceData.h"
+#include "sun_java2d_pipe_hw_AccelSurface.h"
 
 #include "J2D_GL/gl.h"
 #include "SurfaceData.h"
@@ -215,12 +216,12 @@
  * These are shorthand names for the surface type constants defined in
  * OGLSurfaceData.java.
  */
-#define OGLSD_UNDEFINED       sun_java2d_opengl_OGLSurfaceData_UNDEFINED
-#define OGLSD_WINDOW          sun_java2d_opengl_OGLSurfaceData_WINDOW
-#define OGLSD_PBUFFER         sun_java2d_opengl_OGLSurfaceData_PBUFFER
-#define OGLSD_TEXTURE         sun_java2d_opengl_OGLSurfaceData_TEXTURE
-#define OGLSD_FLIP_BACKBUFFER sun_java2d_opengl_OGLSurfaceData_FLIP_BACKBUFFER
-#define OGLSD_FBOBJECT        sun_java2d_opengl_OGLSurfaceData_FBOBJECT
+#define OGLSD_UNDEFINED       sun_java2d_pipe_hw_AccelSurface_UNDEFINED
+#define OGLSD_WINDOW          sun_java2d_pipe_hw_AccelSurface_WINDOW
+#define OGLSD_PBUFFER         sun_java2d_pipe_hw_AccelSurface_RT_PLAIN
+#define OGLSD_TEXTURE         sun_java2d_pipe_hw_AccelSurface_TEXTURE
+#define OGLSD_FLIP_BACKBUFFER sun_java2d_pipe_hw_AccelSurface_FLIP_BACKBUFFER
+#define OGLSD_FBOBJECT        sun_java2d_pipe_hw_AccelSurface_RT_TEXTURE
 
 /**
  * These are shorthand names for the filtering method constants used by
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/pipe/BufferedMaskBlit.c openjdk/jdk/src/share/native/sun/java2d/pipe/BufferedMaskBlit.c
--- openjdk.orig/jdk/src/share/native/sun/java2d/pipe/BufferedMaskBlit.c	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/pipe/BufferedMaskBlit.c	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -59,7 +59,6 @@
 {
     SurfaceDataOps *srcOps = (SurfaceDataOps *)jlong_to_ptr(pSrcOps);
     SurfaceDataRasInfo srcInfo;
-    unsigned char *pMask;
     unsigned char *bbuf;
     jint *pBuf;
 
@@ -97,13 +96,6 @@
         return bpos;
     }
 
-    pMask = (*env)->GetPrimitiveArrayCritical(env, maskArray, 0);
-    if (pMask == NULL) {
-        J2dRlsTraceLn(J2D_TRACE_ERROR,
-            "BufferedMaskBlit_enqueueTile: cannot lock mask array");
-        return bpos;
-    }
-
     srcInfo.bounds.x1 = srcx;
     srcInfo.bounds.y1 = srcy;
     srcInfo.bounds.x2 = srcx + width;
@@ -112,8 +104,6 @@
     if (srcOps->Lock(env, srcOps, &srcInfo, SD_LOCK_READ) != SD_SUCCESS) {
         J2dRlsTraceLn(J2D_TRACE_WARNING,
                       "BufferedMaskBlit_enqueueTile: could not acquire lock");
-        (*env)->ReleasePrimitiveArrayCritical(env, maskArray,
-                                              pMask, JNI_ABORT);
         return bpos;
     }
 
@@ -129,6 +119,15 @@
                 PtrCoord(srcInfo.rasBase,
                          srcInfo.bounds.x1, srcInfo.pixelStride,
                          srcInfo.bounds.y1, srcInfo.scanStride);
+            unsigned char *pMask =
+                (*env)->GetPrimitiveArrayCritical(env, maskArray, 0);
+            if (pMask == NULL) {
+                J2dRlsTraceLn(J2D_TRACE_ERROR,
+                    "BufferedMaskBlit_enqueueTile: cannot lock mask array");
+                SurfaceData_InvokeRelease(env, srcOps, &srcInfo);
+                SurfaceData_InvokeUnlock(env, srcOps, &srcInfo);
+                return bpos;
+            }
 
             width = srcInfo.bounds.x2 - srcInfo.bounds.x1;
             height = srcInfo.bounds.y2 - srcInfo.bounds.y1;
@@ -166,18 +165,22 @@
                 do {
                     jint w = width;
                     do {
-                        jubyte pathA = *pMask++;
+                        jint pathA = *pMask++;
                         if (!pathA) {
                             pBuf[0] = 0;
                         } else {
-                            jint cr, cg, cb, ca;
-                            jubyte r, g, b, a;
-                            LoadIntArgbTo4ByteArgb(pSrc, c, 0, ca, cr, cg, cb);
-                            a = MUL8(ca, pathA);
-                            r = MUL8(cr, a);
-                            g = MUL8(cg, a);
-                            b = MUL8(cb, a);
-                            pBuf[0] = (a << 24) | (r << 16) | (g << 8) | b;
+                            jint pixel = pSrc[0];
+                            if (pathA == 0xff && (pixel >> 24) + 1 == 0) {
+                                pBuf[0] = pixel;
+                            } else {
+                                jint r, g, b, a;
+                                ExtractIntDcmComponents1234(pixel, a, r, g, b);
+                                a = MUL8(pathA, a);
+                                r = MUL8(a, r);
+                                g = MUL8(a, g);
+                                b = MUL8(a, b);
+                                pBuf[0] = (a << 24) | (r << 16) | (g << 8) | b;
+                            }
                         }
                         pSrc = PtrAddBytes(pSrc, srcPixelStride);
                         pBuf++;
@@ -191,17 +194,17 @@
                 do {
                     jint w = width;
                     do {
-                        jubyte pathA = *pMask++;
+                        jint pathA = *pMask++;
                         if (!pathA) {
                             pBuf[0] = 0;
                         } else if (pathA == 0xff) {
                             pBuf[0] = pSrc[0];
                         } else {
-                            jubyte r, g, b, a;
-                            a = MUL8((pSrc[0] >> 24) & 0xff, pathA);
-                            r = MUL8((pSrc[0] >> 16) & 0xff, pathA);
-                            g = MUL8((pSrc[0] >>  8) & 0xff, pathA);
-                            b = MUL8((pSrc[0] >>  0) & 0xff, pathA);
+                            jint r, g, b, a;
+                            a = MUL8(pathA, (pSrc[0] >> 24) & 0xff);
+                            r = MUL8(pathA, (pSrc[0] >> 16) & 0xff);
+                            g = MUL8(pathA, (pSrc[0] >>  8) & 0xff);
+                            b = MUL8(pathA, (pSrc[0] >>  0) & 0xff);
                             pBuf[0] = (a << 24) | (r << 16) | (g << 8) | b;
                         }
                         pSrc = PtrAddBytes(pSrc, srcPixelStride);
@@ -216,17 +219,18 @@
                 do {
                     jint w = width;
                     do {
-                        jubyte pathA = *pMask++;
+                        jint pathA = *pMask++;
                         if (!pathA) {
                             pBuf[0] = 0;
+                        } else if (pathA == 0xff) {
+                            pBuf[0] = pSrc[0] | 0xff000000;
                         } else {
-                            jint cr, cg, cb;
-                            jubyte r, g, b, a;
-                            LoadIntRgbTo3ByteRgb(pSrc, c, 0, cr, cg, cb);
+                            jint r, g, b, a;
+                            LoadIntRgbTo3ByteRgb(pSrc, c, 0, r, g, b);
                             a = pathA;
-                            r = MUL8(cr, a);
-                            g = MUL8(cg, a);
-                            b = MUL8(cb, a);
+                            r = MUL8(a, r);
+                            g = MUL8(a, g);
+                            b = MUL8(a, b);
                             pBuf[0] = (a << 24) | (r << 16) | (g << 8) | b;
                         }
                         pSrc = PtrAddBytes(pSrc, srcPixelStride);
@@ -241,17 +245,16 @@
                 do {
                     jint w = width;
                     do {
-                        jubyte pathA = *pMask++;
+                        jint pathA = *pMask++;
                         if (!pathA) {
                             pBuf[0] = 0;
                         } else {
-                            jint cr, cg, cb;
-                            jubyte r, g, b, a;
-                            LoadIntBgrTo3ByteRgb(pSrc, c, 0, cr, cg, cb);
+                            jint r, g, b, a;
+                            LoadIntBgrTo3ByteRgb(pSrc, c, 0, r, g, b);
                             a = pathA;
-                            r = MUL8(cr, a);
-                            g = MUL8(cg, a);
-                            b = MUL8(cb, a);
+                            r = MUL8(a, r);
+                            g = MUL8(a, g);
+                            b = MUL8(a, b);
                             pBuf[0] = (a << 24) | (r << 16) | (g << 8) | b;
                         }
                         pSrc = PtrAddBytes(pSrc, srcPixelStride);
@@ -269,14 +272,14 @@
 
             // increment current byte position
             bpos += width * height * sizeof(jint);
+
+            (*env)->ReleasePrimitiveArrayCritical(env, maskArray,
+                                                  pMask, JNI_ABORT);
         }
         SurfaceData_InvokeRelease(env, srcOps, &srcInfo);
     }
     SurfaceData_InvokeUnlock(env, srcOps, &srcInfo);
 
-    (*env)->ReleasePrimitiveArrayCritical(env, maskArray,
-                                          pMask, JNI_ABORT);
-
     // return the current byte position
     return bpos;
 }
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/ShaderList.c openjdk/jdk/src/share/native/sun/java2d/ShaderList.c
--- openjdk.orig/jdk/src/share/native/sun/java2d/ShaderList.c	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/native/sun/java2d/ShaderList.c	2011-01-08 01:26:50.459202079 +0000
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include <malloc.h>
+#include <string.h>
+
+#include "ShaderList.h"
+#include "Trace.h"
+
+/**
+ * Creates a new ShaderInfo that wraps the given fragment program handle
+ * and related data and stores it at the front of the provided ShaderList.
+ * If the addition causes the ShaderList to outgrow its defined capacity,
+ * the least-recently used item in the list (including its fragment program
+ * object) will be disposed.
+ */
+void
+ShaderList_AddProgram(ShaderList *programList,
+                      jlong programID,
+                      jint compType, jint compMode, jint flags)
+{
+    ShaderInfo *info;
+
+    J2dTraceLn(J2D_TRACE_INFO, "ShaderList_AddProgram");
+
+    // create new ShaderInfo
+    info = (ShaderInfo *)malloc(sizeof(ShaderInfo));
+    if (info == NULL) {
+        J2dTraceLn(J2D_TRACE_ERROR,
+                   "OGLContext_AddProgram: could not allocate ShaderInfo");
+        return;
+    }
+
+    // fill in the information
+    info->next = programList->head;
+    info->programID = programID;
+    info->compType = compType;
+    info->compMode = compMode;
+    info->flags = flags;
+
+    // insert it at the head of the list
+    programList->head = info;
+
+    // run through the list and see if we need to delete the least
+    // recently used item
+    {
+        int i = 1;
+        ShaderInfo *prev = NULL;
+        ShaderInfo *curr = info->next;
+        while (curr != NULL) {
+            if (i >= programList->maxItems) {
+                prev->next = NULL;
+                programList->dispose(curr->programID);
+                free(curr);
+                break;
+            }
+            i++;
+            prev = curr;
+            curr = curr->next;
+        }
+    }
+}
+
+/**
+ * Locates a fragment program handle given a list of shader programs
+ * (ShaderInfos), using the provided composite state and flags as search
+ * parameters.  The "flags" parameter is a bitwise-or'd value that helps
+ * differentiate one program for another; the interpretation of this value
+ * varies depending on the type of shader (BufImgOp, Paint, etc) but here
+ * it is only used to find another ShaderInfo with that same "flags" value.
+ * If no matching program can be located, this method returns 0.
+ */
+jlong
+ShaderList_FindProgram(ShaderList *programList,
+                       jint compType, jint compMode, jint flags)
+{
+    ShaderInfo *prev = NULL;
+    ShaderInfo *info = programList->head;
+
+    J2dTraceLn(J2D_TRACE_INFO, "ShaderList_FindProgram");
+
+    while (info != NULL) {
+        if (compType == info->compType &&
+            compMode == info->compMode &&
+            flags == info->flags)
+        {
+            // it's a match: move it to the front of the list (if it's not
+            // there already) and patch up the links
+            if (info != programList->head) {
+                prev->next = info->next;
+                info->next = programList->head;
+                programList->head = info;
+            }
+            return info->programID;
+        }
+        prev = info;
+        info = info->next;
+    }
+    return 0;
+}
+
+/**
+ * Disposes all entries (and their associated shader program objects)
+ * contained in the given ShaderList.
+ */
+void
+ShaderList_Dispose(ShaderList *programList)
+{
+    ShaderInfo *info = programList->head;
+
+    J2dTraceLn(J2D_TRACE_INFO, "ShaderList_Dispose");
+
+    while (info != NULL) {
+        ShaderInfo *tmp = info->next;
+        programList->dispose(info->programID);
+        free(info);
+        info = tmp;
+    }
+
+    programList->head = NULL;
+}
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/ShaderList.h openjdk/jdk/src/share/native/sun/java2d/ShaderList.h
--- openjdk.orig/jdk/src/share/native/sun/java2d/ShaderList.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/share/native/sun/java2d/ShaderList.h	2011-01-08 01:26:50.459202079 +0000
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef ShaderList_h_Included
+#define ShaderList_h_Included
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "jni.h"
+#include "jlong.h"
+
+typedef void (ShaderDisposeFunc)(jlong programID);
+
+/**
+ * The following structures are used to maintain a list of fragment program
+ * objects and their associated attributes.  Each logical shader (e.g.
+ * RadialGradientPaint shader, ConvolveOp shader) can have a number of
+ * different variants depending on a number of factors, such as whether
+ * antialiasing is enabled or the current composite mode.  Since the number
+ * of possible combinations of these factors is in the hundreds, we need
+ * some way to create fragment programs on an as-needed basis, and also
+ * keep them in a limited sized cache to avoid creating too many objects.
+ *
+ * The ShaderInfo structure keeps a reference to the fragment program's
+ * handle, as well as some other values that help differentiate one ShaderInfo
+ * from another.  ShaderInfos can be chained together to form a linked list.
+ *
+ * The ShaderList structure acts as a cache for ShaderInfos, placing
+ * most-recently used items at the front, and removing items from the
+ * cache when its size exceeds the "maxItems" limit.
+ */
+typedef struct _ShaderInfo ShaderInfo;
+
+typedef struct {
+    ShaderInfo        *head;
+    ShaderDisposeFunc *dispose;
+    jint              maxItems;
+} ShaderList;
+
+struct _ShaderInfo {
+    ShaderInfo  *next;
+    jlong       programID;
+    jint        compType;
+    jint        compMode;
+    jint        flags;
+};
+
+void ShaderList_AddProgram(ShaderList *programList,
+                           jlong programID,
+                           jint compType, jint compMode,
+                           jint flags);
+jlong ShaderList_FindProgram(ShaderList *programList,
+                             jint compType, jint compMode,
+                             jint flags);
+void ShaderList_Dispose(ShaderList *programList);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif /* ShaderList_h_Included */
diff -Nru openjdk.orig/jdk/src/share/native/sun/java2d/Trace.h openjdk/jdk/src/share/native/sun/java2d/Trace.h
--- openjdk.orig/jdk/src/share/native/sun/java2d/Trace.h	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/share/native/sun/java2d/Trace.h	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -62,12 +62,18 @@
 #define J2dTrace3(level, string, arg1, arg2, arg3)
 #define J2dTrace4(level, string, arg1, arg2, arg3, arg4)
 #define J2dTrace5(level, string, arg1, arg2, arg3, arg4, arg5)
+#define J2dTrace6(level, string, arg1, arg2, arg3, arg4, arg5, arg6)
+#define J2dTrace7(level, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
+#define J2dTrace8(level, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
 #define J2dTraceLn(level, string)
 #define J2dTraceLn1(level, string, arg1)
 #define J2dTraceLn2(level, string, arg1, arg2)
 #define J2dTraceLn3(level, string, arg1, arg2, arg3)
 #define J2dTraceLn4(level, string, arg1, arg2, arg3, arg4)
 #define J2dTraceLn5(level, string, arg1, arg2, arg3, arg4, arg5)
+#define J2dTraceLn6(level, string, arg1, arg2, arg3, arg4, arg5, arg6)
+#define J2dTraceLn7(level, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
+#define J2dTraceLn8(level, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
 #else /* DEBUG */
 #define J2dTrace(level, string) { \
             J2dTraceImpl(level, JNI_FALSE, string); \
@@ -87,6 +93,15 @@
 #define J2dTrace5(level, string, arg1, arg2, arg3, arg4, arg5) { \
             J2dTraceImpl(level, JNI_FALSE, string, arg1, arg2, arg3, arg4, arg5); \
         }
+#define J2dTrace6(level, string, arg1, arg2, arg3, arg4, arg5, arg6) { \
+            J2dTraceImpl(level, JNI_FALSE, string, arg1, arg2, arg3, arg4, arg5, arg6); \
+        }
+#define J2dTrace7(level, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { \
+            J2dTraceImpl(level, JNI_FALSE, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7); \
+        }
+#define J2dTrace8(level, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) { \
+            J2dTraceImpl(level, JNI_FALSE, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8); \
+        }
 #define J2dTraceLn(level, string) { \
             J2dTraceImpl(level, JNI_TRUE, string); \
         }
@@ -105,6 +120,15 @@
 #define J2dTraceLn5(level, string, arg1, arg2, arg3, arg4, arg5) { \
             J2dTraceImpl(level, JNI_TRUE, string, arg1, arg2, arg3, arg4, arg5); \
         }
+#define J2dTraceLn6(level, string, arg1, arg2, arg3, arg4, arg5, arg6) { \
+            J2dTraceImpl(level, JNI_TRUE, string, arg1, arg2, arg3, arg4, arg5, arg6); \
+        }
+#define J2dTraceLn7(level, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7) { \
+            J2dTraceImpl(level, JNI_TRUE, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7); \
+        }
+#define J2dTraceLn8(level, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) { \
+            J2dTraceImpl(level, JNI_TRUE, string, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8); \
+        }
 #endif /* DEBUG */
 
 
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XComponentPeer.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XComponentPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XComponentPeer.java	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XComponentPeer.java	2011-01-08 01:26:50.459202079 +0000
@@ -77,9 +77,12 @@
 import sun.awt.event.IgnorePaintEvent;
 import sun.awt.image.SunVolatileImage;
 import sun.awt.image.ToolkitImage;
+import sun.java2d.BackBufferCapsProvider;
 import sun.java2d.pipe.Region;
 
-public class XComponentPeer extends XWindow implements ComponentPeer, DropTargetPeer, XConstants {
+public class XComponentPeer extends XWindow implements ComponentPeer, DropTargetPeer,
+    BackBufferCapsProvider, XConstants
+{
     /* FIX ME: these constants copied from java.awt.KeyboardFocusManager */
     static final int SNFH_FAILURE = 0;
     static final int SNFH_SUCCESS_HANDLED = 1;
@@ -1286,25 +1289,37 @@
      * native windowing system specific actions.
      */
 
+    private BufferCapabilities backBufferCaps;
+
     public void createBuffers(int numBuffers, BufferCapabilities caps)
       throws AWTException
     {
         if (buffersLog.isLoggable(Level.FINE)) {
             buffersLog.fine("createBuffers(" + numBuffers + ", " + caps + ")");
         }
+        // set the caps first, they're used when creating the bb
+        backBufferCaps = caps;
         backBuffer = graphicsConfig.createBackBuffer(this, numBuffers, caps);
         xBackBuffer = graphicsConfig.createBackBufferImage(target,
                                                            backBuffer);
     }
 
-    public void flip(BufferCapabilities.FlipContents flipAction) {
+    @Override
+    public BufferCapabilities getBackBufferCaps() {
+        return backBufferCaps;
+    }
+
+    public void flip(int x1, int y1, int x2, int y2,
+                     BufferCapabilities.FlipContents flipAction)
+    {
         if (buffersLog.isLoggable(Level.FINE)) {
             buffersLog.fine("flip(" + flipAction + ")");
         }
         if (backBuffer == 0) {
             throw new IllegalStateException("Buffers have not been created");
         }
-        graphicsConfig.flip(this, target, xBackBuffer, flipAction);
+        graphicsConfig.flip(this, target, xBackBuffer,
+                            x1, y1, x2, y2, flipAction);
     }
 
     public Image getBackBuffer() {
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XEmbedChildProxyPeer.java openjdk/jdk/src/solaris/classes/sun/awt/X11/XEmbedChildProxyPeer.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11/XEmbedChildProxyPeer.java	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11/XEmbedChildProxyPeer.java	2011-01-08 01:26:50.459202079 +0000
@@ -257,7 +257,7 @@
     public void createBuffers(int numBuffers, BufferCapabilities caps)
       throws AWTException { }
     public Image getBackBuffer() { return null; }
-    public void flip(BufferCapabilities.FlipContents flipAction) {  }
+    public void flip(int x1, int y1, int x2, int y2, BufferCapabilities.FlipContents flipAction) {  }
     public void destroyBuffers() { }
 
     /**
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/X11GraphicsConfig.java openjdk/jdk/src/solaris/classes/sun/awt/X11GraphicsConfig.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11GraphicsConfig.java	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11GraphicsConfig.java	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,20 +27,17 @@
 
 import java.awt.AWTException;
 import java.awt.BufferCapabilities;
+import java.awt.BufferCapabilities.FlipContents;
 import java.awt.Component;
 import java.awt.Toolkit;
 import java.awt.GraphicsConfiguration;
 import java.awt.GraphicsDevice;
 import java.awt.Image;
 import java.awt.ImageCapabilities;
-import java.awt.image.DataBuffer;
 import java.awt.Transparency;
 import java.awt.image.BufferedImage;
 import java.awt.image.ColorModel;
 import java.awt.image.DirectColorModel;
-import java.awt.image.ImageProducer;
-import java.awt.image.IndexColorModel;
-import java.awt.image.Raster;
 import java.awt.image.VolatileImage;
 import java.awt.image.WritableRaster;
 import java.awt.geom.AffineTransform;
@@ -437,6 +434,7 @@
      */
     public void flip(X11ComponentPeer peer,
                      Component target, VolatileImage xBackBuffer,
+                     int x1, int y1, int x2, int y2,
                      BufferCapabilities.FlipContents flipAction)
     {
         long window = peer.getContentWindow();
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/awt/X11GraphicsDevice.java openjdk/jdk/src/solaris/classes/sun/awt/X11GraphicsDevice.java
--- openjdk.orig/jdk/src/solaris/classes/sun/awt/X11GraphicsDevice.java	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/awt/X11GraphicsDevice.java	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -385,6 +385,9 @@
             throw new IllegalStateException("Must be in fullscreen mode " +
                                             "in order to set display mode");
         }
+        if (getDisplayMode().equals(dm)) {
+            return;
+        }
         if (dm == null ||
             (dm = getMatchingDisplayMode(dm)) == null)
         {
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/java2d/BackBufferCapsProvider.java openjdk/jdk/src/solaris/classes/sun/java2d/BackBufferCapsProvider.java
--- openjdk.orig/jdk/src/solaris/classes/sun/java2d/BackBufferCapsProvider.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/solaris/classes/sun/java2d/BackBufferCapsProvider.java	2011-01-08 01:26:50.459202079 +0000
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d;
+
+import java.awt.BufferCapabilities;
+
+/**
+ * Provides access to back-buffer's BufferCapabilities.
+ */
+public interface BackBufferCapsProvider {
+    public BufferCapabilities getBackBufferCaps();
+}
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/java2d/opengl/GLXGraphicsConfig.java openjdk/jdk/src/solaris/classes/sun/java2d/opengl/GLXGraphicsConfig.java
--- openjdk.orig/jdk/src/solaris/classes/sun/java2d/opengl/GLXGraphicsConfig.java	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/java2d/opengl/GLXGraphicsConfig.java	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,8 +27,11 @@
 
 import java.awt.AWTException;
 import java.awt.BufferCapabilities;
+import java.awt.BufferCapabilities.FlipContents;
+import java.awt.Color;
 import java.awt.Component;
 import java.awt.Graphics;
+import java.awt.Graphics2D;
 import java.awt.Image;
 import java.awt.ImageCapabilities;
 import java.awt.Transparency;
@@ -45,7 +48,19 @@
 import sun.awt.X11GraphicsEnvironment;
 import sun.awt.image.OffScreenImage;
 import sun.awt.image.SunVolatileImage;
+import sun.awt.image.SurfaceManager;
+import sun.java2d.SunGraphics2D;
+import sun.java2d.Surface;
 import sun.java2d.SurfaceData;
+import sun.java2d.pipe.hw.AccelSurface;
+import sun.java2d.pipe.hw.AccelTypedVolatileImage;
+import sun.java2d.pipe.hw.ContextCapabilities;
+import static sun.java2d.opengl.OGLSurfaceData.*;
+import static sun.java2d.opengl.OGLContext.*;
+import static sun.java2d.opengl.OGLContext.OGLContextCaps.*;
+import sun.java2d.opengl.GLXSurfaceData.GLXVSyncOffScreenSurfaceData;
+import sun.java2d.pipe.hw.AccelDeviceEventListener;
+import sun.java2d.pipe.hw.AccelDeviceEventNotifier;
 
 public class GLXGraphicsConfig
     extends X11GraphicsConfig
@@ -54,7 +69,7 @@
     private static ImageCapabilities imageCaps = new GLXImageCaps();
     private BufferCapabilities bufferCaps;
     private long pConfigInfo;
-    private int oglCaps;
+    private ContextCapabilities oglCaps;
     private OGLContext context;
 
     private static native long getGLXConfigInfo(int screennum, int visualnum);
@@ -62,20 +77,22 @@
     private native void initConfig(long aData, long ctxinfo);
 
     private GLXGraphicsConfig(X11GraphicsDevice device, int visualnum,
-                              long configInfo, int oglCaps)
+                              long configInfo, ContextCapabilities oglCaps)
     {
         super(device, visualnum, 0, 0,
-              (oglCaps & OGLContext.CAPS_DOUBLEBUFFERED) != 0);
+              (oglCaps.getCaps() & CAPS_DOUBLEBUFFERED) != 0);
         pConfigInfo = configInfo;
         initConfig(getAData(), configInfo);
         this.oglCaps = oglCaps;
-        context = new OGLContext(OGLRenderQueue.getInstance());
+        context = new OGLContext(OGLRenderQueue.getInstance(), this);
     }
 
+    @Override
     public Object getProxyKey() {
         return this;
     }
 
+    @Override
     public SurfaceData createManagedSurface(int w, int h, int transparency) {
         return GLXSurfaceData.createData(this, w, h,
                                          getColorModel(transparency),
@@ -91,6 +108,7 @@
         }
 
         long cfginfo = 0;
+        final String ids[] = new String[1];
         OGLRenderQueue rq = OGLRenderQueue.getInstance();
         rq.lock();
         try {
@@ -102,6 +120,12 @@
                 new GLXGetConfigInfo(device.getScreen(), visualnum);
             rq.flushAndInvokeNow(action);
             cfginfo = action.getConfigInfo();
+            OGLContext.setScratchSurface(cfginfo);
+            rq.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    ids[0] = OGLContext.getOGLIdString();
+                }
+            });
         } finally {
             rq.unlock();
         }
@@ -110,8 +134,9 @@
         }
 
         int oglCaps = getOGLCapabilities(cfginfo);
+        ContextCapabilities caps = new OGLContextCaps(oglCaps, ids[0]);
 
-        return new GLXGraphicsConfig(device, visualnum, cfginfo, oglCaps);
+        return new GLXGraphicsConfig(device, visualnum, cfginfo, caps);
     }
 
     /**
@@ -138,14 +163,22 @@
      * Returns true if the provided capability bit is present for this config.
      * See OGLContext.java for a list of supported capabilities.
      */
+    @Override
     public final boolean isCapPresent(int cap) {
-        return ((oglCaps & cap) != 0);
+        return ((oglCaps.getCaps() & cap) != 0);
     }
 
+    @Override
     public final long getNativeConfigInfo() {
         return pConfigInfo;
     }
 
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.pipe.hw.BufferedContextProvider#getContext
+     */
+    @Override
     public final OGLContext getContext() {
         return context;
     }
@@ -275,16 +308,36 @@
     @Override
     public void flip(X11ComponentPeer peer,
                      Component target, VolatileImage xBackBuffer,
+                     int x1, int y1, int x2, int y2,
                      BufferCapabilities.FlipContents flipAction)
     {
         if (flipAction == BufferCapabilities.FlipContents.COPIED) {
-            Graphics g = peer.getGraphics();
-            try {
-                g.drawImage(xBackBuffer, 0, 0, null);
-            } finally {
-                g.dispose();
+            SurfaceManager vsm = SurfaceManager.getManager(xBackBuffer);
+            SurfaceData sd = vsm.getPrimarySurfaceData();
+
+            if (sd instanceof GLXVSyncOffScreenSurfaceData) {
+                GLXVSyncOffScreenSurfaceData vsd =
+                    (GLXVSyncOffScreenSurfaceData)sd;
+                SurfaceData bbsd = vsd.getFlipSurface();
+                Graphics2D bbg =
+                    new SunGraphics2D(bbsd, Color.black, Color.white, null);
+                try {
+                    bbg.drawImage(xBackBuffer, 0, 0, null);
+                } finally {
+                    bbg.dispose();
+                }
+            } else {
+                Graphics g = peer.getGraphics();
+                try {
+                    g.drawImage(xBackBuffer,
+                                x1, y1, x2, y2,
+                                x1, y1, x2, y2,
+                                null);
+                } finally {
+                    g.dispose();
+                }
+                return;
             }
-            return;
         } else if (flipAction == BufferCapabilities.FlipContents.PRIOR) {
             // not supported by GLX...
             return;
@@ -333,4 +386,64 @@
     public ImageCapabilities getImageCapabilities() {
         return imageCaps;
     }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.pipe.hw.AccelGraphicsConfig#createCompatibleVolatileImage
+     */
+    @Override
+    public VolatileImage
+        createCompatibleVolatileImage(int width, int height,
+                                      int transparency, int type)
+    {
+        if (type == FLIP_BACKBUFFER || type == WINDOW || type == UNDEFINED ||
+            transparency == Transparency.BITMASK)
+        {
+            return null;
+        }
+
+        if (type == FBOBJECT) {
+            if (!isCapPresent(CAPS_EXT_FBOBJECT)) {
+                return null;
+            }
+        } else if (type == PBUFFER) {
+            boolean isOpaque = transparency == Transparency.OPAQUE;
+            if (!isOpaque && !isCapPresent(CAPS_STORED_ALPHA)) {
+                return null;
+            }
+        }
+
+        SunVolatileImage vi = new AccelTypedVolatileImage(this, width, height,
+                                                          transparency, type);
+        Surface sd = vi.getDestSurface();
+        if (!(sd instanceof AccelSurface) ||
+            ((AccelSurface)sd).getType() != type)
+        {
+            vi.flush();
+            vi = null;
+        }
+
+        return vi;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.pipe.hw.AccelGraphicsConfig#getContextCapabilities
+     */
+    @Override
+    public ContextCapabilities getContextCapabilities() {
+        return oglCaps;
+    }
+
+    @Override
+    public void addDeviceEventListener(AccelDeviceEventListener l) {
+        AccelDeviceEventNotifier.addListener(l, screen.getScreen());
+    }
+
+    @Override
+    public void removeDeviceEventListener(AccelDeviceEventListener l) {
+        AccelDeviceEventNotifier.removeListener(l);
+    }
 }
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/java2d/opengl/GLXSurfaceData.java openjdk/jdk/src/solaris/classes/sun/java2d/opengl/GLXSurfaceData.java
--- openjdk.orig/jdk/src/solaris/classes/sun/java2d/opengl/GLXSurfaceData.java	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/java2d/opengl/GLXSurfaceData.java	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -73,13 +73,20 @@
      * double-buffered on-screen Window.
      */
     public static GLXOffScreenSurfaceData createData(X11ComponentPeer peer,
-                                                     Image image)
+                                                     Image image,
+                                                     int type)
     {
         GLXGraphicsConfig gc = getGC(peer);
         Rectangle r = peer.getBounds();
-        return new GLXOffScreenSurfaceData(peer, gc, r.width, r.height,
-                                           image, peer.getColorModel(),
-                                           FLIP_BACKBUFFER);
+        if (type == FLIP_BACKBUFFER) {
+            return new GLXOffScreenSurfaceData(peer, gc, r.width, r.height,
+                                               image, peer.getColorModel(),
+                                               FLIP_BACKBUFFER);
+        } else {
+            return new GLXVSyncOffScreenSurfaceData(peer, gc, r.width, r.height,
+                                                    image, peer.getColorModel(),
+                                                    type);
+        }
     }
 
     /**
@@ -134,6 +141,42 @@
         }
     }
 
+    /**
+     * A surface which implements a v-synced flip back-buffer with COPIED
+     * FlipContents.
+     *
+     * This surface serves as a back-buffer to the outside world, while
+     * it is actually an offscreen surface. When the BufferStrategy this surface
+     * belongs to is showed, it is first copied to the real private
+     * FLIP_BACKBUFFER, which is then flipped.
+     */
+    public static class GLXVSyncOffScreenSurfaceData extends
+        GLXOffScreenSurfaceData
+    {
+        private GLXOffScreenSurfaceData flipSurface;
+
+        public GLXVSyncOffScreenSurfaceData(X11ComponentPeer peer,
+                                            GLXGraphicsConfig gc,
+                                            int width, int height,
+                                            Image image, ColorModel cm,
+                                            int type)
+        {
+            super(peer, gc, width, height, image, cm, type);
+            flipSurface = GLXSurfaceData.createData(peer, image, FLIP_BACKBUFFER);
+        }
+
+        public SurfaceData getFlipSurface() {
+            return flipSurface;
+        }
+
+        @Override
+        public void flush() {
+            flipSurface.flush();
+            super.flush();
+        }
+
+    }
+
     public static class GLXOffScreenSurfaceData extends GLXSurfaceData {
 
         private Image offscreenImage;
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/java2d/opengl/GLXVolatileSurfaceManager.java openjdk/jdk/src/solaris/classes/sun/java2d/opengl/GLXVolatileSurfaceManager.java
--- openjdk.orig/jdk/src/solaris/classes/sun/java2d/opengl/GLXVolatileSurfaceManager.java	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/java2d/opengl/GLXVolatileSurfaceManager.java	2011-01-08 01:26:50.459202079 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,16 +25,21 @@
 
 package sun.java2d.opengl;
 
+import java.awt.BufferCapabilities;
+import static java.awt.BufferCapabilities.FlipContents.*;
 import java.awt.Component;
 import java.awt.GraphicsConfiguration;
-import java.awt.ImageCapabilities;
-import java.awt.Rectangle;
 import java.awt.Transparency;
 import java.awt.image.ColorModel;
 import sun.awt.X11ComponentPeer;
 import sun.awt.image.SunVolatileImage;
 import sun.awt.image.VolatileSurfaceManager;
+import sun.java2d.BackBufferCapsProvider;
 import sun.java2d.SurfaceData;
+import static sun.java2d.opengl.OGLContext.OGLContextCaps.*;
+import sun.java2d.pipe.hw.ExtendedBufferCapabilities;
+import static sun.java2d.pipe.hw.AccelSurface.*;
+import static sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType.*;
 
 public class GLXVolatileSurfaceManager extends VolatileSurfaceManager {
 
@@ -56,8 +61,8 @@
         accelerationEnabled =
             (transparency == Transparency.OPAQUE) ||
             ((transparency == Transparency.TRANSLUCENT) &&
-             (gc.isCapPresent(OGLContext.CAPS_EXT_FBOBJECT) ||
-              gc.isCapPresent(OGLContext.CAPS_STORED_ALPHA)));
+             (gc.isCapPresent(CAPS_EXT_FBOBJECT) ||
+              gc.isCapPresent(CAPS_STORED_ALPHA)));
     }
 
     protected boolean isAccelerationEnabled() {
@@ -75,24 +80,49 @@
             (comp != null) ? (X11ComponentPeer)comp.getPeer() : null;
 
         try {
+            boolean createVSynced = false;
             boolean forceback = false;
             if (context instanceof Boolean) {
                 forceback = ((Boolean)context).booleanValue();
+                if (forceback && peer instanceof BackBufferCapsProvider) {
+                    BackBufferCapsProvider provider =
+                        (BackBufferCapsProvider)peer;
+                    BufferCapabilities caps = provider.getBackBufferCaps();
+                    if (caps instanceof ExtendedBufferCapabilities) {
+                        ExtendedBufferCapabilities ebc =
+                            (ExtendedBufferCapabilities)caps;
+                        if (ebc.getVSync() == VSYNC_ON &&
+                            ebc.getFlipContents() == COPIED)
+                        {
+                            createVSynced = true;
+                            forceback = false;
+                        }
+                    }
+                }
             }
 
             if (forceback) {
                 // peer must be non-null in this case
-                sData = GLXSurfaceData.createData(peer, vImg);
+                sData = GLXSurfaceData.createData(peer, vImg, FLIP_BACKBUFFER);
             } else {
                 GLXGraphicsConfig gc =
                     (GLXGraphicsConfig)vImg.getGraphicsConfig();
                 ColorModel cm = gc.getColorModel(vImg.getTransparency());
-                int type = gc.isCapPresent(OGLContext.CAPS_EXT_FBOBJECT) ?
-                    OGLSurfaceData.FBOBJECT : OGLSurfaceData.PBUFFER;
-                sData = GLXSurfaceData.createData(gc,
-                                                  vImg.getWidth(),
-                                                  vImg.getHeight(),
-                                                  cm, vImg, type);
+                int type = vImg.getForcedAccelSurfaceType();
+                // if acceleration type is forced (type != UNDEFINED) then
+                // use the forced type, otherwise choose one based on caps
+                if (type == OGLSurfaceData.UNDEFINED) {
+                    type = gc.isCapPresent(CAPS_EXT_FBOBJECT) ?
+                        OGLSurfaceData.FBOBJECT : OGLSurfaceData.PBUFFER;
+                }
+                if (createVSynced) {
+                    sData = GLXSurfaceData.createData(peer, vImg, type);
+                } else {
+                    sData = GLXSurfaceData.createData(gc,
+                                                      vImg.getWidth(),
+                                                      vImg.getHeight(),
+                                                      cm, vImg, type);
+                }
             }
         } catch (NullPointerException ex) {
             sData = null;
@@ -103,7 +133,15 @@
         return sData;
     }
 
+    @Override
     protected boolean isConfigValid(GraphicsConfiguration gc) {
         return ((gc == null) || (gc == vImg.getGraphicsConfig()));
     }
+
+    @Override
+    public void initContents() {
+        if (vImg.getForcedAccelSurfaceType() != OGLSurfaceData.TEXTURE) {
+            super.initContents();
+        }
+    }
 }
diff -Nru openjdk.orig/jdk/src/solaris/classes/sun/java2d/x11/X11PMBlitBgLoops.java openjdk/jdk/src/solaris/classes/sun/java2d/x11/X11PMBlitBgLoops.java
--- openjdk.orig/jdk/src/solaris/classes/sun/java2d/x11/X11PMBlitBgLoops.java	2011-01-07 21:33:04.000000000 +0000
+++ openjdk/jdk/src/solaris/classes/sun/java2d/x11/X11PMBlitBgLoops.java	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -79,15 +79,16 @@
         super(srcType, CompositeType.SrcNoEa, dstType);
     }
 
+    @Override
     public void BlitBg(SurfaceData src, SurfaceData dst,
-                       Composite comp, Region clip, Color bgColor,
+                       Composite comp, Region clip, int bgColor,
                        int sx, int sy,
                        int dx, int dy,
                        int w, int h)
     {
         SunToolkit.awtLock();
         try {
-            int pixel = dst.pixelFor(bgColor.getRGB());
+            int pixel = dst.pixelFor(bgColor);
             X11SurfaceData x11sd = (X11SurfaceData)dst;
             // use false for needExposures since we clip to the pixmap
             long xgc = x11sd.getBlitGC(clip, false);
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/java2d/opengl/GLXGraphicsConfig.c openjdk/jdk/src/solaris/native/sun/java2d/opengl/GLXGraphicsConfig.c
--- openjdk.orig/jdk/src/solaris/native/sun/java2d/opengl/GLXGraphicsConfig.c	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/solaris/native/sun/java2d/opengl/GLXGraphicsConfig.c	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -471,7 +471,7 @@
     GLXContext context;
     GLXPbuffer scratch;
     GLXGraphicsConfigInfo *glxinfo;
-    jint caps = sun_java2d_opengl_OGLContext_CAPS_EMPTY;
+    jint caps = CAPS_EMPTY;
     int db, alpha;
     const unsigned char *versionstr;
 
@@ -581,11 +581,11 @@
     // get config-specific capabilities
     j2d_glXGetFBConfigAttrib(awt_display, fbconfig, GLX_DOUBLEBUFFER, &db);
     if (db) {
-        caps |= sun_java2d_opengl_OGLContext_CAPS_DOUBLEBUFFERED;
+        caps |= CAPS_DOUBLEBUFFERED;
     }
     j2d_glXGetFBConfigAttrib(awt_display, fbconfig, GLX_ALPHA_SIZE, &alpha);
     if (alpha > 0) {
-        caps |= sun_java2d_opengl_OGLContext_CAPS_STORED_ALPHA;
+        caps |= CAPS_STORED_ALPHA;
     }
 
     // initialize the OGLContext, which wraps the GLXFBConfig and GLXContext
@@ -662,11 +662,11 @@
     J2dTraceLn(J2D_TRACE_INFO, "GLXGraphicsConfig_getOGLCapabilities");
 
     if (glxinfo == NULL || glxinfo->context == NULL) {
-        return sun_java2d_opengl_OGLContext_CAPS_EMPTY;
+        return CAPS_EMPTY;
     }
 
     return glxinfo->context->caps;
 #else
-    return sun_java2d_opengl_OGLContext_CAPS_EMPTY;
+    return CAPS_EMPTY;
 #endif /* !HEADLESS */
 }
diff -Nru openjdk.orig/jdk/src/solaris/native/sun/java2d/opengl/GLXSurfaceData.c openjdk/jdk/src/solaris/native/sun/java2d/opengl/GLXSurfaceData.c
--- openjdk.orig/jdk/src/solaris/native/sun/java2d/opengl/GLXSurfaceData.c	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/solaris/native/sun/java2d/opengl/GLXSurfaceData.c	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -47,6 +47,9 @@
 
 extern struct MComponentPeerIDs mComponentPeerIDs;
 
+extern void
+    OGLSD_SetNativeDimensions(JNIEnv *env, OGLSDOps *oglsdo, jint w, jint h);
+
 jboolean surfaceCreationFailed = JNI_FALSE;
 
 #endif /* !HEADLESS */
@@ -460,6 +463,8 @@
     glxsdo->drawable = pbuffer;
     glxsdo->xdrawable = 0;
 
+    OGLSD_SetNativeDimensions(env, oglsdo, width, height);
+
     return JNI_TRUE;
 }
 
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/awt/Win32GraphicsConfig.java openjdk/jdk/src/windows/classes/sun/awt/Win32GraphicsConfig.java
--- openjdk.orig/jdk/src/windows/classes/sun/awt/Win32GraphicsConfig.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/Win32GraphicsConfig.java	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -55,9 +55,7 @@
 import sun.java2d.loops.RenderLoops;
 import sun.java2d.loops.SurfaceType;
 import sun.java2d.loops.CompositeType;
-import sun.java2d.windows.Win32SurfaceData;
-import sun.java2d.windows.WinBackBuffer;
-import sun.java2d.windows.WindowsFlags;
+import sun.java2d.windows.GDIWindowSurfaceData;
 
 /**
  * This is an implementation of a GraphicsConfiguration object for a
@@ -72,8 +70,6 @@
     protected Win32GraphicsDevice screen;
     protected int visual;  //PixelFormatID
     protected RenderLoops solidloops;
-    private static BufferCapabilities bufferCaps;
-    private static ImageCapabilities imageCaps;
 
     private static native void initIDs();
 
@@ -178,32 +174,12 @@
         case Transparency.BITMASK:
             return new DirectColorModel(25, 0xff0000, 0xff00, 0xff, 0x1000000);
         case Transparency.TRANSLUCENT:
-            return getTranslucentColorModel();
+            return ColorModel.getRGBdefault();
         default:
             return null;
         }
     }
 
-    private static final int DCM_4444_RED_MASK = 0x0f00;
-    private static final int DCM_4444_GRN_MASK = 0x00f0;
-    private static final int DCM_4444_BLU_MASK = 0x000f;
-    private static final int DCM_4444_ALP_MASK = 0xf000;
-    static ColorModel translucentCM = null;
-    public static ColorModel getTranslucentColorModel() {
-        if (WindowsFlags.getD3DTexBpp() == 16) {
-            if (translucentCM == null) {
-                translucentCM = new DirectColorModel(16,
-                                                     DCM_4444_RED_MASK,
-                                                     DCM_4444_GRN_MASK,
-                                                     DCM_4444_BLU_MASK,
-                                                     DCM_4444_ALP_MASK);
-            }
-            return translucentCM;
-        } else {
-            return ColorModel.getRGBdefault();
-        }
-    }
-
     /**
      * Returns the default Transform for this configuration.  This
      * Transform is typically the Identity transform for most normal
@@ -254,44 +230,6 @@
         return getBounds(screen.getScreen());
     }
 
-    private static class DDrawBufferCapabilities extends BufferCapabilities {
-        public DDrawBufferCapabilities(ImageCapabilities imageCaps) {
-            super(imageCaps, imageCaps, FlipContents.PRIOR);
-        }
-        public boolean isFullScreenRequired() { return true; }
-        public boolean isMultiBufferAvailable() { return true; }
-    }
-
-    private static class DDrawImageCapabilities extends ImageCapabilities {
-        public DDrawImageCapabilities() {
-            super(true);
-        }
-        public boolean isTrueVolatile() { return true; }
-    }
-
-    public BufferCapabilities getBufferCapabilities() {
-        if (bufferCaps == null) {
-            if (WindowsFlags.isDDEnabled()) {
-                bufferCaps = new DDrawBufferCapabilities(
-                    getImageCapabilities());
-            } else {
-                bufferCaps = super.getBufferCapabilities();
-            }
-        }
-        return bufferCaps;
-    }
-
-    public ImageCapabilities getImageCapabilities() {
-        if (imageCaps == null) {
-            if (WindowsFlags.isDDEnabled()) {
-                imageCaps = new DDrawImageCapabilities();
-            } else {
-                imageCaps = super.getImageCapabilities();
-            }
-        }
-        return imageCaps;
-    }
-
     public synchronized void displayChanged() {
         solidloops = null;
     }
@@ -313,11 +251,11 @@
     public SurfaceData createSurfaceData(WComponentPeer peer,
                                          int numBackBuffers)
     {
-        return Win32SurfaceData.createData(peer, numBackBuffers);
+        return GDIWindowSurfaceData.createData(peer);
     }
 
     /**
-     * Creates a new hidden-acceleration image of the given width and height
+     * Creates a new managed image of the given width and height
      * that is associated with the target Component.
      */
     public Image createAcceleratedImage(Component target,
@@ -335,15 +273,6 @@
      * WComponentPeer.java...
      */
 
-    private boolean isFullScreenExclusive(Component target) {
-        Win32GraphicsDevice gd = (Win32GraphicsDevice)getDevice();
-        while (target != null && !(target instanceof Window)) {
-            target = target.getParent();
-        }
-        return (target == gd.getFullScreenWindow() &&
-                gd.isDDEnabledOnDevice());
-    }
-
     /**
      * Checks that the requested configuration is natively supported; if not,
      * an AWTException is thrown.
@@ -353,51 +282,61 @@
                                          BufferCapabilities caps)
         throws AWTException
     {
-        if (!isFullScreenExclusive(target)) {
-            throw new AWTException(
-                "The operation requested is only supported on a full-screen" +
-                " exclusive window");
-        }
+        // the default pipeline doesn't support flip buffer strategy
+        throw new AWTException(
+            "The operation requested is not supported");
     }
 
     /**
-     * Creates a backbuffer for the given peer and returns the image wrapper.
+     * This method is called from WComponentPeer when a surface data is replaced
+     * REMIND: while the default pipeline doesn't support flipping, it may
+     * happen that the accelerated device may have this graphics config
+     * (like if the device restoration failed when one device exits fs mode
+     * while others remain).
      */
     public VolatileImage createBackBuffer(WComponentPeer peer) {
-        // Create the back buffer object
-        return new WinBackBuffer((Component)peer.getTarget(),
-                                 (Win32SurfaceData)peer.getSurfaceData());
+        Component target = (Component)peer.getTarget();
+        return new SunVolatileImage(target,
+                                    target.getWidth(), target.getHeight(),
+                                    Boolean.TRUE);
     }
 
     /**
      * Performs the native flip operation for the given target Component.
+     *
+     * REMIND: we should really not get here because that would mean that
+     * a FLIP BufferStrategy has been created, and one could only be created
+     * if accelerated pipeline is present but in some rare (and transitional)
+     * cases it may happen that the accelerated graphics device may have a
+     * default graphics configuraiton, so this is just a precaution.
      */
     public void flip(WComponentPeer peer,
                      Component target, VolatileImage backBuffer,
+                     int x1, int y1, int x2, int y2,
                      BufferCapabilities.FlipContents flipAction)
     {
-        int width = target.getWidth();
-        int height = target.getHeight();
-        if (flipAction == BufferCapabilities.FlipContents.COPIED) {
-            Graphics g = target.getGraphics();
-            g.drawImage(backBuffer, 0, 0, width, height, null);
-            g.dispose();
-            return;
-        }
-        Win32SurfaceData sd = (Win32SurfaceData)peer.getSurfaceData();
-        try {
-            sd.flip(((WinBackBuffer)backBuffer).getHWSurfaceData());
-        } catch (sun.java2d.InvalidPipeException e) {
-            // copy software surface to the screen via gdi blit
-            Graphics g = target.getGraphics();
-            g.drawImage(backBuffer, 0, 0, width, height, null);
-            g.dispose();
-        }
-        if (flipAction == BufferCapabilities.FlipContents.BACKGROUND) {
+        if (flipAction == BufferCapabilities.FlipContents.COPIED ||
+            flipAction == BufferCapabilities.FlipContents.UNDEFINED) {
+            Graphics g = peer.getGraphics();
+            try {
+                g.drawImage(backBuffer,
+                            x1, y1, x2, y2,
+                            x1, y1, x2, y2,
+                            null);
+            } finally {
+                g.dispose();
+            }
+        } else if (flipAction == BufferCapabilities.FlipContents.BACKGROUND) {
             Graphics g = backBuffer.getGraphics();
-            g.setColor(target.getBackground());
-            g.fillRect(0, 0, width, height);
-            g.dispose();
+            try {
+                g.setColor(target.getBackground());
+                g.fillRect(0, 0,
+                           backBuffer.getWidth(),
+                           backBuffer.getHeight());
+            } finally {
+                g.dispose();
+            }
         }
+        // the rest of the flip actions are not supported
     }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/awt/Win32GraphicsDevice.java openjdk/jdk/src/windows/classes/sun/awt/Win32GraphicsDevice.java
--- openjdk.orig/jdk/src/windows/classes/sun/awt/Win32GraphicsDevice.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/Win32GraphicsDevice.java	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,12 +33,14 @@
 import java.awt.Frame;
 import java.awt.Rectangle;
 import java.awt.Window;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.event.WindowListener;
 import java.awt.image.ColorModel;
 import java.util.ArrayList;
 import java.util.Vector;
 import java.awt.peer.WindowPeer;
 import sun.awt.windows.WWindowPeer;
-import sun.java2d.d3d.D3DContext;
 import sun.java2d.opengl.WGLGraphicsConfig;
 import sun.java2d.windows.WindowsFlags;
 
@@ -54,13 +56,11 @@
     int screen;
     ColorModel dynamicColorModel;   // updated with dev changes
     ColorModel colorModel;          // static for device
-    GraphicsConfiguration[] configs;
-    GraphicsConfiguration defaultConfig;
-    boolean offscreenAccelerationEnabled = true;
-    private D3DContext d3dContext;
+    protected GraphicsConfiguration[] configs;
+    protected GraphicsConfiguration defaultConfig;
 
     private final String idString;
-    private final String descString;
+    protected String descString;
     // Note that we do not synchronize access to this variable - it doesn't
     // really matter if a thread does an operation on graphics device which is
     // about to become invalid (or already become) - we are prepared to deal
@@ -69,12 +69,16 @@
 
     // keep track of top-level windows on this display
     private SunDisplayChanger topLevels = new SunDisplayChanger();
-    private static boolean pfDisabled;
+    // REMIND: we may disable the use of pixel formats for some accelerated
+    // pipelines which are mutually exclusive with opengl, for which
+    // pixel formats were added in the first place
+    protected static boolean pfDisabled;
     private static AWTPermission fullScreenExclusivePermission;
-    private Rectangle ownerWindowedModeBounds = null;
     // the original display mode we had before entering the fullscreen
     // mode
     private DisplayMode defaultDisplayMode;
+    // activation/deactivation listener for the full-screen window
+    private WindowListener fsWindowListener;
 
     static {
 
@@ -91,16 +95,6 @@
 
     private static native void initIDs();
 
-    /**
-     * Acceleration can be disabled due to capabilities of the display
-     * device discovered during ddraw initialization.  This is not the
-     * same as isDDEnabledOnDevice(), which returns false when ddraw
-     * was disabled by the user or had problems initializing.
-     */
-    public boolean isOffscreenAccelerationEnabled() {
-        return offscreenAccelerationEnabled;
-    }
-
     native void initDevice(int screen);
 
     public Win32GraphicsDevice(int screennum) {
@@ -109,6 +103,7 @@
         // to reflect the original screen number (which may change if the
         // device is removed)
         idString = "\\Display"+screen;
+        // REMIND: may be should use class name?
         descString = "Win32GraphicsDevice[screen=" + screen;
         valid = true;
 
@@ -136,7 +131,7 @@
      * Returns whether this is a valid devicie. Device can become
      * invalid as a result of device removal event.
      */
-    boolean isValid() {
+    public boolean isValid() {
         return valid;
     }
 
@@ -145,7 +140,7 @@
      *
      * @param defaultScreen the current default screen
      */
-    void invalidate(int defaultScreen) {
+    protected void invalidate(int defaultScreen) {
         valid = false;
         screen = defaultScreen;
     }
@@ -178,8 +173,7 @@
             int defaultPixID = getDefaultPixID(screen);
             Vector v = new Vector( max );
             if (defaultPixID == 0) {
-                // Workaround for failing GDI calls, or if DirectDraw
-                // is disabled
+                // Workaround for failing GDI calls
                 defaultConfig = Win32GraphicsConfig.getConfig(this,
                                                               defaultPixID);
                 v.addElement(defaultConfig);
@@ -309,32 +303,6 @@
                     getLocalGraphicsEnvironment().getDefaultScreenDevice());
     }
 
-    private native boolean isDDEnabledOnDeviceNative(int screen);
-
-    public D3DContext getD3DContext() {
-        if (d3dContext == null) {
-            d3dContext = new D3DContext(this);
-        }
-        return d3dContext;
-    }
-
-
-    public boolean isDDEnabledOnDevice() {
-        return (WindowsFlags.isDDEnabled() && isValid() &&
-                isDDEnabledOnDeviceNative(screen));
-    }
-
-    public boolean isD3DEnabledOnDevice() {
-        // The conditions under which we enable the D3D pipeline for the device:
-        //  - d3d is not disabled via a flag
-        //  - either d3d is forced via property or we're in fullscreen mode
-        //  - the hardware/drivers meet our requirements
-        return (WindowsFlags.isD3DEnabled() && isValid() &&
-                (WindowsFlags.isD3DSet() || getFullScreenWindow() != null) &&
-                ((getD3DContext().getDeviceCaps() &
-                  D3DContext.J2D_D3D_ENABLED_OK) != 0));
-    }
-
     private static boolean isFSExclusiveModeAllowed() {
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
@@ -352,31 +320,14 @@
     }
 
     /**
-     * We support the exclusive fullscreen mode in both ddraw and
-     * noddraw modes, so we return true unless we're not allowed to use
-     * fullscreen mode.
+     * returns true unless we're not allowed to use fullscreen mode.
      */
+    @Override
     public boolean isFullScreenSupported() {
         return isFSExclusiveModeAllowed();
     }
 
-    /**
-     * Return the owning Frame for a given Window.  Used in setFSWindow below
-     * to set the properties of the owning Frame when a Window goes
-     * into fullscreen mode.
-     */
-    private Frame getToplevelOwner(Window w) {
-        Window owner = w;
-        while (owner != null) {
-            owner = owner.getOwner();
-            if (owner instanceof Frame) {
-                return (Frame) owner;
-            }
-        }
-        // Should not get here, but return something intelligent just in case
-        return null;
-    }
-
+    @Override
     public synchronized void setFullScreenWindow(Window w) {
         Window old = getFullScreenWindow();
         if (w == old) {
@@ -402,51 +353,25 @@
             }
             WWindowPeer peer = (WWindowPeer)old.getPeer();
             if (peer != null) {
+                // we used to destroy the buffers on exiting fs mode, this
+                // is no longer needed since fs change will cause a surface
+                // data replacement
                 synchronized(peer) {
-                    peer.destroyBuffers();
-                    exitFullScreenExclusive(isDDEnabledOnDevice(),
-                                            screen, peer);
-                }
-            }
-            /**
-             * Bug 4933099: There is some funny-business to deal with when this
-             * method is called with a Window instead of a Frame.  See 4836744
-             * for more information on this.  One side-effect of our workaround
-             * for the problem is that the owning Frame of a Window may end
-             * up getting resized during the fullscreen process.  When we
-             * return from fullscreen mode, we should resize the Frame to
-             * its original size (just like the Window is being resized
-             * to its original size in GraphicsDevice).
-             */
-            if (!(old instanceof Frame)) {
-                Frame owner = getToplevelOwner(old);
-                if (owner != null && ownerWindowedModeBounds != null) {
-                    owner.setBounds(ownerWindowedModeBounds);
+                    exitFullScreenExclusive(screen, peer);
                 }
-                ownerWindowedModeBounds = null;
             }
+            removeFSWindowListener(old);
         }
         super.setFullScreenWindow(w);
         if (w != null) {
             // always record the default display mode prior to going
             // fullscreen
             defaultDisplayMode = getDisplayMode();
-            // Bug 4933099
-            if (!(w instanceof Frame)) {
-                Frame owner = getToplevelOwner(w);
-                if (owner != null) {
-                    ownerWindowedModeBounds = owner.getBounds();
-                    // These will get set for the native window in
-                    // any case.  Set them here so that resetting them
-                    // later actually does the right thing
-                    owner.setBounds(w.getBounds());
-                }
-            }
+            addFSWindowListener(w);
             // Enter full screen exclusive mode.
             WWindowPeer peer = (WWindowPeer)w.getPeer();
             synchronized(peer) {
-                enterFullScreenExclusive(isDDEnabledOnDevice(),
-                                         screen, peer);
+                enterFullScreenExclusive(screen, peer);
                 // Note: removed replaceSurfaceData() call because
                 // changing the window size or making it visible
                 // will cause this anyway, and both of these events happen
@@ -463,15 +388,18 @@
     // tree-lock and should never lock on any resources which are
     // required by other threads which may have them and may require
     // the tree-lock.
-    private native void enterFullScreenExclusive(boolean useDD,
-                                                 int screen, WindowPeer w);
-    private native void exitFullScreenExclusive(boolean useDD,
-                                                int screen, WindowPeer w);
+    // REMIND: in the future these methods may need to become protected so that
+    // subclasses could override them and use appropriate api other than GDI
+    // for implementing these functions.
+    protected native void enterFullScreenExclusive(int screen, WindowPeer w);
+    protected native void exitFullScreenExclusive(int screen, WindowPeer w);
 
+    @Override
     public boolean isDisplayChangeSupported() {
         return (isFullScreenSupported() && getFullScreenWindow() != null);
     }
 
+    @Override
     public synchronized void setDisplayMode(DisplayMode dm) {
         if (!isDisplayChangeSupported()) {
             super.setDisplayMode(dm);
@@ -501,22 +429,19 @@
         }
     }
 
-    private native DisplayMode getCurrentDisplayMode(int screen);
-    private native void configDisplayMode(int screen, WindowPeer w, int width,
+    protected native DisplayMode getCurrentDisplayMode(int screen);
+    protected native void configDisplayMode(int screen, WindowPeer w, int width,
                                           int height, int bitDepth,
                                           int refreshRate);
-    private native void enumDisplayModes(int screen, ArrayList modes);
-    // This function is only available if DirectDraw is enabled, otherwise we
-    // have to do the work the hard way (enumerating all of the display modes
-    // and checking each one)
-    private native boolean isDisplayModeAvailable(int screen, int width, int height,
-        int bitDepth, int refreshRate);
+    protected native void enumDisplayModes(int screen, ArrayList modes);
 
+    @Override
     public synchronized DisplayMode getDisplayMode() {
         DisplayMode res = getCurrentDisplayMode(screen);
         return res;
     }
 
+    @Override
     public synchronized DisplayMode[] getDisplayModes() {
         ArrayList modes = new ArrayList();
         enumDisplayModes(screen, modes);
@@ -528,33 +453,22 @@
         return retArray;
     }
 
-    private synchronized DisplayMode getMatchingDisplayMode(DisplayMode dm) {
+    protected synchronized DisplayMode getMatchingDisplayMode(DisplayMode dm) {
         if (!isDisplayChangeSupported()) {
             return null;
         }
-        if (isDDEnabledOnDevice()) {
-            return
-                isDisplayModeAvailable(screen, dm.getWidth(), dm.getHeight(),
-                                       dm.getBitDepth(), dm.getRefreshRate())
-                ? dm : null;
-        } else {
-            // The function isDisplayModeAvailable is only available if
-            // DirectDraw is enabled, otherwise we have to do the work the
-            // hard way (enumerating all of the display modes
-            // and checking each one)
-            DisplayMode[] modes = getDisplayModes();
-            for (DisplayMode mode : modes) {
-                if (dm.equals(mode) ||
-                    (dm.getRefreshRate() == DisplayMode.REFRESH_RATE_UNKNOWN &&
-                     dm.getWidth() == mode.getWidth() &&
-                     dm.getHeight() == mode.getHeight() &&
-                     dm.getBitDepth() == mode.getBitDepth()))
-                {
-                    return mode;
-                }
+        DisplayMode[] modes = getDisplayModes();
+        for (DisplayMode mode : modes) {
+            if (dm.equals(mode) ||
+                (dm.getRefreshRate() == DisplayMode.REFRESH_RATE_UNKNOWN &&
+                 dm.getWidth() == mode.getWidth() &&
+                 dm.getHeight() == mode.getHeight() &&
+                 dm.getBitDepth() == mode.getBitDepth()))
+            {
+                return mode;
             }
-            return null;
         }
+        return null;
     }
 
     /*
@@ -563,7 +477,6 @@
      * changed.
      */
     public void displayChanged() {
-        d3dContext = null;
         dynamicColorModel = null;
         defaultConfig = null;
         configs = null;
@@ -621,17 +534,93 @@
         return colorModel;
     }
 
-    private native int getDeviceMemoryNative(int screen);
-
     /**
-     * Returns number of bytes available in VRAM on this device.
+     * WindowAdapter class responsible for de/iconifying full-screen window
+     * of this device.
+     *
+     * The listener restores the default display mode when window is iconified
+     * and sets it back to the one set by the user on de-iconification.
      */
-    public int getAvailableAcceleratedMemory() {
-        if (getDefaultConfiguration() instanceof WGLGraphicsConfig) {
-            // when OGL is enabled, there is no way to determine the amount
-            // of accelerated memory, so just return the default value
-            return super.getAvailableAcceleratedMemory();
+    private static class Win32FSWindowAdapter extends WindowAdapter {
+        private Win32GraphicsDevice device;
+        private DisplayMode dm;
+
+        Win32FSWindowAdapter(Win32GraphicsDevice device) {
+            this.device = device;
+        }
+
+        private void setFSWindowsState(Window other, int state) {
+            GraphicsDevice gds[] =
+                    GraphicsEnvironment.getLocalGraphicsEnvironment().
+                    getScreenDevices();
+            // check if the de/activation was caused by other
+            // fs window and ignore the event if that's the case
+            if (other != null) {
+                for (GraphicsDevice gd : gds) {
+                    if (other == gd.getFullScreenWindow()) {
+                        return;
+                    }
+                }
+            }
+            // otherwise apply state to all fullscreen windows
+            for (GraphicsDevice gd : gds) {
+                Window fsw = gd.getFullScreenWindow();
+                if (fsw instanceof Frame) {
+                    ((Frame)fsw).setExtendedState(state);
+                }
+            }
+        }
+
+        @Override
+        public void windowDeactivated(WindowEvent e) {
+            setFSWindowsState(e.getOppositeWindow(), Frame.ICONIFIED);
+        }
+
+        @Override
+        public void windowActivated(WindowEvent e) {
+            setFSWindowsState(e.getOppositeWindow(), Frame.NORMAL);
+        }
+
+        @Override
+        public void windowIconified(WindowEvent e) {
+            // restore the default display mode for this device
+            DisplayMode ddm = device.defaultDisplayMode;
+            if (ddm != null) {
+                dm = device.getDisplayMode();
+                device.setDisplayMode(ddm);
+            }
         }
-        return getDeviceMemoryNative(screen);
+
+        @Override
+        public void windowDeiconified(WindowEvent e) {
+            // restore the user-set display mode for this device
+            if (dm != null) {
+                device.setDisplayMode(dm);
+                dm = null;
+            }
+        }
+    }
+
+    /**
+     * Adds a WindowListener to be used as
+     * activation/deactivation listener for the current full-screen window.
+     *
+     * @param w full-screen window
+     */
+    protected void addFSWindowListener(Window w) {
+        // Note: even though we create a listener for Window instances of
+        // fs windows they will not receive window events.
+        fsWindowListener = new Win32FSWindowAdapter(this);
+        w.addWindowListener(fsWindowListener);
+    }
+
+    /**
+     * Removes the fs window listener.
+     *
+     * @param w full-screen window
+     */
+    protected void removeFSWindowListener(Window w) {
+        w.removeWindowListener(fsWindowListener);
+        fsWindowListener = null;
     }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/awt/Win32GraphicsEnvironment.java openjdk/jdk/src/windows/classes/sun/awt/Win32GraphicsEnvironment.java
--- openjdk.orig/jdk/src/windows/classes/sun/awt/Win32GraphicsEnvironment.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/Win32GraphicsEnvironment.java	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,9 +25,11 @@
 
 package sun.awt;
 
+import java.awt.GraphicsConfiguration;
 import java.awt.GraphicsDevice;
 import java.awt.GraphicsEnvironment;
 import java.awt.Toolkit;
+import java.awt.peer.ComponentPeer;
 import java.io.File;
 import java.io.IOException;
 import java.lang.ref.WeakReference;
@@ -321,7 +323,14 @@
     protected static native void deRegisterFontWithPlatform(String fontName);
 
     protected GraphicsDevice makeScreenDevice(int screennum) {
-        return new Win32GraphicsDevice(screennum);
+        GraphicsDevice device = null;
+        if (WindowsFlags.isD3DEnabled()) {
+            device = D3DGraphicsDevice.createDevice(screennum);
+        }
+        if (device == null) {
+            device = new Win32GraphicsDevice(screennum);
+        }
+        return device;
     }
 
     // Implements SunGraphicsEnvironment.createFontConfiguration.
@@ -334,4 +343,39 @@
 
         return new WFontConfiguration(this, preferLocaleFonts,preferPropFonts);
     }
+
+    @Override
+    public boolean isFlipStrategyPreferred(ComponentPeer peer) {
+        GraphicsConfiguration gc;
+        if (peer != null && (gc = peer.getGraphicsConfiguration()) != null) {
+            GraphicsDevice gd = gc.getDevice();
+            if (gd instanceof D3DGraphicsDevice) {
+                return ((D3DGraphicsDevice)gd).isD3DEnabledOnDevice();
+            }
+        }
+        return false;
+    }
+
+    private static volatile boolean isDWMCompositionEnabled;
+    /**
+     * Returns true if dwm composition is currently enabled, false otherwise.
+     *
+     * @return true if dwm composition is enabled, false otherwise
+     */
+    public static boolean isDWMCompositionEnabled() {
+        return isDWMCompositionEnabled;
+    }
+
+    /**
+     * Called from the native code when DWM composition state changed.
+     * May be called multiple times during the lifetime of the application.
+     * REMIND: we may want to create a listener mechanism for this.
+     *
+     * Note: called on the Toolkit thread, no user code or locks are allowed.
+     *
+     * @param enabled indicates the state of dwm composition
+     */
+    private static void dwmCompositionChanged(boolean enabled) {
+        isDWMCompositionEnabled = enabled;
+    }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/awt/windows/WComponentPeer.java openjdk/jdk/src/windows/classes/sun/awt/windows/WComponentPeer.java
--- openjdk.orig/jdk/src/windows/classes/sun/awt/windows/WComponentPeer.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/windows/WComponentPeer.java	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -40,8 +40,10 @@
 import java.awt.event.KeyEvent;
 import sun.awt.Win32GraphicsConfig;
 import sun.java2d.InvalidPipeException;
-import sun.java2d.SunGraphics2D;
 import sun.java2d.SurfaceData;
+import sun.java2d.d3d.D3DScreenUpdateManager;
+import static sun.java2d.d3d.D3DSurfaceData.*;
+import sun.java2d.ScreenUpdateManager;
 import sun.java2d.opengl.OGLSurfaceData;
 import sun.awt.DisplayChangedListener;
 import sun.awt.PaintEventDispatcher;
@@ -51,7 +53,6 @@
 import java.awt.dnd.peer.DropTargetPeer;
 import sun.awt.ComponentAccessor;
 
-import java.util.logging.*;
 
 import java.util.logging.*;
 
@@ -87,6 +88,7 @@
     int     oldHeight = -1;
     private int numBackBuffers = 0;
     private VolatileImage backBuffer = null;
+    private BufferCapabilities backBufferCaps = null;
 
     // foreground, background and color are cached to avoid calling back
     // into the Component.
@@ -191,10 +193,12 @@
                 cont.invalidate();
                 cont.validate();
 
-                if (surfaceData instanceof OGLSurfaceData) {
-                    // 6290245: When OGL is enabled, it is necessary to
+                if (surfaceData instanceof D3DWindowSurfaceData ||
+                    surfaceData instanceof OGLSurfaceData)
+                {
+                    // When OGL or D3D is enabled, it is necessary to
                     // replace the SurfaceData for each dynamic layout
-                    // request so that the OGL viewport stays in sync
+                    // request so that the viewport stays in sync
                     // with the window bounds.
                     try {
                         replaceSurfaceData();
@@ -377,7 +381,7 @@
      * just call that version with our current numBackBuffers.
      */
     public void replaceSurfaceData() {
-        replaceSurfaceData(this.numBackBuffers);
+        replaceSurfaceData(this.numBackBuffers, this.backBufferCaps);
     }
 
     /**
@@ -386,35 +390,51 @@
      * order, but also needs to perform additional functions inside the
      * locks.
      */
-    public void replaceSurfaceData(int newNumBackBuffers) {
+    public void replaceSurfaceData(int newNumBackBuffers,
+                                   BufferCapabilities caps)
+    {
+        SurfaceData oldData = null;
+        VolatileImage oldBB = null;
         synchronized(((Component)target).getTreeLock()) {
             synchronized(this) {
                 if (pData == 0) {
                     return;
                 }
                 numBackBuffers = newNumBackBuffers;
-                SurfaceData oldData = surfaceData;
                 Win32GraphicsConfig gc =
-                    (Win32GraphicsConfig)getGraphicsConfiguration();
-                surfaceData = gc.createSurfaceData(this, numBackBuffers);
+                        (Win32GraphicsConfig)getGraphicsConfiguration();
+                ScreenUpdateManager mgr = ScreenUpdateManager.getInstance();
+                oldData = surfaceData;
+                mgr.dropScreenSurface(oldData);
+                surfaceData =
+                    mgr.createScreenSurface(gc, this, numBackBuffers, true);
                 if (oldData != null) {
                     oldData.invalidate();
-                    // null out the old data to make it collected faster
-                    oldData = null;
-                }
-
-                if (backBuffer != null) {
-                    // this will remove the back buffer from the
-                    // display change notification list
-                    backBuffer.flush();
-                    backBuffer = null;
                 }
 
+                oldBB = backBuffer;
                 if (numBackBuffers > 0) {
+                    // set the caps first, they're used when creating the bb
+                    backBufferCaps = caps;
                     backBuffer = gc.createBackBuffer(this);
+                } else if (backBuffer != null) {
+                    backBufferCaps = null;
+                    backBuffer = null;
                 }
             }
         }
+        // it would be better to do this before we create new ones,
+        // but then we'd run into deadlock issues
+        if (oldData != null) {
+            oldData.flush();
+            // null out the old data to make it collected faster
+            oldData = null;
+        }
+        if (oldBB != null) {
+            oldBB.flush();
+            // null out the old data to make it collected faster
+            oldData = null;
+        }
     }
 
     public void replaceSurfaceDataLater() {
@@ -518,7 +538,10 @@
             if (font == null) {
                 font = defaultFont;
             }
-            return new SunGraphics2D(surfaceData, fgColor, bgColor, font);
+            ScreenUpdateManager mgr =
+                ScreenUpdateManager.getInstance();
+            return mgr.createGraphics(surfaceData, this, fgColor,
+                                      bgColor, font);
         }
         return null;
     }
@@ -530,6 +553,7 @@
     protected void disposeImpl() {
         SurfaceData oldData = surfaceData;
         surfaceData = null;
+        ScreenUpdateManager.getInstance().dropScreenSurface(oldData);
         oldData.invalidate();
         // remove from updater before calling targetDisposedPeer
         WToolkit.targetDisposedPeer(target, this);
@@ -546,6 +570,16 @@
         _setBackground(c.getRGB());
     }
 
+    /**
+     * This method is intentionally not synchronized as it is called while
+     * holding other locks.
+     *
+     * @see sun.java2d.d3d.D3DScreenUpdateManager#validate(D3DWindowSurfaceData)
+     */
+    public Color getBackgroundNoSync() {
+        return background;
+    }
+
     public native void _setForeground(int rgb);
     public native void _setBackground(int rgb);
 
@@ -617,8 +651,9 @@
         checkCreation();
         this.winGraphicsConfig =
             (Win32GraphicsConfig)getGraphicsConfiguration();
-        this.surfaceData =
-            winGraphicsConfig.createSurfaceData(this, numBackBuffers);
+        ScreenUpdateManager mgr = ScreenUpdateManager.getInstance();
+        this.surfaceData = mgr.createScreenSurface(winGraphicsConfig, this,
+                                                   numBackBuffers, false);
         initialize();
         start();  // Initialize enable/disable state, turn on callbacks
     }
@@ -793,6 +828,7 @@
      * native windowing system specific actions.
      */
 
+    @Override
     public void createBuffers(int numBuffers, BufferCapabilities caps)
         throws AWTException
     {
@@ -802,39 +838,44 @@
 
         // Re-create the primary surface with the new number of back buffers
         try {
-            replaceSurfaceData(numBuffers - 1);
+            replaceSurfaceData(numBuffers - 1, caps);
         } catch (InvalidPipeException e) {
             throw new AWTException(e.getMessage());
         }
     }
 
-    public synchronized void destroyBuffers() {
-        disposeBackBuffer();
-        numBackBuffers = 0;
-    }
-
-    private synchronized void disposeBackBuffer() {
-        if (backBuffer == null) {
-            return;
-        }
-        backBuffer = null;
+    @Override
+    public void destroyBuffers() {
+        replaceSurfaceData(0, null);
     }
 
-    public synchronized void flip(BufferCapabilities.FlipContents flipAction) {
+    @Override
+    public void flip(int x1, int y1, int x2, int y2,
+                                  BufferCapabilities.FlipContents flipAction)
+    {
+        VolatileImage backBuffer = this.backBuffer;
         if (backBuffer == null) {
             throw new IllegalStateException("Buffers have not been created");
         }
         Win32GraphicsConfig gc =
             (Win32GraphicsConfig)getGraphicsConfiguration();
-        gc.flip(this, (Component)target, backBuffer, flipAction);
+        gc.flip(this, (Component)target, backBuffer, x1, y1, x2, y2, flipAction);
     }
 
+    @Override
     public synchronized Image getBackBuffer() {
+        Image backBuffer = this.backBuffer;
         if (backBuffer == null) {
             throw new IllegalStateException("Buffers have not been created");
         }
         return backBuffer;
     }
+    public BufferCapabilities getBackBufferCaps() {
+        return backBufferCaps;
+    }
+    public int getBackBuffersNum() {
+        return numBackBuffers;
+    }
 
     /* override and return false on components that DO NOT require
        a clearRect() before painting (i.e. native components) */
@@ -866,6 +907,51 @@
                      sun.java2d.pipe.Region region);
 
 
+    // REMIND: Temp workaround for issues with using HW acceleration
+    // in the browser on Vista when DWM is enabled.
+    // @return true if the toplevel container is not an EmbeddedFrame or
+    // if this EmbeddedFrame is acceleration capable, false otherwise
+    private static final boolean isContainingTopLevelAccelCapable(Component c) {
+        while (c != null && !(c instanceof WEmbeddedFrame)) {
+            c = c.getParent();
+        }
+        if (c == null) {
+            return true;
+        }
+        return ((WEmbeddedFramePeer)c.getPeer()).isAccelCapable();
+    }
+
+    /**
+     * Returns whether this component is capable of being hw accelerated.
+     * More specifically, whether rendering to this component or a
+     * BufferStrategy's back-buffer for this component can be hw accelerated.
+     *
+     * Conditions which could prevent hw acceleration include the toplevel
+     * window containing this component being
+     * {@link com.sun.awt.AWTUtilities.Translucency#TRANSLUCENT TRANSLUCENT}.
+     *
+     * @return {@code true} if this component is capable of being hw
+     * accelerated, {@code false} otherwise
+     * @see com.sun.awt.AWTUtilities.Translucency#TRANSLUCENT
+     */
+    public boolean isAccelCapable() {
+        // REMIND: Temp workaround for issues with using HW acceleration
+        // in the browser on Vista when DWM is enabled
+        if (!isContainingTopLevelAccelCapable((Component)target)) {
+            return false;
+        }
+
+        // REMIND: translucent windows support-related
+/*
+        boolean isTranslucent =
+            SunToolkit.isContainingTopLevelTranslucent((Component)target);
+        // D3D/OGL and translucent windows interacted poorly in Windows XP;
+        // these problems are no longer present in Vista
+        return !isTranslucent || Win32GraphicsEnvironment.isVistaOS();
+*/
+        return true;
+    }
+
     /**
      * Applies the shape to the native component window.
      * @since 1.7
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/awt/windows/WEmbeddedFramePeer.java openjdk/jdk/src/windows/classes/sun/awt/windows/WEmbeddedFramePeer.java
--- openjdk.orig/jdk/src/windows/classes/sun/awt/windows/WEmbeddedFramePeer.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/windows/WEmbeddedFramePeer.java	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,6 +30,7 @@
 import java.awt.Rectangle;
 
 import sun.awt.EmbeddedFrame;
+import sun.awt.Win32GraphicsEnvironment;
 
 public class WEmbeddedFramePeer extends WFramePeer {
 
@@ -71,4 +72,13 @@
         // We don't constrain the bounds of the EmbeddedFrames
         return new Rectangle(x, y, width, height);
     }
+
+    @Override
+    public boolean isAccelCapable() {
+        // REMIND: Temp workaround for issues with using HW acceleration
+        // in the browser on Vista when DWM is enabled
+        // Note: isDWMCompositionEnabled is only relevant on Vista, returns
+        // false on other systems.
+        return !Win32GraphicsEnvironment.isDWMCompositionEnabled();
+    }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/awt/windows/WToolkit.java openjdk/jdk/src/windows/classes/sun/awt/windows/WToolkit.java
--- openjdk.orig/jdk/src/windows/classes/sun/awt/windows/WToolkit.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/awt/windows/WToolkit.java	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -40,6 +40,7 @@
 import sun.awt.SunToolkit;
 import sun.awt.Win32GraphicsDevice;
 import sun.awt.Win32GraphicsEnvironment;
+import sun.java2d.d3d.D3DRenderQueue;
 import sun.java2d.opengl.OGLRenderQueue;
 
 import sun.print.PrintJob2D;
@@ -595,6 +596,8 @@
         nativeSync();
         // now flush the OGL pipeline (this is a no-op if OGL is not enabled)
         OGLRenderQueue.sync();
+        // now flush the D3D pipeline (this is a no-op if D3D is not enabled)
+        D3DRenderQueue.sync();
     }
 
     public PrintJob getPrintJob(Frame frame, String doctitle,
@@ -914,8 +917,31 @@
         return toolkit;
     }
 
+    /**
+     * There are two reasons why we don't use buffer per window when
+     * Vista's DWM (aka Aero) is enabled:
+     * - since with DWM all windows are already double-buffered, the application
+     *   doesn't get expose events so we don't get to use our true back-buffer,
+     *   wasting memory and performance (this is valid for both d3d and gdi
+     *   pipelines)
+     * - in some cases with buffer per window enabled it is possible for the
+     *   paint manager to redirect rendering to the screen for some operations
+     *   (like copyArea), and since bpw uses its own BufferStrategy the
+     *   d3d onscreen rendering support is disabled and rendering goes through
+     *   GDI. This doesn't work well with Vista's DWM since one
+     *   can not perform GDI and D3D operations on the same surface
+     *   (see 6630702 for more info)
+     *
+     * Note: even though DWM composition state can change during the lifetime
+     * of the application it is a rare event, and it is more often that it
+     * is temporarily disabled (because of some app) than it is getting
+     * permanently enabled so we can live with this approach without the
+     * complexity of dwm state listeners and such. This can be revisited if
+     * proved otherwise.
+     */
+    @Override
     public boolean useBufferPerWindow() {
-        return true;
+        return !Win32GraphicsEnvironment.isDWMCompositionEnabled();
     }
 
     public void grab(Window w) {
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DBlitLoops.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DBlitLoops.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DBlitLoops.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DBlitLoops.java	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,131 +29,423 @@
 import java.awt.Transparency;
 import java.awt.geom.AffineTransform;
 import java.awt.image.AffineTransformOp;
+import java.awt.image.BufferedImage;
+import java.awt.image.BufferedImageOp;
+import java.lang.ref.WeakReference;
+import sun.java2d.ScreenUpdateManager;
+import sun.java2d.SurfaceData;
+import sun.java2d.loops.Blit;
+import sun.java2d.loops.CompositeType;
 import sun.java2d.loops.GraphicsPrimitive;
 import sun.java2d.loops.GraphicsPrimitiveMgr;
-import sun.java2d.loops.CompositeType;
-import sun.java2d.loops.SurfaceType;
-import sun.java2d.loops.Blit;
 import sun.java2d.loops.ScaledBlit;
+import sun.java2d.loops.SurfaceType;
 import sun.java2d.loops.TransformBlit;
 import sun.java2d.pipe.Region;
-import sun.java2d.SurfaceData;
+import sun.java2d.pipe.RenderBuffer;
+import sun.java2d.pipe.RenderQueue;
+import static sun.java2d.pipe.BufferedOpCodes.*;
+import sun.java2d.windows.GDIWindowSurfaceData;
+
+class D3DBlitLoops {
+
+    static void register() {
+        Blit blitIntArgbPreToSurface =
+            new D3DSwToSurfaceBlit(SurfaceType.IntArgbPre,
+                                   D3DSurfaceData.ST_INT_ARGB_PRE);
+        Blit blitIntArgbPreToTexture =
+            new D3DSwToTextureBlit(SurfaceType.IntArgbPre,
+                                   D3DSurfaceData.ST_INT_ARGB_PRE);
 
-import static sun.java2d.d3d.D3DSurfaceData.*;
+        GraphicsPrimitive[] primitives = {
+            // prevent D3DSurface -> Screen blits
+            new D3DSurfaceToGDIWindowSurfaceBlit(),
+            new D3DSurfaceToGDIWindowSurfaceScale(),
+            new D3DSurfaceToGDIWindowSurfaceTransform(),
+
+            // surface->surface ops
+            new D3DSurfaceToSurfaceBlit(),
+            new D3DSurfaceToSurfaceScale(),
+            new D3DSurfaceToSurfaceTransform(),
+
+            // render-to-texture surface->surface ops
+            new D3DRTTSurfaceToSurfaceBlit(),
+            new D3DRTTSurfaceToSurfaceScale(),
+            new D3DRTTSurfaceToSurfaceTransform(),
+
+            // surface->sw ops
+            new D3DSurfaceToSwBlit(SurfaceType.IntArgb,
+                                   D3DSurfaceData.ST_INT_ARGB),
+
+            // sw->surface ops
+            blitIntArgbPreToSurface,
+            new D3DSwToSurfaceBlit(SurfaceType.IntArgb,
+                                   D3DSurfaceData.ST_INT_ARGB),
+            new D3DSwToSurfaceBlit(SurfaceType.IntRgb,
+                                   D3DSurfaceData.ST_INT_RGB),
+            new D3DSwToSurfaceBlit(SurfaceType.IntBgr,
+                                   D3DSurfaceData.ST_INT_BGR),
+            new D3DSwToSurfaceBlit(SurfaceType.Ushort565Rgb,
+                                   D3DSurfaceData.ST_USHORT_565_RGB),
+            new D3DSwToSurfaceBlit(SurfaceType.Ushort555Rgb,
+                                   D3DSurfaceData.ST_USHORT_555_RGB),
+            new D3DSwToSurfaceBlit(SurfaceType.ByteIndexed,
+                                   D3DSurfaceData.ST_BYTE_INDEXED),
+            // REMIND: we don't have a native sw loop to back this loop up
+//            new D3DSwToSurfaceBlit(SurfaceType.ByteIndexedBm,
+//                                   D3DSurfaceData.ST_BYTE_INDEXED_BM),
+            new D3DGeneralBlit(D3DSurfaceData.D3DSurface,
+                               CompositeType.AnyAlpha,
+                               blitIntArgbPreToSurface),
+
+            new D3DSwToSurfaceScale(SurfaceType.IntArgb,
+                                    D3DSurfaceData.ST_INT_ARGB),
+            new D3DSwToSurfaceScale(SurfaceType.IntArgbPre,
+                                    D3DSurfaceData.ST_INT_ARGB_PRE),
+            new D3DSwToSurfaceScale(SurfaceType.IntRgb,
+                                    D3DSurfaceData.ST_INT_RGB),
+            new D3DSwToSurfaceScale(SurfaceType.IntBgr,
+                                    D3DSurfaceData.ST_INT_BGR),
+            new D3DSwToSurfaceScale(SurfaceType.Ushort565Rgb,
+                                    D3DSurfaceData.ST_USHORT_565_RGB),
+            new D3DSwToSurfaceScale(SurfaceType.Ushort555Rgb,
+                                    D3DSurfaceData.ST_USHORT_555_RGB),
+            new D3DSwToSurfaceScale(SurfaceType.ByteIndexed,
+                                    D3DSurfaceData.ST_BYTE_INDEXED),
+            // REMIND: we don't have a native sw loop to back this loop up
+//            new D3DSwToSurfaceScale(SurfaceType.ByteIndexedBm,
+//                                    D3DSurfaceData.ST_BYTE_INDEXED_BM),
+
+            new D3DSwToSurfaceTransform(SurfaceType.IntArgb,
+                                        D3DSurfaceData.ST_INT_ARGB),
+            new D3DSwToSurfaceTransform(SurfaceType.IntArgbPre,
+                                        D3DSurfaceData.ST_INT_ARGB_PRE),
+            new D3DSwToSurfaceTransform(SurfaceType.IntRgb,
+                                        D3DSurfaceData.ST_INT_RGB),
+            new D3DSwToSurfaceTransform(SurfaceType.IntBgr,
+                                        D3DSurfaceData.ST_INT_BGR),
+            new D3DSwToSurfaceTransform(SurfaceType.Ushort565Rgb,
+                                        D3DSurfaceData.ST_USHORT_565_RGB),
+            new D3DSwToSurfaceTransform(SurfaceType.Ushort555Rgb,
+                                        D3DSurfaceData.ST_USHORT_555_RGB),
+            new D3DSwToSurfaceTransform(SurfaceType.ByteIndexed,
+                                        D3DSurfaceData.ST_BYTE_INDEXED),
+            // REMIND: we don't have a native sw loop to back this loop up
+//            new D3DSwToSurfaceTransform(SurfaceType.ByteIndexedBm,
+//                                        D3DSurfaceData.ST_BYTE_INDEXED_BM),
+
+            // texture->surface ops
+            new D3DTextureToSurfaceBlit(),
+            new D3DTextureToSurfaceScale(),
+            new D3DTextureToSurfaceTransform(),
+
+            // sw->texture ops
+            blitIntArgbPreToTexture,
+            new D3DSwToTextureBlit(SurfaceType.IntRgb,
+                                   D3DSurfaceData.ST_INT_RGB),
+            new D3DSwToTextureBlit(SurfaceType.IntArgb,
+                                   D3DSurfaceData.ST_INT_ARGB),
+            new D3DSwToTextureBlit(SurfaceType.IntBgr,
+                                   D3DSurfaceData.ST_INT_BGR),
+            new D3DSwToTextureBlit(SurfaceType.Ushort565Rgb,
+                                   D3DSurfaceData.ST_USHORT_565_RGB),
+            new D3DSwToTextureBlit(SurfaceType.Ushort555Rgb,
+                                   D3DSurfaceData.ST_USHORT_555_RGB),
+            new D3DSwToTextureBlit(SurfaceType.ByteIndexed,
+                                   D3DSurfaceData.ST_BYTE_INDEXED),
+            // REMIND: we don't have a native sw loop to back this loop up
+//            new D3DSwToTextureBlit(SurfaceType.ByteIndexedBm,
+//                                   D3DSurfaceData.ST_BYTE_INDEXED_BM),
+            new D3DGeneralBlit(D3DSurfaceData.D3DTexture,
+                               CompositeType.SrcNoEa,
+                               blitIntArgbPreToTexture),
+        };
+        GraphicsPrimitiveMgr.register(primitives);
+    }
 
-/**
- * This class contains accelerated blits/scales/transforms
- * between textures and DD surfaces.
- */
-public class D3DBlitLoops {
+    /**
+     * The following offsets are used to pack the parameters in
+     * createPackedParams().  (They are also used at the native level when
+     * unpacking the params.)
+     */
+    private static final int OFFSET_SRCTYPE = 16;
+    private static final int OFFSET_HINT    =  8;
+    private static final int OFFSET_TEXTURE =  3;
+    private static final int OFFSET_RTT     =  2;
+    private static final int OFFSET_XFORM   =  1;
+    private static final int OFFSET_ISOBLIT =  0;
 
-    static void register()
+    /**
+     * Packs the given parameters into a single int value in order to save
+     * space on the rendering queue.
+     */
+    private static int createPackedParams(boolean isoblit, boolean texture,
+                                          boolean rtt, boolean xform,
+                                          int hint, int srctype)
     {
-        GraphicsPrimitive[] primitives = {
-            new D3DTextureToSurfaceBlit(IntRgbD3D),
-            new D3DTextureToSurfaceBlit(Ushort565RgbD3D),
-            new D3DTextureToSurfaceBlit(IntRgbxD3D),
-            new D3DTextureToSurfaceBlit(Ushort555RgbD3D),
-            new D3DTextureToSurfaceBlit(ThreeByteBgrD3D),
-
-            new D3DTextureToSurfaceScale(IntRgbD3D),
-            new D3DTextureToSurfaceScale(Ushort565RgbD3D),
-            new D3DTextureToSurfaceScale(IntRgbxD3D),
-            new D3DTextureToSurfaceScale(Ushort555RgbD3D),
-            new D3DTextureToSurfaceScale(ThreeByteBgrD3D),
-
-            new D3DTextureToSurfaceTransform(D3DTexture, IntRgbD3D),
-            new D3DTextureToSurfaceTransform(D3DTexture, Ushort565RgbD3D),
-            new D3DTextureToSurfaceTransform(D3DTexture, IntRgbxD3D),
-            new D3DTextureToSurfaceTransform(D3DTexture, Ushort555RgbD3D),
-            new D3DTextureToSurfaceTransform(D3DTexture, ThreeByteBgrD3D),
+        return
+            ((srctype           << OFFSET_SRCTYPE) |
+             (hint              << OFFSET_HINT   ) |
+             ((texture ? 1 : 0) << OFFSET_TEXTURE) |
+             ((rtt     ? 1 : 0) << OFFSET_RTT    ) |
+             ((xform   ? 1 : 0) << OFFSET_XFORM  ) |
+             ((isoblit ? 1 : 0) << OFFSET_ISOBLIT));
+    }
 
-            new DelegateSwToTextureLoop(),
+    /**
+     * Enqueues a BLIT operation with the given parameters.  Note that the
+     * RenderQueue lock must be held before calling this method.
+     */
+    private static void enqueueBlit(RenderQueue rq,
+                                    SurfaceData src, SurfaceData dst,
+                                    int packedParams,
+                                    int sx1, int sy1,
+                                    int sx2, int sy2,
+                                    double dx1, double dy1,
+                                    double dx2, double dy2)
+    {
+        // assert rq.lock.isHeldByCurrentThread();
+        RenderBuffer buf = rq.getBuffer();
+        rq.ensureCapacityAndAlignment(72, 24);
+        buf.putInt(BLIT);
+        buf.putInt(packedParams);
+        buf.putInt(sx1).putInt(sy1);
+        buf.putInt(sx2).putInt(sy2);
+        buf.putDouble(dx1).putDouble(dy1);
+        buf.putDouble(dx2).putDouble(dy2);
+        buf.putLong(src.getNativeOps());
+        buf.putLong(dst.getNativeOps());
+    }
 
-        };
-        GraphicsPrimitiveMgr.register(primitives);
+    static void Blit(SurfaceData srcData, SurfaceData dstData,
+                     Composite comp, Region clip,
+                     AffineTransform xform, int hint,
+                     int sx1, int sy1,
+                     int sx2, int sy2,
+                     double dx1, double dy1,
+                     double dx2, double dy2,
+                     int srctype, boolean texture)
+    {
+        int ctxflags = 0;
+        if (srcData.getTransparency() == Transparency.OPAQUE) {
+            ctxflags |= D3DContext.SRC_IS_OPAQUE;
+        }
+
+        D3DSurfaceData d3dDst = (D3DSurfaceData)dstData;
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            // make sure the RenderQueue keeps a hard reference to the
+            // source (sysmem) SurfaceData to prevent it from being
+            // disposed while the operation is processed on the QFT
+            rq.addReference(srcData);
+
+            if (texture) {
+                // make sure we have a current context before uploading
+                // the sysmem data to the texture object
+                D3DContext.setScratchSurface(d3dDst.getContext());
+            } else {
+                D3DContext.validateContext(d3dDst, d3dDst,
+                                           clip, comp, xform, null, null,
+                                           ctxflags);
+            }
+
+            int packedParams = createPackedParams(false, texture,
+                                                  false, xform != null,
+                                                  hint, srctype);
+            enqueueBlit(rq, srcData, dstData,
+                        packedParams,
+                        sx1, sy1, sx2, sy2,
+                        dx1, dy1, dx2, dy2);
+
+            // always flush immediately, since we (currently) have no means
+            // of tracking changes to the system memory surface
+            rq.flushNow();
+        } finally {
+            rq.unlock();
+        }
+
+        if (d3dDst.getType() == D3DSurfaceData.WINDOW) {
+            // flush immediately when copying to the screen to improve
+            // responsiveness of applications using VI or BI backbuffers
+            D3DScreenUpdateManager mgr =
+                (D3DScreenUpdateManager)ScreenUpdateManager.getInstance();
+            mgr.runUpdateNow();
+        }
     }
-    static native void doTransform(long pSrc, long pDst, long pCtx,
-                                   int hint,
-                                   int sx1, int sy1, int sx2, int sy2,
-                                   float dx1, float dy1,
-                                   float dx2, float dy2);
-
-    static long getContext(SurfaceData src, SurfaceData dst,
-                           Region clip, Composite comp, AffineTransform at)
-    {
-        int ctxFlags;
-        if (src.getTransparency() == Transparency.OPAQUE) {
-            ctxFlags = D3DContext.SRC_IS_OPAQUE;
-        } else {
-            ctxFlags = D3DContext.NO_CONTEXT_FLAGS;
+
+    /**
+     * Note: The srcImg and biop parameters are only used when invoked
+     * from the D3DBufImgOps.renderImageWithOp() method; in all other cases,
+     * this method can be called with null values for those two parameters,
+     * and they will be effectively ignored.
+     */
+    static void IsoBlit(SurfaceData srcData, SurfaceData dstData,
+                        BufferedImage srcImg, BufferedImageOp biop,
+                        Composite comp, Region clip,
+                        AffineTransform xform, int hint,
+                        int sx1, int sy1,
+                        int sx2, int sy2,
+                        double dx1, double dy1,
+                        double dx2, double dy2,
+                        boolean texture)
+    {
+        int ctxflags = 0;
+        if (srcData.getTransparency() == Transparency.OPAQUE) {
+            ctxflags |= D3DContext.SRC_IS_OPAQUE;
+        }
+
+        D3DSurfaceData d3dDst = (D3DSurfaceData)dstData;
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        boolean rtt = false;
+        rq.lock();
+        try {
+            D3DSurfaceData d3dSrc = (D3DSurfaceData)srcData;
+            int srctype = d3dSrc.getType();
+            D3DSurfaceData srcCtxData = d3dSrc;
+            if (srctype == D3DSurfaceData.TEXTURE) {
+                rtt = false;
+            } else {
+                // the source is a backbuffer, or render-to-texture
+                // surface; we set rtt to true to differentiate this kind
+                // of surface from a regular texture object
+                rtt = true;
+            }
+
+            D3DContext.validateContext(srcCtxData, d3dDst,
+                                       clip, comp, xform, null, null,
+                                       ctxflags);
+
+            if (biop != null) {
+                D3DBufImgOps.enableBufImgOp(rq, d3dSrc, srcImg, biop);
+            }
+
+            int packedParams = createPackedParams(true, texture,
+                                                  rtt, xform != null,
+                                                  hint, 0 /*unused*/);
+            enqueueBlit(rq, srcData, dstData,
+                        packedParams,
+                        sx1, sy1, sx2, sy2,
+                        dx1, dy1, dx2, dy2);
+
+            if (biop != null) {
+                D3DBufImgOps.disableBufImgOp(rq, biop);
+            }
+        } finally {
+            rq.unlock();
         }
 
-        return D3DContext.getContext(src, dst, clip, comp, at,
-                                     0xffffffff /* rgb */, ctxFlags);
+        if (rtt && (d3dDst.getType() == D3DSurfaceData.WINDOW)) {
+            // we only have to flush immediately when copying from a
+            // (non-texture) surface to the screen; otherwise Swing apps
+            // might appear unresponsive until the auto-flush completes
+            D3DScreenUpdateManager mgr =
+                (D3DScreenUpdateManager)ScreenUpdateManager.getInstance();
+            mgr.runUpdateNow();
+        }
     }
 }
 
-class D3DTextureToSurfaceBlit extends Blit {
-    D3DTextureToSurfaceBlit(SurfaceType dstType) {
-        super(D3DTexture, CompositeType.AnyAlpha , dstType);
+class D3DSurfaceToSurfaceBlit extends Blit {
+
+    D3DSurfaceToSurfaceBlit() {
+        super(D3DSurfaceData.D3DSurface,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
     }
 
-    /**
-     * Blit
-     * This native method is where all of the work happens in the
-     * accelerated Blit.
-     */
-    @Override
     public void Blit(SurfaceData src, SurfaceData dst,
                      Composite comp, Region clip,
                      int sx, int sy, int dx, int dy, int w, int h)
     {
-        synchronized (D3DContext.LOCK) {
-            long pCtx = D3DBlitLoops.getContext(src, dst, clip, comp, null);
-            D3DBlitLoops.doTransform(src.getNativeOps(), dst.getNativeOps(),
-                                     pCtx,
-                                     AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
-                                     sx, sy, sx+w, sy+h,
-                                     (float)dx, (float)dy,
-                                     (float)(dx+w), (float)(dy+h));
-        }
+        D3DBlitLoops.IsoBlit(src, dst,
+                             null, null,
+                             comp, clip, null,
+                             AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
+                             sx, sy, sx+w, sy+h,
+                             dx, dy, dx+w, dy+h,
+                             false);
     }
 }
 
-class D3DTextureToSurfaceTransform extends TransformBlit {
+class D3DSurfaceToSurfaceScale extends ScaledBlit {
 
-    D3DTextureToSurfaceTransform(SurfaceType srcType,
-                                 SurfaceType dstType)
+    D3DSurfaceToSurfaceScale() {
+        super(D3DSurfaceData.D3DSurface,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
+    }
+
+    public void Scale(SurfaceData src, SurfaceData dst,
+                      Composite comp, Region clip,
+                      int sx1, int sy1,
+                      int sx2, int sy2,
+                      double dx1, double dy1,
+                      double dx2, double dy2)
     {
-        super(srcType, CompositeType.AnyAlpha, dstType);
+        D3DBlitLoops.IsoBlit(src, dst,
+                             null, null,
+                             comp, clip, null,
+                             AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
+                             sx1, sy1, sx2, sy2,
+                             dx1, dy1, dx2, dy2,
+                             false);
+    }
+}
+
+class D3DSurfaceToSurfaceTransform extends TransformBlit {
+
+    D3DSurfaceToSurfaceTransform() {
+        super(D3DSurfaceData.D3DSurface,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
     }
 
-    @Override
     public void Transform(SurfaceData src, SurfaceData dst,
                           Composite comp, Region clip,
                           AffineTransform at, int hint,
                           int sx, int sy, int dx, int dy,
                           int w, int h)
     {
-        synchronized (D3DContext.LOCK) {
-            long pCtx = D3DBlitLoops.getContext(src, dst, clip, comp, at);
-            D3DBlitLoops.doTransform(src.getNativeOps(), dst.getNativeOps(),
-                                     pCtx, hint,
-                                     sx, sy, sx+w, sy+h,
-                                     (float)dx, (float)dy,
-                                     (float)(dx+w), (float)(dy+h));
-        }
+        D3DBlitLoops.IsoBlit(src, dst,
+                             null, null,
+                             comp, clip, at, hint,
+                             sx, sy, sx+w, sy+h,
+                             dx, dy, dx+w, dy+h,
+                             false);
     }
 }
 
-class D3DTextureToSurfaceScale extends ScaledBlit {
+class D3DRTTSurfaceToSurfaceBlit extends Blit {
 
-    D3DTextureToSurfaceScale(SurfaceType dstType) {
-        super(D3DTexture, CompositeType.AnyAlpha, dstType);
+    D3DRTTSurfaceToSurfaceBlit() {
+        super(D3DSurfaceData.D3DSurfaceRTT,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
+    }
+
+    public void Blit(SurfaceData src, SurfaceData dst,
+                     Composite comp, Region clip,
+                     int sx, int sy, int dx, int dy, int w, int h)
+    {
+        D3DBlitLoops.IsoBlit(src, dst,
+                             null, null,
+                             comp, clip, null,
+                             AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
+                             sx, sy, sx+w, sy+h,
+                             dx, dy, dx+w, dy+h,
+                             true);
+    }
+}
+
+class D3DRTTSurfaceToSurfaceScale extends ScaledBlit {
+
+    D3DRTTSurfaceToSurfaceScale() {
+        super(D3DSurfaceData.D3DSurfaceRTT,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
     }
 
-    @Override
     public void Scale(SurfaceData src, SurfaceData dst,
                       Composite comp, Region clip,
                       int sx1, int sy1,
@@ -161,65 +453,381 @@
                       double dx1, double dy1,
                       double dx2, double dy2)
     {
-        synchronized (D3DContext.LOCK) {
-            long pCtx = D3DBlitLoops.getContext(src, dst, clip, comp, null);
-            D3DBlitLoops.doTransform(src.getNativeOps(), dst.getNativeOps(),
-                                     pCtx,
-                                     AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
-                                     sx1, sy1, sx2, sy2,
-                                     (float)dx1, (float)dy1,
-                                     (float)dx2, (float)dy2);
+        D3DBlitLoops.IsoBlit(src, dst,
+                             null, null,
+                             comp, clip, null,
+                             AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
+                             sx1, sy1, sx2, sy2,
+                             dx1, dy1, dx2, dy2,
+                             true);
+    }
+}
+
+class D3DRTTSurfaceToSurfaceTransform extends TransformBlit {
+
+    D3DRTTSurfaceToSurfaceTransform() {
+        super(D3DSurfaceData.D3DSurfaceRTT,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
+    }
+
+    public void Transform(SurfaceData src, SurfaceData dst,
+                          Composite comp, Region clip,
+                          AffineTransform at, int hint,
+                          int sx, int sy, int dx, int dy, int w, int h)
+    {
+        D3DBlitLoops.IsoBlit(src, dst,
+                             null, null,
+                             comp, clip, at, hint,
+                             sx, sy, sx+w, sy+h,
+                             dx, dy, dx+w, dy+h,
+                             true);
+    }
+}
+
+class D3DSurfaceToSwBlit extends Blit {
+
+    private int typeval;
+
+    // REMIND: destination will actually be opaque/premultiplied...
+    D3DSurfaceToSwBlit(SurfaceType dstType, int typeval) {
+        super(D3DSurfaceData.D3DSurface,
+              CompositeType.SrcNoEa,
+              dstType);
+        this.typeval = typeval;
+    }
+
+    public void Blit(SurfaceData src, SurfaceData dst,
+                     Composite comp, Region clip,
+                     int sx, int sy, int dx, int dy,
+                     int w, int h)
+    {
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            // make sure the RenderQueue keeps a hard reference to the
+            // destination (sysmem) SurfaceData to prevent it from being
+            // disposed while the operation is processed on the QFT
+            rq.addReference(dst);
+
+            RenderBuffer buf = rq.getBuffer();
+            D3DContext.setScratchSurface(((D3DSurfaceData)src).getContext());
+
+            rq.ensureCapacityAndAlignment(48, 32);
+            buf.putInt(SURFACE_TO_SW_BLIT);
+            buf.putInt(sx).putInt(sy);
+            buf.putInt(dx).putInt(dy);
+            buf.putInt(w).putInt(h);
+            buf.putInt(typeval);
+            buf.putLong(src.getNativeOps());
+            buf.putLong(dst.getNativeOps());
+
+            // always flush immediately
+            rq.flushNow();
+        } finally {
+            rq.unlock();
         }
     }
 }
 
-class DelegateSwToTextureLoop extends Blit {
+class D3DSwToSurfaceBlit extends Blit {
+
+    private int typeval;
 
-    DelegateSwToTextureLoop() {
-        super(SurfaceType.Any, CompositeType.SrcNoEa, D3DTexture);
+    D3DSwToSurfaceBlit(SurfaceType srcType, int typeval) {
+        super(srcType,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
+        this.typeval = typeval;
     }
 
-    @Override
     public void Blit(SurfaceData src, SurfaceData dst,
                      Composite comp, Region clip,
                      int sx, int sy, int dx, int dy, int w, int h)
     {
-        Blit realBlit = null;
-        int pf = ((D3DSurfaceData)dst).getPixelFormat();
-        switch (pf) {
-        case PF_INT_ARGB:
-            realBlit = Blit.getFromCache(src.getSurfaceType(),
-                                         CompositeType.SrcNoEa,
-                                         SurfaceType.IntArgbPre);
-            break;
-        case PF_INT_RGB:
-            realBlit = Blit.getFromCache(src.getSurfaceType(),
-                                         CompositeType.SrcNoEa,
-                                         SurfaceType.IntRgb);
-            break;
-        case PF_USHORT_565_RGB:
-            realBlit = Blit.getFromCache(src.getSurfaceType(),
-                                         CompositeType.SrcNoEa,
-                                         SurfaceType.Ushort565Rgb);
-            break;
-        case PF_USHORT_555_RGB:
-            realBlit = Blit.getFromCache(src.getSurfaceType(),
-                                         CompositeType.SrcNoEa,
-                                         SurfaceType.Ushort555Rgb);
-            break;
-        case PF_USHORT_4444_ARGB:
-            // REMIND: this should really be premultiplied!
-            realBlit = Blit.getFromCache(src.getSurfaceType(),
-                                         CompositeType.SrcNoEa,
-                                         SurfaceType.Ushort4444Argb);
-            break;
-        default:
-             throw
-                 new InternalError("Can't yet handle dest pixel format: "+pf);
+        D3DBlitLoops.Blit(src, dst,
+                          comp, clip, null,
+                          AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
+                          sx, sy, sx+w, sy+h,
+                          dx, dy, dx+w, dy+h,
+                          typeval, false);
+    }
+}
+
+class D3DSwToSurfaceScale extends ScaledBlit {
+
+    private int typeval;
+
+    D3DSwToSurfaceScale(SurfaceType srcType, int typeval) {
+        super(srcType,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
+        this.typeval = typeval;
+    }
+
+    public void Scale(SurfaceData src, SurfaceData dst,
+                      Composite comp, Region clip,
+                      int sx1, int sy1,
+                      int sx2, int sy2,
+                      double dx1, double dy1,
+                      double dx2, double dy2)
+    {
+        D3DBlitLoops.Blit(src, dst,
+                          comp, clip, null,
+                          AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
+                          sx1, sy1, sx2, sy2,
+                          dx1, dy1, dx2, dy2,
+                          typeval, false);
+    }
+}
+
+class D3DSwToSurfaceTransform extends TransformBlit {
+
+    private int typeval;
+
+    D3DSwToSurfaceTransform(SurfaceType srcType, int typeval) {
+        super(srcType,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
+        this.typeval = typeval;
+    }
+
+    public void Transform(SurfaceData src, SurfaceData dst,
+                          Composite comp, Region clip,
+                          AffineTransform at, int hint,
+                          int sx, int sy, int dx, int dy, int w, int h)
+    {
+        D3DBlitLoops.Blit(src, dst,
+                          comp, clip, at, hint,
+                          sx, sy, sx+w, sy+h,
+                          dx, dy, dx+w, dy+h,
+                          typeval, false);
+    }
+}
+
+class D3DSwToTextureBlit extends Blit {
+
+    private int typeval;
+
+    D3DSwToTextureBlit(SurfaceType srcType, int typeval) {
+        super(srcType,
+              CompositeType.SrcNoEa,
+              D3DSurfaceData.D3DTexture);
+        this.typeval = typeval;
+    }
+
+    public void Blit(SurfaceData src, SurfaceData dst,
+                     Composite comp, Region clip,
+                     int sx, int sy, int dx, int dy, int w, int h)
+    {
+        D3DBlitLoops.Blit(src, dst,
+                          comp, clip, null,
+                          AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
+                          sx, sy, sx+w, sy+h,
+                          dx, dy, dx+w, dy+h,
+                          typeval, true);
+    }
+}
+
+class D3DTextureToSurfaceBlit extends Blit {
+
+    D3DTextureToSurfaceBlit() {
+        super(D3DSurfaceData.D3DTexture,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
+    }
+
+    public void Blit(SurfaceData src, SurfaceData dst,
+                     Composite comp, Region clip,
+                     int sx, int sy, int dx, int dy, int w, int h)
+    {
+        D3DBlitLoops.IsoBlit(src, dst,
+                             null, null,
+                             comp, clip, null,
+                             AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
+                             sx, sy, sx+w, sy+h,
+                             dx, dy, dx+w, dy+h,
+                             true);
+    }
+}
+
+class D3DTextureToSurfaceScale extends ScaledBlit {
+
+    D3DTextureToSurfaceScale() {
+        super(D3DSurfaceData.D3DTexture,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
+    }
+
+    public void Scale(SurfaceData src, SurfaceData dst,
+                      Composite comp, Region clip,
+                      int sx1, int sy1,
+                      int sx2, int sy2,
+                      double dx1, double dy1,
+                      double dx2, double dy2)
+    {
+        D3DBlitLoops.IsoBlit(src, dst,
+                             null, null,
+                             comp, clip, null,
+                             AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
+                             sx1, sy1, sx2, sy2,
+                             dx1, dy1, dx2, dy2,
+                             true);
+    }
+}
+
+class D3DTextureToSurfaceTransform extends TransformBlit {
+
+    D3DTextureToSurfaceTransform() {
+        super(D3DSurfaceData.D3DTexture,
+              CompositeType.AnyAlpha,
+              D3DSurfaceData.D3DSurface);
+    }
+
+    public void Transform(SurfaceData src, SurfaceData dst,
+                          Composite comp, Region clip,
+                          AffineTransform at, int hint,
+                          int sx, int sy, int dx, int dy,
+                          int w, int h)
+    {
+        D3DBlitLoops.IsoBlit(src, dst,
+                             null, null,
+                             comp, clip, at, hint,
+                             sx, sy, sx+w, sy+h,
+                             dx, dy, dx+w, dy+h,
+                             true);
+    }
+}
+
+/**
+ * This general Blit implemenation converts any source surface to an
+ * intermediate IntArgbPre surface, and then uses the more specific
+ * IntArgbPre->D3DSurface/Texture loop to get the intermediate
+ * (premultiplied) surface down to D3D.
+ */
+class D3DGeneralBlit extends Blit {
+
+    private Blit performop;
+    private WeakReference srcTmp;
+
+    D3DGeneralBlit(SurfaceType dstType,
+                   CompositeType compType,
+                   Blit performop)
+    {
+        super(SurfaceType.Any, compType, dstType);
+        this.performop = performop;
+    }
+
+    public synchronized void Blit(SurfaceData src, SurfaceData dst,
+                                  Composite comp, Region clip,
+                                  int sx, int sy, int dx, int dy,
+                                  int w, int h)
+    {
+        Blit convertsrc = Blit.getFromCache(src.getSurfaceType(),
+                                            CompositeType.SrcNoEa,
+                                            SurfaceType.IntArgbPre);
+
+        SurfaceData cachedSrc = null;
+        if (srcTmp != null) {
+            // use cached intermediate surface, if available
+            cachedSrc = (SurfaceData)srcTmp.get();
         }
 
-        if (realBlit != null) {
-            realBlit.Blit(src, dst, comp, clip, sx, sy, dx, dy, w, h);
+        // convert source to IntArgbPre
+        src = convertFrom(convertsrc, src, sx, sy, w, h,
+                          cachedSrc, BufferedImage.TYPE_INT_ARGB_PRE);
+
+        // copy IntArgbPre intermediate surface to D3D surface
+        performop.Blit(src, dst, comp, clip,
+                       0, 0, dx, dy, w, h);
+
+        if (src != cachedSrc) {
+            // cache the intermediate surface
+            srcTmp = new WeakReference(src);
         }
     }
 }
+
+/*
+ * The following classes prohibit copying D3DSurfaces to the screen
+ * (the D3D->sysmem->GDI path is known to be very very slow).
+ *
+ * Note: we used to disable hw acceleration for the surafce manager associated
+ * with the source surface in these loops but it proved to be too cautious.
+ *
+ * In most cases d3d->screen copy happens only during some transitional
+ * period where the accelerated destination surface is being recreated or
+ * restored (for example, when Swing's backbuffer VI is copied to the screen
+ * but the D3DScreenSurfaceManager couldn't restore its surface).
+ *
+ * An exception is if for some reason we could not enable accelerated on-screen
+ * rendering for this window for some permanent reason (like window being too
+ * small, or a present BufferStrategy).
+ *
+ * This meant that we'd disable hw acceleration after the first failure
+ * completely (at least until the src image is recreated which in case of
+ * Swing back-buffer happens only after resize).
+ *
+ * Now we delegate to the VISM to figure out if the acceleration needs to
+ * be disabled or if we can wait for a while until the onscreen accelerated
+ * can resume (by marking the source surface lost and making sure the
+ * VISM has a chance to use the backup surface).
+ *
+ */
+
+class D3DSurfaceToGDIWindowSurfaceBlit extends Blit {
+
+    D3DSurfaceToGDIWindowSurfaceBlit() {
+        super(D3DSurfaceData.D3DSurface,
+              CompositeType.AnyAlpha,
+              GDIWindowSurfaceData.AnyGdi);
+    }
+    @Override
+    public void Blit(SurfaceData src, SurfaceData dst,
+                     Composite comp, Region clip,
+                     int sx, int sy, int dx, int dy, int w, int h)
+    {
+        // see comment above
+        D3DVolatileSurfaceManager.handleVItoScreenOp(src, dst);
+    }
+
+}
+
+class D3DSurfaceToGDIWindowSurfaceScale extends ScaledBlit {
+
+    D3DSurfaceToGDIWindowSurfaceScale() {
+        super(D3DSurfaceData.D3DSurface,
+              CompositeType.AnyAlpha,
+              GDIWindowSurfaceData.AnyGdi);
+    }
+    @Override
+    public void Scale(SurfaceData src, SurfaceData dst,
+                      Composite comp, Region clip,
+                      int sx1, int sy1,
+                      int sx2, int sy2,
+                      double dx1, double dy1,
+                      double dx2, double dy2)
+    {
+        // see comment above
+        D3DVolatileSurfaceManager.handleVItoScreenOp(src, dst);
+    }
+}
+
+class D3DSurfaceToGDIWindowSurfaceTransform extends TransformBlit {
+
+    D3DSurfaceToGDIWindowSurfaceTransform() {
+        super(D3DSurfaceData.D3DSurface,
+              CompositeType.AnyAlpha,
+              GDIWindowSurfaceData.AnyGdi);
+    }
+    @Override
+    public void Transform(SurfaceData src, SurfaceData dst,
+                          Composite comp, Region clip,
+                          AffineTransform at, int hint,
+                          int sx, int sy, int dx, int dy,
+                          int w, int h)
+    {
+        // see comment above
+        D3DVolatileSurfaceManager.handleVItoScreenOp(src, dst);
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DBufImgOps.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DBufImgOps.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DBufImgOps.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DBufImgOps.java	2011-01-08 01:26:50.463202123 +0000
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.d3d;
+
+import java.awt.image.AffineTransformOp;
+import java.awt.image.BufferedImage;
+import java.awt.image.BufferedImageOp;
+import java.awt.image.ConvolveOp;
+import java.awt.image.LookupOp;
+import java.awt.image.RescaleOp;
+import sun.java2d.SunGraphics2D;
+import sun.java2d.SurfaceData;
+import sun.java2d.loops.CompositeType;
+import sun.java2d.pipe.BufferedBufImgOps;
+import static sun.java2d.d3d.D3DContext.D3DContextCaps.*;
+
+class D3DBufImgOps extends BufferedBufImgOps {
+
+    /**
+     * This method is called from D3DDrawImage.transformImage() only.  It
+     * validates the provided BufferedImageOp to determine whether the op
+     * is one that can be accelerated by the D3D pipeline.  If the operation
+     * cannot be completed for any reason, this method returns false;
+     * otherwise, the given BufferedImage is rendered to the destination
+     * using the provided BufferedImageOp and this method returns true.
+     */
+    static boolean renderImageWithOp(SunGraphics2D sg, BufferedImage img,
+                                     BufferedImageOp biop, int x, int y)
+    {
+        // Validate the provided BufferedImage (make sure it is one that
+        // is supported, and that its properties are acceleratable)
+        if (biop instanceof ConvolveOp) {
+            if (!isConvolveOpValid((ConvolveOp)biop)) {
+                return false;
+            }
+        } else if (biop instanceof RescaleOp) {
+            if (!isRescaleOpValid((RescaleOp)biop, img)) {
+                return false;
+            }
+        } else if (biop instanceof LookupOp) {
+            if (!isLookupOpValid((LookupOp)biop, img)) {
+                return false;
+            }
+        } else {
+            // No acceleration for other BufferedImageOps (yet)
+            return false;
+        }
+
+        SurfaceData dstData = sg.surfaceData;
+        if (!(dstData instanceof D3DSurfaceData) ||
+            (sg.interpolationType == AffineTransformOp.TYPE_BICUBIC) ||
+            (sg.compositeState > SunGraphics2D.COMP_ALPHA))
+        {
+            return false;
+        }
+
+        SurfaceData srcData =
+            dstData.getSourceSurfaceData(img, sg.TRANSFORM_ISIDENT,
+                                         CompositeType.SrcOver, null);
+        if (!(srcData instanceof D3DSurfaceData)) {
+            // REMIND: this hack tries to ensure that we have a cached texture
+            srcData =
+                dstData.getSourceSurfaceData(img, sg.TRANSFORM_ISIDENT,
+                                             CompositeType.SrcOver, null);
+            if (!(srcData instanceof D3DSurfaceData)) {
+                return false;
+            }
+        }
+
+        // Verify that the source surface is actually a texture and that
+        // shaders are supported
+        D3DSurfaceData d3dSrc = (D3DSurfaceData)srcData;
+        D3DGraphicsDevice gd =
+            (D3DGraphicsDevice)d3dSrc.getDeviceConfiguration().getDevice();
+        if (d3dSrc.getType() != D3DSurfaceData.TEXTURE ||
+            !gd.isCapPresent(CAPS_LCD_SHADER))
+        {
+            return false;
+        }
+
+        int sw = img.getWidth();
+        int sh = img.getHeight();
+        D3DBlitLoops.IsoBlit(srcData, dstData,
+                             img, biop,
+                             sg.composite, sg.getCompClip(),
+                             sg.transform, sg.interpolationType,
+                             0, 0, sw, sh,
+                             x, y, x+sw, y+sh,
+                             true);
+
+        return true;
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DContext.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DContext.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DContext.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DContext.java	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,392 +25,165 @@
 
 package sun.java2d.d3d;
 
-import java.awt.AlphaComposite;
-import java.awt.Composite;
-import java.awt.GraphicsEnvironment;
-import java.awt.geom.AffineTransform;
-import sun.awt.Win32GraphicsDevice;
-import sun.java2d.InvalidPipeException;
-import sun.java2d.SurfaceData;
-import sun.java2d.pipe.Region;
-import sun.java2d.windows.WindowsFlags;
+import sun.java2d.pipe.BufferedContext;
+import sun.java2d.pipe.RenderBuffer;
+import sun.java2d.pipe.RenderQueue;
+import sun.java2d.pipe.hw.ContextCapabilities;
+import static sun.java2d.pipe.BufferedOpCodes.*;
+import static sun.java2d.pipe.hw.ContextCapabilities.*;
+import static sun.java2d.d3d.D3DContext.D3DContextCaps.*;
+
+/**
+ * Note that the RenderQueue lock must be acquired before calling any of
+ * the methods in this class.
+ */
+class D3DContext extends BufferedContext {
 
-public class D3DContext {
+    private final D3DGraphicsDevice device;
 
-    public static final int NO_CONTEXT_FLAGS = 0;
-    /**
-     * Used in D3DBlitLoops: if the source surface is opaque
-     * alpha blending can be turned off on the native level
-     * (if there's no ea), thus improving performance.
-     */
-    public static final int SRC_IS_OPAQUE    = 1;
-
-    /**
-     * This is a list of capabilities supported by the device this
-     * context is associated with.
-     * @see getDeviceCaps
-     */
-    public static final int J2D_D3D_FAILURE                = (0 << 0);
-    /**
-     * Device supports depth buffer for d3d render targets
-     */
-    public static final int J2D_D3D_DEPTH_SURFACE_OK       = (1 << 0);
-    /**
-     * Device supports creation of plain d3d surfaces
-     */
-    public static final int J2D_D3D_PLAIN_SURFACE_OK       = (1 << 1);
-    /**
-     * Device supports creation of opaque textures
-     */
-    public static final int J2D_D3D_OP_TEXTURE_SURFACE_OK  = (1 << 2);
-    /**
-     * Device supports creation of bitmask textures
-     */
-    public static final int J2D_D3D_BM_TEXTURE_SURFACE_OK  = (1 << 3);
-    /**
-     * Device supports creation of translucent textures
-     */
-    public static final int J2D_D3D_TR_TEXTURE_SURFACE_OK  = (1 << 4);
-    /**
-     * Device supports creation of opaque render-to-textures
-     */
-    public static final int J2D_D3D_OP_RTT_SURFACE_OK      = (1 << 5);
-    /**
-     * Device can render lines correctly (no pixelization issues)
-     */
-    public static final int J2D_D3D_LINES_OK               = (1 << 6);
-    /**
-     * Device supports texture mapping (no pixelization issues)
-     */
-    public static final int J2D_D3D_TEXTURE_BLIT_OK        = (1 << 7);
-    /**
-     * Device supports texture mapping with transforms (no pixelization issues)
-     */
-    public static final int J2D_D3D_TEXTURE_TRANSFORM_OK   = (1 << 8);
-    /**
-     * Device can render clipped lines correctly.
-     */
-    public static final int J2D_D3D_LINE_CLIPPING_OK       = (1 << 9);
-    /**
-     * Device has all hw capabilities the d3d pipeline requires
-     */
-    public static final int J2D_D3D_DEVICE_OK              = (1 <<10);
-    /**
-     * Device supports all necessary texture formats required by d3d pipeline
-     */
-    public static final int J2D_D3D_PIXEL_FORMATS_OK       = (1 <<11);
-    /**
-     * Device supports geometry transformations
-     */
-    public static final int J2D_D3D_SET_TRANSFORM_OK       = (1 <<12);
-    /**
-     * The device is not from a list of known bad devices
-     * (see D3DRuntimeTest.cpp)
-     */
-    public static final int J2D_D3D_HW_OK                  = (1 <<13);
-    /**
-     * Direct3D pipeline is enabled on this device
-     */
-    public static final int J2D_D3D_ENABLED_OK             = (1 <<14);
+    D3DContext(RenderQueue rq, D3DGraphicsDevice device) {
+        super(rq);
+        this.device = device;
+    }
 
     /**
-     * The lock object used to synchronize access to the native windowing
-     * system layer.  Note that rendering methods should always synchronize on
-     * D3DContext.LOCK before calling the D3DContext.getContext() method,
-     * or any other method that invokes native D3d commands.
-     * REMIND: in D3D case we should really be synchronizing on per-device
-     * basis.
+     * Invalidates the currentContext field to ensure that we properly
+     * revalidate the D3DContext (make it current, etc.) next time through
+     * the validate() method.  This is typically invoked from methods
+     * that affect the current context state (e.g. disposing a context or
+     * surface).
      */
-    static Object LOCK;
-
-    private Win32GraphicsDevice  gd;
-    private boolean         valid;
+    static void invalidateCurrentContext() {
+        // assert D3DRenderQueue.getInstance().lock.isHeldByCurrentThread();
 
-    protected long          nativeContext;
-    private SurfaceData     validatedDstData;
-    private Region          validatedClip;
-    private Composite       validatedComp;
-    private int             validatedPixel;
-    private int             validatedFlags;
-    private boolean         xformInUse;
-    // validated transform's data
-    private double vScaleX, vScaleY, vShearX, vShearY, vTransX, vTransY;
-
-    private int             deviceCaps;
-
-    private native void setRenderTarget(long pCtx, long pDst);
-    private native void setClip(long pCtx, long pDst, Region clip, boolean isRect,
-                                int x1, int y1, int x2, int y2);
-    private native void resetClip(long pCtx, long pDst);
-    private native void resetComposite(long pCtx);
-    private native void setAlphaComposite(long pCtx, int rule,
-                                          float extraAlpha, int flags);
-    private native void setTransform(long pCtx, long pDst,
-                                     AffineTransform xform,
-                                     double m00, double m10, double m01,
-                                     double m11, double m02, double m12);
-    private native void resetTransform(long pCtx, long pDst);
-    private native void setColor(long pCtx, int pixel, int flags);
-    private native long initNativeContext(int screen);
-    private native int getNativeDeviceCaps(long pCtx);
-
-    static {
-        if (!GraphicsEnvironment.isHeadless()) {
-            LOCK = D3DContext.class;
+        // invalidate the current Java-level context so that we
+        // revalidate everything the next time around
+        if (currentContext != null) {
+            currentContext.invalidateContext();
+            currentContext = null;
         }
-    }
-
-    public D3DContext(Win32GraphicsDevice gd) {
-        this.gd = gd;
-        reinitNativeContext();
-    }
 
-    /**
-     * Reinitializes the context by retrieving a pointer to the native
-     * D3DContext object, and resetting the device caps.
-     */
-    void reinitNativeContext() {
-        nativeContext = initNativeContext(gd.getScreen());
-        deviceCaps = nativeContext != 0L ?
-            getNativeDeviceCaps(nativeContext) : J2D_D3D_FAILURE;
-        valid = ((deviceCaps & J2D_D3D_ENABLED_OK) != 0);
-        if (WindowsFlags.isD3DVerbose()) {
-            if (valid) {
-                System.out.println("Direct3D pipeline enabled on screen " +
-                                   gd.getScreen());
-            } else {
-                System.out.println("Could not enable Direct3D pipeline on " +
-                                   "screen " + gd.getScreen() +
-                                   ". Device Caps: " +
-                                   Integer.toHexString(deviceCaps));
-            }
-        }
+        // invalidate the context reference at the native level, and
+        // then flush the queue so that we have no pending operations
+        // dependent on the current context
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.ensureCapacity(4);
+        rq.getBuffer().putInt(INVALIDATE_CONTEXT);
+        rq.flushNow();
     }
 
     /**
-     * Invalidates this context by resetting its status: the validated
-     * destination surface, and a pointer to the native context.
-     * This method is called in the following cases:
-     *  - if a surface loss situation is detected at the native level
-     *    during any of the validation methods (setClip, setRenderTarget etc)
-     *    and an InvalidPipeException is thrown.
-     *    This situation happens when there was a surface loss, but
-     *    there were no display change event (like in case of command prompt
-     *    going fullscreen).
-     *  - as part of surface restoration when a surface is the current
-     *    target surface for this context. Since surface restoration
-     *    resets the depth buffer contents, we need to make sure the clip
-     *    is reset, and since the target surface is reset, we'll set a new
-     *    clip the next time we attempt to render to the target surface.
-     *  - when a display change occurs, the native D3DContext object is
-     *    released and recreated as part of primary surface recreation.
-     *    At the time of the release, the java D3DContext object need to be
-     *    invalidated because a new D3D device is created and the target
-     *    surface will need to be reset.
+     * Sets the current context on the native level to be the one passed as
+     * the argument.
+     * If the context is not the same as the defaultContext the latter
+     * will be reset to null.
      *
-     *  Invalidation of the context causes its revalidation the next time
-     *  someone tries to get the D3DContext for rendering or creating a new
-     *  surface.
+     * This call is needed when copying from a SW surface to a Texture
+     * (the upload test) or copying from d3d to SW surface to make sure we
+     * have the correct current context.
      *
-     *  @see #reinitNativeContext
+     * @param d3dc the context to be made current on the native level
      */
-    private void invalidateContext() {
-        valid = false;
-        nativeContext = 0L;
-        validatedDstData = null;
-        // We don't set deviceCaps to J2D_D3D_FAILURE here because
-        // it will prevent from creating d3d surfaces, which means that
-        // we'll never get a chance to continue using d3d after a single
-        // invalidation event (for example, a display change).
-    }
+    static void setScratchSurface(D3DContext d3dc) {
+        // assert D3DRenderQueue.getInstance().lock.isHeldByCurrentThread();
 
-    /**
-     * Fetches the D3DContext associated with the current
-     * thread/GraphicsConfig pair, validates the context using the given
-     * parameters, then returns the handle to the native context object.
-     * Most rendering operations will call this method first in order to
-     * prepare the native D3d layer before issuing rendering commands.
-     */
-    static long getContext(SurfaceData srcData,
-                           SurfaceData dstData,
-                            Region clip, Composite comp,
-                           AffineTransform xform,
-                           int pixel, int flags)
-    {
-        if (dstData instanceof D3DSurfaceData == false) {
-            throw new InvalidPipeException("Incorrect destination surface");
+        // invalidate the current context
+        if (d3dc != currentContext) {
+            currentContext = null;
         }
 
-        D3DContext d3dc = ((D3DSurfaceData)dstData).getContext();
-        try {
-            d3dc.validate(srcData, dstData, clip, comp, xform, pixel, flags);
-        } catch (InvalidPipeException e) {
-            d3dc.invalidateContext();
-            // note that we do not propagate the exception. Once the context
-            // is invalidated, any d3d rendering operations are noops, and
-            // we are waiting for the primary surface restoration, which
-            // happens when VolatileImage is validated. At this point
-            // the native D3DContext will be reinitialized, and the next
-            // time around validation of the context will succeed.
-            // Throwing the exception here will do no good, since the
-            // destination surface (which is associated with a VolatileImage
-            // or a BufferStrategy) will not be restored until VI.validate()
-            // is called by the rendering thread.
-        }
-        return d3dc.getNativeContext();
+        // set the scratch context
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        RenderBuffer buf = rq.getBuffer();
+        rq.ensureCapacity(8);
+        buf.putInt(SET_SCRATCH_SURFACE);
+        buf.putInt(d3dc.getDevice().getScreen());
     }
 
-    public int getDeviceCaps() {
-        return deviceCaps;
+    public RenderQueue getRenderQueue() {
+        return D3DRenderQueue.getInstance();
     }
 
-    boolean isRTTSupported() {
-        return ((deviceCaps & J2D_D3D_OP_RTT_SURFACE_OK) != 0);
+    @Override
+    public void saveState() {
+        // assert rq.lock.isHeldByCurrentThread();
+
+        // reset all attributes of this and current contexts
+        invalidateContext();
+        invalidateCurrentContext();
+
+        setScratchSurface(this);
+
+        // save the state on the native level
+        rq.ensureCapacity(4);
+        buf.putInt(SAVE_STATE);
+        rq.flushNow();
     }
 
-    /**
-     * Returns a handle to the native D3DContext structure associated with
-     * this object.
-     */
-    long getNativeContext() {
-        return nativeContext;
+    @Override
+    public void restoreState() {
+        // assert rq.lock.isHeldByCurrentThread();
+
+        // reset all attributes of this and current contexts
+        invalidateContext();
+        invalidateCurrentContext();
+
+        setScratchSurface(this);
+
+        // restore the state on the native level
+        rq.ensureCapacity(4);
+        buf.putInt(RESTORE_STATE);
+        rq.flushNow();
     }
 
-    /**
-     * Validates the given parameters against the current state for this
-     * context.  If this context is not current, it will be made current
-     * for the given source and destination surfaces, and the viewport will
-     * be updated.  Then each part of the context state (clip, composite,
-     * etc.) is checked against the previous value.  If the value has changed
-     * since the last call to validate(), it will be updated accordingly.
-     */
-    private void validate(SurfaceData srcData, SurfaceData dstData,
-                          Region clip, Composite comp, AffineTransform xform,
-                          int pixel, int flags)
-    {
-        boolean updateClip = false;
-
-        if ((srcData != null && !srcData.isValid()) || !dstData.isValid() ||
-            dstData.getNativeOps() == 0L || dstData.isSurfaceLost())
-        {
-            throw new InvalidPipeException("Invalid surface");
-        }
+    D3DGraphicsDevice getDevice() {
+        return device;
+    }
 
-        if (!valid) {
-            // attempt to reinitialize the context. If the device has been
-            // reset, the following calls to setRenderTarget/setClip will
-            // succeed and not throw InvalidPipeException.
-            reinitNativeContext();
-        }
+    static class D3DContextCaps extends ContextCapabilities {
+        /**
+         * Indicates the presence of pixel shaders (v2.0 or greater).
+         * This cap will only be set if the hardware supports the minimum number
+         * of texture units.
+         */
+        static final int CAPS_LCD_SHADER       = (FIRST_PRIVATE_CAP << 0);
+        /**
+         * Indicates the presence of pixel shaders (v2.0 or greater).
+         * This cap will only be set if the hardware meets our
+         * minimum requirements.
+         */
+        static final int CAPS_BIOP_SHADER      = (FIRST_PRIVATE_CAP << 1);
+        /**
+         * Indicates that the device was successfully initialized and can
+         * be safely used.
+         */
+        static final int CAPS_DEVICE_OK        = (FIRST_PRIVATE_CAP << 2);
+        /**
+         * Indicates that the device has all of the necessary capabilities
+         * to support the Antialiasing Pixel Shader program.
+         */
+        static final int CAPS_AA_SHADER        = (FIRST_PRIVATE_CAP << 3);
 
-        if (dstData != validatedDstData) {
-            // invalidate pixel and clip (so they will be updated below)
-            validatedPixel = ~pixel;
-            updateClip = true;
-
-            // update the viewport
-            long pDst = dstData.getNativeOps();
-            setRenderTarget(nativeContext, pDst);
-
-            // keep the reference to the old data until we set the
-            // new one on the native level, preventing it from being disposed
-            SurfaceData tmpData = dstData;
-            validatedDstData = dstData;
-            tmpData = null;
-        }
-        // it's better to use dstData instead of validatedDstData because
-        // the latter may be set to null via invalidateContext at any moment.
-        long pDest = dstData.getNativeOps();
-
-        // validate clip
-        if ((clip != validatedClip) || updateClip) {
-            if (clip != null) {
-                /**
-                 * It's cheaper to make this check than set clip every time.
-                 *
-                 * Set the new clip only if:
-                 *  - we were asked to do it (updateClip == true)
-                 *  - no clip was set before
-                 *  - if both the old and the new clip are shapes
-                 *  - if they're both rectangular but don't represent
-                 *    the same rectangle
-                 */
-                if (updateClip ||
-                    validatedClip == null ||
-                    !(validatedClip.isRectangular() && clip.isRectangular()) ||
-                    ((clip.getLoX() != validatedClip.getLoX() ||
-                      clip.getLoY() != validatedClip.getLoY() ||
-                      clip.getHiX() != validatedClip.getHiX() ||
-                      clip.getHiY() != validatedClip.getHiY())))
-                {
-                    setClip(nativeContext, pDest,
-                            clip, clip.isRectangular(),
-                            clip.getLoX(), clip.getLoY(),
-                            clip.getHiX(), clip.getHiY());
-                }
-            } else {
-                resetClip(nativeContext, pDest);
-            }
-            validatedClip = clip;
+        D3DContextCaps(int caps, String adapterId) {
+            super(caps, adapterId);
         }
 
-        if ((comp != validatedComp) || (flags != validatedFlags)) {
-            // invalidate pixel
-            validatedPixel = ~pixel;
-            validatedComp = comp;
-            if (comp != null) {
-                AlphaComposite ac = (AlphaComposite)comp;
-                setAlphaComposite(nativeContext, ac.getRule(),
-                                  ac.getAlpha(), flags);
-            } else {
-                resetComposite(nativeContext);
+        @Override
+        public String toString() {
+            StringBuffer buf = new StringBuffer(super.toString());
+            if ((caps & CAPS_LCD_SHADER) != 0) {
+                buf.append("CAPS_LCD_SHADER|");
             }
-        }
-
-        // validate transform
-        if (xform == null) {
-            if (xformInUse) {
-                resetTransform(nativeContext, pDest);
-                xformInUse = false;
-                vScaleX = vScaleY = 1.0;
-                vShearX = vShearY = vTransX = vTransY = 0.0;
+            if ((caps & CAPS_BIOP_SHADER) != 0) {
+                buf.append("CAPS_BIOP_SHADER|");
             }
-        } else {
-            double nScaleX = xform.getScaleX();
-            double nScaleY = xform.getScaleY();
-            double nShearX = xform.getShearX();
-            double nShearY = xform.getShearY();
-            double nTransX = xform.getTranslateX();
-            double nTransY = xform.getTranslateY();
-
-            if (nTransX != vTransX || nTransY != vTransY ||
-                nScaleX != vScaleX || nScaleY != vScaleY ||
-                nShearX != vShearX || nShearY != vShearY)
-            {
-                setTransform(nativeContext, pDest,
-                             xform,
-                             nScaleX, nShearY, nShearX, nScaleY,
-                             nTransX, nTransY);
-                vScaleX = nScaleX;
-                vScaleY = nScaleY;
-                vShearX = nShearX;
-                vShearY = nShearY;
-                vTransX = nTransY;
-                vTransY = nTransY;
-                xformInUse = true;
+            if ((caps & CAPS_AA_SHADER) != 0) {
+                buf.append("CAPS_AA_SHADER|");
             }
+            if ((caps & CAPS_DEVICE_OK) != 0) {
+                buf.append("CAPS_DEVICE_OK|");
+            }
+            return buf.toString();
         }
-
-        // validate pixel
-        if (pixel != validatedPixel) {
-            validatedPixel = pixel;
-            setColor(nativeContext, pixel, flags);
-        }
-
-        // save flags for later comparison
-        validatedFlags = flags;
-
-        // mark dstData dirty
-        dstData.markDirty();
     }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DDrawImage.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DDrawImage.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DDrawImage.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DDrawImage.java	2011-01-08 01:26:50.463202123 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,6 +29,8 @@
 import java.awt.Image;
 import java.awt.geom.AffineTransform;
 import java.awt.image.AffineTransformOp;
+import java.awt.image.BufferedImage;
+import java.awt.image.BufferedImageOp;
 import sun.java2d.SunGraphics2D;
 import sun.java2d.SurfaceData;
 import sun.java2d.loops.SurfaceType;
@@ -36,6 +38,8 @@
 import sun.java2d.pipe.DrawImage;
 
 public class D3DDrawImage extends DrawImage {
+
+    @Override
     protected void renderImageXform(SunGraphics2D sg, Image img,
                                     AffineTransform tx, int interpType,
                                     int sx1, int sy1, int sx2, int sy2,
@@ -44,7 +48,6 @@
         // punt to the MediaLib-based transformImage() in the superclass if:
         //     - bicubic interpolation is specified
         //     - a background color is specified and will be used
-        //     - the source surface is not a texture
         //     - an appropriate TransformBlit primitive could not be found
         if (interpType != AffineTransformOp.TYPE_BICUBIC) {
             SurfaceData dstData = sg.surfaceData;
@@ -54,10 +57,7 @@
                                              sg.imageComp,
                                              bgColor);
 
-            if (srcData != null &&
-                !isBgOperation(srcData, bgColor) &&
-                srcData.getSurfaceType() == D3DSurfaceData.D3DTexture)
-            {
+            if (srcData != null && !isBgOperation(srcData, bgColor)) {
                 SurfaceType srcType = srcData.getSurfaceType();
                 SurfaceType dstType = dstData.getSurfaceType();
                 TransformBlit blit = TransformBlit.getFromCache(srcType,
@@ -77,4 +77,25 @@
         super.renderImageXform(sg, img, tx, interpType,
                                sx1, sy1, sx2, sy2, bgColor);
     }
+
+    @Override
+    public void transformImage(SunGraphics2D sg, BufferedImage img,
+                               BufferedImageOp op, int x, int y)
+    {
+        if (op != null) {
+            if (op instanceof AffineTransformOp) {
+                AffineTransformOp atop = (AffineTransformOp) op;
+                transformImage(sg, img, x, y,
+                               atop.getTransform(),
+                               atop.getInterpolationType());
+                return;
+            } else {
+                if (D3DBufImgOps.renderImageWithOp(sg, img, op, x, y)) {
+                    return;
+                }
+            }
+            img = op.filter(img, null);
+        }
+        copyImage(sg, img, x, y, null);
+    }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DGraphicsConfig.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DGraphicsConfig.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DGraphicsConfig.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DGraphicsConfig.java	2011-01-08 01:26:50.463202123 +0000
@@ -0,0 +1,327 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.d3d;
+
+import java.awt.AWTException;
+import java.awt.BufferCapabilities;
+import java.awt.BufferCapabilities.FlipContents;
+import java.awt.Component;
+import java.awt.Graphics;
+import java.awt.ImageCapabilities;
+import java.awt.Transparency;
+import java.awt.color.ColorSpace;
+import java.awt.image.ColorModel;
+import java.awt.image.DataBuffer;
+import java.awt.image.DirectColorModel;
+import java.awt.image.VolatileImage;
+import sun.awt.Win32GraphicsConfig;
+import sun.awt.image.SunVolatileImage;
+import sun.awt.image.SurfaceManager;
+import sun.awt.windows.WComponentPeer;
+import sun.java2d.Surface;
+import sun.java2d.SurfaceData;
+import sun.java2d.pipe.hw.AccelDeviceEventNotifier;
+import sun.java2d.pipe.hw.AccelTypedVolatileImage;
+import sun.java2d.pipe.hw.AccelGraphicsConfig;
+import sun.java2d.pipe.hw.AccelSurface;
+import sun.java2d.pipe.hw.ContextCapabilities;
+import static sun.java2d.pipe.hw.AccelSurface.*;
+import static sun.java2d.d3d.D3DContext.D3DContextCaps.*;
+import sun.java2d.pipe.hw.AccelDeviceEventListener;
+
+public class D3DGraphicsConfig
+    extends Win32GraphicsConfig
+    implements AccelGraphicsConfig
+{
+    private static ImageCapabilities imageCaps = new D3DImageCaps();
+
+    private BufferCapabilities bufferCaps;
+    private D3DGraphicsDevice device;
+
+    protected D3DGraphicsConfig(D3DGraphicsDevice device) {
+        super(device, 0);
+        this.device = device;
+    }
+
+    public SurfaceData createManagedSurface(int w, int h, int transparency) {
+        return D3DSurfaceData.createData(this, w, h,
+                                         getColorModel(transparency),
+                                         null,
+                                         D3DSurfaceData.TEXTURE);
+    }
+
+    @Override
+    public synchronized void displayChanged() {
+        super.displayChanged();
+        // the context could hold a reference to a D3DSurfaceData, which in
+        // turn has a reference back to this D3DGraphicsConfig, so in order
+        // for this instance to be disposed we need to break the connection
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            D3DContext.invalidateCurrentContext();
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    @Override
+    public ColorModel getColorModel(int transparency) {
+        switch (transparency) {
+        case Transparency.OPAQUE:
+            // REMIND: once the ColorModel spec is changed, this should be
+            //         an opaque premultiplied DCM...
+            return new DirectColorModel(24, 0xff0000, 0xff00, 0xff);
+        case Transparency.BITMASK:
+            return new DirectColorModel(25, 0xff0000, 0xff00, 0xff, 0x1000000);
+        case Transparency.TRANSLUCENT:
+            ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);
+            return new DirectColorModel(cs, 32,
+                                        0xff0000, 0xff00, 0xff, 0xff000000,
+                                        true, DataBuffer.TYPE_INT);
+        default:
+            return null;
+        }
+    }
+
+    @Override
+    public String toString() {
+        return ("D3DGraphicsConfig[dev="+screen+",pixfmt="+visual+"]");
+    }
+
+    /**
+     * The following methods are invoked from WComponentPeer.java rather
+     * than having the Win32-dependent implementations hardcoded in that
+     * class.  This way the appropriate actions are taken based on the peer's
+     * GraphicsConfig, whether it is a Win32GraphicsConfig or a
+     * D3DGraphicsConfig.
+     */
+
+    /**
+     * Creates a new SurfaceData that will be associated with the given
+     * WComponentPeer. D3D9 doesn't allow rendering to the screen,
+     * so a GDI surface will be returned.
+     */
+    @Override
+    public SurfaceData createSurfaceData(WComponentPeer peer,
+                                         int numBackBuffers)
+    {
+        return super.createSurfaceData(peer, numBackBuffers);
+    }
+
+    /**
+     * The following methods correspond to the multibuffering methods in
+     * WComponentPeer.java...
+     */
+
+    /**
+     * Checks that the requested configuration is natively supported; if not,
+     * an AWTException is thrown.
+     */
+    @Override
+    public void assertOperationSupported(Component target,
+                                         int numBuffers,
+                                         BufferCapabilities caps)
+        throws AWTException
+    {
+        if (numBuffers < 2 || numBuffers > 4) {
+            throw new AWTException("Only 2-4 buffers supported");
+        }
+        if (caps.getFlipContents() == BufferCapabilities.FlipContents.COPIED &&
+            numBuffers != 2)
+        {
+            throw new AWTException("FlipContents.COPIED is only" +
+                                   "supported for 2 buffers");
+        }
+    }
+
+    /**
+     * Creates a D3D-based backbuffer for the given peer and returns the
+     * image wrapper.
+     */
+    @Override
+    public VolatileImage createBackBuffer(WComponentPeer peer) {
+        Component target = (Component)peer.getTarget();
+        // it is possible for the component to have size 0x0, adjust it to
+        // be at least 1x1 to avoid IAE
+        int w = Math.max(1, target.getWidth());
+        int h = Math.max(1, target.getHeight());
+        return new SunVolatileImage(target, w, h, Boolean.TRUE);
+    }
+
+    /**
+     * Performs the native D3D flip operation for the given target Component.
+     */
+    @Override
+    public void flip(WComponentPeer peer,
+                     Component target, VolatileImage backBuffer,
+                     int x1, int y1, int x2, int y2,
+                     BufferCapabilities.FlipContents flipAction)
+    {
+        // REMIND: we should actually get a surface data for the
+        // backBuffer's VI
+        SurfaceManager d3dvsm =
+            SurfaceManager.getManager(backBuffer);
+        SurfaceData sd = d3dvsm.getPrimarySurfaceData();
+        if (sd instanceof D3DSurfaceData) {
+            D3DSurfaceData d3dsd = (D3DSurfaceData)sd;
+            D3DSurfaceData.swapBuffers(d3dsd, x1, y1, x2, y2);
+        } else {
+            // the surface was likely lost could not have been restored
+            Graphics g = peer.getGraphics();
+            try {
+                g.drawImage(backBuffer,
+                            x1, y1, x2, y2,
+                            x1, y1, x2, y2,
+                            null);
+            } finally {
+                g.dispose();
+            }
+        }
+
+        if (flipAction == BufferCapabilities.FlipContents.BACKGROUND) {
+            Graphics g = backBuffer.getGraphics();
+            try {
+                g.setColor(target.getBackground());
+                g.fillRect(0, 0,
+                           backBuffer.getWidth(),
+                           backBuffer.getHeight());
+            } finally {
+                g.dispose();
+            }
+        }
+    }
+
+    private static class D3DBufferCaps extends BufferCapabilities {
+        public D3DBufferCaps() {
+            // REMIND: should we indicate that the front-buffer
+            // (the on-screen rendering) is not accelerated?
+            super(imageCaps, imageCaps, FlipContents.UNDEFINED);
+        }
+        @Override
+        public boolean isMultiBufferAvailable() {
+            return true;
+        }
+
+    }
+
+    @Override
+    public BufferCapabilities getBufferCapabilities() {
+        if (bufferCaps == null) {
+            bufferCaps = new D3DBufferCaps();
+        }
+        return bufferCaps;
+    }
+
+    private static class D3DImageCaps extends ImageCapabilities {
+        private D3DImageCaps() {
+            super(true);
+        }
+        @Override
+        public boolean isTrueVolatile() {
+            return true;
+        }
+    }
+
+    @Override
+    public ImageCapabilities getImageCapabilities() {
+        return imageCaps;
+    }
+
+    D3DGraphicsDevice getD3DDevice() {
+        return device;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.pipe.hw.BufferedContextProvider#getContext
+     */
+    @Override
+    public D3DContext getContext() {
+        return device.getContext();
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.pipe.hw.AccelGraphicsConfig#createCompatibleVolatileImage
+     */
+    @Override
+    public VolatileImage
+        createCompatibleVolatileImage(int width, int height,
+                                      int transparency, int type)
+    {
+        if (type == FLIP_BACKBUFFER || type == WINDOW || type == UNDEFINED ||
+            transparency == Transparency.BITMASK)
+        {
+            return null;
+        }
+        boolean isOpaque = transparency == Transparency.OPAQUE;
+        if (type == RT_TEXTURE) {
+            int cap = isOpaque ? CAPS_RT_TEXTURE_OPAQUE : CAPS_RT_TEXTURE_ALPHA;
+            if (!device.isCapPresent(cap)) {
+                return null;
+            }
+        } else if (type == RT_PLAIN) {
+            if (!isOpaque && !device.isCapPresent(CAPS_RT_PLAIN_ALPHA)) {
+                return null;
+            }
+        }
+
+        SunVolatileImage vi = new AccelTypedVolatileImage(this, width, height,
+                                                          transparency, type);
+        Surface sd = vi.getDestSurface();
+        if (!(sd instanceof AccelSurface) ||
+            ((AccelSurface)sd).getType() != type)
+        {
+            vi.flush();
+            vi = null;
+        }
+
+        return vi;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.pipe.hw.AccelGraphicsConfig#getContextCapabilities
+     */
+    @Override
+    public ContextCapabilities getContextCapabilities() {
+        return device.getContextCapabilities();
+    }
+
+    @Override
+    public void addDeviceEventListener(AccelDeviceEventListener l) {
+        AccelDeviceEventNotifier.addListener(l, device.getScreen());
+    }
+
+    @Override
+    public void removeDeviceEventListener(AccelDeviceEventListener l) {
+        AccelDeviceEventNotifier.removeListener(l);
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DGraphicsDevice.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DGraphicsDevice.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DGraphicsDevice.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DGraphicsDevice.java	2011-01-08 01:26:50.467202167 +0000
@@ -0,0 +1,500 @@
+/*
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.java2d.d3d;
+
+import java.awt.Dialog;
+import java.awt.DisplayMode;
+import java.awt.Frame;
+import java.awt.GraphicsConfiguration;
+import java.awt.Rectangle;
+import java.awt.Toolkit;
+import java.awt.Window;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.event.WindowListener;
+import java.awt.peer.WindowPeer;
+import java.util.ArrayList;
+import sun.awt.Win32GraphicsDevice;
+import sun.awt.windows.WWindowPeer;
+import sun.java2d.pipe.hw.ContextCapabilities;
+import sun.java2d.windows.WindowsFlags;
+import static sun.java2d.pipe.BufferedOpCodes.*;
+import static sun.java2d.d3d.D3DContext.D3DContextCaps.*;
+import sun.java2d.d3d.D3DContext.D3DContextCaps;
+
+/**
+ * This class implements D3D-specific functionality, such as fullscreen
+ * exclusive mode and display changes.  It is kept separate from
+ * Win32GraphicsDevice to help avoid overburdening the parent class.
+ */
+public class D3DGraphicsDevice extends Win32GraphicsDevice {
+    private D3DContext context;
+
+    private static boolean d3dAvailable;
+
+    private ContextCapabilities d3dCaps;
+
+    private static native boolean initD3D();
+
+    static {
+        // loading the library doesn't help because we need the
+        // toolkit thread running, so we have to call getDefaultToolkit()
+        Toolkit.getDefaultToolkit();
+        d3dAvailable = initD3D();
+        if (d3dAvailable) {
+            // we don't use pixel formats for the d3d pipeline
+            pfDisabled = true;
+        }
+    }
+
+    /**
+     * Used to construct a Direct3D-enabled GraphicsDevice.
+     *
+     * @return a D3DGraphicsDevice if it could be created
+     * successfully, null otherwise.
+     */
+    public static D3DGraphicsDevice createDevice(int screen) {
+        if (!d3dAvailable) {
+            return null;
+        }
+
+        ContextCapabilities d3dCaps = getDeviceCaps(screen);
+        // could not initialize the device successfully
+        if ((d3dCaps.getCaps() & CAPS_DEVICE_OK) == 0) {
+            if (WindowsFlags.isD3DVerbose()) {
+                System.out.println("Could not enable Direct3D pipeline on " +
+                                   "screen " + screen);
+            }
+            return null;
+        }
+        if (WindowsFlags.isD3DVerbose()) {
+            System.out.println("Direct3D pipeline enabled on screen " + screen);
+        }
+
+        D3DGraphicsDevice gd = new D3DGraphicsDevice(screen, d3dCaps);
+        return gd;
+    }
+
+    private static native int getDeviceCapsNative(int screen);
+    private static native String getDeviceIdNative(int screen);
+    private static ContextCapabilities getDeviceCaps(final int screen) {
+        ContextCapabilities d3dCaps = null;
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            class Result {
+                int caps;
+                String id;
+            };
+            final Result res = new Result();
+            rq.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    res.caps = getDeviceCapsNative(screen);
+                    res.id = getDeviceIdNative(screen);
+                }
+            });
+            d3dCaps = new D3DContextCaps(res.caps, res.id);
+        } finally {
+            rq.unlock();
+        }
+
+        return d3dCaps != null ? d3dCaps : new D3DContextCaps(CAPS_EMPTY, null);
+    }
+
+    public final boolean isCapPresent(int cap) {
+        return ((d3dCaps.getCaps() & cap) != 0);
+    }
+
+    private D3DGraphicsDevice(int screennum, ContextCapabilities d3dCaps) {
+        super(screennum);
+        descString = "D3DGraphicsDevice[screen="+screennum;
+        this.d3dCaps = d3dCaps;
+        context = new D3DContext(D3DRenderQueue.getInstance(), this);
+    }
+
+    public boolean isD3DEnabledOnDevice() {
+        return isValid() && isCapPresent(CAPS_DEVICE_OK);
+    }
+
+    /**
+     * Returns true if d3d pipeline has been successfully initialized.
+     * @return true if d3d pipeline is initialized, false otherwise
+     */
+    public static boolean isD3DAvailable() {
+        return d3dAvailable;
+    }
+
+    /**
+     * Return the owning Frame for a given Window.  Used in setFSWindow below
+     * to set the properties of the owning Frame when a Window goes
+     * into fullscreen mode.
+     */
+    private Frame getToplevelOwner(Window w) {
+        Window owner = w;
+        while (owner != null) {
+            owner = owner.getOwner();
+            if (owner instanceof Frame) {
+                return (Frame) owner;
+            }
+        }
+        // could get here if passed Window is an owner-less Dialog
+        return null;
+    }
+
+    private boolean fsStatus;
+    private Rectangle ownerOrigBounds = null;
+    private boolean ownerWasVisible;
+    private Window realFSWindow;
+    private WindowListener fsWindowListener;
+    private boolean fsWindowWasAlwaysOnTop;
+    private static native boolean enterFullScreenExclusiveNative(int screen,
+                                                                 long hwnd);
+
+    @Override
+    protected void enterFullScreenExclusive(final int screen, WindowPeer wp)
+    {
+        final WWindowPeer wpeer = (WWindowPeer)realFSWindow.getPeer();
+
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            rq.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    long hwnd = wpeer.getHWnd();
+                    if (hwnd == 0l) {
+                        // window is disposed
+                        fsStatus = false;
+                        return;
+                    }
+                    fsStatus = enterFullScreenExclusiveNative(screen, hwnd);
+                }
+            });
+        } finally {
+            rq.unlock();
+        }
+        if (!fsStatus) {
+            super.enterFullScreenExclusive(screen, wp);
+        }
+    }
+
+    private static native boolean exitFullScreenExclusiveNative(int screen);
+    @Override
+    protected void exitFullScreenExclusive(final int screen, WindowPeer w) {
+        if (fsStatus) {
+            D3DRenderQueue rq = D3DRenderQueue.getInstance();
+            rq.lock();
+            try {
+                rq.flushAndInvokeNow(new Runnable() {
+                    public void run() {
+                        exitFullScreenExclusiveNative(screen);
+                    }
+                });
+            } finally {
+                rq.unlock();
+            }
+        } else {
+            super.exitFullScreenExclusive(screen, w);
+        }
+    }
+
+    /**
+     * WindowAdapter class for the full-screen frame, responsible for
+     * restoring the devices. This is important to do because unless the device
+     * is restored it will not go back into the FS mode once alt+tabbed out.
+     * This is a problem for windows for which we do not do any d3d-related
+     * operations (like when we disabled on-screen rendering).
+     *
+     * REMIND: we create an instance per each full-screen device while a single
+     * instance would suffice (but requires more management).
+     */
+    private static class D3DFSWindowAdapter extends WindowAdapter {
+        @Override
+        public void windowDeactivated(WindowEvent e) {
+            D3DRenderQueue.getInstance().restoreDevices();
+        }
+        @Override
+        public void windowActivated(WindowEvent e) {
+            D3DRenderQueue.getInstance().restoreDevices();
+        }
+    }
+
+    @Override
+    protected void addFSWindowListener(Window w) {
+        // if the window is not a toplevel (has an owner) we have to use the
+        // real toplevel to enter the full-screen mode with (4933099).
+        if (!(w instanceof Frame) && !(w instanceof Dialog) &&
+            (realFSWindow = getToplevelOwner(w)) != null)
+        {
+            ownerOrigBounds = realFSWindow.getBounds();
+            WWindowPeer fp = (WWindowPeer)realFSWindow.getPeer();
+
+            ownerWasVisible = realFSWindow.isVisible();
+            Rectangle r = w.getBounds();
+            // we use operations on peer instead of component because calling
+            // them on component will take the tree lock
+            fp.reshape(r.x, r.y, r.width, r.height);
+            fp.setVisible(true);
+        } else {
+            realFSWindow = w;
+        }
+
+        fsWindowWasAlwaysOnTop = realFSWindow.isAlwaysOnTop();
+        ((WWindowPeer)realFSWindow.getPeer()).setAlwaysOnTop(true);
+
+        fsWindowListener = new D3DFSWindowAdapter();
+        realFSWindow.addWindowListener(fsWindowListener);
+    }
+
+    @Override
+    protected void removeFSWindowListener(Window w) {
+        realFSWindow.removeWindowListener(fsWindowListener);
+        fsWindowListener = null;
+
+        /**
+         * Bug 4933099: There is some funny-business to deal with when this
+         * method is called with a Window instead of a Frame.  See 4836744
+         * for more information on this.  One side-effect of our workaround
+         * for the problem is that the owning Frame of a Window may end
+         * up getting resized during the fullscreen process.  When we
+         * return from fullscreen mode, we should resize the Frame to
+         * its original size (just like the Window is being resized
+         * to its original size in GraphicsDevice).
+         */
+        WWindowPeer wpeer = (WWindowPeer)realFSWindow.getPeer();
+        if (wpeer != null) {
+            if (ownerOrigBounds != null) {
+                // if the window went into fs mode before it was realized it
+                // could have (0,0) dimensions
+                if (ownerOrigBounds.width  == 0) ownerOrigBounds.width  = 1;
+                if (ownerOrigBounds.height == 0) ownerOrigBounds.height = 1;
+                wpeer.reshape(ownerOrigBounds.x,     ownerOrigBounds.y,
+                              ownerOrigBounds.width, ownerOrigBounds.height);
+                if (!ownerWasVisible) {
+                    wpeer.setVisible(false);
+                }
+                ownerOrigBounds = null;
+            }
+            if (!fsWindowWasAlwaysOnTop) {
+                wpeer.setAlwaysOnTop(false);
+            }
+        }
+
+        realFSWindow = null;
+    }
+
+    private static native DisplayMode getCurrentDisplayModeNative(int screen);
+    @Override
+    protected DisplayMode getCurrentDisplayMode(final int screen) {
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            class Result {
+                DisplayMode dm = null;
+            };
+            final Result res = new Result();
+            rq.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    res.dm = getCurrentDisplayModeNative(screen);
+                }
+            });
+            if (res.dm == null) {
+                return super.getCurrentDisplayMode(screen);
+            }
+            return res.dm;
+        } finally {
+            rq.unlock();
+        }
+    }
+    private static native void configDisplayModeNative(int screen, long hwnd,
+                                                       int width, int height,
+                                                       int bitDepth,
+                                                       int refreshRate);
+    @Override
+    protected void configDisplayMode(final int screen, final WindowPeer w,
+                                     final int width, final int height,
+                                     final int bitDepth, final int refreshRate)
+    {
+        // we entered fs mode via gdi
+        if (!fsStatus) {
+            super.configDisplayMode(screen, w, width, height, bitDepth,
+                                    refreshRate);
+            return;
+        }
+
+        final WWindowPeer wpeer = (WWindowPeer)realFSWindow.getPeer();
+
+        // REMIND: we do this before we switch the display mode, so
+        // the dimensions may be exceeding the dimensions of the screen,
+        // is this a problem?
+
+        // update the bounds of the owner frame
+        if (getFullScreenWindow() != realFSWindow) {
+            Rectangle screenBounds = getDefaultConfiguration().getBounds();
+            wpeer.reshape(screenBounds.x, screenBounds.y, width, height);
+        }
+
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            rq.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    long hwnd = wpeer.getHWnd();
+                    if (hwnd == 0l) {
+                        // window is disposed
+                        return;
+                    }
+                    // REMIND: do we really need a window here?
+                    // we should probably just use the current one
+                    configDisplayModeNative(screen, hwnd, width, height,
+                                            bitDepth, refreshRate);
+                }
+            });
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    private static native void enumDisplayModesNative(int screen,
+                                                      ArrayList modes);
+    @Override
+    protected void enumDisplayModes(final int screen, final ArrayList modes) {
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            rq.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    enumDisplayModesNative(screen, modes);
+                }
+            });
+            if (modes.size() == 0) {
+                modes.add(getCurrentDisplayModeNative(screen));
+            }
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    private static native long getAvailableAcceleratedMemoryNative(int screen);
+    @Override
+    public int getAvailableAcceleratedMemory() {
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            class Result {
+                long mem = 0L;
+            };
+            final Result res = new Result();
+            rq.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    res.mem = getAvailableAcceleratedMemoryNative(getScreen());
+                }
+            });
+            return (int)res.mem;
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    @Override
+    public GraphicsConfiguration[] getConfigurations() {
+        if (configs == null) {
+            if (isD3DEnabledOnDevice()) {
+                defaultConfig = getDefaultConfiguration();
+                if (defaultConfig != null) {
+                    configs = new GraphicsConfiguration[1];
+                    configs[0] = defaultConfig;
+                    return configs;
+                }
+            }
+        }
+        return super.getConfigurations();
+    }
+
+    @Override
+    public GraphicsConfiguration getDefaultConfiguration() {
+        if (defaultConfig == null) {
+            if (isD3DEnabledOnDevice()) {
+                defaultConfig = new D3DGraphicsConfig(this);
+            } else {
+                defaultConfig = super.getDefaultConfiguration();
+            }
+        }
+        return defaultConfig;
+    }
+
+    private static native boolean isD3DAvailableOnDeviceNative(int screen);
+    // REMIND: this method is not used now, we use caps instead
+    public static boolean isD3DAvailableOnDevice(final int screen) {
+        if (!d3dAvailable) {
+            return false;
+        }
+
+        // REMIND: should we cache the result per device somehow,
+        // and then reset and retry it on display change?
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            class Result {
+                boolean avail = false;
+            };
+            final Result res = new Result();
+            rq.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    res.avail = isD3DAvailableOnDeviceNative(screen);
+                }
+            });
+            return res.avail;
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    D3DContext getContext() {
+        return context;
+    }
+
+    ContextCapabilities getContextCapabilities() {
+        return d3dCaps;
+    }
+
+    @Override
+    public void displayChanged() {
+        super.displayChanged();
+        // REMIND: make sure this works when the device is lost and we don't
+        // disable d3d too eagerly
+        if (d3dAvailable) {
+            d3dCaps = getDeviceCaps(getScreen());
+        }
+    }
+
+    @Override
+    protected void invalidate(int defaultScreen) {
+        super.invalidate(defaultScreen);
+        // REMIND: this is a bit excessive, isD3DEnabledOnDevice will return
+        // false anyway because the device is invalid
+        d3dCaps = new D3DContextCaps(CAPS_EMPTY, null);
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DMaskBlit.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DMaskBlit.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DMaskBlit.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DMaskBlit.java	2011-01-08 01:26:50.467202167 +0000
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.d3d;
+
+import java.awt.Composite;
+import sun.java2d.SurfaceData;
+import sun.java2d.loops.CompositeType;
+import sun.java2d.loops.GraphicsPrimitive;
+import sun.java2d.loops.GraphicsPrimitiveMgr;
+import sun.java2d.loops.SurfaceType;
+import sun.java2d.pipe.Region;
+import sun.java2d.pipe.BufferedMaskBlit;
+import static sun.java2d.loops.CompositeType.*;
+import static sun.java2d.loops.SurfaceType.*;
+
+class D3DMaskBlit extends BufferedMaskBlit {
+
+    static void register() {
+        GraphicsPrimitive[] primitives = {
+            new D3DMaskBlit(IntArgb,    SrcOver),
+            new D3DMaskBlit(IntArgbPre, SrcOver),
+            new D3DMaskBlit(IntRgb,     SrcOver),
+            new D3DMaskBlit(IntRgb,     SrcNoEa),
+            new D3DMaskBlit(IntBgr,     SrcOver),
+            new D3DMaskBlit(IntBgr,     SrcNoEa),
+        };
+        GraphicsPrimitiveMgr.register(primitives);
+    }
+
+    private D3DMaskBlit(SurfaceType srcType,
+                        CompositeType compType)
+    {
+        super(D3DRenderQueue.getInstance(),
+              srcType, compType, D3DSurfaceData.D3DSurface);
+    }
+
+    @Override
+    protected void validateContext(SurfaceData dstData,
+                                   Composite comp, Region clip)
+    {
+        D3DSurfaceData d3dDst = (D3DSurfaceData)dstData;
+        D3DContext.validateContext(d3dDst, d3dDst,
+                                   clip, comp, null, null, null,
+                                   D3DContext.NO_CONTEXT_FLAGS);
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DMaskFill.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DMaskFill.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DMaskFill.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DMaskFill.java	2011-01-08 01:26:50.467202167 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,115 +25,51 @@
 
 package sun.java2d.d3d;
 
-import java.awt.AlphaComposite;
 import java.awt.Composite;
 import sun.java2d.SunGraphics2D;
-import sun.java2d.SurfaceData;
 import sun.java2d.loops.GraphicsPrimitive;
 import sun.java2d.loops.GraphicsPrimitiveMgr;
 import sun.java2d.loops.CompositeType;
 import sun.java2d.loops.SurfaceType;
-import sun.java2d.loops.MaskFill;
-import static sun.java2d.d3d.D3DSurfaceData.*;
+import sun.java2d.pipe.BufferedMaskFill;
+import static sun.java2d.loops.CompositeType.*;
+import static sun.java2d.loops.SurfaceType.*;
 
-/**
- * The MaskFill operation is expressed as:
- *   dst = ((src <MODE> dst) * pathA) + (dst * (1 - pathA))
- *
- * The D3D implementation of the MaskFill operation differs from the above
- * equation because it is not possible to perform such a complex operation in
- * D3d (without the use of advanced techniques like fragment shaders and
- * multitexturing).  Therefore, the D3DMaskFill operation is expressed as:
- *   dst = (src * pathA) <SrcOver> dst
- *
- * This simplified formula is only equivalent to the "true" MaskFill equation
- * in the following situations:
- *   - <MODE> is SrcOver
- *   - <MODE> is Src, extra alpha == 1.0, and the source color is opaque
- *
- * Therefore, we register D3DMaskFill primitives for only the SurfaceType and
- * CompositeType restrictions mentioned above.  In addition for the Src
- * case, we must override the composite with a SrcOver (no extra alpha)
- * instance, so that we set up the D3d blending mode to match the
- * D3DMaskFill equation.
- */
-public class D3DMaskFill extends MaskFill {
+class D3DMaskFill extends BufferedMaskFill {
 
-    public static void register() {
+    static void register() {
         GraphicsPrimitive[] primitives = {
-            new D3DMaskFill(SurfaceType.AnyColor,
-                            CompositeType.SrcOver,
-                            IntRgbD3D),
-            new D3DMaskFill(SurfaceType.OpaqueColor,
-                            CompositeType.SrcNoEa,
-                            IntRgbD3D),
-
-            new D3DMaskFill(SurfaceType.AnyColor,
-                            CompositeType.SrcOver,
-                            Ushort565RgbD3D),
-            new D3DMaskFill(SurfaceType.OpaqueColor,
-                            CompositeType.SrcNoEa,
-                            Ushort565RgbD3D),
-
-            new D3DMaskFill(SurfaceType.AnyColor,
-                            CompositeType.SrcOver,
-                            IntRgbxD3D),
-            new D3DMaskFill(SurfaceType.OpaqueColor,
-                            CompositeType.SrcNoEa,
-                            IntRgbxD3D),
-
-            new D3DMaskFill(SurfaceType.AnyColor,
-                            CompositeType.SrcOver,
-                            Ushort555RgbD3D),
-            new D3DMaskFill(SurfaceType.OpaqueColor,
-                            CompositeType.SrcNoEa,
-                            Ushort555RgbD3D),
-
-            new D3DMaskFill(SurfaceType.AnyColor,
-                            CompositeType.SrcOver,
-                            Ushort555RgbxD3D),
-            new D3DMaskFill(SurfaceType.OpaqueColor,
-                            CompositeType.SrcNoEa,
-                            Ushort555RgbxD3D),
-
-            new D3DMaskFill(SurfaceType.AnyColor,
-                            CompositeType.SrcOver,
-                            ThreeByteBgrD3D),
-            new D3DMaskFill(SurfaceType.OpaqueColor,
-                            CompositeType.SrcNoEa,
-                            ThreeByteBgrD3D),
+            new D3DMaskFill(AnyColor,                  SrcOver),
+            new D3DMaskFill(OpaqueColor,               SrcNoEa),
+            new D3DMaskFill(GradientPaint,             SrcOver),
+            new D3DMaskFill(OpaqueGradientPaint,       SrcNoEa),
+            new D3DMaskFill(LinearGradientPaint,       SrcOver),
+            new D3DMaskFill(OpaqueLinearGradientPaint, SrcNoEa),
+            new D3DMaskFill(RadialGradientPaint,       SrcOver),
+            new D3DMaskFill(OpaqueRadialGradientPaint, SrcNoEa),
+            new D3DMaskFill(TexturePaint,              SrcOver),
+            new D3DMaskFill(OpaqueTexturePaint,        SrcNoEa),
         };
         GraphicsPrimitiveMgr.register(primitives);
     }
 
-    D3DMaskFill(SurfaceType srcType, CompositeType compType,
-                SurfaceType dstType) {
-        super(srcType, compType, dstType);
+    protected D3DMaskFill(SurfaceType srcType, CompositeType compType) {
+        super(D3DRenderQueue.getInstance(),
+              srcType, compType, D3DSurfaceData.D3DSurface);
     }
 
-    private native void MaskFill(long pData, long pCtx,
-                                 int x, int y, int w, int h,
-                                 byte[] mask, int maskoff, int maskscan);
+    @Override
+    protected native void maskFill(int x, int y, int w, int h,
+                                   int maskoff, int maskscan, int masklen,
+                                   byte[] mask);
 
     @Override
-    public void MaskFill(SunGraphics2D sg2d, SurfaceData sData,
-                         Composite comp,
-                         int x, int y, int w, int h,
-                         byte[] mask, int maskoff, int maskscan)
+    protected void validateContext(SunGraphics2D sg2d,
+                                   Composite comp, int ctxflags)
     {
-        AlphaComposite acomp = (AlphaComposite)comp;
-        if (acomp.getRule() != AlphaComposite.SRC_OVER) {
-            comp = AlphaComposite.SrcOver;
-        }
-
-        synchronized (D3DContext.LOCK) {
-            long pCtx = D3DContext.getContext(sData, sData,
-                                              sg2d.getCompClip(), comp,
-                                              null, sg2d.eargb,
-                                              D3DContext.NO_CONTEXT_FLAGS);
-
-            MaskFill(sData.getNativeOps(), pCtx, x, y, w, h,
-                     mask, maskoff, maskscan);
-        }
+        D3DSurfaceData dstData = (D3DSurfaceData)sg2d.surfaceData;
+        D3DContext.validateContext(dstData, dstData,
+                                   sg2d.getCompClip(), comp,
+                                   null, sg2d.paint, sg2d, ctxflags);
     }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DPaints.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DPaints.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DPaints.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DPaints.java	2011-01-08 01:26:50.467202167 +0000
@@ -0,0 +1,233 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.d3d;
+
+import java.awt.LinearGradientPaint;
+import java.awt.MultipleGradientPaint;
+import java.awt.MultipleGradientPaint.ColorSpaceType;
+import java.awt.MultipleGradientPaint.CycleMethod;
+import java.awt.TexturePaint;
+import java.awt.image.BufferedImage;
+import java.util.HashMap;
+import java.util.Map;
+import sun.java2d.SunGraphics2D;
+import sun.java2d.SurfaceData;
+import sun.java2d.loops.CompositeType;
+import static sun.java2d.d3d.D3DContext.D3DContextCaps.*;
+
+abstract class D3DPaints {
+
+    /**
+     * Holds all registered implementations, using the corresponding
+     * SunGraphics2D.PAINT_* constant as the hash key.
+     */
+    private static Map<Integer, D3DPaints> impls =
+        new HashMap<Integer, D3DPaints>(4, 1.0f);
+
+    static {
+        impls.put(SunGraphics2D.PAINT_GRADIENT, new Gradient());
+        impls.put(SunGraphics2D.PAINT_LIN_GRADIENT, new LinearGradient());
+        impls.put(SunGraphics2D.PAINT_RAD_GRADIENT, new RadialGradient());
+        impls.put(SunGraphics2D.PAINT_TEXTURE, new Texture());
+    }
+
+    /**
+     * Attempts to locate an implementation corresponding to the paint state
+     * of the provided SunGraphics2D object.  If no implementation can be
+     * found, or if the paint cannot be accelerated under the conditions
+     * of the SunGraphics2D, this method returns false; otherwise, returns
+     * true.
+     */
+    static boolean isValid(SunGraphics2D sg2d) {
+        D3DPaints impl = impls.get(sg2d.paintState);
+        return (impl != null && impl.isPaintValid(sg2d));
+    }
+
+    /**
+     * Returns true if this implementation is able to accelerate the
+     * Paint object associated with, and under the conditions of, the
+     * provided SunGraphics2D instance; otherwise returns false.
+     */
+    abstract boolean isPaintValid(SunGraphics2D sg2d);
+
+/************************* GradientPaint support ****************************/
+
+    private static class Gradient extends D3DPaints {
+        private Gradient() {}
+
+        /**
+         * Returns true if the given GradientPaint instance can be
+         * used by the accelerated D3DPaints.Gradient implementation.
+         * A GradientPaint is considered valid only if the destination
+         * has support for fragment shaders.
+         */
+        @Override
+        boolean isPaintValid(SunGraphics2D sg2d) {
+            D3DSurfaceData dstData = (D3DSurfaceData)sg2d.surfaceData;
+            D3DGraphicsDevice gd = (D3DGraphicsDevice)
+                dstData.getDeviceConfiguration().getDevice();
+            return gd.isCapPresent(CAPS_LCD_SHADER);
+        }
+    }
+
+/************************** TexturePaint support ****************************/
+
+    private static class Texture extends D3DPaints {
+        private Texture() {}
+
+        /**
+         * Returns true if the given TexturePaint instance can be used by the
+         * accelerated BufferedPaints.Texture implementation.
+         *
+         * A TexturePaint is considered valid if the following conditions
+         * are met:
+         *   - the texture image dimensions are power-of-two
+         *   - the texture image can be (or is already) cached in a D3D
+         *     texture object
+         */
+        @Override
+        public boolean isPaintValid(SunGraphics2D sg2d) {
+            TexturePaint paint = (TexturePaint)sg2d.paint;
+            D3DSurfaceData dstData = (D3DSurfaceData)sg2d.surfaceData;
+            BufferedImage bi = paint.getImage();
+
+            // verify that the texture image dimensions are pow2
+            D3DGraphicsDevice gd =
+                (D3DGraphicsDevice)dstData.getDeviceConfiguration().getDevice();
+            int imgw = bi.getWidth();
+            int imgh = bi.getHeight();
+            if (!gd.isCapPresent(CAPS_TEXNONPOW2)) {
+                if ((imgw & (imgw - 1)) != 0 || (imgh & (imgh - 1)) != 0) {
+                    return false;
+                }
+            }
+            // verify that the texture image is square if it has to be
+            if (!gd.isCapPresent(CAPS_TEXNONSQUARE) && imgw != imgh)
+            {
+                return false;
+            }
+
+            SurfaceData srcData =
+                dstData.getSourceSurfaceData(bi, sg2d.TRANSFORM_ISIDENT,
+                                             CompositeType.SrcOver, null);
+            if (!(srcData instanceof D3DSurfaceData)) {
+                // REMIND: this is a hack that attempts to cache the system
+                //         memory image from the TexturePaint instance into a
+                //         D3D texture...
+                srcData =
+                    dstData.getSourceSurfaceData(bi, sg2d.TRANSFORM_ISIDENT,
+                                                 CompositeType.SrcOver, null);
+                if (!(srcData instanceof D3DSurfaceData)) {
+                    return false;
+                }
+            }
+
+            // verify that the source surface is actually a texture
+            D3DSurfaceData d3dData = (D3DSurfaceData)srcData;
+            if (d3dData.getType() != D3DSurfaceData.TEXTURE) {
+                return false;
+            }
+
+            return true;
+        }
+    }
+
+/****************** Shared MultipleGradientPaint support ********************/
+
+    private static abstract class MultiGradient extends D3DPaints {
+
+        /**
+         * Note that this number is lower than the MULTI_MAX_FRACTIONS
+         * defined in the superclass.  The D3D pipeline now uses a
+         * slightly more complicated shader (to avoid the gradient banding
+         * issues), which has a higher instruction count.  To ensure that
+         * all versions of the shader can be compiled for PS 2.0 hardware,
+         * we need to cap this maximum value at 8.
+         */
+        public static final int MULTI_MAX_FRACTIONS_D3D = 8;
+
+        protected MultiGradient() {}
+
+        /**
+         * Returns true if the given MultipleGradientPaint instance can be
+         * used by the accelerated D3DPaints.MultiGradient implementation.
+         * A MultipleGradientPaint is considered valid if the following
+         * conditions are met:
+         *   - the number of gradient "stops" is <= MAX_FRACTIONS
+         *   - the destination has support for fragment shaders
+         */
+        @Override
+        boolean isPaintValid(SunGraphics2D sg2d) {
+            MultipleGradientPaint paint = (MultipleGradientPaint)sg2d.paint;
+            // REMIND: ugh, this creates garbage; would be nicer if
+            // we had a MultipleGradientPaint.getNumStops() method...
+            if (paint.getFractions().length > MULTI_MAX_FRACTIONS_D3D) {
+                return false;
+            }
+
+            D3DSurfaceData dstData = (D3DSurfaceData)sg2d.surfaceData;
+            D3DGraphicsDevice gd = (D3DGraphicsDevice)
+                dstData.getDeviceConfiguration().getDevice();
+            if (!gd.isCapPresent(CAPS_LCD_SHADER)) {
+                return false;
+            }
+            return true;
+        }
+    }
+
+/********************** LinearGradientPaint support *************************/
+
+    private static class LinearGradient extends MultiGradient {
+        private LinearGradient() {}
+
+        @Override
+        boolean isPaintValid(SunGraphics2D sg2d) {
+            LinearGradientPaint paint = (LinearGradientPaint)sg2d.paint;
+
+            if (paint.getFractions().length == 2 &&
+                paint.getCycleMethod() != CycleMethod.REPEAT &&
+                paint.getColorSpace() != ColorSpaceType.LINEAR_RGB)
+            {
+                D3DSurfaceData dstData = (D3DSurfaceData)sg2d.surfaceData;
+                D3DGraphicsDevice gd = (D3DGraphicsDevice)
+                    dstData.getDeviceConfiguration().getDevice();
+                if (gd.isCapPresent(CAPS_LCD_SHADER)) {
+                    // we can delegate to the optimized two-color gradient
+                    // codepath, which should be faster
+                    return true;
+                }
+            }
+
+            return super.isPaintValid(sg2d);
+        }
+    }
+
+/********************** RadialGradientPaint support *************************/
+
+    private static class RadialGradient extends MultiGradient {
+        private RadialGradient() {}
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DRenderer.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DRenderer.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DRenderer.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DRenderer.java	2011-01-08 01:26:50.467202167 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,341 +25,169 @@
 
 package sun.java2d.d3d;
 
-import java.awt.Composite;
-import java.awt.Polygon;
-import java.awt.Shape;
-import java.awt.geom.AffineTransform;
-import java.awt.geom.Arc2D;
-import java.awt.geom.Ellipse2D;
-import java.awt.geom.IllegalPathStateException;
-import java.awt.geom.PathIterator;
-import java.awt.geom.RoundRectangle2D;
+import java.awt.Transparency;
+import java.awt.geom.Path2D;
 import sun.java2d.SunGraphics2D;
-import sun.java2d.pipe.Region;
-import sun.java2d.SurfaceData;
 import sun.java2d.loops.GraphicsPrimitive;
-import sun.java2d.pipe.LoopPipe;
-import sun.java2d.pipe.ShapeSpanIterator;
+import sun.java2d.pipe.BufferedPaints;
+import sun.java2d.pipe.BufferedRenderPipe;
+import sun.java2d.pipe.RenderQueue;
 import sun.java2d.pipe.SpanIterator;
+import sun.java2d.pipe.ParallelogramPipe;
+import static sun.java2d.pipe.BufferedOpCodes.*;
 
-import static sun.java2d.d3d.D3DContext.*;
-import sun.java2d.windows.DDRenderer;
+class D3DRenderer extends BufferedRenderPipe {
 
-public class D3DRenderer extends DDRenderer {
-
-    native boolean doDrawLineD3D(long pData, long pCtx,
-                                 int x1, int y1, int x2, int y2);
-    native boolean doDrawRectD3D(long pData, long pCtx,
-                                 int x, int y, int w, int h);
-    native boolean doFillRectD3D(long pData, long pCtx, int x, int y,
-                                 int width, int height);
-    native void doDrawPoly(long pData, long pCtx, int transx, int transy,
-                           int[] xpoints, int[] ypoints,
-                           int npoints, boolean isclosed);
-    native void devFillSpans(long pData, long pCtx, SpanIterator si,
-                             long iterator, int transx, int transy);
-
-
-    private long getContext(SunGraphics2D sg2d) {
-        AffineTransform at =
-            sg2d.transformState < sg2d.TRANSFORM_TRANSLATESCALE ?
-            null : sg2d.transform;
-        int ctxflags = (sg2d.eargb >>> 24) == 0xff ?
-            SRC_IS_OPAQUE : NO_CONTEXT_FLAGS;
-        return D3DContext.getContext(null, sg2d.surfaceData,
-                                     sg2d.getCompClip(),
-                                     sg2d.getComposite(),
-                                     at,
-                                     sg2d.eargb,
-                                     ctxflags);
+    D3DRenderer(RenderQueue rq) {
+        super(rq);
     }
 
     @Override
-    public void drawLine(SunGraphics2D sg2d,
-                         int x1, int y1, int x2, int y2)
-    {
-        synchronized (D3DContext.LOCK) {
-            doDrawLineD3D(sg2d.surfaceData.getNativeOps(),
-                          getContext(sg2d),
-                          x1 + sg2d.transX, y1 + sg2d.transY,
-                          x2 + sg2d.transX, y2 + sg2d.transY);
-        }
+    protected void validateContext(SunGraphics2D sg2d) {
+        int ctxflags =
+            sg2d.paint.getTransparency() == Transparency.OPAQUE ?
+                D3DContext.SRC_IS_OPAQUE : D3DContext.NO_CONTEXT_FLAGS;
+        D3DSurfaceData dstData = (D3DSurfaceData)sg2d.surfaceData;
+        D3DContext.validateContext(dstData, dstData,
+                                   sg2d.getCompClip(), sg2d.composite,
+                                   null, sg2d.paint, sg2d, ctxflags);
     }
 
     @Override
-    public void fillRect(SunGraphics2D sg2d,
-                         int x, int y, int width, int height)
-    {
-        synchronized (D3DContext.LOCK) {
-            doFillRectD3D(sg2d.surfaceData.getNativeOps(),
-                          getContext(sg2d),
-                          sg2d.transX + x, sg2d.transY + y, width, height);
-        }
+    protected void validateContextAA(SunGraphics2D sg2d) {
+        int ctxflags = D3DContext.NO_CONTEXT_FLAGS;
+        D3DSurfaceData dstData = (D3DSurfaceData)sg2d.surfaceData;
+        D3DContext.validateContext(dstData, dstData,
+                                   sg2d.getCompClip(), sg2d.composite,
+                                   null, sg2d.paint, sg2d, ctxflags);
     }
 
-    @Override
-    public void drawRect(SunGraphics2D sg2d,
-                         int x, int y, int width, int height)
+    void copyArea(SunGraphics2D sg2d,
+                  int x, int y, int w, int h, int dx, int dy)
     {
-        synchronized (D3DContext.LOCK) {
-            doDrawRectD3D(sg2d.surfaceData.getNativeOps(),
-                          getContext(sg2d),
-                          x + sg2d.transX, sg2d.transY + y, width, height);
-        }
-    }
-
-    @Override
-    public void drawPolyline(SunGraphics2D sg2d,
-                             int xpoints[], int ypoints[], int npoints)
-    {
-        synchronized (D3DContext.LOCK) {
-            doDrawPoly(sg2d.surfaceData.getNativeOps(),
-                       getContext(sg2d),
-                       sg2d.transX, sg2d.transY,
-                       xpoints, ypoints, npoints, false);
-        }
-    }
-
-    @Override
-    public void drawPolygon(SunGraphics2D sg2d,
-                            int xpoints[], int ypoints[], int npoints)
-    {
-        synchronized (D3DContext.LOCK) {
-            doDrawPoly(sg2d.surfaceData.getNativeOps(),
-                       getContext(sg2d),
-                       sg2d.transX, sg2d.transY,
-                       xpoints, ypoints, npoints, true);
+        rq.lock();
+        try {
+            int ctxflags =
+                sg2d.surfaceData.getTransparency() == Transparency.OPAQUE ?
+                    D3DContext.SRC_IS_OPAQUE : D3DContext.NO_CONTEXT_FLAGS;
+            D3DSurfaceData dstData = (D3DSurfaceData)sg2d.surfaceData;
+            D3DContext.validateContext(dstData, dstData,
+                                       sg2d.getCompClip(), sg2d.composite,
+                                       null, null, null, ctxflags);
+
+            rq.ensureCapacity(28);
+            buf.putInt(COPY_AREA);
+            buf.putInt(x).putInt(y).putInt(w).putInt(h);
+            buf.putInt(dx).putInt(dy);
+        } finally {
+            rq.unlock();
         }
     }
 
-    @Override
-    public void drawRoundRect(SunGraphics2D sg2d,
-                              int x, int y, int width, int height,
-                              int arcWidth, int arcHeight)
-    {
-        draw(sg2d, new RoundRectangle2D.Float(x, y, width, height,
-                                              arcWidth, arcHeight));
-    }
-
-    @Override
-    public void drawOval(SunGraphics2D sg2d,
-                         int x, int y, int width, int height)
-    {
-        draw(sg2d, new Ellipse2D.Float(x, y, width, height));
-    }
-
-    @Override
-    public void drawArc(SunGraphics2D sg2d,
-                        int x, int y, int width, int height,
-                        int startAngle, int arcAngle)
-    {
-        draw(sg2d, new Arc2D.Float(x, y, width, height,
-                                   startAngle, arcAngle,
-                                   Arc2D.OPEN));
-    }
-
-    @Override
-    public void fillRoundRect(SunGraphics2D sg2d,
-                              int x, int y, int width, int height,
-                              int arcWidth, int arcHeight)
-    {
-        fill(sg2d, new RoundRectangle2D.Float(x, y, width, height,
-             arcWidth, arcHeight));
-    }
-
-    @Override
-    public void fillOval(SunGraphics2D sg2d,
-                         int x, int y, int width, int height)
-    {
-        fill(sg2d, new Ellipse2D.Float(x, y, width, height));
-    }
+    protected native void drawPoly(int[] xPoints, int[] yPoints,
+                                   int nPoints, boolean isClosed,
+                                   int transX, int transY);
 
-    @Override
-    public void fillArc(SunGraphics2D sg2d,
-                        int x, int y, int width, int height,
-                        int startAngle, int arcAngle)
-    {
-        fill(sg2d, new Arc2D.Float(x, y, width, height,
-             startAngle, arcAngle, Arc2D.PIE));
-    }
-
-    @Override
-    public void fillPolygon(SunGraphics2D sg2d,
-                            int xpoints[], int ypoints[],
-                            int npoints)
-    {
-        fill(sg2d, new Polygon(xpoints, ypoints, npoints));
+    D3DRenderer traceWrap() {
+        return new Tracer(this);
     }
 
-    @Override
-    public void draw(SunGraphics2D sg2d, Shape s)
-    {
-        if (sg2d.strokeState == sg2d.STROKE_THIN) {
-            Polygon p;
-            if (s instanceof Polygon) {
-                p = (Polygon) s;
-                drawPolygon(sg2d, p.xpoints, p.ypoints, p.npoints);
-                return;
-            }
-            // we're letting d3d handle the transforms
-            PathIterator pi = s.getPathIterator(null, 0.5f);
-            p = new Polygon();
-            float coords[] = new float[2];
-            while (!pi.isDone()) {
-                switch (pi.currentSegment(coords)) {
-                    case PathIterator.SEG_MOVETO:
-                        if (p.npoints > 1) {
-                            drawPolyline(sg2d, p.xpoints, p.ypoints, p.npoints);
-                        }
-                        p.reset();
-                        p.addPoint((int) Math.floor(coords[0]),
-                            (int) Math.floor(coords[1]));
-                        break;
-                    case PathIterator.SEG_LINETO:
-                        if (p.npoints == 0) {
-                            throw new IllegalPathStateException
-                                ("missing initial moveto in path definition");
-                        }
-                        p.addPoint((int) Math.floor(coords[0]),
-                            (int) Math.floor(coords[1]));
-                        break;
-                    case PathIterator.SEG_CLOSE:
-                        if (p.npoints > 0) {
-                            p.addPoint(p.xpoints[0], p.ypoints[0]);
-                        }
-                        break;
-                    default:
-                        throw new
-                            IllegalPathStateException("path not flattened");
+    private class Tracer extends D3DRenderer {
+        private D3DRenderer d3dr;
+        Tracer(D3DRenderer d3dr) {
+            super(d3dr.rq);
+            this.d3dr = d3dr;
+        }
+        public ParallelogramPipe getAAParallelogramPipe() {
+            final ParallelogramPipe realpipe = d3dr.getAAParallelogramPipe();
+            return new ParallelogramPipe() {
+                public void fillParallelogram(SunGraphics2D sg2d,
+                                              double x, double y,
+                                              double dx1, double dy1,
+                                              double dx2, double dy2)
+                {
+                    GraphicsPrimitive.tracePrimitive("D3DFillAAParallelogram");
+                    realpipe.fillParallelogram(sg2d,
+                                               x, y, dx1, dy1, dx2, dy2);
                 }
-                pi.next();
-            }
-            if (p.npoints > 1) {
-                drawPolyline(sg2d, p.xpoints, p.ypoints, p.npoints);
-            }
-        } else if (sg2d.strokeState < sg2d.STROKE_CUSTOM) {
-            ShapeSpanIterator si = LoopPipe.getStrokeSpans(sg2d, s);
-            try {
-                synchronized (D3DContext.LOCK) {
-                    int ctxflags = (sg2d.eargb >>> 24) == 0xff ?
-                        SRC_IS_OPAQUE : NO_CONTEXT_FLAGS;
-                    // in this case the spans will be pre-transformed, so we
-                    // pass null transform to getContext
-                    long pCtx = D3DContext.getContext(null, sg2d.surfaceData,
-                                                      sg2d.getCompClip(),
-                                                      sg2d.getComposite(),
-                                                      null /*transform*/,
-                                                      sg2d.eargb/*pixel*/,
-                                                      ctxflags);
-                    devFillSpans(sg2d.surfaceData.getNativeOps(), pCtx, si,
-                                 si.getNativeIterator(), 0, 0);
+                public void drawParallelogram(SunGraphics2D sg2d,
+                                              double x, double y,
+                                              double dx1, double dy1,
+                                              double dx2, double dy2,
+                                              double lw1, double lw2)
+                {
+                    GraphicsPrimitive.tracePrimitive("D3DDrawAAParallelogram");
+                    realpipe.drawParallelogram(sg2d,
+                                               x, y, dx1, dy1, dx2, dy2,
+                                               lw1, lw2);
                 }
-            } finally {
-                si.dispose();
-            }
-        } else {
-            fill(sg2d, sg2d.stroke.createStrokedShape(s));
-        }
-    }
-
-    @Override
-    public void fill(SunGraphics2D sg2d, Shape s) {
-        AffineTransform at;
-        int transx, transy;
-
-        if ( sg2d.transformState < sg2d.TRANSFORM_TRANSLATESCALE) {
-            // Transform (translation) will be done by devFillSpans
-            at = null;
-            transx = sg2d.transX;
-            transy = sg2d.transY;
-        } else {
-            // Transform will be done by the PathIterator
-            at = sg2d.transform;
-            transx = transy = 0;
+            };
         }
 
-        ShapeSpanIterator ssi = LoopPipe.getFillSSI(sg2d);
-        try {
-            // Subtract transx/y from the SSI clip to match the
-            // (potentially untranslated) geometry fed to it
-            Region clip = sg2d.getCompClip();
-            ssi.setOutputAreaXYXY(clip.getLoX() - transx,
-                                  clip.getLoY() - transy,
-                                  clip.getHiX() - transx,
-                                  clip.getHiY() - transy);
-            ssi.appendPath(s.getPathIterator(at));
-            synchronized (D3DContext.LOCK) {
-                int ctxflags = (sg2d.eargb >>> 24) == 0xff ?
-                    SRC_IS_OPAQUE : NO_CONTEXT_FLAGS;
-                long pCtx = D3DContext.getContext(null, sg2d.surfaceData,
-                                                  sg2d.getCompClip(),
-                                                  sg2d.getComposite(),
-                                                  null/*transform*/,
-                                                  sg2d.eargb/*pixel*/,
-                                                  ctxflags);
-                devFillSpans(sg2d.surfaceData.getNativeOps(), pCtx, ssi,
-                             ssi.getNativeIterator(),
-                             transx, transy);
-            }
-        } finally {
-            ssi.dispose();
+        protected void validateContext(SunGraphics2D sg2d) {
+            d3dr.validateContext(sg2d);
         }
-    }
-
-    D3DRenderer traceWrapD3D() {
-        return new Tracer();
-    }
-
-    private class Tracer extends D3DRenderer {
-        @Override
         public void drawLine(SunGraphics2D sg2d,
                              int x1, int y1, int x2, int y2)
         {
             GraphicsPrimitive.tracePrimitive("D3DDrawLine");
-            super.drawLine(sg2d, x1, y1, x2, y2);
+            d3dr.drawLine(sg2d, x1, y1, x2, y2);
         }
-        @Override
         public void drawRect(SunGraphics2D sg2d, int x, int y, int w, int h) {
             GraphicsPrimitive.tracePrimitive("D3DDrawRect");
-            super.drawRect(sg2d, x, y, w, h);
-        }
-        @Override
-        public void drawPolyline(SunGraphics2D sg2d,
-                                 int[] xPoints, int[] yPoints,
-                                 int nPoints)
-        {
-            GraphicsPrimitive.tracePrimitive("D3DDrawPolyline");
-            super.drawPolyline(sg2d, xPoints, yPoints, nPoints);
+            d3dr.drawRect(sg2d, x, y, w, h);
         }
-        @Override
-        public void drawPolygon(SunGraphics2D sg2d,
+        protected void drawPoly(SunGraphics2D sg2d,
                                 int[] xPoints, int[] yPoints,
-                                int nPoints)
+                                int nPoints, boolean isClosed)
         {
-            GraphicsPrimitive.tracePrimitive("D3DDrawPolygon");
-            super.drawPolygon(sg2d, xPoints, yPoints, nPoints);
+            GraphicsPrimitive.tracePrimitive("D3DDrawPoly");
+            d3dr.drawPoly(sg2d, xPoints, yPoints, nPoints, isClosed);
         }
-        @Override
         public void fillRect(SunGraphics2D sg2d, int x, int y, int w, int h) {
             GraphicsPrimitive.tracePrimitive("D3DFillRect");
-            super.fillRect(sg2d, x, y, w, h);
+            d3dr.fillRect(sg2d, x, y, w, h);
         }
-        @Override
-        void devFillSpans(long pData, long pCtx, SpanIterator si, long iterator,
-                          int transx, int transy)
+        protected void drawPath(SunGraphics2D sg2d,
+                                Path2D.Float p2df, int transx, int transy)
+        {
+            GraphicsPrimitive.tracePrimitive("D3DDrawPath");
+            d3dr.drawPath(sg2d, p2df, transx, transy);
+        }
+        protected void fillPath(SunGraphics2D sg2d,
+                                Path2D.Float p2df, int transx, int transy)
+        {
+            GraphicsPrimitive.tracePrimitive("D3DFillPath");
+            d3dr.fillPath(sg2d, p2df, transx, transy);
+        }
+        protected void fillSpans(SunGraphics2D sg2d, SpanIterator si,
+                                 int transx, int transy)
         {
             GraphicsPrimitive.tracePrimitive("D3DFillSpans");
-            super.devFillSpans(pData, pCtx, si, iterator, transx, transy);
+            d3dr.fillSpans(sg2d, si, transx, transy);
         }
-        @Override
-        public void devCopyArea(SurfaceData sData,
-                                int srcx, int srcy,
-                                int dx, int dy,
-                                int w, int h)
+        public void fillParallelogram(SunGraphics2D sg2d,
+                                      double x, double y,
+                                      double dx1, double dy1,
+                                      double dx2, double dy2)
         {
-            GraphicsPrimitive.tracePrimitive("DXCopyArea");
-            super.devCopyArea(sData, srcx, srcy, dx, dy, w, h);
+            GraphicsPrimitive.tracePrimitive("D3DFillParallelogram");
+            d3dr.fillParallelogram(sg2d, x, y, dx1, dy1, dx2, dy2);
+        }
+        public void drawParallelogram(SunGraphics2D sg2d,
+                                      double x, double y,
+                                      double dx1, double dy1,
+                                      double dx2, double dy2,
+                                      double lw1, double lw2)
+        {
+            GraphicsPrimitive.tracePrimitive("D3DDrawParallelogram");
+            d3dr.drawParallelogram(sg2d, x, y, dx1, dy1, dx2, dy2, lw1, lw2);
+        }
+        public void copyArea(SunGraphics2D sg2d,
+                             int x, int y, int w, int h, int dx, int dy)
+        {
+            GraphicsPrimitive.tracePrimitive("D3DCopyArea");
+            d3dr.copyArea(sg2d, x, y, w, h, dx, dy);
         }
-
     }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DRenderQueue.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DRenderQueue.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DRenderQueue.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DRenderQueue.java	2011-01-08 01:26:50.467202167 +0000
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.d3d;
+
+import sun.java2d.ScreenUpdateManager;
+import sun.java2d.pipe.RenderBuffer;
+import sun.java2d.pipe.RenderQueue;
+import static sun.java2d.pipe.BufferedOpCodes.*;
+
+/**
+ * D3D-specific implementation of RenderQueue.
+ */
+public class D3DRenderQueue extends RenderQueue {
+
+    private static D3DRenderQueue theInstance;
+    private static Thread rqThread;
+
+    private D3DRenderQueue() {
+    }
+
+    /**
+     * Returns the single D3DRenderQueue instance.  If it has not yet been
+     * initialized, this method will first construct the single instance
+     * before returning it.
+     */
+    public static synchronized D3DRenderQueue getInstance() {
+        if (theInstance == null) {
+            theInstance = new D3DRenderQueue();
+            // no need to lock, noone has reference to this instance yet
+            theInstance.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    rqThread = Thread.currentThread();
+                }
+            });
+        }
+        return theInstance;
+    }
+
+    /**
+     * Flushes the single D3DRenderQueue instance synchronously.  If an
+     * D3DRenderQueue has not yet been instantiated, this method is a no-op.
+     * This method is useful in the case of Toolkit.sync(), in which we want
+     * to flush the D3D pipeline, but only if the D3D pipeline is currently
+     * enabled.  Since this class has few external dependencies, callers need
+     * not be concerned that calling this method will trigger initialization
+     * of the D3D pipeline and related classes.
+     */
+    public static void sync() {
+        if (theInstance != null) {
+            // need to make sure any/all screen surfaces are presented prior
+            // to completing the sync operation
+            D3DScreenUpdateManager mgr =
+                (D3DScreenUpdateManager)ScreenUpdateManager.getInstance();
+            mgr.runUpdateNow();
+
+            theInstance.lock();
+            try {
+                theInstance.ensureCapacity(4);
+                theInstance.getBuffer().putInt(SYNC);
+                theInstance.flushNow();
+            } finally {
+                theInstance.unlock();
+            }
+        }
+    }
+
+    /**
+     * Attempt to restore the devices if they're in the lost state.
+     * (used when a full-screen window is activated/deactivated)
+     */
+    public static void restoreDevices() {
+        D3DRenderQueue rq = getInstance();
+        rq.lock();
+        try {
+            rq.ensureCapacity(4);
+            rq.getBuffer().putInt(RESTORE_DEVICES);
+            rq.flushNow();
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    /**
+     * @return true if current thread is the render queue thread,
+     * false otherwise
+     */
+    public static boolean isRenderQueueThread() {
+        return (Thread.currentThread() == rqThread);
+    }
+
+    /**
+     * Disposes the native memory associated with the given native
+     * graphics config info pointer on the single queue flushing thread.
+     */
+    public static void disposeGraphicsConfig(long pConfigInfo) {
+        D3DRenderQueue rq = getInstance();
+        rq.lock();
+        try {
+
+            RenderBuffer buf = rq.getBuffer();
+            rq.ensureCapacityAndAlignment(12, 4);
+            buf.putInt(DISPOSE_CONFIG);
+            buf.putLong(pConfigInfo);
+
+            // this call is expected to complete synchronously, so flush now
+            rq.flushNow();
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    public void flushNow() {
+        // assert lock.isHeldByCurrentThread();
+        flushBuffer(null);
+    }
+
+    public void flushAndInvokeNow(Runnable r) {
+        // assert lock.isHeldByCurrentThread();
+        flushBuffer(r);
+    }
+
+    private native void flushBuffer(long buf, int limit, Runnable task);
+
+    private void flushBuffer(Runnable task) {
+        // assert lock.isHeldByCurrentThread();
+        int limit = buf.position();
+        if (limit > 0 || task != null) {
+            // process the queue
+            flushBuffer(buf.getAddress(), limit, task);
+        }
+        // reset the buffer position
+        buf.clear();
+        // clear the set of references, since we no longer need them
+        refSet.clear();
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DScreenUpdateManager.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DScreenUpdateManager.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DScreenUpdateManager.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DScreenUpdateManager.java	2011-01-08 01:26:50.467202167 +0000
@@ -0,0 +1,552 @@
+/*
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.java2d.d3d;
+
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.Font;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.Window;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.ArrayList;
+import java.util.HashMap;
+import sun.awt.SunToolkit;
+import sun.awt.Win32GraphicsConfig;
+import sun.awt.windows.WComponentPeer;
+import sun.java2d.InvalidPipeException;
+import sun.java2d.ScreenUpdateManager;
+import sun.java2d.SunGraphics2D;
+import sun.java2d.SurfaceData;
+import sun.java2d.windows.GDIWindowSurfaceData;
+import sun.java2d.d3d.D3DSurfaceData.D3DWindowSurfaceData;
+import sun.java2d.windows.WindowsFlags;
+
+/**
+ * This class handles rendering to the screen with the D3D pipeline.
+ *
+ * Since it is not possible to render directly to the front buffer
+ * with D3D9, we create a swap chain surface (with COPY effect) in place of the
+ * GDIWindowSurfaceData. A background thread handles the swap chain flips.
+ *
+ * There are some restrictions to which windows we would use this for.
+ * @see #createScreenSurface()
+ */
+public class D3DScreenUpdateManager extends ScreenUpdateManager
+    implements Runnable
+{
+    /**
+     * A window must be at least MIN_WIN_SIZE in one or both dimensions
+     * to be considered for the update manager.
+     */
+    private static final int MIN_WIN_SIZE = 150;
+
+    private volatile boolean done;
+    private volatile Thread screenUpdater;
+    private boolean needsUpdateNow;
+
+    /**
+     * Object used by the screen updater thread for waiting
+     */
+    private Object runLock = new Object();
+    /**
+     * List of D3DWindowSurfaceData surfaces. Surfaces are added to the
+     * list when a graphics object is created, and removed when the surface
+     * is invalidated.
+     */
+    private ArrayList<D3DWindowSurfaceData> d3dwSurfaces;
+    /**
+     * Cache of GDIWindowSurfaceData surfaces corresponding to the
+     * D3DWindowSurfaceData surfaces. Surfaces are added to the list when
+     * a d3dw surface is lost and could not be restored (due to lack of vram,
+     * for example), and removed then the d3dw surface is invalidated.
+     */
+    private HashMap<D3DWindowSurfaceData, GDIWindowSurfaceData> gdiSurfaces;
+
+    public D3DScreenUpdateManager() {
+        done = false;
+        AccessController.doPrivileged(
+            new PrivilegedAction() {
+                public Object run() {
+                    ThreadGroup currentTG =
+                        Thread.currentThread().getThreadGroup();
+                    ThreadGroup parentTG = currentTG.getParent();
+                    while (parentTG != null) {
+                        currentTG = parentTG;
+                        parentTG = currentTG.getParent();
+                    }
+                    try {
+                        Runtime.getRuntime().addShutdownHook(
+                            new Thread(currentTG,
+                                new Runnable() {
+                                    public void run() {
+                                        done = true;
+                                        wakeUpUpdateThread();
+                                    }
+                                }
+                            )
+                        );
+                    } catch (Exception e) {
+                        done = true;
+                    }
+                    return null;
+                }
+            }
+        );
+    }
+
+    /**
+     * If possible, creates a D3DWindowSurfaceData (which is actually
+     * a back-buffer surface). If the creation fails, returns GDI
+     * onscreen surface instead.
+     *
+     * Note that the created D3D surface does not initialize the native
+     * resources (and is marked lost) to avoid wasting video memory. It is
+     * restored when a graphics object is requested from the peer.
+     *
+     * Note that this method is called from a synchronized block in
+     * WComponentPeer, so we don't need to synchronize
+     *
+     * Note that we only create a substibute d3dw surface if certain conditions
+     * are met
+     * <ul>
+     *  <li>the fake d3d rendering on screen is not disabled via flag
+     *  <li>d3d on the device is enabled
+     *  <li>surface is larger than MIN_WIN_SIZE (don't bother for smaller ones)
+     *  <li>it doesn't have a backBuffer for a BufferStrategy already
+     *  <li>the peer is either Canvas, Panel, Window, Frame,
+     *  Dialog or EmbeddedFrame
+     * </ul>
+     *
+     * @param gc GraphicsConfiguration on associated with the surface
+     * @param peer peer for which the surface is to be created
+     * @param bbNum number of back-buffers requested. if this number is >0,
+     * method returns GDI surface (we don't want to have two swap chains)
+     * @param isResize whether this surface is being created in response to
+     * a component resize event. This determines whether a repaint event will
+     * be issued after a surface is created: it will be if <code>isResize</code>
+     * is <code>true</code>.
+     * @return surface data to be use for onscreen rendering
+     */
+    @Override
+    public SurfaceData createScreenSurface(Win32GraphicsConfig gc,
+                                           WComponentPeer peer,
+                                           int bbNum, boolean isResize)
+    {
+        if (done || !(gc instanceof D3DGraphicsConfig)) {
+            return super.createScreenSurface(gc, peer, bbNum, isResize);
+        }
+
+        SurfaceData sd = null;
+
+        if (canUseD3DOnScreen(peer, gc, bbNum)) {
+            try {
+                // note that the created surface will be in the "lost"
+                // state, it will be restored prior to rendering to it
+                // for the first time. This is done so that vram is not
+                // wasted for surfaces never rendered to
+                sd = D3DSurfaceData.createData(peer);
+            }  catch (InvalidPipeException ipe) {
+                sd = null;
+            }
+        }
+        if (sd == null) {
+            sd = GDIWindowSurfaceData.createData(peer);
+            // note that we do not add this surface to the list of cached gdi
+            // surfaces as there's no d3dw surface to associate it with;
+            // this peer will have a gdi surface until next time a surface
+            // will need to be replaced
+        }
+
+        if (isResize) {
+            // since we'd potentially replaced the back-buffer surface
+            // (either with another bb, or a gdi one), the
+            // component will need to be completely repainted;
+            // this only need to be done when the surface is created in
+            // response to a resize event since when a component is created it
+            // will be repainted anyway
+            repaintPeerTarget(peer);
+        }
+
+        return sd;
+    }
+
+    /**
+     * Determines if we can use a d3d surface for onscreen rendering for this
+     * peer.
+     * We only create onscreen d3d surfaces if the following conditions are met:
+     *  - d3d is enabled on this device and onscreen emulation is enabled
+     *  - window is big enough to bother (either dimension > MIN_WIN_SIZE)
+     *  - this heavyweight doesn't have a BufferStrategy
+     *  - if we are in full-screen mode then it must be the peer of the
+     *    full-screen window (since there could be only one SwapChain in fs)
+     *    and it must not have any heavyweight children
+     *    (as Present() doesn't respect component clipping in fullscreen mode)
+     *  - it's one of the classes likely to have custom rendering worth
+     *    accelerating
+     *
+     * @returns true if we can use a d3d surface for this peer's onscreen
+     *          rendering
+     */
+    public static boolean canUseD3DOnScreen(final WComponentPeer peer,
+                                            final Win32GraphicsConfig gc,
+                                            final int bbNum)
+    {
+        if (!(gc instanceof D3DGraphicsConfig)) {
+            return false;
+        }
+        D3DGraphicsConfig d3dgc = (D3DGraphicsConfig)gc;
+        D3DGraphicsDevice d3dgd = d3dgc.getD3DDevice();
+        String peerName = peer.getClass().getName();
+        Rectangle r = peer.getBounds();
+        Component target = (Component)peer.getTarget();
+        Window fsw = d3dgd.getFullScreenWindow();
+
+        return
+            WindowsFlags.isD3DOnScreenEnabled() &&
+            d3dgd.isD3DEnabledOnDevice() &&
+            peer.isAccelCapable() &&
+            (r.width > MIN_WIN_SIZE || r.height > MIN_WIN_SIZE) &&
+            bbNum == 0 &&
+            (fsw == null || (fsw == target && !hasHWChildren(target))) &&
+            (peerName.equals("sun.awt.windows.WCanvasPeer") ||
+             peerName.equals("sun.awt.windows.WDialogPeer") ||
+             peerName.equals("sun.awt.windows.WPanelPeer")  ||
+             peerName.equals("sun.awt.windows.WWindowPeer") ||
+             peerName.equals("sun.awt.windows.WFramePeer")  ||
+             peerName.equals("sun.awt.windows.WEmbeddedFramePeer"));
+    }
+
+    /**
+     * Creates a graphics object for the passed in surface data. If
+     * the surface is lost, it is restored.
+     * If the surface wasn't lost or the restoration was successful
+     * the surface is added to the list of maintained surfaces
+     * (if it hasn't been already).
+     *
+     * If the updater thread hasn't been created yet , it will be created and
+     * started.
+     *
+     * @param sd surface data for which to create SunGraphics2D
+     * @param peer peer associated with the surface data
+     * @param fgColor fg color to be used in graphics
+     * @param bgColor bg color to be used in graphics
+     * @param font font to be used in graphics
+     * @return a SunGraphics2D object for the surface (or for temp GDI
+     * surface data)
+     */
+    @Override
+    public Graphics2D createGraphics(SurfaceData sd,
+            WComponentPeer peer, Color fgColor, Color bgColor, Font font)
+    {
+        if (!done && sd instanceof D3DWindowSurfaceData) {
+            D3DWindowSurfaceData d3dw = (D3DWindowSurfaceData)sd;
+            if (!d3dw.isSurfaceLost() || validate(d3dw)) {
+                trackScreenSurface(d3dw);
+                return new SunGraphics2D(sd, fgColor, bgColor, font);
+            }
+            // could not restore the d3dw surface, use the cached gdi surface
+            // instead for this graphics object; note that we do not track
+            // this new gdi surface, it is only used for this graphics
+            // object
+            sd = getGdiSurface(d3dw);
+        }
+        return super.createGraphics(sd, peer, fgColor, bgColor, font);
+    }
+
+    /**
+     * Posts a repaint event for the peer's target to the EDT
+     * @param peer for which target's the repaint should be issued
+     */
+    private void repaintPeerTarget(WComponentPeer peer) {
+        // we don't want to call user code on our priveleged
+        // thread, delegate to EDT
+        final Component target = (Component)peer.getTarget();
+        SunToolkit.executeOnEventHandlerThread(target, new Runnable() {
+            public void run() {
+                target.repaint();
+            }
+        });
+    }
+
+    /**
+     * Adds a surface to the list of tracked surfaces.
+     *
+     * @param d3dw the surface to be added
+     */
+    private void trackScreenSurface(SurfaceData sd) {
+        if (!done && sd instanceof D3DWindowSurfaceData) {
+            synchronized (this) {
+                if (d3dwSurfaces == null) {
+                    d3dwSurfaces = new ArrayList<D3DWindowSurfaceData>();
+                }
+                D3DWindowSurfaceData d3dw = (D3DWindowSurfaceData)sd;
+                if (!d3dwSurfaces.contains(d3dw)) {
+                    d3dwSurfaces.add(d3dw);
+                }
+            }
+            startUpdateThread();
+        }
+    }
+
+    @Override
+    public synchronized void dropScreenSurface(SurfaceData sd) {
+        if (d3dwSurfaces != null && sd instanceof D3DWindowSurfaceData) {
+            D3DWindowSurfaceData d3dw = (D3DWindowSurfaceData)sd;
+            removeGdiSurface(d3dw);
+            d3dwSurfaces.remove(d3dw);
+        }
+    }
+
+    @Override
+    public SurfaceData getReplacementScreenSurface(WComponentPeer peer,
+                                                   SurfaceData sd)
+    {
+        SurfaceData newSurface = super.getReplacementScreenSurface(peer, sd);
+        // if some outstanding graphics context wants to get a replacement we
+        // need to make sure that the new surface (if it is accelerated) is
+        // being tracked
+        trackScreenSurface(newSurface);
+        return newSurface;
+    }
+
+    /**
+     * Remove the gdi surface corresponding to the passed d3dw surface
+     * from list of the cached gdi surfaces.
+     *
+     * @param d3dw surface for which associated gdi surface is to be removed
+     */
+    private void removeGdiSurface(final D3DWindowSurfaceData d3dw) {
+        if (gdiSurfaces != null) {
+            GDIWindowSurfaceData gdisd = gdiSurfaces.get(d3dw);
+            if (gdisd != null) {
+                gdisd.invalidate();
+                gdiSurfaces.remove(d3dw);
+            }
+        }
+    }
+
+    /**
+     * If the update thread hasn't yet been created, it will be;
+     * otherwise it is awaken
+     */
+    private synchronized void startUpdateThread() {
+        if (screenUpdater == null) {
+            screenUpdater = (Thread)java.security.AccessController.doPrivileged(
+                new java.security.PrivilegedAction() {
+                    public Object run() {
+                        ThreadGroup tg =
+                            Thread.currentThread().getThreadGroup();
+                        for (ThreadGroup tgn = tg;
+                             tgn != null; tg = tgn, tgn = tg.getParent());
+                        Thread t = new Thread(tg, D3DScreenUpdateManager.this,
+                                              "D3D Screen Updater");
+                        // REMIND: should it be higher?
+                        t.setPriority(Thread.NORM_PRIORITY + 2);
+                        t.setDaemon(true);
+                        return t;
+                    }
+            });
+            screenUpdater.start();
+        } else {
+            wakeUpUpdateThread();
+        }
+    }
+
+    /**
+     * Wakes up the screen updater thread.
+     *
+     * This method is not synchronous, it doesn't wait
+     * for the updater thread to complete the updates.
+     *
+     * It should be used when it is not necessary to wait for the
+     * completion, for example, when a new surface had been added
+     * to the list of tracked surfaces (which means that it's about
+     * to be rendered to).
+     */
+    public void wakeUpUpdateThread() {
+        synchronized (runLock) {
+            runLock.notifyAll();
+        }
+    }
+
+    /**
+     * Wakes up the screen updater thread and waits for the completion
+     * of the update.
+     *
+     * This method is called from Toolkit.sync() or
+     * when there was a copy from a VI to the screen
+     * so that swing applications would not appear to be
+     * sluggish.
+     */
+    public void runUpdateNow() {
+        synchronized (this) {
+            // nothing to do if the updater thread hadn't been started or if
+            // there are no tracked surfaces
+            if (done || screenUpdater == null ||
+                d3dwSurfaces  == null || d3dwSurfaces.size() == 0)
+            {
+                return;
+            }
+        }
+        synchronized (runLock) {
+            needsUpdateNow = true;
+            runLock.notifyAll();
+            while (needsUpdateNow) {
+                try {
+                    runLock.wait();
+                } catch (InterruptedException e) {}
+            }
+        }
+    }
+
+    public void run() {
+        while (!done) {
+            synchronized (runLock) {
+                // If the list is empty, suspend the thread until a
+                // new surface is added. Note that we have to check before
+                // wait() (and inside the runLock), otherwise we could miss a
+                // notify() when a new surface is added and sleep forever.
+                long timeout = d3dwSurfaces.size() > 0 ? 100 : 0;
+
+                // don't go to sleep if there's a thread waiting for an update
+                if (!needsUpdateNow) {
+                    try { runLock.wait(timeout); }
+                        catch (InterruptedException e) {}
+                }
+                // if we were woken up, there are probably surfaces in the list,
+                // no need to check if the list is empty
+            }
+
+            // make a copy to avoid synchronization during the loop
+            D3DWindowSurfaceData surfaces[] = new D3DWindowSurfaceData[] {};
+            synchronized (this) {
+                surfaces = d3dwSurfaces.toArray(surfaces);
+            }
+            for (D3DWindowSurfaceData sd : surfaces) {
+                // skip invalid surfaces (they could have become invalid
+                // after we made a copy of the list) - just a precaution
+                if (sd.isValid() && (sd.isDirty() || sd.isSurfaceLost())) {
+                    if (!sd.isSurfaceLost()) {
+                        // the flip and the clearing of the dirty state
+                        // must be done under the lock, otherwise it's
+                        // possible to miss an update to the surface
+                        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+                        rq.lock();
+                        try {
+                            Rectangle r = sd.getBounds();
+                            D3DSurfaceData.swapBuffers(sd, 0, 0,
+                                                       r.width, r.height);
+                            sd.markClean();
+                        } finally {
+                            rq.unlock();
+                        }
+                    } else if (!validate(sd)) {
+                        // it is possible that the validation may never
+                        // succeed, we need to detect this and replace
+                        // the d3dw surface with gdi; the replacement of
+                        // the surface will also trigger a repaint
+                        sd.getPeer().replaceSurfaceDataLater();
+                    }
+                }
+            }
+            synchronized (runLock) {
+                needsUpdateNow = false;
+                runLock.notifyAll();
+            }
+        }
+    }
+
+    /**
+     * Restores the passed surface if it was lost, resets the lost status.
+     * @param sd surface to be validated
+     * @return true if surface wasn't lost or if restoration was successful,
+     * false otherwise
+     */
+    private boolean validate(D3DWindowSurfaceData sd) {
+        if (sd.isSurfaceLost()) {
+            try {
+                sd.restoreSurface();
+                // if succeeded, first fill the surface with bg color
+                // note: use the non-synch method to avoid incorrect lock order
+                Color bg = sd.getPeer().getBackgroundNoSync();
+                SunGraphics2D sg2d = new SunGraphics2D(sd, bg, bg, null);
+                sg2d.fillRect(0, 0, sd.getBounds().width, sd.getBounds().height);
+                sg2d.dispose();
+                // now clean the dirty status so that we don't flip it
+                // next time before it gets repainted; it is safe
+                // to do without the lock because we will issue a
+                // repaint anyway so we will not lose any rendering
+                sd.markClean();
+                // since the surface was successfully restored we need to
+                // repaint whole window to repopulate the back-buffer
+                repaintPeerTarget(sd.getPeer());
+            } catch (InvalidPipeException ipe) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Creates (or returns a cached one) gdi surface for the same peer as
+     * the passed d3dw surface has.
+     *
+     * @param d3dw surface used as key into the cache
+     * @return gdi window surface associated with the d3d window surfaces' peer
+     */
+    private synchronized SurfaceData getGdiSurface(D3DWindowSurfaceData d3dw) {
+        if (gdiSurfaces == null) {
+            gdiSurfaces =
+                new HashMap<D3DWindowSurfaceData, GDIWindowSurfaceData>();
+        }
+        GDIWindowSurfaceData gdisd = gdiSurfaces.get(d3dw);
+        if (gdisd == null) {
+            gdisd = GDIWindowSurfaceData.createData(d3dw.getPeer());
+            gdiSurfaces.put(d3dw, gdisd);
+        }
+        return gdisd;
+    }
+
+    /**
+     * Returns true if the component has heavyweight children.
+     *
+     * @param comp component to check for hw children
+     * @return true if Component has heavyweight children
+     */
+    private static boolean hasHWChildren(Component comp) {
+        if (comp instanceof Container) {
+            for (Component c : ((Container)comp).getComponents()) {
+                if (c.getPeer() instanceof WComponentPeer || hasHWChildren(c)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DSurfaceData.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DSurfaceData.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DSurfaceData.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DSurfaceData.java	2011-01-08 01:26:50.467202167 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,432 +26,919 @@
 package sun.java2d.d3d;
 
 import java.awt.AlphaComposite;
+import java.awt.BufferCapabilities;
+import java.awt.Component;
 import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
 import java.awt.Image;
+import java.awt.Rectangle;
 import java.awt.Transparency;
 import java.awt.image.ColorModel;
+import java.awt.image.DataBuffer;
 import java.awt.image.DirectColorModel;
+import java.awt.image.Raster;
+import java.awt.image.SampleModel;
+import java.awt.image.SinglePixelPackedSampleModel;
 import sun.awt.SunHints;
-import sun.awt.Win32GraphicsConfig;
-import sun.awt.Win32GraphicsDevice;
+import sun.awt.image.DataBufferNative;
+import sun.awt.image.PixelConverter;
 import sun.awt.image.SurfaceManager;
+import sun.awt.image.WritableRasterNative;
+import sun.awt.windows.WComponentPeer;
+import sun.java2d.pipe.hw.AccelSurface;
 import sun.java2d.InvalidPipeException;
 import sun.java2d.SunGraphics2D;
 import sun.java2d.SurfaceData;
-import sun.java2d.SurfaceDataProxy;
 import sun.java2d.loops.GraphicsPrimitive;
+import sun.java2d.loops.MaskFill;
 import sun.java2d.loops.SurfaceType;
-import sun.java2d.pipe.PixelToShapeConverter;
+import sun.java2d.loops.CompositeType;
+import sun.java2d.pipe.ParallelogramPipe;
+import sun.java2d.pipe.PixelToParallelogramConverter;
+import sun.java2d.pipe.RenderBuffer;
 import sun.java2d.pipe.TextPipe;
-import sun.java2d.windows.Win32OffScreenSurfaceData;
-import sun.java2d.windows.Win32SurfaceData;
-import sun.java2d.windows.WinVolatileSurfaceManager;
-import sun.java2d.windows.WindowsFlags;
-
-import static sun.java2d.windows.Win32SurfaceData.*;
+import static sun.java2d.pipe.BufferedOpCodes.*;
+import static sun.java2d.d3d.D3DContext.D3DContextCaps.*;
+import static sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType.*;
+import sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType;
+import java.awt.BufferCapabilities.FlipContents;
+import java.awt.Window;
+import sun.awt.SunToolkit;
+import sun.awt.image.SunVolatileImage;
+import sun.java2d.ScreenUpdateManager;
+import sun.java2d.StateTracker;
+import sun.java2d.SurfaceDataProxy;
+import sun.java2d.pipe.hw.ExtendedBufferCapabilities;
 
-public class D3DSurfaceData extends Win32OffScreenSurfaceData {
+/**
+ * This class describes a D3D "surface", that is, a region of pixels
+ * managed via D3D.  An D3DSurfaceData can be tagged with one of three
+ * different SurfaceType objects for the purpose of registering loops, etc.
+ * This diagram shows the hierarchy of D3D SurfaceTypes:
+ *
+ *                               Any
+ *                             /     \
+ *                    D3DSurface     D3DTexture
+ *                         |
+ *                   D3DSurfaceRTT
+ *
+ * D3DSurface
+ * This kind of surface can be rendered to using D3D APIs.  It is also
+ * possible to copy a D3DSurface to another D3DSurface (or to itself).
+ *
+ * D3DTexture
+ * This kind of surface cannot be rendered to using D3D (in the same sense
+ * as in D3DSurface).  However, it is possible to upload a region of pixels
+ * to a D3DTexture object via Lock/UnlockRect().  One can also copy a
+ * surface of type D3DTexture to a D3DSurface by binding the texture
+ * to a quad and then rendering it to the destination surface (this process
+ * is known as "texture mapping").
+ *
+ * D3DSurfaceRTT
+ * This kind of surface can be thought of as a sort of hybrid between
+ * D3DSurface and D3DTexture, in that one can render to this kind of
+ * surface as if it were of type D3DSurface, but the process of copying
+ * this kind of surface to another is more like a D3DTexture.  (Note that
+ * "RTT" stands for "render-to-texture".)
+ *
+ * In addition to these SurfaceType variants, we have also defined some
+ * constants that describe in more detail the type of underlying D3D
+ * surface.  This table helps explain the relationships between those
+ * "type" constants and their corresponding SurfaceType:
+ *
+ * D3D Type          Corresponding SurfaceType
+ * --------          -------------------------
+ * RT_PLAIN          D3DSurface
+ * TEXTURE           D3DTexture
+ * FLIP_BACKBUFFER   D3DSurface
+ * RT_TEXTURE        D3DSurfaceRTT
+ */
+public class D3DSurfaceData extends SurfaceData implements AccelSurface {
 
-    // properties of a surface
     /**
-     * This property is used for a back-buffer surface
+     * To be used with getNativeResource() only.
+     * @see #getNativeResource()
      */
-    public static final int D3D_ATTACHED_SURFACE = (1 << 15);
-    /**
-     * A surface with this property can be used as a Direct3D rendering
-     * destination.
-     */
-    public static final int D3D_RENDER_TARGET    = (1 << 16);
+    public static final int D3D_DEVICE_RESOURCE= 100;
+    /*
+     * Surface types.
+     * We use these surface types when copying from a sw surface
+     * to a surface or texture.
+     */
+    public static final int ST_INT_ARGB        = 0;
+    public static final int ST_INT_ARGB_PRE    = 1;
+    public static final int ST_INT_ARGB_BM     = 2;
+    public static final int ST_INT_RGB         = 3;
+    public static final int ST_INT_BGR         = 4;
+    public static final int ST_USHORT_565_RGB  = 5;
+    public static final int ST_USHORT_555_RGB  = 6;
+    public static final int ST_BYTE_INDEXED    = 7;
+    public static final int ST_BYTE_INDEXED_BM = 8;
+
+    /** Equals to D3DSWAPEFFECT_DISCARD */
+    public static final int SWAP_DISCARD       = 1;
+    /** Equals to D3DSWAPEFFECT_FLIP    */
+    public static final int SWAP_FLIP          = 2;
+    /** Equals to D3DSWAPEFFECT_COPY    */
+    public static final int SWAP_COPY          = 3;
+    /*
+     * SurfaceTypes
+     */
+    private static final String DESC_D3D_SURFACE = "D3D Surface";
+    private static final String DESC_D3D_SURFACE_RTT =
+        "D3D Surface (render-to-texture)";
+    private static final String DESC_D3D_TEXTURE = "D3D Texture";
+
+    // REMIND: regarding ArgbPre??
+    static final SurfaceType D3DSurface =
+        SurfaceType.Any.deriveSubType(DESC_D3D_SURFACE,
+                                      PixelConverter.ArgbPre.instance);
+    static final SurfaceType D3DSurfaceRTT =
+        D3DSurface.deriveSubType(DESC_D3D_SURFACE_RTT);
+    static final SurfaceType D3DTexture =
+        SurfaceType.Any.deriveSubType(DESC_D3D_TEXTURE);
+
+    private int type;
+    private int width, height;
+    // these fields are set from the native code when the surface is
+    // initialized
+    private int nativeWidth, nativeHeight;
+    protected WComponentPeer peer;
+    private Image offscreenImage;
+    protected D3DGraphicsDevice graphicsDevice;
+
+    private int swapEffect;
+    private VSyncType syncType;
+    private int backBuffersNum;
+
+    private WritableRasterNative wrn;
+
+    protected static D3DRenderer d3dRenderPipe;
+    protected static PixelToParallelogramConverter d3dTxRenderPipe;
+    protected static ParallelogramPipe d3dAAPgramPipe;
+    protected static D3DTextRenderer d3dTextPipe;
+    protected static D3DDrawImage d3dImagePipe;
+
+    private native boolean initTexture(long pData, boolean isRTT,
+                                       boolean isOpaque);
+    private native boolean initFlipBackbuffer(long pData, long pPeerData,
+                                              int numbuffers,
+                                              int swapEffect, int syncType);
+    private native boolean initRTSurface(long pData, boolean isOpaque);
+    private native void initOps(int screen, int width, int height);
+
+    static {
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        d3dImagePipe = new D3DDrawImage();
+        d3dTextPipe = new D3DTextRenderer(rq);
+        d3dRenderPipe = new D3DRenderer(rq);
+        if (GraphicsPrimitive.tracingEnabled()) {
+            d3dTextPipe = d3dTextPipe.traceWrap();
+            d3dRenderPipe = d3dRenderPipe.traceWrap();
+            //The wrapped d3dRenderPipe will wrap the AA pipe as well...
+            //d3dAAPgramPipe = d3dRenderPipe.traceWrap();
+        }
+        d3dAAPgramPipe = d3dRenderPipe.getAAParallelogramPipe();
+        d3dTxRenderPipe =
+            new PixelToParallelogramConverter(d3dRenderPipe, d3dRenderPipe,
+                                              1.0, 0.25, true);
+
+        D3DBlitLoops.register();
+        D3DMaskFill.register();
+        D3DMaskBlit.register();
+    }
+
+    protected D3DSurfaceData(WComponentPeer peer, D3DGraphicsConfig gc,
+                             int width, int height, Image image,
+                             ColorModel cm, int numBackBuffers,
+                             int swapEffect, VSyncType vSyncType,
+                             int type)
+    {
+        super(getCustomSurfaceType(type), cm);
+        this.graphicsDevice = gc.getD3DDevice();
+        this.peer = peer;
+        this.type = type;
+        this.width = width;
+        this.height = height;
+        this.offscreenImage = image;
+        this.backBuffersNum = numBackBuffers;
+        this.swapEffect = swapEffect;
+        this.syncType = vSyncType;
+
+        initOps(graphicsDevice.getScreen(), width, height);
+        if (type == WINDOW) {
+            // we put the surface into the "lost"
+            // state; it will be restored by the D3DScreenUpdateManager
+            // prior to rendering to it for the first time. This is done
+            // so that vram is not wasted for surfaces never rendered to
+            setSurfaceLost(true);
+        } else {
+            initSurface();
+        }
+        setBlitProxyKey(gc.getProxyKey());
+    }
+
+    @Override
+    public SurfaceDataProxy makeProxyFor(SurfaceData srcData) {
+        return D3DSurfaceDataProxy.
+            createProxy(srcData,
+                        (D3DGraphicsConfig)graphicsDevice.getDefaultConfiguration());
+    }
 
-    public static final int
-        D3D_INVALID_SURFACE    = 0;
     /**
-     * Surface is a Direct3D plain surface (not a texture).
-     * Plain surface can be used as render target.
-     * VolatileImages typically use plain surfaces as their hardware
-     * accelerated surfaces.
+     * Creates a SurfaceData object representing the back buffer of a
+     * double-buffered on-screen Window.
      */
-    public static final int
-        D3D_PLAIN_SURFACE      = (1 << 0) | D3D_RENDER_TARGET;
+    public static D3DSurfaceData createData(WComponentPeer peer, Image image) {
+        D3DGraphicsConfig gc = getGC(peer);
+        if (gc == null || !peer.isAccelCapable()) {
+            return null;
+        }
+        BufferCapabilities caps = peer.getBackBufferCaps();
+        VSyncType vSyncType = VSYNC_DEFAULT;
+        if (caps instanceof ExtendedBufferCapabilities) {
+            vSyncType = ((ExtendedBufferCapabilities)caps).getVSync();
+        }
+        Rectangle r = peer.getBounds();
+        BufferCapabilities.FlipContents flip = caps.getFlipContents();
+        int swapEffect;
+        if (flip == FlipContents.COPIED) {
+            swapEffect = SWAP_COPY;
+        } else if (flip == FlipContents.PRIOR) {
+            swapEffect = SWAP_FLIP;
+        } else { // flip == FlipContents.UNDEFINED || .BACKGROUND
+            swapEffect = SWAP_DISCARD;
+        }
+        return new D3DSurfaceData(peer, gc, r.width, r.height,
+                                  image, peer.getColorModel(),
+                                  peer.getBackBuffersNum(),
+                                  swapEffect, vSyncType, FLIP_BACKBUFFER);
+    }
+
     /**
-     * Direct3D texture. Mostly used for cached accelerated surfaces.
-     * Surfaces of this type can be copied from using hardware acceleration
-     * by using texture mapping.
+     * Returns a WINDOW type of surface - a
+     * swap chain which serves as an on-screen surface,
+     * handled by the D3DScreenUpdateManager.
+     *
+     * Note that the native surface is not initialized
+     * when the surface is created to avoid using excessive
+     * resources, and the surface is placed into the lost
+     * state. It will be restored prior to any rendering
+     * to it.
+     *
+     * @param peer peer for which the onscreen surface is to be created
+     * @return a D3DWindowSurfaceData (flip chain) surface
      */
-    public static final int
-        D3D_TEXTURE_SURFACE    = (1 << 1);
+    public static D3DSurfaceData createData(WComponentPeer peer) {
+        D3DGraphicsConfig gc = getGC(peer);
+        if (gc == null || !peer.isAccelCapable()) {
+            return null;
+        }
+        return new D3DWindowSurfaceData(peer, gc);
+    }
+
     /**
-     * Direct3D Backbuffer surface - an attached surface. Used for
-     * multibuffered BufferStrategies.
+     * Creates a SurfaceData object representing an off-screen buffer (either
+     * a plain surface or Texture).
      */
-    public static final int
-        D3D_BACKBUFFER_SURFACE = D3D_PLAIN_SURFACE | D3D_ATTACHED_SURFACE;
+    public static D3DSurfaceData createData(D3DGraphicsConfig gc,
+                                            int width, int height,
+                                            ColorModel cm,
+                                            Image image, int type)
+    {
+        if (type == RT_TEXTURE) {
+            boolean isOpaque = cm.getTransparency() == Transparency.OPAQUE;
+            int cap = isOpaque ? CAPS_RT_TEXTURE_OPAQUE : CAPS_RT_TEXTURE_ALPHA;
+            if (!gc.getD3DDevice().isCapPresent(cap)) {
+                type = RT_PLAIN;
+            }
+        }
+        D3DSurfaceData ret = null;
+        try {
+            ret = new D3DSurfaceData(null, gc, width, height,
+                                     image, cm, 0, SWAP_DISCARD, VSYNC_DEFAULT,
+                                     type);
+        } catch (InvalidPipeException ipe) {
+            // try again - we might have ran out of vram, and rt textures
+            // could take up more than a plain surface, so it might succeed
+            if (type == RT_TEXTURE) {
+                // If a RT_TEXTURE was requested do not attempt to create a
+                // plain surface. (note that RT_TEXTURE can only be requested
+                // from a VI so the cast is safe)
+                if (((SunVolatileImage)image).getForcedAccelSurfaceType() !=
+                    RT_TEXTURE)
+                {
+                    type = RT_PLAIN;
+                    ret = new D3DSurfaceData(null, gc, width, height,
+                                             image, cm, 0, SWAP_DISCARD,
+                                             VSYNC_DEFAULT, type);
+                }
+            }
+        }
+        return ret;
+    }
+
     /**
-     * Render-to-texture. A texture which can also be a render target.
-     * Combines the benefits of textures (fast copies-from) and
-     * backbuffers or plain surfaces (hw-accelerated rendering to the surface)
+     * Returns the appropriate SurfaceType corresponding to the given D3D
+     * surface type constant (e.g. TEXTURE -> D3DTexture).
      */
-    public static final int
-        D3D_RTT_SURFACE        = D3D_TEXTURE_SURFACE | D3D_RENDER_TARGET;
+    private static SurfaceType getCustomSurfaceType(int d3dType) {
+        switch (d3dType) {
+        case TEXTURE:
+            return D3DTexture;
+        case RT_TEXTURE:
+            return D3DSurfaceRTT;
+        default:
+            return D3DSurface;
+        }
+    }
 
-    // supported texture pixel formats
-    public static final int PF_INVALID         =  0;
-    public static final int PF_INT_ARGB        =  1;
-    public static final int PF_INT_RGB         =  2;
-    public static final int PF_INT_RGBX        =  3;
-    public static final int PF_INT_BGR         =  4;
-    public static final int PF_USHORT_565_RGB  =  5;
-    public static final int PF_USHORT_555_RGB  =  6;
-    public static final int PF_USHORT_555_RGBX =  7;
-    public static final int PF_INT_ARGB_PRE    =  8;
-    public static final int PF_USHORT_4444_ARGB=  9;
+    private boolean initSurfaceNow() {
+        boolean isOpaque = (getTransparency() == Transparency.OPAQUE);
+        switch (type) {
+            case RT_PLAIN:
+                return initRTSurface(getNativeOps(), isOpaque);
+            case TEXTURE:
+                return initTexture(getNativeOps(), false/*isRTT*/, isOpaque);
+            case RT_TEXTURE:
+                return initTexture(getNativeOps(), true/*isRTT*/,  isOpaque);
+            // REMIND: we may want to pass the exact type to the native
+            // level here so that we could choose the right presentation
+            // interval for the frontbuffer (immediate vs v-synced)
+            case WINDOW:
+            case FLIP_BACKBUFFER:
+                return initFlipBackbuffer(getNativeOps(), peer.getData(),
+                                          backBuffersNum, swapEffect,
+                                          syncType.id());
+            default:
+                return false;
+        }
+    }
 
-    public static final String
-        DESC_INT_ARGB_D3D         = "Integer ARGB D3D with translucency";
-    public static final String
-        DESC_USHORT_4444_ARGB_D3D = "UShort 4444 ARGB D3D with translucency";
+    /**
+     * Initializes the appropriate D3D offscreen surface based on the value
+     * of the type parameter.  If the surface creation fails for any reason,
+     * an OutOfMemoryError will be thrown.
+     */
+    protected void initSurface() {
+        // any time we create or restore the surface, recreate the raster
+        synchronized (this) {
+            wrn = null;
+        }
+        // REMIND: somewhere a puppy died
+        class Status {
+            boolean success = false;
+        };
+        final Status status = new Status();
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            rq.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    status.success = initSurfaceNow();
+                }
+            });
+            if (!status.success) {
+                throw new InvalidPipeException("Error creating D3DSurface");
+            }
+        } finally {
+            rq.unlock();
+        }
+    }
 
     /**
-     * Surface type for texture destination.  We cannot render textures to
-     * the screen because Direct3D is not clipped by the window's clip list,
-     * so we only enable the texture blit loops for copies to offscreen
-     * accelerated surfaces.
+     * Returns the D3DContext for the GraphicsConfig associated with this
+     * surface.
      */
-    public static final String
-        DESC_DEST_D3D           = "D3D render target";
-
-    public static final SurfaceType D3DSurface =
-        SurfaceType.Any.deriveSubType("Direct3D Surface");
-    public static final SurfaceType D3DTexture =
-        D3DSurface.deriveSubType("Direct3D Texture");
+    public final D3DContext getContext() {
+        return graphicsDevice.getContext();
+    }
 
     /**
-     * D3D destination surface types (derive from offscreen dd surfaces).
-     * Note that all of these surfaces have the same surface description;
-     * we do not care about the depth of the surface since texture ops
-     * support multiple depths.
+     * Returns one of the surface type constants defined above.
      */
-    public static final SurfaceType IntRgbD3D =
-        IntRgbDD.deriveSubType(DESC_DEST_D3D);
-
-    public static final SurfaceType IntRgbxD3D =
-        IntRgbxDD.deriveSubType(DESC_DEST_D3D);
-
-    public static final SurfaceType Ushort565RgbD3D =
-        Ushort565RgbDD.deriveSubType(DESC_DEST_D3D);
-
-    public static final SurfaceType Ushort555RgbxD3D =
-        Ushort555RgbxDD.deriveSubType(DESC_DEST_D3D);
+    public final int getType() {
+        return type;
+    }
 
-    public static final SurfaceType Ushort555RgbD3D =
-        Ushort555RgbDD.deriveSubType(DESC_DEST_D3D);
+    private static native int  dbGetPixelNative(long pData, int x, int y);
+    private static native void dbSetPixelNative(long pData, int x, int y,
+                                                int pixel);
+    static class D3DDataBufferNative extends DataBufferNative {
+        int pixel;
+        protected D3DDataBufferNative(SurfaceData sData,
+                                      int type, int w, int h)
+        {
+            super(sData, type, w, h);
+        }
 
-    // REMIND: Is it possible to have d3d accelerated on this type of surface?
-    public static final SurfaceType ThreeByteBgrD3D =
-        ThreeByteBgrDD.deriveSubType(DESC_DEST_D3D);
+        protected int getElem(final int x, final int y,
+                              final SurfaceData sData)
+        {
+            int retPixel;
+            D3DRenderQueue rq = D3DRenderQueue.getInstance();
+            rq.lock();
+            try {
+                rq.flushAndInvokeNow(new Runnable() {
+                    public void run() {
+                        pixel = dbGetPixelNative(sData.getNativeOps(), x, y);
+                    }
+                });
+            } finally {
+                retPixel = pixel;
+                rq.unlock();
+            }
+            return retPixel;
+        }
 
-    public static final SurfaceType IntArgbD3D =
-        SurfaceType.IntArgb.deriveSubType(DESC_INT_ARGB_D3D);
+        protected void setElem(final int x, final int y, final int pixel,
+                               final SurfaceData sData)
+        {
+            D3DRenderQueue rq = D3DRenderQueue.getInstance();
+            rq.lock();
+            try {
+                rq.flushAndInvokeNow(new Runnable() {
+                    public void run() {
+                        dbSetPixelNative(sData.getNativeOps(), x, y, pixel);
+                    }
+                });
+                sData.markDirty();
+            } finally {
+                rq.unlock();
+            }
+        }
+    }
 
-    public static final SurfaceType Ushort4444ArgbD3D =
-        SurfaceType.Ushort4444Argb.deriveSubType(DESC_USHORT_4444_ARGB_D3D);
+    public synchronized Raster getRaster(int x, int y, int w, int h) {
+        if (wrn == null) {
+            DirectColorModel dcm = (DirectColorModel)getColorModel();
+            SampleModel smHw;
+            int dataType = 0;
+            int scanStride = width;
 
-    // Textures we can render to using d3d
-    public static final SurfaceType IntRgbD3D_RTT =
-        IntRgbD3D.deriveSubType(DESC_DEST_D3D);
+            if (dcm.getPixelSize() == 24 || dcm.getPixelSize() == 32) {
+                dataType = DataBuffer.TYPE_INT;
+            } else {
+                // 15, 16
+                dataType = DataBuffer.TYPE_USHORT;
+            }
 
-    public static final SurfaceType IntRgbxD3D_RTT =
-        IntRgbxD3D.deriveSubType(DESC_DEST_D3D);
+            // note that we have to use the surface width and height here,
+            // not the passed w,h
+            smHw = new SinglePixelPackedSampleModel(dataType, width, height,
+                                                    scanStride, dcm.getMasks());
+            DataBuffer dbn = new D3DDataBufferNative(this, dataType,
+                                                     width, height);
+            wrn = WritableRasterNative.createNativeRaster(smHw, dbn);
+        }
 
-    public static final SurfaceType Ushort565RgbD3D_RTT =
-        Ushort565RgbD3D.deriveSubType(DESC_DEST_D3D);
+        return wrn;
+    }
 
-    public static final SurfaceType Ushort555RgbxD3D_RTT =
-        Ushort555RgbxD3D.deriveSubType(DESC_DEST_D3D);
+    /**
+     * For now, we can only render LCD text if:
+     *   - the pixel shaders are available, and
+     *   - blending is disabled, and
+     *   - the source color is opaque
+     */
+    public boolean canRenderLCDText(SunGraphics2D sg2d) {
+        return
+            graphicsDevice.isCapPresent(CAPS_LCD_SHADER) &&
+            sg2d.compositeState <= SunGraphics2D.COMP_ISCOPY &&
+            sg2d.paintState <= SunGraphics2D.PAINT_OPAQUECOLOR;
+    }
 
-    public static final SurfaceType Ushort555RgbD3D_RTT =
-        Ushort555RgbD3D.deriveSubType(DESC_DEST_D3D);
+    public void validatePipe(SunGraphics2D sg2d) {
+        TextPipe textpipe;
+        boolean validated = false;
 
-    public static final SurfaceType Ushort4444ArgbD3D_RTT =
-        Ushort4444ArgbD3D.deriveSubType(DESC_DEST_D3D);
+        // REMIND: the D3D pipeline doesn't support XOR!, more
+        // fixes will be needed below
+        if (sg2d.compositeState >= sg2d.COMP_XOR) {
+            super.validatePipe(sg2d);
+            sg2d.imagepipe = d3dImagePipe;
+            return;
+        }
 
-    public static final SurfaceType IntArgbD3D_RTT =
-        IntArgbD3D.deriveSubType(DESC_DEST_D3D);
+        // D3DTextRenderer handles both AA and non-AA text, but
+        // only works with the following modes:
+        // (Note: For LCD text we only enter this code path if
+        // canRenderLCDText() has already validated that the mode is
+        // CompositeType.SrcNoEa (opaque color), which will be subsumed
+        // by the CompositeType.SrcNoEa (any color) test below.)
+
+        if (/* CompositeType.SrcNoEa (any color) */
+            (sg2d.compositeState <= sg2d.COMP_ISCOPY &&
+             sg2d.paintState <= sg2d.PAINT_ALPHACOLOR)        ||
+
+            /* CompositeType.SrcOver (any color) */
+            (sg2d.compositeState == sg2d.COMP_ALPHA    &&
+             sg2d.paintState <= sg2d.PAINT_ALPHACOLOR &&
+             (((AlphaComposite)sg2d.composite).getRule() ==
+              AlphaComposite.SRC_OVER))                       ||
+
+            /* CompositeType.Xor (any color) */
+            (sg2d.compositeState == sg2d.COMP_XOR &&
+             sg2d.paintState <= sg2d.PAINT_ALPHACOLOR))
+        {
+            textpipe = d3dTextPipe;
+        } else {
+            // do this to initialize textpipe correctly; we will attempt
+            // to override the non-text pipes below
+            super.validatePipe(sg2d);
+            textpipe = sg2d.textpipe;
+            validated = true;
+        }
 
-    public static final SurfaceType ThreeByteBgrD3D_RTT =
-        ThreeByteBgrD3D.deriveSubType(DESC_DEST_D3D);
+        PixelToParallelogramConverter txPipe = null;
+        D3DRenderer nonTxPipe = null;
 
-    // the type of this surface - texture, plain, back-buffer
-    protected int type;
-    protected int pixelFormat;
+        if (sg2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON) {
+            if (sg2d.paintState <= sg2d.PAINT_ALPHACOLOR) {
+                if (sg2d.compositeState <= sg2d.COMP_XOR) {
+                    txPipe = d3dTxRenderPipe;
+                    nonTxPipe = d3dRenderPipe;
+                }
+            } else if (sg2d.compositeState <= sg2d.COMP_ALPHA) {
+                if (D3DPaints.isValid(sg2d)) {
+                    txPipe = d3dTxRenderPipe;
+                    nonTxPipe = d3dRenderPipe;
+                }
+                // custom paints handled by super.validatePipe() below
+            }
+        } else {
+            if (sg2d.paintState <= sg2d.PAINT_ALPHACOLOR) {
+                if (graphicsDevice.isCapPresent(CAPS_AA_SHADER) &&
+                    (sg2d.imageComp == CompositeType.SrcOverNoEa ||
+                     sg2d.imageComp == CompositeType.SrcOver))
+                {
+                    if (!validated) {
+                        super.validatePipe(sg2d);
+                        validated = true;
+                    }
+                    PixelToParallelogramConverter aaConverter =
+                        new PixelToParallelogramConverter(sg2d.shapepipe,
+                                                          d3dAAPgramPipe,
+                                                          1.0/8.0, 0.499,
+                                                          false);
+                    sg2d.drawpipe = aaConverter;
+                    sg2d.fillpipe = aaConverter;
+                    sg2d.shapepipe = aaConverter;
+                } else if (sg2d.compositeState == sg2d.COMP_XOR) {
+                    // install the solid pipes when AA and XOR are both enabled
+                    txPipe = d3dTxRenderPipe;
+                    nonTxPipe = d3dRenderPipe;
+                }
+            }
+            // other cases handled by super.validatePipe() below
+        }
 
-    private D3DContext d3dContext;
+        if (txPipe != null) {
+            if (sg2d.transformState >= sg2d.TRANSFORM_TRANSLATESCALE) {
+                sg2d.drawpipe = txPipe;
+                sg2d.fillpipe = txPipe;
+            } else if (sg2d.strokeState != sg2d.STROKE_THIN) {
+                sg2d.drawpipe = txPipe;
+                sg2d.fillpipe = nonTxPipe;
+            } else {
+                sg2d.drawpipe = nonTxPipe;
+                sg2d.fillpipe = nonTxPipe;
+            }
+            // Note that we use the transforming pipe here because it
+            // will examine the shape and possibly perform an optimized
+            // operation if it can be simplified.  The simplifications
+            // will be valid for all STROKE and TRANSFORM types.
+            sg2d.shapepipe = txPipe;
+        } else {
+            if (!validated) {
+                super.validatePipe(sg2d);
+            }
+        }
 
-    protected static D3DRenderer d3dPipe;
-    protected static PixelToShapeConverter d3dTxPipe;
-    protected static D3DTextRenderer d3dTextPipe;
-    protected static D3DDrawImage d3dDrawImagePipe;
+        // install the text pipe based on our earlier decision
+        sg2d.textpipe = textpipe;
 
-    private native void initOps(int depth, int transparency);
+        // always override the image pipe with the specialized D3D pipe
+        sg2d.imagepipe = d3dImagePipe;
+    }
 
-    static {
-        if (WindowsFlags.isD3DEnabled()) {
-            D3DBlitLoops.register();
-            D3DMaskFill.register();
+    @Override
+    protected MaskFill getMaskFill(SunGraphics2D sg2d) {
+        if (sg2d.paintState > sg2d.PAINT_ALPHACOLOR) {
+            /*
+             * We can only accelerate non-Color MaskFill operations if
+             * all of the following conditions hold true:
+             *   - there is an implementation for the given paintState
+             *   - the current Paint can be accelerated for this destination
+             *   - multitexturing is available (since we need to modulate
+             *     the alpha mask texture with the paint texture)
+             *
+             * In all other cases, we return null, in which case the
+             * validation code will choose a more general software-based loop.
+             */
+            if (!D3DPaints.isValid(sg2d) ||
+                !graphicsDevice.isCapPresent(CAPS_MULTITEXTURE))
+            {
+                return null;
+            }
         }
+        return super.getMaskFill(sg2d);
+    }
 
-        d3dPipe = new D3DRenderer();
-        d3dTxPipe = new PixelToShapeConverter(d3dPipe);
-        d3dTextPipe = new D3DTextRenderer();
-        d3dDrawImagePipe = new D3DDrawImage();
+    @Override
+    public boolean copyArea(SunGraphics2D sg2d,
+                            int x, int y, int w, int h, int dx, int dy)
+    {
+        if (sg2d.transformState < sg2d.TRANSFORM_TRANSLATESCALE &&
+            sg2d.compositeState < sg2d.COMP_XOR)
+        {
+            x += sg2d.transX;
+            y += sg2d.transY;
 
-        if (GraphicsPrimitive.tracingEnabled()) {
-            d3dPipe = d3dPipe.traceWrapD3D();
-            d3dTextPipe = d3dTextPipe.traceWrap();
+            d3dRenderPipe.copyArea(sg2d, x, y, w, h, dx, dy);
+
+            return true;
         }
+        return false;
     }
 
     @Override
-    public SurfaceDataProxy makeProxyFor(SurfaceData srcData) {
-        //D3D may be eliminated soon so no Proxy was created for it...
-        //return D3DSurfaceDataProxy.createProxy(srcData, graphicsConfig);
-        return SurfaceDataProxy.UNCACHED;
+    public void flush() {
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            RenderBuffer buf = rq.getBuffer();
+            rq.ensureCapacityAndAlignment(12, 4);
+            buf.putInt(FLUSH_SURFACE);
+            buf.putLong(getNativeOps());
+
+            // this call is expected to complete synchronously, so flush now
+            rq.flushNow();
+        } finally {
+            rq.unlock();
+        }
     }
 
     /**
-     * Non-public constructor.  Use createData() to create an object.
-     *
-     * This constructor is used to house the common construction
-     * code shared between the creation of D3DSurfaceData objects
-     * and subclasses of D3DSurfaceData (such as D3DBackBufferSD).
-     *
-     * It calls the common constructor in the parent, and then
-     * initializes other shared D3D data.
-     */
-    protected D3DSurfaceData(int width, int height,
-                             int d3dSurfaceType,
-                             SurfaceType sType, ColorModel cm,
-                             GraphicsConfiguration gc,
-                             Image image, int transparency)
+     * Disposes the native resources associated with the given D3DSurfaceData
+     * (referenced by the pData parameter).  This method is invoked from
+     * the native Dispose() method from the Disposer thread when the
+     * Java-level D3DSurfaceData object is about to go away.
+     */
+    static void dispose(long pData) {
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        rq.lock();
+        try {
+            RenderBuffer buf = rq.getBuffer();
+            rq.ensureCapacityAndAlignment(12, 4);
+            buf.putInt(DISPOSE_SURFACE);
+            buf.putLong(pData);
+
+            // this call is expected to complete synchronously, so flush now
+            rq.flushNow();
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    static void swapBuffers(D3DSurfaceData sd,
+                            final int x1, final int y1,
+                            final int x2, final int y2)
     {
-        super(width, height, sType, cm, gc, image, transparency);
-        this.type = d3dSurfaceType;
+        long pData = sd.getNativeOps();
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        // swapBuffers can be called from the toolkit thread by swing, we
+        // should detect this and prevent the deadlocks
+        if (rq.isRenderQueueThread()) {
+            if (!rq.tryLock()) {
+                // if we could not obtain the lock, repaint the area
+                // that was supposed to be swapped, and no-op this swap
+                final Component target = (Component)sd.getPeer().getTarget();
+                SunToolkit.executeOnEventHandlerThread(target, new Runnable() {
+                    public void run() {
+                        target.repaint(x1, y1, x2, y2);
+                    }
+                });
+                return;
+            }
+        } else {
+            rq.lock();
+        }
+        try {
+            RenderBuffer buf = rq.getBuffer();
+            rq.ensureCapacityAndAlignment(28, 4);
+            buf.putInt(SWAP_BUFFERS);
+            buf.putLong(pData);
+            buf.putInt(x1);
+            buf.putInt(y1);
+            buf.putInt(x2);
+            buf.putInt(y2);
+            rq.flushNow();
+        } finally {
+            rq.unlock();
+        }
     }
 
     /**
-     * Private constructor.  Use createData() to create an object.
-     *
-     * This constructor calls the common constructor above and then
-     * performs the specific initialization of the D3DSurface.
+     * Returns destination Image associated with this SurfaceData.
      */
-    private D3DSurfaceData(int width, int height,
-                           int d3dSurfaceType,
-                           SurfaceType sType, ColorModel cm,
-                           GraphicsConfiguration gc,
-                           Image image, int transparency,
-                           int screen)
-    {
-        this(width, height, d3dSurfaceType, sType, cm, gc, image, transparency);
-        pixelFormat = initSurface(width, height, screen,
-                                  null /*parent SurfaceData*/);
+    public Object getDestination() {
+        return offscreenImage;
     }
 
-    public static D3DSurfaceData createData(int width, int height,
-                                            int d3dSurfaceType,
-                                            ColorModel cm,
-                                            GraphicsConfiguration gc,
-                                            Image image)
-    {
-        Win32GraphicsDevice gd = (Win32GraphicsDevice)gc.getDevice();
-        // After a display change ddInstance may not be
-        // recreated yet, and in this case isD3DEnabledOnDevice will
-        // return false, until someone attempted to recreate the
-        // primary.
-        if (!gd.isD3DEnabledOnDevice()) {
-            return null;
+    public Rectangle getBounds() {
+        if (type == FLIP_BACKBUFFER || type == WINDOW) {
+            Rectangle r = peer.getBounds();
+            r.x = r.y = 0;
+            return r;
+        } else {
+            return new Rectangle(width, height);
         }
+    }
 
-        return new D3DSurfaceData(width, height,
-                                  d3dSurfaceType,
-                                  getSurfaceType(gc, cm, d3dSurfaceType),
-                                  cm, gc, image,
-                                  cm.getTransparency(), gd.getScreen());
+    public Rectangle getNativeBounds() {
+        D3DRenderQueue rq = D3DRenderQueue.getInstance();
+        // need to lock to make sure nativeWidth and Height are consistent
+        // since they are set from the render thread from the native
+        // level
+        rq.lock();
+        try {
+            // REMIND: use xyoffsets?
+            return new Rectangle(nativeWidth, nativeHeight);
+        } finally {
+            rq.unlock();
+        }
     }
 
-    int getPixelFormat() {
-        return pixelFormat;
+
+    public GraphicsConfiguration getDeviceConfiguration() {
+        return graphicsDevice.getDefaultConfiguration();
     }
 
-    static SurfaceType getSurfaceType(GraphicsConfiguration gc,
-                                      ColorModel cm,
-                                      int d3dSurfaceType)
-    {
-        if (d3dSurfaceType == D3D_TEXTURE_SURFACE) {
-            // for non-rtt textures we have only one surface type
-            return D3DTexture;
+    public SurfaceData getReplacement() {
+        return restoreContents(offscreenImage);
+    }
+
+    private static D3DGraphicsConfig getGC(WComponentPeer peer) {
+        GraphicsConfiguration gc;
+        if (peer != null) {
+            gc =  peer.getGraphicsConfiguration();
         } else {
-            int pixelSize = cm.getPixelSize();
-            Win32GraphicsDevice gd = (Win32GraphicsDevice)gc.getDevice();
-            int transparency = cm.getTransparency();
-
-            // We'll attempt to use render-to-texture if render target is
-            // requested, but it's not a back-buffer and we support RTT
-            // for this configuration.
-            boolean useRTT =
-                ((d3dSurfaceType & D3D_RENDER_TARGET) != 0) &&
-                ((d3dSurfaceType & D3D_BACKBUFFER_SURFACE) == 0) &&
-                gd.getD3DContext().isRTTSupported();
-
-            // if there's no RTT available, we can't accelerate non-opaque
-            // surfaces, so we return null.
-            if (transparency == Transparency.TRANSLUCENT ||
-                transparency == Transparency.BITMASK)
-            {
-                if (pixelSize == 16) {
-                    return useRTT ? Ushort4444ArgbD3D_RTT :
-                        null/*Ushort4444ArgbD3D*/;
-                } else {
-                    return useRTT ? IntArgbD3D_RTT : null/*IntArgbD3D*/;
-                }
-            } else {
-                // it's an opaque surface, either a VI or a back-buffer
-                switch (pixelSize) {
-                case 32:
-                case 24:
-                    if (cm instanceof DirectColorModel) {
-                        if (((DirectColorModel)cm).getRedMask() == 0xff0000) {
-                            return useRTT ? IntRgbD3D_RTT : IntRgbD3D;
-                        } else {
-                            return useRTT ? IntRgbxD3D_RTT : IntRgbxD3D;
-                        }
-                    } else {
-                        return useRTT ? ThreeByteBgrD3D_RTT : ThreeByteBgrD3D;
-                    }
-                case 15:
-                    return useRTT ? Ushort555RgbD3D_RTT : Ushort555RgbD3D;
-                case 16:
-                    if ((cm instanceof DirectColorModel) &&
-                        (((DirectColorModel)cm).getBlueMask() == 0x3e))
-                    {
-                        return useRTT ? Ushort555RgbxD3D_RTT : Ushort555RgbxD3D;
-                    } else {
-                        return useRTT ? Ushort565RgbD3D_RTT : Ushort565RgbD3D;
-                    }
-                case 8: // not supported
-                default:
-                    throw new sun.java2d.InvalidPipeException("Unsupported bit " +
-                                                              "depth: " +
-                                                              cm.getPixelSize());
-                }
-            }
+            GraphicsEnvironment env =
+                    GraphicsEnvironment.getLocalGraphicsEnvironment();
+            GraphicsDevice gd = env.getDefaultScreenDevice();
+            gc = gd.getDefaultConfiguration();
         }
+        return (gc instanceof D3DGraphicsConfig) ? (D3DGraphicsConfig)gc : null;
     }
 
-    private native int initOffScreenSurface(long pCtx,
-                                            long pData, long parentPdata,
-                                            int width, int height,
-                                            int type, int screen);
-
-    protected int initSurface(int width, int height, int screen,
-                              Win32SurfaceData parentData)
-    {
-        int pFormat = PF_INVALID;
+    /**
+     * Attempts to restore the surface by initializing the native data
+     */
+    void restoreSurface() {
+        initSurface();
+    }
 
-        synchronized (D3DContext.LOCK) {
-            long pData = getNativeOps();
-            long pDataParent = 0L;
-            if (parentData != null) {
-                pDataParent = parentData.getNativeOps();
-            }
-            D3DContext d3dContext = getContext();
-            long pCtx = d3dContext.getNativeContext();
-            // native context could be 0 if the context is currently invalid,
-            // so attempt to revalidate
-            if (pCtx == 0) {
-                d3dContext.reinitNativeContext();
-                pCtx = d3dContext.getNativeContext();
-            }
-            if (pData != 0 && pCtx != 0) {
-                pFormat = initOffScreenSurface(pCtx,
-                                               pData, pDataParent,
-                                               width, height, type, screen);
-            } else {
-                // if the context can't be restored, give up for now.
-                throw new InvalidPipeException("D3DSD.initSurface: pData " +
-                                               "or pCtx is null");
-            }
-        }
-        return pFormat;
+    WComponentPeer getPeer() {
+        return peer;
     }
 
+    /**
+     * We need to let the surface manager know that the surface is lost so
+     * that for example BufferStrategy.contentsLost() returns correct result.
+     * Normally the status of contentsLost is set in validate(), but in some
+     * cases (like Swing's buffer per window) we intentionally don't call
+     * validate from the toolkit thread but only check for the BS status.
+     */
     @Override
-    public void validatePipe(SunGraphics2D sg2d) {
-        // we don't support COMP_XOR yet..
-        if (sg2d.compositeState < sg2d.COMP_XOR) {
-            TextPipe textpipe;
-            boolean validated = false;
-
-            if (((sg2d.compositeState <= sg2d.COMP_ISCOPY &&
-                  sg2d.paintState <= sg2d.PAINT_ALPHACOLOR) ||
-                 (sg2d.compositeState == sg2d.COMP_ALPHA &&
-                  sg2d.paintState <= sg2d.PAINT_ALPHACOLOR &&
-                  (((AlphaComposite)sg2d.composite).getRule() ==
-                   AlphaComposite.SRC_OVER))) &&
-                sg2d.textAntialiasHint <= SunHints.INTVAL_TEXT_ANTIALIAS_GASP)
-            {
-                // D3DTextRenderer handles both AA and non-AA text, but
-                // only works if composite is SrcNoEa or SrcOver
-                textpipe = d3dTextPipe;
-            } else {
-                // do this to initialize textpipe correctly; we will attempt
-                // to override the non-text pipes below
-                super.validatePipe(sg2d);
-                textpipe = sg2d.textpipe;
-                validated = true;
-            }
-
-            if (sg2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON &&
-                sg2d.paintState <= sg2d.PAINT_ALPHACOLOR)
-            {
-                sg2d.drawpipe =
-                    sg2d.strokeState == sg2d.STROKE_THIN ? d3dPipe : d3dTxPipe;
-                sg2d.fillpipe = d3dPipe;
-                sg2d.shapepipe = d3dPipe;
-            } else if (!validated) {
-                super.validatePipe(sg2d);
-            }
-            // install the text pipe based on our earlier decision
-            sg2d.textpipe = textpipe;
-        } else {
-            super.validatePipe(sg2d);
+    public void setSurfaceLost(boolean lost) {
+        super.setSurfaceLost(lost);
+        if (lost && offscreenImage != null) {
+            SurfaceManager sm = SurfaceManager.getManager(offscreenImage);
+            sm.acceleratedSurfaceLost();
         }
+    }
 
-        // always override the image pipe with the specialized D3D pipe
-        sg2d.imagepipe = d3dDrawImagePipe;
+    private static native long getNativeResourceNative(long sdops, int resType);
+    /**
+     * Returns a pointer to the native resource of specified {@code resType}
+     * associated with this surface.
+     *
+     * Specifically, for {@code D3DSurfaceData} this method returns pointers of
+     * the following:
+     * <pre>
+     * TEXTURE              - (IDirect3DTexture9*)
+     * RT_TEXTURE, RT_PLAIN - (IDirect3DSurface9*)
+     * FLIP_BACKBUFFER      - (IDirect3DSwapChain9*)
+     * D3D_DEVICE_RESOURCE  - (IDirect3DDevice9*)
+     * </pre>
+     *
+     * Multiple resources may be available for some types (i.e. for render to
+     * texture one could retrieve both a destination surface by specifying
+     * RT_TEXTURE, and a texture by using TEXTURE).
+     *
+     * Note: the pointer returned by this method is only valid on the rendering
+     * thread.
+     *
+     * @return pointer to the native resource of specified type or 0L if
+     * such resource doesn't exist or can not be retrieved.
+     * @see sun.java2d.pipe.hw.AccelSurface#getNativeResource
+     */
+    public long getNativeResource(int resType) {
+        return getNativeResourceNative(getNativeOps(), resType);
     }
 
     /**
-     * Disables D3D acceleration on the surface manager of this surfaceData
-     * object. This can happen when we encounter a hard error in rendering a D3D
-     * primitive (for example, if we were unable to set a surface as D3D target
-     * surface).
-     * Upon next validation the SurfaceManager will create a non-D3D surface.
+     * Class representing an on-screen d3d surface. Since d3d can't
+     * render to the screen directly, it is implemented as a swap chain,
+     * controlled by D3DScreenUpdateManager.
+     *
+     * @see D3DScreenUpdateManager
      */
-    public void disableD3D() {
-        markSurfaceLost();
-        SurfaceManager sMgr = SurfaceManager.getManager(image);
-        if (sMgr instanceof WinVolatileSurfaceManager) {
-            ((WinVolatileSurfaceManager)sMgr).setD3DAccelerationEnabled(false);
+    public static class D3DWindowSurfaceData extends D3DSurfaceData {
+        StateTracker dirtyTracker;
+
+        public D3DWindowSurfaceData(WComponentPeer peer,
+                                    D3DGraphicsConfig gc)
+        {
+            super(peer, gc,
+                  peer.getBounds().width, peer.getBounds().height,
+                  null, peer.getColorModel(), 1, SWAP_COPY, VSYNC_DEFAULT,
+                  WINDOW);
+            dirtyTracker = getStateTracker();
         }
-    }
 
-    @Override
-    public boolean surfacePunted() {
-        // Punting is disabled for D3D surfaces
-        return false;
-    }
+        /**
+         * {@inheritDoc}
+         *
+         * Overridden to use ScreenUpdateManager to obtain the replacement
+         * surface.
+         *
+         * @see sun.java2d.ScreenUpdateManager#getReplacementScreenSurface
+         */
+        @Override
+        public SurfaceData getReplacement() {
+            ScreenUpdateManager mgr = ScreenUpdateManager.getInstance();
+            return mgr.getReplacementScreenSurface(peer, this);
+        }
 
-    D3DContext getContext() {
-        return ((Win32GraphicsDevice)graphicsConfig.getDevice()).getD3DContext();
+        /**
+         * Returns destination Component associated with this SurfaceData.
+         */
+        @Override
+        public Object getDestination() {
+            return peer.getTarget();
+        }
+
+        @Override
+        void restoreSurface() {
+            Window fsw = graphicsDevice.getFullScreenWindow();
+            if (fsw != null && fsw != peer.getTarget()) {
+                throw new InvalidPipeException("Can't restore onscreen surface"+
+                                               " when in full-screen mode");
+            }
+            super.restoreSurface();
+            // if initialization was unsuccessful, an IPE will be thrown
+            // and the surface will remain lost
+            setSurfaceLost(false);
+
+            // This is to make sure the render target is reset after this
+            // surface is restored. The reason for this is that sometimes this
+            // surface can be restored from multiple threads (the screen update
+            // manager's thread and app's rendering thread) at the same time,
+            // and when that happens the second restoration will create the
+            // native resource which will not be set as render target because
+            // the BufferedContext's validate method will think that since the
+            // surface data object didn't change then the current render target
+            // is correct and no rendering will appear on the screen.
+            D3DRenderQueue rq = D3DRenderQueue.getInstance();
+            rq.lock();
+            try {
+                getContext().invalidateContext();
+            } finally {
+                rq.unlock();
+            }
+        }
+
+        public boolean isDirty() {
+            return !dirtyTracker.isCurrent();
+        }
+
+        public void markClean() {
+            dirtyTracker = getStateTracker();
+        }
     }
+
+    /**
+     * Updates the layered window with the contents of the surface.
+     *
+     * @param pd3dsd pointer to the D3DSDOps structure
+     * @param pData pointer to the AwtWindow peer data
+     * @param w width of the window
+     * @param h height of the window
+     * @see sun.awt.windows.TranslucentWindowPainter
+     */
+    public static native boolean updateWindowAccelImpl(long pd3dsd, long pData,
+                                                       int w, int h);
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DSurfaceDataProxy.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DSurfaceDataProxy.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DSurfaceDataProxy.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DSurfaceDataProxy.java	2011-01-08 01:26:50.467202167 +0000
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.d3d;
+
+import java.awt.Color;
+import java.awt.Transparency;
+
+import sun.java2d.InvalidPipeException;
+import sun.java2d.SurfaceData;
+import sun.java2d.SurfaceDataProxy;
+import sun.java2d.loops.CompositeType;
+
+/**
+ * The proxy class contains the logic for when to replace a
+ * SurfaceData with a cached D3D Texture and the code to create
+ * the accelerated surfaces.
+ */
+public class D3DSurfaceDataProxy extends SurfaceDataProxy {
+
+    public static SurfaceDataProxy createProxy(SurfaceData srcData,
+                                               D3DGraphicsConfig dstConfig)
+    {
+        if (srcData instanceof D3DSurfaceData) {
+            // srcData must be a VolatileImage which either matches
+            // our pixel format or not - either way we do not cache it...
+            return UNCACHED;
+        }
+
+        return new D3DSurfaceDataProxy(dstConfig, srcData.getTransparency());
+    }
+
+    D3DGraphicsConfig d3dgc;
+    int transparency;
+
+    public D3DSurfaceDataProxy(D3DGraphicsConfig d3dgc, int transparency) {
+        this.d3dgc = d3dgc;
+        this.transparency = transparency;
+        // REMIND: we may want to change this for the d3d pipeline, it's not
+        // necessary to invalidate them all at once on display change
+        activateDisplayListener();
+    }
+
+    @Override
+    public SurfaceData validateSurfaceData(SurfaceData srcData,
+                                           SurfaceData cachedData,
+                                           int w, int h)
+    {
+        if (cachedData == null || cachedData.isSurfaceLost()) {
+            try {
+                cachedData = d3dgc.createManagedSurface(w, h, transparency);
+            } catch (InvalidPipeException e) {
+                if (!d3dgc.getD3DDevice().isD3DAvailable()) {
+                    invalidate();
+                    flush();
+                    return null;
+                }
+            }
+        }
+        return cachedData;
+    }
+
+    @Override
+    public boolean isSupportedOperation(SurfaceData srcData,
+                                        int txtype,
+                                        CompositeType comp,
+                                        Color bgColor)
+    {
+        return (bgColor == null || transparency == Transparency.OPAQUE);
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DTextRenderer.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DTextRenderer.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DTextRenderer.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DTextRenderer.java	2011-01-08 01:26:50.467202167 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,51 +25,47 @@
 
 package sun.java2d.d3d;
 
-import java.awt.AlphaComposite;
+import java.awt.Composite;
 import sun.font.GlyphList;
 import sun.java2d.SunGraphics2D;
-import sun.java2d.SurfaceData;
 import sun.java2d.loops.GraphicsPrimitive;
-import sun.java2d.pipe.GlyphListPipe;
-import sun.java2d.pipe.Region;
+import sun.java2d.pipe.BufferedTextPipe;
+import sun.java2d.pipe.RenderQueue;
 
-public class D3DTextRenderer extends GlyphListPipe {
+class D3DTextRenderer extends BufferedTextPipe {
 
-    protected native void doDrawGlyphList(long pData, long pCtx,
-                                          Region clip, GlyphList gl);
-
-    protected void drawGlyphList(SunGraphics2D sg2d, GlyphList gl) {
-        AlphaComposite comp = (AlphaComposite)sg2d.composite;
-        // We can only get here if the comp is Src or SrcOver (see
-        // pipeline validation in D3DSurfaceData, so we force
-        // it to be SrcOver.
-        if (comp.getRule() != AlphaComposite.SRC_OVER) {
-            comp = AlphaComposite.SrcOver;
-        }
-
-        synchronized (D3DContext.LOCK) {
-            SurfaceData dstData = sg2d.surfaceData;
-            long pCtx = D3DContext.getContext(dstData, dstData,
-                                              sg2d.getCompClip(), comp,
-                                              null, sg2d.eargb,
-                                              D3DContext.NO_CONTEXT_FLAGS);
+    D3DTextRenderer(RenderQueue rq) {
+        super(rq);
+    }
 
-            doDrawGlyphList(dstData.getNativeOps(), pCtx,
-                            sg2d.getCompClip(), gl);
-        }
+    @Override
+    protected native void drawGlyphList(int numGlyphs, boolean usePositions,
+                                        boolean subPixPos, boolean rgbOrder,
+                                        int lcdContrast,
+                                        float glOrigX, float glOrigY,
+                                        long[] images, float[] positions);
+
+    @Override
+    protected void validateContext(SunGraphics2D sg2d, Composite comp) {
+        // assert rq.lock.isHeldByCurrentThread();
+        D3DSurfaceData d3dDst = (D3DSurfaceData)sg2d.surfaceData;
+        D3DContext.validateContext(d3dDst, d3dDst,
+                                   sg2d.getCompClip(), comp,
+                                   null, sg2d.paint, sg2d,
+                                   D3DContext.NO_CONTEXT_FLAGS);
     }
 
-    public D3DTextRenderer traceWrap() {
-        return new Tracer();
+    D3DTextRenderer traceWrap() {
+        return new Tracer(this);
     }
 
-    public static class Tracer extends D3DTextRenderer {
-        @Override
-        protected void doDrawGlyphList(long pData, long pCtx,
-                                       Region clip, GlyphList gl)
-        {
+    private static class Tracer extends D3DTextRenderer {
+        Tracer(D3DTextRenderer d3dtr) {
+            super(d3dtr.rq);
+        }
+        protected void drawGlyphList(SunGraphics2D sg2d, GlyphList gl) {
             GraphicsPrimitive.tracePrimitive("D3DDrawGlyphs");
-            super.doDrawGlyphList(pData, pCtx, clip, gl);
+            super.drawGlyphList(sg2d, gl);
         }
     }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DVolatileSurfaceManager.java openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DVolatileSurfaceManager.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/d3d/D3DVolatileSurfaceManager.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/d3d/D3DVolatileSurfaceManager.java	2011-01-08 01:26:50.467202167 +0000
@@ -0,0 +1,230 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d.d3d;
+
+import java.awt.Component;
+import java.awt.GraphicsConfiguration;
+import java.awt.Image;
+import java.awt.Transparency;
+import java.awt.image.ColorModel;
+import sun.awt.Win32GraphicsConfig;
+import sun.awt.image.SunVolatileImage;
+import sun.awt.image.SurfaceManager;
+import sun.awt.image.VolatileSurfaceManager;
+import sun.awt.windows.WComponentPeer;
+import sun.java2d.InvalidPipeException;
+import sun.java2d.SurfaceData;
+import static sun.java2d.pipe.hw.AccelSurface.*;
+import static sun.java2d.d3d.D3DContext.D3DContextCaps.*;
+import sun.java2d.windows.GDIWindowSurfaceData;
+
+public class D3DVolatileSurfaceManager
+    extends VolatileSurfaceManager
+{
+    private boolean accelerationEnabled;
+    private int restoreCountdown;
+
+    public D3DVolatileSurfaceManager(SunVolatileImage vImg, Object context) {
+        super(vImg, context);
+
+        /*
+         * We will attempt to accelerate this image only under the
+         * following conditions:
+         *   - the image is opaque OR
+         *   - the image is translucent AND
+         *       - the GraphicsConfig supports the FBO extension OR
+         *       - the GraphicsConfig has a stored alpha channel
+         */
+        int transparency = vImg.getTransparency();
+        D3DGraphicsDevice gd = (D3DGraphicsDevice)
+            vImg.getGraphicsConfig().getDevice();
+        accelerationEnabled =
+            (transparency == Transparency.OPAQUE) ||
+            (transparency == Transparency.TRANSLUCENT &&
+             (gd.isCapPresent(CAPS_RT_PLAIN_ALPHA) ||
+              gd.isCapPresent(CAPS_RT_TEXTURE_ALPHA)));
+    }
+
+    protected boolean isAccelerationEnabled() {
+        return accelerationEnabled;
+    }
+    public void setAccelerationEnabled(boolean accelerationEnabled) {
+        this.accelerationEnabled = accelerationEnabled;
+    }
+
+    /**
+     * Create a pbuffer-based SurfaceData object (or init the backbuffer
+     * of an existing window if this is a double buffered GraphicsConfig).
+     */
+    protected SurfaceData initAcceleratedSurface() {
+        SurfaceData sData;
+        Component comp = vImg.getComponent();
+        WComponentPeer peer =
+            (comp != null) ? (WComponentPeer)comp.getPeer() : null;
+
+        try {
+            boolean forceback = false;
+            if (context instanceof Boolean) {
+                forceback = ((Boolean)context).booleanValue();
+            }
+
+            if (forceback) {
+                // peer must be non-null in this case
+                sData = D3DSurfaceData.createData(peer, vImg);
+            } else {
+                D3DGraphicsConfig gc =
+                    (D3DGraphicsConfig)vImg.getGraphicsConfig();
+                ColorModel cm = gc.getColorModel(vImg.getTransparency());
+                int type = vImg.getForcedAccelSurfaceType();
+                // if acceleration type is forced (type != UNDEFINED) then
+                // use the forced type, otherwise use RT_TEXTURE
+                if (type == UNDEFINED) {
+                    type = RT_TEXTURE;
+                }
+                sData = D3DSurfaceData.createData(gc,
+                                                  vImg.getWidth(),
+                                                  vImg.getHeight(),
+                                                  cm, vImg,
+                                                  type);
+            }
+        } catch (NullPointerException ex) {
+            sData = null;
+        } catch (OutOfMemoryError er) {
+            sData = null;
+        } catch (InvalidPipeException ipe) {
+            sData = null;
+        }
+
+        return sData;
+    }
+
+    protected boolean isConfigValid(GraphicsConfiguration gc) {
+        return ((gc == null) || (gc == vImg.getGraphicsConfig()));
+    }
+
+    /**
+     * Set the number of iterations for restoreAcceleratedSurface to fail
+     * before attempting to restore the accelerated surface.
+     *
+     * @see #restoreAcceleratedSurface
+     * @see #handleVItoScreenOp
+     */
+    private synchronized void setRestoreCountdown(int count) {
+        restoreCountdown = count;
+    }
+
+    /**
+     * Note that we create a new surface instead of restoring
+     * an old one. This will help with D3DContext revalidation.
+     */
+    @Override
+    protected void restoreAcceleratedSurface() {
+        synchronized (this) {
+            if (restoreCountdown > 0) {
+                restoreCountdown--;
+                throw new
+                    InvalidPipeException("Will attempt to restore surface " +
+                                          " in " + restoreCountdown);
+            }
+        }
+
+        SurfaceData sData = initAcceleratedSurface();
+        if (sData != null) {
+            sdAccel = sData;
+        } else {
+            throw new InvalidPipeException("could not restore surface");
+            // REMIND: alternatively, we could try this:
+//            ((D3DSurfaceData)sdAccel).restoreSurface();
+        }
+    }
+
+    /**
+     * We're asked to restore contents by the accelerated surface, which means
+     * that it had been lost.
+     */
+    @Override
+    public SurfaceData restoreContents() {
+        acceleratedSurfaceLost();
+        return super.restoreContents();
+    }
+
+    /**
+     * If the destination surface's peer can potentially handle accelerated
+     * on-screen rendering then it is likely that the condition which resulted
+     * in VI to Screen operation is temporary, so this method sets the
+     * restore countdown in hope that the on-screen accelerated rendering will
+     * resume. In the meantime the backup surface of the VISM will be used.
+     *
+     * The countdown is needed because otherwise we may never break out
+     * of "do { vi.validate()..} while(vi.lost)" loop since validate() could
+     * restore the source surface every time and it will get lost again on the
+     * next copy attempt, and we would never get a chance to use the backup
+     * surface. By using the countdown we allow the backup surface to be used
+     * while the screen surface gets sorted out, or if it for some reason can
+     * never be restored.
+     *
+     * If the destination surface's peer could never do accelerated onscreen
+     * rendering then the acceleration for the SurfaceManager associated with
+     * the source surface is disabled forever.
+     */
+    static void handleVItoScreenOp(SurfaceData src, SurfaceData dst) {
+        if (src instanceof D3DSurfaceData &&
+            dst instanceof GDIWindowSurfaceData)
+        {
+            D3DSurfaceData d3dsd = (D3DSurfaceData)src;
+            SurfaceManager mgr =
+                SurfaceManager.getManager((Image)d3dsd.getDestination());
+            if (mgr instanceof D3DVolatileSurfaceManager) {
+                D3DVolatileSurfaceManager vsm = (D3DVolatileSurfaceManager)mgr;
+                if (vsm != null) {
+                    d3dsd.setSurfaceLost(true);
+
+                    GDIWindowSurfaceData wsd = (GDIWindowSurfaceData)dst;
+                    WComponentPeer p = wsd.getPeer();
+                    if (D3DScreenUpdateManager.canUseD3DOnScreen(p,
+                            (Win32GraphicsConfig)p.getGraphicsConfiguration(),
+                            p.getBackBuffersNum()))
+                    {
+                        // 10 is only chosen to be greater than the number of
+                        // times a sane person would call validate() inside
+                        // a validation loop, and to reduce thrashing between
+                        // accelerated and backup surfaces
+                        vsm.setRestoreCountdown(10);
+                    } else {
+                        vsm.setAccelerationEnabled(false);
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public void initContents() {
+        if (vImg.getForcedAccelSurfaceType() != TEXTURE) {
+            super.initContents();
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/opengl/WGLGraphicsConfig.java openjdk/jdk/src/windows/classes/sun/java2d/opengl/WGLGraphicsConfig.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/opengl/WGLGraphicsConfig.java	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/opengl/WGLGraphicsConfig.java	2011-01-08 01:26:50.467202167 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,8 +27,11 @@
 
 import java.awt.AWTException;
 import java.awt.BufferCapabilities;
+import java.awt.BufferCapabilities.FlipContents;
+import java.awt.Color;
 import java.awt.Component;
 import java.awt.Graphics;
+import java.awt.Graphics2D;
 import java.awt.ImageCapabilities;
 import java.awt.Transparency;
 import java.awt.color.ColorSpace;
@@ -39,10 +42,22 @@
 import sun.awt.Win32GraphicsConfig;
 import sun.awt.Win32GraphicsDevice;
 import sun.awt.image.SunVolatileImage;
+import sun.awt.image.SurfaceManager;
 import sun.awt.windows.WComponentPeer;
 import sun.java2d.Disposer;
 import sun.java2d.DisposerRecord;
+import sun.java2d.SunGraphics2D;
+import sun.java2d.Surface;
 import sun.java2d.SurfaceData;
+import sun.java2d.pipe.hw.AccelSurface;
+import sun.java2d.pipe.hw.AccelTypedVolatileImage;
+import sun.java2d.pipe.hw.ContextCapabilities;
+import static sun.java2d.opengl.OGLContext.OGLContextCaps.*;
+import static sun.java2d.opengl.WGLSurfaceData.*;
+import sun.java2d.opengl.OGLContext.OGLContextCaps;
+import sun.java2d.pipe.hw.AccelDeviceEventListener;
+import sun.java2d.pipe.hw.AccelDeviceEventNotifier;
+import sun.java2d.windows.GDIWindowSurfaceData;
 
 public class WGLGraphicsConfig
     extends Win32GraphicsConfig
@@ -53,7 +68,7 @@
 
     private BufferCapabilities bufferCaps;
     private long pConfigInfo;
-    private int oglCaps;
+    private ContextCapabilities oglCaps;
     private OGLContext context;
     private Object disposerReferent = new Object();
 
@@ -67,17 +82,18 @@
     }
 
     protected WGLGraphicsConfig(Win32GraphicsDevice device, int visualnum,
-                                long configInfo, int oglCaps)
+                                long configInfo, ContextCapabilities oglCaps)
     {
         super(device, visualnum);
         this.pConfigInfo = configInfo;
         this.oglCaps = oglCaps;
-        context = new OGLContext(OGLRenderQueue.getInstance());
+        context = new OGLContext(OGLRenderQueue.getInstance(), this);
 
         // add a record to the Disposer so that we destroy the native
         // WGLGraphicsConfigInfo data when this object goes away
         Disposer.addRecord(disposerReferent,
-                           new WGLGCDisposerRecord(pConfigInfo));
+                           new WGLGCDisposerRecord(pConfigInfo,
+                                                   device.getScreen()));
     }
 
     public Object getProxyKey() {
@@ -99,6 +115,7 @@
         }
 
         long cfginfo = 0;
+        final String ids[] = new String[1];
         OGLRenderQueue rq = OGLRenderQueue.getInstance();
         rq.lock();
         try {
@@ -110,6 +127,12 @@
                 new WGLGetConfigInfo(device.getScreen(), pixfmt);
             rq.flushAndInvokeNow(action);
             cfginfo = action.getConfigInfo();
+            OGLContext.setScratchSurface(cfginfo);
+            rq.flushAndInvokeNow(new Runnable() {
+                public void run() {
+                    ids[0] = OGLContext.getOGLIdString();
+                }
+            });
         } finally {
             rq.unlock();
         }
@@ -118,8 +141,9 @@
         }
 
         int oglCaps = getOGLCapabilities(cfginfo);
+        ContextCapabilities caps = new OGLContextCaps(oglCaps, ids[0]);
 
-        return new WGLGraphicsConfig(device, pixfmt, cfginfo, oglCaps);
+        return new WGLGraphicsConfig(device, pixfmt, cfginfo, caps);
     }
 
     /**
@@ -150,24 +174,49 @@
      * Returns true if the provided capability bit is present for this config.
      * See OGLContext.java for a list of supported capabilities.
      */
+    @Override
     public final boolean isCapPresent(int cap) {
-        return ((oglCaps & cap) != 0);
+        return ((oglCaps.getCaps() & cap) != 0);
     }
 
+    @Override
     public final long getNativeConfigInfo() {
         return pConfigInfo;
     }
 
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.pipe.hw.BufferedContextProvider#getContext
+     */
+    @Override
     public final OGLContext getContext() {
         return context;
     }
 
     private static class WGLGCDisposerRecord implements DisposerRecord {
         private long pCfgInfo;
-        public WGLGCDisposerRecord(long pCfgInfo) {
+        private int screen;
+        public WGLGCDisposerRecord(long pCfgInfo, int screen) {
             this.pCfgInfo = pCfgInfo;
         }
         public void dispose() {
+            OGLRenderQueue rq = OGLRenderQueue.getInstance();
+            rq.lock();
+            try {
+                rq.flushAndInvokeNow(new Runnable() {
+                    public void run() {
+                        AccelDeviceEventNotifier.
+                            eventOccured(screen,
+                                AccelDeviceEventNotifier.DEVICE_RESET);
+                        AccelDeviceEventNotifier.
+                            eventOccured(screen,
+                                AccelDeviceEventNotifier.DEVICE_DISPOSED);
+                    }
+                });
+            } finally {
+                rq.unlock();
+            }
             if (pCfgInfo != 0) {
                 OGLRenderQueue.disposeGraphicsConfig(pCfgInfo);
                 pCfgInfo = 0;
@@ -230,7 +279,11 @@
     public SurfaceData createSurfaceData(WComponentPeer peer,
                                          int numBackBuffers)
     {
-        return WGLSurfaceData.createData(peer);
+        SurfaceData sd = WGLSurfaceData.createData(peer);
+        if (sd == null) {
+            sd = GDIWindowSurfaceData.createData(peer);
+        }
+        return sd;
     }
 
     /**
@@ -279,16 +332,36 @@
     @Override
     public void flip(WComponentPeer peer,
                      Component target, VolatileImage backBuffer,
+                     int x1, int y1, int x2, int y2,
                      BufferCapabilities.FlipContents flipAction)
     {
         if (flipAction == BufferCapabilities.FlipContents.COPIED) {
-            Graphics g = peer.getGraphics();
-            try {
-                g.drawImage(backBuffer, 0, 0, null);
-            } finally {
-                g.dispose();
+            SurfaceManager vsm = SurfaceManager.getManager(backBuffer);
+            SurfaceData sd = vsm.getPrimarySurfaceData();
+
+            if (sd instanceof WGLVSyncOffScreenSurfaceData) {
+                WGLVSyncOffScreenSurfaceData vsd =
+                    (WGLVSyncOffScreenSurfaceData)sd;
+                SurfaceData bbsd = vsd.getFlipSurface();
+                Graphics2D bbg =
+                    new SunGraphics2D(bbsd, Color.black, Color.white, null);
+                try {
+                    bbg.drawImage(backBuffer, 0, 0, null);
+                } finally {
+                    bbg.dispose();
+                }
+            } else {
+                Graphics g = peer.getGraphics();
+                try {
+                    g.drawImage(backBuffer,
+                                x1, y1, x2, y2,
+                                x1, y1, x2, y2,
+                                null);
+                } finally {
+                    g.dispose();
+                }
+                return;
             }
-            return;
         } else if (flipAction == BufferCapabilities.FlipContents.PRIOR) {
             // not supported by WGL...
             return;
@@ -319,7 +392,7 @@
     @Override
     public BufferCapabilities getBufferCapabilities() {
         if (bufferCaps == null) {
-            boolean dblBuf = isCapPresent(OGLContext.CAPS_DOUBLEBUFFERED);
+            boolean dblBuf = isCapPresent(CAPS_DOUBLEBUFFERED);
             bufferCaps = new WGLBufferCaps(dblBuf);
         }
         return bufferCaps;
@@ -338,4 +411,64 @@
     public ImageCapabilities getImageCapabilities() {
         return imageCaps;
     }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.pipe.hw.AccelGraphicsConfig#createCompatibleVolatileImage
+     */
+    @Override
+    public VolatileImage
+        createCompatibleVolatileImage(int width, int height,
+                                      int transparency, int type)
+    {
+        if (type == FLIP_BACKBUFFER || type == WINDOW || type == UNDEFINED ||
+            transparency == Transparency.BITMASK)
+        {
+            return null;
+        }
+
+        if (type == FBOBJECT) {
+            if (!isCapPresent(CAPS_EXT_FBOBJECT)) {
+                return null;
+            }
+        } else if (type == PBUFFER) {
+            boolean isOpaque = transparency == Transparency.OPAQUE;
+            if (!isOpaque && !isCapPresent(CAPS_STORED_ALPHA)) {
+                return null;
+            }
+        }
+
+        SunVolatileImage vi = new AccelTypedVolatileImage(this, width, height,
+                                                          transparency, type);
+        Surface sd = vi.getDestSurface();
+        if (!(sd instanceof AccelSurface) ||
+            ((AccelSurface)sd).getType() != type)
+        {
+            vi.flush();
+            vi = null;
+        }
+
+        return vi;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @see sun.java2d.pipe.hw.AccelGraphicsConfig#getContextCapabilities
+     */
+    @Override
+    public ContextCapabilities getContextCapabilities() {
+        return oglCaps;
+    }
+
+    @Override
+    public void addDeviceEventListener(AccelDeviceEventListener l) {
+        AccelDeviceEventNotifier.addListener(l, screen.getScreen());
+    }
+
+    @Override
+    public void removeDeviceEventListener(AccelDeviceEventListener l) {
+        AccelDeviceEventNotifier.removeListener(l);
+    }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/opengl/WGLSurfaceData.java openjdk/jdk/src/windows/classes/sun/java2d/opengl/WGLSurfaceData.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/opengl/WGLSurfaceData.java	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/opengl/WGLSurfaceData.java	2011-01-08 01:26:50.471202211 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,26 +26,23 @@
 package sun.java2d.opengl;
 
 import java.awt.Component;
-import java.awt.Container;
 import java.awt.GraphicsConfiguration;
 import java.awt.GraphicsDevice;
 import java.awt.GraphicsEnvironment;
 import java.awt.Image;
-import java.awt.Insets;
 import java.awt.Rectangle;
-import java.awt.Transparency;
 import java.awt.image.ColorModel;
+import sun.awt.SunToolkit;
 import sun.awt.windows.WComponentPeer;
 import sun.java2d.SurfaceData;
-import sun.java2d.loops.SurfaceType;
 
 public abstract class WGLSurfaceData extends OGLSurfaceData {
 
     protected WComponentPeer peer;
     private WGLGraphicsConfig graphicsConfig;
 
-    private native void initOps(long pConfigInfo, long pPeerData,
-                                int xoff, int yoff);
+    private native void initOps(long pConfigInfo, WComponentPeer peer,
+                                long hwnd);
     protected native boolean initPbuffer(long pData, long pConfigInfo,
                                          boolean isOpaque,
                                          int width, int height);
@@ -58,19 +55,9 @@
         this.graphicsConfig = gc;
 
         long pConfigInfo = gc.getNativeConfigInfo();
-        long pPeerData = 0L;
-        int xoff = 0, yoff = 0;
-        if (peer != null) {
-            Component c = (Component)peer.getTarget();
-            if (c instanceof Container) {
-                Insets insets = ((Container)c).getInsets();
-                xoff = -insets.left;
-                yoff = -insets.bottom;
-            }
-            pPeerData = peer.getData();
-        }
+        long hwnd = peer != null ? peer.getHWnd() : 0L;
 
-        initOps(pConfigInfo, pPeerData, xoff, yoff);
+        initOps(pConfigInfo, peer, hwnd);
     }
 
     public GraphicsConfiguration getDeviceConfiguration() {
@@ -82,6 +69,15 @@
      * of an on-screen Window.
      */
     public static WGLWindowSurfaceData createData(WComponentPeer peer) {
+        // the OGL pipeline can render directly to the screen and interfere
+        // with layered windows, which is why we don't allow accelerated
+        // surfaces in this case
+        if (!peer.isAccelCapable())
+        // REMIND: commented until toplevel translucency is implemented
+//            || !SunToolkit.isContainingTopLevelOpaque((Component)peer.getTarget()))
+        {
+            return null;
+        }
         WGLGraphicsConfig gc = getGC(peer);
         return new WGLWindowSurfaceData(peer, gc);
     }
@@ -91,13 +87,29 @@
      * double-buffered on-screen Window.
      */
     public static WGLOffScreenSurfaceData createData(WComponentPeer peer,
-                                                     Image image)
+                                                     Image image,
+                                                     int type)
     {
+        // the OGL pipeline can render directly to the screen and interfere
+        // with layered windows, which is why we don't allow accelerated
+        // surfaces in this case
+        if (!peer.isAccelCapable())
+        // REMIND: commented until toplevel translucency is implemented
+//            || !SunToolkit.isContainingTopLevelOpaque((Component)peer.getTarget()))
+        {
+            return null;
+        }
         WGLGraphicsConfig gc = getGC(peer);
         Rectangle r = peer.getBounds();
-        return new WGLOffScreenSurfaceData(peer, gc, r.width, r.height,
-                                           image, peer.getColorModel(),
-                                           FLIP_BACKBUFFER);
+        if (type == FLIP_BACKBUFFER) {
+            return new WGLOffScreenSurfaceData(peer, gc, r.width, r.height,
+                                               image, peer.getColorModel(),
+                                               type);
+        } else {
+            return new WGLVSyncOffScreenSurfaceData(peer, gc, r.width, r.height,
+                                                    image, peer.getColorModel(),
+                                                    type);
+        }
     }
 
     /**
@@ -152,6 +164,42 @@
         }
     }
 
+    /**
+     * A surface which implements a v-synced flip back-buffer with COPIED
+     * FlipContents.
+     *
+     * This surface serves as a back-buffer to the outside world, while
+     * it is actually an offscreen surface. When the BufferStrategy this surface
+     * belongs to is showed, it is first copied to the real private
+     * FLIP_BACKBUFFER, which is then flipped.
+     */
+    public static class WGLVSyncOffScreenSurfaceData extends
+        WGLOffScreenSurfaceData
+    {
+        private WGLOffScreenSurfaceData flipSurface;
+
+        public WGLVSyncOffScreenSurfaceData(WComponentPeer peer,
+                                            WGLGraphicsConfig gc,
+                                            int width, int height,
+                                            Image image, ColorModel cm,
+                                            int type)
+        {
+            super(peer, gc, width, height, image, cm, type);
+            flipSurface = WGLSurfaceData.createData(peer, image, FLIP_BACKBUFFER);
+        }
+
+        public SurfaceData getFlipSurface() {
+            return flipSurface;
+        }
+
+        @Override
+        public void flush() {
+            flipSurface.flush();
+            super.flush();
+        }
+
+    }
+
     public static class WGLOffScreenSurfaceData extends WGLSurfaceData {
 
         private Image offscreenImage;
@@ -193,4 +241,17 @@
             return offscreenImage;
         }
     }
+
+    /**
+     * Updates the layered window with the contents of the surface.
+     *
+     * @param psdops pointer to the native ogl sd structure
+     * @param pData pointer to the AwtWindow peer data
+     * @param w width of the window
+     * @param h height of the window
+     * @see sun.awt.windows.TranslucentWindowPainter
+     */
+    public static native boolean updateWindowAccelImpl(long psdops,
+                                                       WComponentPeer peer,
+                                                       int w, int h);
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/opengl/WGLVolatileSurfaceManager.java openjdk/jdk/src/windows/classes/sun/java2d/opengl/WGLVolatileSurfaceManager.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/opengl/WGLVolatileSurfaceManager.java	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/opengl/WGLVolatileSurfaceManager.java	2011-01-08 01:26:50.471202211 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,16 +25,20 @@
 
 package sun.java2d.opengl;
 
+import java.awt.BufferCapabilities;
+import static java.awt.BufferCapabilities.FlipContents.*;
 import java.awt.Component;
 import java.awt.GraphicsConfiguration;
-import java.awt.ImageCapabilities;
-import java.awt.Rectangle;
 import java.awt.Transparency;
 import java.awt.image.ColorModel;
 import sun.awt.image.SunVolatileImage;
 import sun.awt.image.VolatileSurfaceManager;
 import sun.awt.windows.WComponentPeer;
 import sun.java2d.SurfaceData;
+import static sun.java2d.opengl.OGLContext.OGLContextCaps.*;
+import static sun.java2d.pipe.hw.AccelSurface.*;
+import sun.java2d.pipe.hw.ExtendedBufferCapabilities;
+import static sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType.*;
 
 public class WGLVolatileSurfaceManager
     extends VolatileSurfaceManager
@@ -57,8 +61,8 @@
         accelerationEnabled =
             (transparency == Transparency.OPAQUE) ||
             ((transparency == Transparency.TRANSLUCENT) &&
-             (gc.isCapPresent(OGLContext.CAPS_EXT_FBOBJECT) ||
-              gc.isCapPresent(OGLContext.CAPS_STORED_ALPHA)));
+             (gc.isCapPresent(CAPS_EXT_FBOBJECT) ||
+              gc.isCapPresent(CAPS_STORED_ALPHA)));
     }
 
     protected boolean isAccelerationEnabled() {
@@ -76,24 +80,47 @@
             (comp != null) ? (WComponentPeer)comp.getPeer() : null;
 
         try {
+            boolean createVSynced = false;
             boolean forceback = false;
             if (context instanceof Boolean) {
                 forceback = ((Boolean)context).booleanValue();
+                if (forceback) {
+                    BufferCapabilities caps = peer.getBackBufferCaps();
+                    if (caps instanceof ExtendedBufferCapabilities) {
+                        ExtendedBufferCapabilities ebc =
+                            (ExtendedBufferCapabilities)caps;
+                        if (ebc.getVSync() == VSYNC_ON &&
+                            ebc.getFlipContents() == COPIED)
+                        {
+                            createVSynced = true;
+                            forceback = false;
+                        }
+                    }
+                }
             }
 
             if (forceback) {
                 // peer must be non-null in this case
-                sData = WGLSurfaceData.createData(peer, vImg);
+                sData = WGLSurfaceData.createData(peer, vImg, FLIP_BACKBUFFER);
             } else {
                 WGLGraphicsConfig gc =
                     (WGLGraphicsConfig)vImg.getGraphicsConfig();
                 ColorModel cm = gc.getColorModel(vImg.getTransparency());
-                int type = gc.isCapPresent(OGLContext.CAPS_EXT_FBOBJECT) ?
-                    OGLSurfaceData.FBOBJECT : OGLSurfaceData.PBUFFER;
-                sData = WGLSurfaceData.createData(gc,
-                                                  vImg.getWidth(),
-                                                  vImg.getHeight(),
-                                                  cm, vImg, type);
+                int type = vImg.getForcedAccelSurfaceType();
+                // if acceleration type is forced (type != UNDEFINED) then
+                // use the forced type, otherwise choose one based on caps
+                if (type == OGLSurfaceData.UNDEFINED) {
+                    type = gc.isCapPresent(CAPS_EXT_FBOBJECT) ?
+                        OGLSurfaceData.FBOBJECT : OGLSurfaceData.PBUFFER;
+                }
+                if (createVSynced) {
+                    sData = WGLSurfaceData.createData(peer, vImg, type);
+                } else {
+                    sData = WGLSurfaceData.createData(gc,
+                                                      vImg.getWidth(),
+                                                      vImg.getHeight(),
+                                                      cm, vImg, type);
+                }
             }
         } catch (NullPointerException ex) {
             sData = null;
@@ -104,7 +131,15 @@
         return sData;
     }
 
+    @Override
     protected boolean isConfigValid(GraphicsConfiguration gc) {
         return ((gc == null) || (gc == vImg.getGraphicsConfig()));
     }
+
+    @Override
+    public void initContents() {
+        if (vImg.getForcedAccelSurfaceType() != OGLSurfaceData.TEXTURE) {
+            super.initContents();
+        }
+    }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/ScreenUpdateManager.java openjdk/jdk/src/windows/classes/sun/java2d/ScreenUpdateManager.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/ScreenUpdateManager.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/ScreenUpdateManager.java	2011-01-08 01:26:50.471202211 +0000
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.java2d;
+
+import java.awt.Color;
+import java.awt.Font;
+import java.awt.Graphics2D;
+import sun.awt.Win32GraphicsConfig;
+import sun.awt.windows.WComponentPeer;
+import sun.java2d.d3d.D3DScreenUpdateManager;
+import sun.java2d.windows.WindowsFlags;
+
+/**
+ * This class handles the creation of on-screen surfaces and
+ * corresponding graphics objects.
+ *
+ * By default it delegates the surface creation to the
+ * particular GraphicsConfiguration classes.
+ */
+public class ScreenUpdateManager {
+    private static ScreenUpdateManager theInstance;
+
+    protected ScreenUpdateManager() {
+    }
+
+    /**
+     * Creates a SunGraphics2D object for the surface,
+     * given the parameters.
+     *
+     * @param sd surface data for which a graphics is to be created
+     * @param peer peer which owns the surface
+     * @param fgColor fg color to be used in the graphics
+     * @param bgColor bg color to be used in the graphics
+     * @param font font to be used in the graphics
+     * @return a SunGraphics2D object for rendering to the passed surface
+     */
+    public synchronized Graphics2D createGraphics(SurfaceData sd,
+            WComponentPeer peer, Color fgColor, Color bgColor, Font font)
+    {
+        return new SunGraphics2D(sd, fgColor, bgColor, font);
+    }
+
+    /**
+     * Creates and returns the surface for the peer. This surface becomes
+     * managed by this manager. To remove the surface from the managed list
+     * {@code}dropScreenSurface(SurfaceData){@code} will need to be called.
+     *
+     * The default implementation delegates surface creation
+     * to the passed in GraphicsConfiguration object.
+     *
+     * @param gc graphics configuration for which the surface is to be created
+     * @param peer peer for which the onscreen surface is to be created
+     * @param bbNum number of back-buffers requested for this peer
+     * @param isResize whether this surface is being created in response to
+     * a component resize event
+     * @return a SurfaceData to be used for on-screen rendering for this peer.
+     * @see #dropScreenSurface(SurfaceData)
+     */
+    public SurfaceData createScreenSurface(Win32GraphicsConfig gc,
+                                           WComponentPeer peer, int bbNum,
+                                           boolean isResize)
+    {
+        return gc.createSurfaceData(peer, bbNum);
+    }
+
+    /**
+     * Drops the passed surface from the list of managed surfaces.
+     *
+     * Nothing happens if the surface wasn't managed by this manager.
+     *
+     * @param sd SurfaceData to be removed from the list of managed surfaces
+     */
+    public void dropScreenSurface(SurfaceData sd) {}
+
+    /**
+     * Returns a replacement SurfaceData for the invalid passed one.
+     *
+     * This method should be used by SurfaceData's created by
+     * the ScreenUpdateManager for providing replacement surfaces.
+     *
+     * @param peer to which the old surface belongs
+     * @param oldsd the old (invalid) surface to get replaced
+     * @return a replacement surface
+     * @see sun.java2d.d3d.D3DSurfaceData.D3DWindowSurfaceData#getReplacement()
+     * @see sun.java2d.windows.GDIWindowSurfaceData#getReplacement()
+     */
+    public SurfaceData getReplacementScreenSurface(WComponentPeer peer,
+                                                   SurfaceData oldsd)
+    {
+        return peer.getSurfaceData();
+    }
+
+    /**
+     * Returns an (singleton) instance of the screen surfaces
+     * manager class.
+     * @return instance of onscreen surfaces manager
+     */
+    public static synchronized ScreenUpdateManager getInstance() {
+        if (theInstance == null) {
+            if (WindowsFlags.isD3DEnabled()) {
+                theInstance = new D3DScreenUpdateManager();
+            } else {
+                theInstance = new ScreenUpdateManager();
+            }
+        }
+        return theInstance;
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/SurfaceManagerFactory.java openjdk/jdk/src/windows/classes/sun/java2d/SurfaceManagerFactory.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/SurfaceManagerFactory.java	2011-01-07 21:33:07.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/SurfaceManagerFactory.java	2011-01-08 01:26:50.471202211 +0000
@@ -26,14 +26,13 @@
 package sun.java2d;
 
 import java.awt.GraphicsConfiguration;
-import java.awt.image.BufferedImage;
+import sun.awt.image.BufImgVolatileSurfaceManager;
 import sun.awt.image.SunVolatileImage;
-import sun.awt.image.SurfaceManager;
 import sun.awt.image.VolatileSurfaceManager;
+import sun.java2d.d3d.D3DGraphicsConfig;
+import sun.java2d.d3d.D3DVolatileSurfaceManager;
 import sun.java2d.opengl.WGLGraphicsConfig;
 import sun.java2d.opengl.WGLVolatileSurfaceManager;
-import sun.java2d.windows.WindowsFlags;
-import sun.java2d.windows.WinVolatileSurfaceManager;
 
 /**
  * This is a factory class with static methods for creating a
@@ -55,10 +54,12 @@
                               Object context)
     {
         GraphicsConfiguration gc = vImg.getGraphicsConfig();
-        if (gc instanceof WGLGraphicsConfig) {
+        if (gc instanceof D3DGraphicsConfig) {
+            return new D3DVolatileSurfaceManager(vImg, context);
+        } else if (gc instanceof WGLGraphicsConfig) {
             return new WGLVolatileSurfaceManager(vImg, context);
         } else {
-            return new WinVolatileSurfaceManager(vImg, context);
+            return new BufImgVolatileSurfaceManager(vImg, context);
         }
     }
 }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/windows/GDIBlitLoops.java openjdk/jdk/src/windows/classes/sun/java2d/windows/GDIBlitLoops.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/windows/GDIBlitLoops.java	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/windows/GDIBlitLoops.java	2011-01-08 01:26:50.471202211 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -60,23 +60,23 @@
     {
         GraphicsPrimitive[] primitives = {
             new GDIBlitLoops(SurfaceType.IntRgb,
-                             Win32SurfaceData.AnyGdi),
+                             GDIWindowSurfaceData.AnyGdi),
             new GDIBlitLoops(SurfaceType.Ushort555Rgb,
-                             Win32SurfaceData.AnyGdi,
+                             GDIWindowSurfaceData.AnyGdi,
                              0x7C00, 0x03E0, 0x001F),
             new GDIBlitLoops(SurfaceType.Ushort565Rgb,
-                             Win32SurfaceData.AnyGdi,
+                             GDIWindowSurfaceData.AnyGdi,
                              0xF800, 0x07E0, 0x001F),
             new GDIBlitLoops(SurfaceType.ThreeByteBgr,
-                             Win32SurfaceData.AnyGdi),
+                             GDIWindowSurfaceData.AnyGdi),
             new GDIBlitLoops(SurfaceType.ByteIndexedOpaque,
-                             Win32SurfaceData.AnyGdi,
+                             GDIWindowSurfaceData.AnyGdi,
                              true),
             new GDIBlitLoops(SurfaceType.Index8Gray,
-                             Win32SurfaceData.AnyGdi,
+                             GDIWindowSurfaceData.AnyGdi,
                              true),
             new GDIBlitLoops(SurfaceType.ByteGray,
-                             Win32SurfaceData.AnyGdi),
+                             GDIWindowSurfaceData.AnyGdi),
         };
         GraphicsPrimitiveMgr.register(primitives);
     }
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/windows/GDIWindowSurfaceData.java openjdk/jdk/src/windows/classes/sun/java2d/windows/GDIWindowSurfaceData.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/windows/GDIWindowSurfaceData.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/classes/sun/java2d/windows/GDIWindowSurfaceData.java	2011-01-08 01:26:50.471202211 +0000
@@ -0,0 +1,354 @@
+/*
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.java2d.windows;
+
+import java.awt.Rectangle;
+import java.awt.GraphicsConfiguration;
+import java.awt.color.ColorSpace;
+import java.awt.image.ColorModel;
+import java.awt.image.ComponentColorModel;
+import java.awt.image.DirectColorModel;
+import java.awt.image.IndexColorModel;
+import java.awt.image.Raster;
+
+import sun.awt.SunHints;
+import sun.awt.Win32GraphicsConfig;
+import sun.awt.Win32GraphicsDevice;
+import sun.awt.windows.WComponentPeer;
+import sun.awt.windows.WFileDialogPeer;
+import sun.awt.windows.WPrintDialogPeer;
+import sun.java2d.ScreenUpdateManager;
+import sun.java2d.SunGraphics2D;
+import sun.java2d.SurfaceData;
+import sun.java2d.SurfaceDataProxy;
+import sun.java2d.pipe.Region;
+import sun.java2d.pipe.PixelToShapeConverter;
+import sun.java2d.loops.GraphicsPrimitive;
+import sun.java2d.loops.SurfaceType;
+import sun.java2d.loops.CompositeType;
+import sun.java2d.loops.RenderLoops;
+import sun.java2d.loops.XORComposite;
+
+public class GDIWindowSurfaceData extends SurfaceData {
+    private WComponentPeer peer;
+    private Win32GraphicsConfig graphicsConfig;
+    private RenderLoops solidloops;
+
+    // GDI onscreen surface type
+    public static final String
+        DESC_GDI                = "GDI";
+
+    // Generic GDI surface type - used for registering all loops
+    public static final SurfaceType AnyGdi =
+        SurfaceType.IntRgb.deriveSubType(DESC_GDI);
+
+    public static final SurfaceType IntRgbGdi =
+        SurfaceType.IntRgb.deriveSubType(DESC_GDI);
+
+    public static final SurfaceType Ushort565RgbGdi =
+        SurfaceType.Ushort565Rgb.deriveSubType(DESC_GDI);
+
+    public static final SurfaceType Ushort555RgbGdi =
+        SurfaceType.Ushort555Rgb.deriveSubType(DESC_GDI);
+
+    public static final SurfaceType ThreeByteBgrGdi =
+        SurfaceType.ThreeByteBgr.deriveSubType(DESC_GDI);
+
+    private static native void initIDs(Class xorComp);
+
+    static {
+        initIDs(XORComposite.class);
+        if (WindowsFlags.isGdiBlitEnabled()) {
+            // Register our gdi Blit loops
+            GDIBlitLoops.register();
+        }
+    }
+
+    public static SurfaceType getSurfaceType(ColorModel cm) {
+        switch (cm.getPixelSize()) {
+        case 32:
+        case 24:
+            if (cm instanceof DirectColorModel) {
+                if (((DirectColorModel)cm).getRedMask() == 0xff0000) {
+                    return IntRgbGdi;
+                } else {
+                    return SurfaceType.IntRgbx;
+                }
+            } else {
+                return ThreeByteBgrGdi;
+            }
+        case 15:
+            return Ushort555RgbGdi;
+        case 16:
+            if ((cm instanceof DirectColorModel) &&
+                (((DirectColorModel)cm).getBlueMask() == 0x3e))
+            {
+                return SurfaceType.Ushort555Rgbx;
+            } else {
+                return Ushort565RgbGdi;
+            }
+        case 8:
+            if (cm.getColorSpace().getType() == ColorSpace.TYPE_GRAY &&
+                cm instanceof ComponentColorModel) {
+                return SurfaceType.ByteGray;
+            } else if (cm instanceof IndexColorModel &&
+                       isOpaqueGray((IndexColorModel)cm)) {
+                return SurfaceType.Index8Gray;
+            } else {
+                return SurfaceType.ByteIndexedOpaque;
+            }
+        default:
+            throw new sun.java2d.InvalidPipeException("Unsupported bit " +
+                                                      "depth: " +
+                                                      cm.getPixelSize());
+        }
+    }
+
+    public static GDIWindowSurfaceData createData(WComponentPeer peer) {
+        SurfaceType sType = getSurfaceType(peer.getDeviceColorModel());
+        return new GDIWindowSurfaceData(peer, sType);
+    }
+
+    @Override
+    public SurfaceDataProxy makeProxyFor(SurfaceData srcData) {
+        return SurfaceDataProxy.UNCACHED;
+    }
+
+    public Raster getRaster(int x, int y, int w, int h) {
+        throw new InternalError("not implemented yet");
+    }
+
+    protected static GDIRenderer gdiPipe;
+    protected static PixelToShapeConverter gdiTxPipe;
+
+    static {
+        gdiPipe = new GDIRenderer();
+        if (GraphicsPrimitive.tracingEnabled()) {
+            gdiPipe = gdiPipe.traceWrap();
+        }
+        gdiTxPipe = new PixelToShapeConverter(gdiPipe);
+
+    }
+
+    public void validatePipe(SunGraphics2D sg2d) {
+        if (sg2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON &&
+            sg2d.paintState <= sg2d.PAINT_ALPHACOLOR &&
+            (sg2d.compositeState <= sg2d.COMP_ISCOPY ||
+             sg2d.compositeState == sg2d.COMP_XOR))
+        {
+            if (sg2d.clipState == sg2d.CLIP_SHAPE) {
+                // Do this to init textpipe correctly; we will override the
+                // other non-text pipes below
+                // REMIND: we should clean this up eventually instead of
+                // having this work duplicated.
+                super.validatePipe(sg2d);
+            } else {
+                switch (sg2d.textAntialiasHint) {
+
+                case SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT:
+                    /* equate DEFAULT to OFF which it is for us */
+                case SunHints.INTVAL_TEXT_ANTIALIAS_OFF:
+                    sg2d.textpipe = solidTextRenderer;
+                    break;
+
+                case SunHints.INTVAL_TEXT_ANTIALIAS_ON:
+                    sg2d.textpipe = aaTextRenderer;
+                    break;
+
+                default:
+                    switch (sg2d.getFontInfo().aaHint) {
+
+                    case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB:
+                    case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB:
+                        sg2d.textpipe = lcdTextRenderer;
+                        break;
+
+                    case SunHints.INTVAL_TEXT_ANTIALIAS_ON:
+                        sg2d.textpipe = aaTextRenderer;
+                        break;
+
+                    default:
+                        sg2d.textpipe = solidTextRenderer;
+                    }
+                }
+            }
+            sg2d.imagepipe = imagepipe;
+            if (sg2d.transformState >= sg2d.TRANSFORM_TRANSLATESCALE) {
+                sg2d.drawpipe = gdiTxPipe;
+                sg2d.fillpipe = gdiTxPipe;
+            } else if (sg2d.strokeState != sg2d.STROKE_THIN){
+                sg2d.drawpipe = gdiTxPipe;
+                sg2d.fillpipe = gdiPipe;
+            } else {
+                sg2d.drawpipe = gdiPipe;
+                sg2d.fillpipe = gdiPipe;
+            }
+            sg2d.shapepipe = gdiPipe;
+            // This is needed for AA text.
+            // Note that even a SolidTextRenderer can dispatch AA text
+            // if a GlyphVector overrides the AA setting.
+            // We use getRenderLoops() rather than setting solidloops
+            // directly so that we get the appropriate loops in XOR mode.
+            sg2d.loops = getRenderLoops(sg2d);
+        } else {
+            super.validatePipe(sg2d);
+        }
+    }
+
+    public RenderLoops getRenderLoops(SunGraphics2D sg2d) {
+        if (sg2d.paintState <= sg2d.PAINT_ALPHACOLOR &&
+            sg2d.compositeState <= sg2d.COMP_ISCOPY)
+        {
+            return solidloops;
+        }
+        return super.getRenderLoops(sg2d);
+    }
+
+    public GraphicsConfiguration getDeviceConfiguration() {
+        return graphicsConfig;
+    }
+
+    /**
+     * Initializes the native Ops pointer.
+     */
+    private native void initOps(WComponentPeer peer, int depth, int redMask,
+                                int greenMask, int blueMask, int screen);
+
+    private GDIWindowSurfaceData(WComponentPeer peer, SurfaceType sType) {
+        super(sType, peer.getDeviceColorModel());
+        ColorModel cm = peer.getDeviceColorModel();
+        this.peer = peer;
+        int rMask = 0, gMask = 0, bMask = 0;
+        int depth;
+        switch (cm.getPixelSize()) {
+        case 32:
+        case 24:
+            if (cm instanceof DirectColorModel) {
+                depth = 32;
+            } else {
+                depth = 24;
+            }
+            break;
+        default:
+            depth = cm.getPixelSize();
+        }
+        if (cm instanceof DirectColorModel) {
+            DirectColorModel dcm = (DirectColorModel)cm;
+            rMask = dcm.getRedMask();
+            gMask = dcm.getGreenMask();
+            bMask = dcm.getBlueMask();
+        }
+        this.graphicsConfig =
+            (Win32GraphicsConfig) peer.getGraphicsConfiguration();
+        this.solidloops = graphicsConfig.getSolidLoops(sType);
+        if (peer instanceof WFileDialogPeer ||
+            peer instanceof WPrintDialogPeer )
+        {
+            // REMIND: Awful hack.  The right fix for this problem
+            // would be for these type of Peers to not even use a
+            // GDIWindowSurfaceData object since they never do any
+            // rendering.  Or they could actually implement the
+            // functionality needed in initOps.  But this seems
+            // to work for now.  See bug 4391928 for more info.
+            return;
+        }
+        Win32GraphicsDevice gd =
+            (Win32GraphicsDevice)graphicsConfig.getDevice();
+        initOps(peer, depth, rMask, gMask, bMask, gd.getScreen());
+        setBlitProxyKey(graphicsConfig.getProxyKey());
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Overridden to use ScreenUpdateManager to obtain the replacement surface.
+     *
+     * @see sun.java2d.ScreenUpdateManager#getReplacementScreenSurface
+     */
+    @Override
+    public SurfaceData getReplacement() {
+        ScreenUpdateManager mgr = ScreenUpdateManager.getInstance();
+        return mgr.getReplacementScreenSurface(peer, this);
+    }
+
+    public Rectangle getBounds() {
+        Rectangle r = peer.getBounds();
+        r.x = r.y = 0;
+        return r;
+    }
+
+    public boolean copyArea(SunGraphics2D sg2d,
+                            int x, int y, int w, int h, int dx, int dy)
+    {
+        CompositeType comptype = sg2d.imageComp;
+        if (sg2d.transformState < sg2d.TRANSFORM_TRANSLATESCALE &&
+            sg2d.clipState != sg2d.CLIP_SHAPE &&
+            (CompositeType.SrcOverNoEa.equals(comptype) ||
+             CompositeType.SrcNoEa.equals(comptype)))
+        {
+            x += sg2d.transX;
+            y += sg2d.transY;
+            int dstx1 = x + dx;
+            int dsty1 = y + dy;
+            int dstx2 = dstx1 + w;
+            int dsty2 = dsty1 + h;
+            Region clip = sg2d.getCompClip();
+            if (dstx1 < clip.getLoX()) dstx1 = clip.getLoX();
+            if (dsty1 < clip.getLoY()) dsty1 = clip.getLoY();
+            if (dstx2 > clip.getHiX()) dstx2 = clip.getHiX();
+            if (dsty2 > clip.getHiY()) dsty2 = clip.getHiY();
+            if (dstx1 < dstx2 && dsty1 < dsty2) {
+                gdiPipe.devCopyArea(this, dstx1 - dx, dsty1 - dy,
+                                    dx, dy,
+                                    dstx2 - dstx1, dsty2 - dsty1);
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private native void invalidateSD();
+    @Override
+    public void invalidate() {
+        if (isValid()) {
+            invalidateSD();
+            super.invalidate();
+            //peer.invalidateBackBuffer();
+        }
+    }
+
+    /**
+     * Returns destination Component associated with this SurfaceData.
+     */
+    @Override
+    public Object getDestination() {
+        return peer.getTarget();
+    }
+
+    public WComponentPeer getPeer() {
+        return peer;
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/classes/sun/java2d/windows/WindowsFlags.java openjdk/jdk/src/windows/classes/sun/java2d/windows/WindowsFlags.java
--- openjdk.orig/jdk/src/windows/classes/sun/java2d/windows/WindowsFlags.java	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/classes/sun/java2d/windows/WindowsFlags.java	2011-01-08 01:26:50.471202211 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,71 +39,24 @@
      * has forced it on with d3d=true.  These associated variables have
      * the same base (eg, d3d) but end in "Set" (eg, d3dEnabled and
      * d3dSet).
-     *      ddEnabled: usage: "-Dsun.java2d.noddraw[=true]"
-     *               turns off all usage of ddraw, including surface -> surface
-     *               Blts (including onscreen->onscreen copyarea), offscreen
-     *               surface creation, and surface locking via DDraw.
-     *      ddOffscreenEnabled: usage: "-Dsun.java2d.ddoffscreen=false"
-     *               disables the use of ddraw surfaces for offscreen
-     *               images.  Effectively disables use of ddraw for most
-     *               operations except onscreen scrolling and some locking.
-     *      ddVramForced: usage: "-Dsun.java2d.ddforcevram=true"
-     *               Disables punts of offscreen ddraw surfaces to ddraw
-     *               system memory.  We use a punting mechanism when we detect
-     *               a high proportion of expensive read operations on a ddraw
-     *               surface; this flag disables that mechanism and forces the
-     *               surfaces to remain in VRAM regardless.
-     *      ddLockEnabled:  usage: "-Dsun.java2d.ddlock=[true|false]"
-     *               forces on|off usage of DirectDraw for locking the
-     *               screen.  This feature is usually enabled by default
-     *               for pre-Win2k OS's and disabled by default for
-     *               Win2k and future OS's (as of jdk1.4.1).
+     *      ddEnabled: usage: "-Dsun.java2d.noddraw[=false|true]"
+     *               turns on/off all usage of Direct3D
+     *      ddOffscreenEnabled: equivalent of sun.java2d.noddraw
      *      gdiBlitEnabled: usage: "-Dsun.java2d.gdiblit=false"
      *               turns off Blit loops that use GDI for copying to
      *               the screen from certain image types.  Copies will,
      *               instead, happen via ddraw locking or temporary GDI DIB
      *               creation/copying (depending on OS and other flags)
-     *      ddBlitEnabled: usage: "-Dsun.java2d.ddblit=false"
-     *               turns off Blit loops that use DDraw for copying to
-     *               the screen from other ddraw surfaces.  Copies will use
-     *               fallback mechanisms of GDI blits or ddraw locks, as
-     *               appropriate.  This flag is primarily for debugging
-     *               purposes, to force our copies through a different code
-     *               path.
-     *      ddScaleEnabled: usage: "-Dsun.java2d.ddscale=true"
-     *               Turns on hardware-accelerated iamge scaling via ddraw.
-     *               This is off by default because we cannot guarantee the
-     *               quality of the scaling; hardware may choose to do
-     *               filtered or unfiltered scales, resulting in inconsistent
-     *               scaling between ddraw-accelerated and java2D-rendered
-     *               operations.  This flag and capability should go away
-     *               someday as we eventually should use Direct3D for any
-     *               scaling operation (where we can control the filtering
-     *               used).
      *      d3dEnabled: usage: "-Dsun.java2d.d3d=[true|false]"
      *               Forces our use of Direct3D on or off.  Direct3D is on
      *               by default, but may be disabled in some situations, such
-     *               as when running on Itanium, or on a card with bad d3d line
-     *               quality, or on a video card that we have had bad experience
-     *               with (e.g., Trident).  This flag can force us to use d3d
+     *               as on a card with bad d3d line quality, or on a video card
+     *               that we have had bad experience with (e.g., Trident).
+     *               This flag can force us to use d3d
      *               anyway in these situations.  Or, this flag can force us to
      *               not use d3d in a situation where we would use it otherwise.
      *      translAccelEnabled: usage: "-Dsun.java2d.translaccel=true"
-     *               Turns on hardware acceleration for some translucent
-     *               image copying via Direct3D.  Images that are created with
-     *               GraphicsConfiguration.createCompatibleImage(w, h, trans)
-     *               may be acceleratable by use a Direct3D texture and
-     *               performing copying operations to other DirectX-based
-     *               image destinations via a textured quad.  This capability
-     *               is disabled by default pending further testing and fixing
-     *               some minor bugs (such as the ability to render Direct3D
-     *               to the screen which completely ignores the desktop
-     *               clip list).  When this capability is turned on by default,
-     *               this flag should go away.  Note: currently, enabling this
-     *               flag also enables the ddVramForced flag.  This is because
-     *               d3d translucency acceleration can only happen to offscreen
-     *               surfaces which have not been punted through the means that
-     *               ddVramForced disables.
+     *               equivalent to sun.java2d.d3d=true
      *      offscreenSharingEnabled: usage: "-Dsun.java2d.offscreenSharing=true"
      *               Turns on the ability to share a hardware-accelerated
      *               offscreen surface through the JAWT interface.  See
@@ -114,15 +67,6 @@
      *               without being very sure that we will be willing to support
      *               that API in the future regardless of other native
      *               rendering pipeline changes.
-     *      d3dTexBpp: usage: "-Dsun.java2d.d3dtexbpp=[16|32]
-     *               When translucent image acceleration is enabled (see
-     *               translAccelEnabled above), this flag specifies the bit
-     *               depth of the software (BufferedImage) and hardware
-     *               (textures) that we should use.  The default is to use
-     *               32 bit images and textures, but specifying a value of 16
-     *               for this flag will force us to use a color model of 4444
-     *               and 16-bit textures.  This can be useful for applications
-     *               with heavy requirements on constrained VRAM resources.
      *      accelReset: usage: "-Dsun.java2d.accelReset"
      *               This flag tells us to reset any persistent information
      *               the display device acceleration characteristics so that
@@ -169,28 +113,19 @@
      *
      */
 
-    private static boolean ddEnabled;
-    private static boolean ddSet;
-    private static boolean ddOffscreenEnabled;
-    private static boolean ddVramForced;
-    private static boolean ddLockEnabled;
-    private static boolean ddLockSet;
     private static boolean gdiBlitEnabled;
-    private static boolean ddBlitEnabled;
-    private static boolean ddScaleEnabled;
     private static boolean d3dEnabled;
     private static boolean d3dVerbose;
     private static boolean d3dSet;
+    private static boolean d3dOnScreenEnabled;
     private static boolean oglEnabled;
     private static boolean oglVerbose;
-    private static boolean translAccelEnabled;
     private static boolean offscreenSharingEnabled;
     private static boolean accelReset;
     private static boolean checkRegistry;
     private static boolean disableRegistry;
     private static boolean magPresent;
     private static boolean setHighDPIAware;
-    private static int d3dTexBpp;
     private static String javaVersion;
     // TODO: other flags, including nopixfmt
 
@@ -271,20 +206,18 @@
             public Object run() {
                 magPresent = getBooleanProp(
                     "javax.accessibility.screen_magnifier_present", false);
-                ddEnabled = !getBooleanProp("sun.java2d.noddraw", magPresent);
-                ddSet = getPropertySet("sun.java2d.noddraw");
-                ddOffscreenEnabled = getBooleanProp("sun.java2d.ddoffscreen",
-                    !magPresent);
-                ddVramForced = getBooleanProp("sun.java2d.ddforcevram", false);
-                ddLockEnabled = getBooleanProp("sun.java2d.ddlock", false);
-                ddBlitEnabled = getBooleanProp("sun.java2d.ddblit", !magPresent);
-                ddScaleEnabled = getBooleanProp("sun.java2d.ddscale", false);
-                d3dEnabled = getBooleanProp("sun.java2d.d3d", !magPresent);
+                boolean ddEnabled =
+                    !getBooleanProp("sun.java2d.noddraw", magPresent);
+                boolean ddOffscreenEnabled =
+                    getBooleanProp("sun.java2d.ddoffscreen", ddEnabled);
+                d3dEnabled = getBooleanProp("sun.java2d.d3d",
+                    ddEnabled && ddOffscreenEnabled);
+                d3dOnScreenEnabled =
+                    getBooleanProp("sun.java2d.d3d.onscreen", d3dEnabled);
                 oglEnabled = getBooleanProp("sun.java2d.opengl", false);
                 if (oglEnabled) {
                     oglVerbose = isBooleanPropTrueVerbose("sun.java2d.opengl");
                     if (WGLGraphicsConfig.isWGLAvailable()) {
-                        ddEnabled = false;
                         d3dEnabled = false;
                     } else {
                         if (oglVerbose) {
@@ -300,18 +233,6 @@
                 if (d3dSet) {
                     d3dVerbose = isBooleanPropTrueVerbose("sun.java2d.d3d");
                 }
-                translAccelEnabled =
-                    getBooleanProp("sun.java2d.translaccel", false);
-                if (translAccelEnabled) {
-                    // translucency only accelerated to un-punted buffers
-                    ddVramForced = true;
-                    // since they've requested translucency acceleration,
-                    // we assume they'll be happy with d3d quality
-                    if (!d3dSet && !magPresent) {
-                        d3dEnabled = true;
-                        d3dSet = true;
-                    }
-                }
                 offscreenSharingEnabled =
                     getBooleanProp("sun.java2d.offscreenSharing", false);
                 accelReset = getBooleanProp("sun.java2d.accelReset", false);
@@ -330,9 +251,6 @@
                         javaVersion = javaVersion.substring(0, dashIndex);
                     }
                 }
-                d3dTexBpp = getIntProp("sun.java2d.d3dtexbpp", 32);
-                ddLockSet = getPropertySet("sun.java2d.ddlock");
-
                 String dpiOverride = System.getProperty("sun.java2d.dpiaware");
                 if (dpiOverride != null) {
                     setHighDPIAware = dpiOverride.equalsIgnoreCase("true");
@@ -351,16 +269,6 @@
                         "releases and applications that depend on it " +
                         "may not work correctly");
                 }
-                if (translAccelEnabled) {
-                    System.out.println(
-                        "Acceleration for translucent images is enabled.");
-                }
-                if (!ddBlitEnabled) {
-                    System.out.println("DirectDraw Blits disabled");
-                }
-                if (ddScaleEnabled) {
-                    System.out.println("DirectDraw Scaling enabled");
-                }
                 */
                 return null;
             }
@@ -388,34 +296,6 @@
         */
     }
 
-    public static boolean isDDEnabled() {
-        return ddEnabled;
-    }
-
-    public static boolean isDDOffscreenEnabled() {
-        return ddOffscreenEnabled;
-    }
-
-    public static boolean isDDVramForced() {
-        return ddVramForced;
-    }
-
-    public static boolean isDDLockEnabled() {
-        return ddLockEnabled;
-    }
-
-    public static boolean isDDLockSet() {
-        return ddLockSet;
-    }
-
-    public static boolean isDDBlitEnabled() {
-        return ddBlitEnabled;
-    }
-
-    public static boolean isDDScaleEnabled() {
-        return ddScaleEnabled;
-    }
-
     public static boolean isD3DEnabled() {
         return d3dEnabled;
     }
@@ -424,12 +304,12 @@
         return d3dSet;
     }
 
-    public static boolean isD3DVerbose() {
-        return d3dVerbose;
+    public static boolean isD3DOnScreenEnabled() {
+        return d3dOnScreenEnabled;
     }
 
-    public static int getD3DTexBpp() {
-        return d3dTexBpp;
+    public static boolean isD3DVerbose() {
+        return d3dVerbose;
     }
 
     public static boolean isGdiBlitEnabled() {
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DBadHardware.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DBadHardware.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DBadHardware.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DBadHardware.h	2011-01-08 01:26:50.471202211 +0000
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifndef D3DBADHARDWARE_H
+#define D3DBADHARDWARE_H
+
+#include "D3DPipeline.h"
+#include "D3DPipelineManager.h"
+
+typedef struct ADAPTER_INFO {
+  DWORD    VendorId;
+  DWORD    DeviceId;
+  LONGLONG DriverVersion; // minimum driver version to pass, or NO_VERSION
+  USHORT   OsInfo;        // OSes where the DriverVersion is relevant or, OS_ALL
+} ADAPTER_INFO;
+
+// this DeviceId means that all vendor boards are to be excluded
+#define ALL_DEVICEIDS (0xffffffff)
+
+#define D_VERSION(H1, H2, L1, L2) \
+  (((LONGLONG)((H1 << 16) | H2) << 32) | ((L1 << 16) | (L2)))
+
+// this driver version is used to pass the driver version check
+// as it is always greater than any driver version
+#define MAX_VERSION D_VERSION(0x7fff, 0x7fff, 0x7fff, 0x7fff)
+// this DriverVersion means that the version of the driver doesn't matter,
+// all versions must fail ("there's no version of the driver that passes")
+#define NO_VERSION D_VERSION(0xffff, 0xffff, 0xffff, 0xffff)
+
+static const ADAPTER_INFO badHardware[] = {
+
+    // any Intel chip
+    // Reason: workaround for 6620073, 6612195, 6620073
+    { 0x8086, ALL_DEVICEIDS, NO_VERSION, OS_ALL },
+
+    // ATI Mobility Radeon X1600, X1400, X1450, X1300, X1350
+    // Reason: workaround for 6613066, 6687166
+    // X1300 (four sub ids)
+    { 0x1002, 0x714A, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x714A, D_VERSION(7,14,10,0567), OS_VISTA },
+    { 0x1002, 0x7149, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x7149, D_VERSION(7,14,10,0567), OS_VISTA },
+    { 0x1002, 0x714B, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x714B, D_VERSION(7,14,10,0567), OS_VISTA },
+    { 0x1002, 0x714C, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x714C, D_VERSION(7,14,10,0567), OS_VISTA },
+    // X1350 (three sub ids)
+    { 0x1002, 0x718B, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x718B, D_VERSION(7,14,10,0567), OS_VISTA },
+    { 0x1002, 0x718C, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x718C, D_VERSION(7,14,10,0567), OS_VISTA },
+    { 0x1002, 0x7196, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x7196, D_VERSION(7,14,10,0567), OS_VISTA },
+    // X1400
+    { 0x1002, 0x7145, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x7145, D_VERSION(7,14,10,0567), OS_VISTA },
+    // X1450 (two sub ids)
+    { 0x1002, 0x7186, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x7186, D_VERSION(7,14,10,0567), OS_VISTA },
+    { 0x1002, 0x718D, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x718D, D_VERSION(7,14,10,0567), OS_VISTA },
+    // X1600
+    { 0x1002, 0x71C5, D_VERSION(6,14,10,6706), OS_WINXP },
+    { 0x1002, 0x71C5, D_VERSION(7,14,10,0567), OS_VISTA },
+
+    // Nvidia Quadro NVS 110M
+    // Reason: workaround for 6629891
+    { 0x10DE, 0x01D7, D_VERSION(6,14,11,5665), OS_WINXP },
+
+    // Nvidia Quadro PCI-E series
+    // Reason: workaround for 6653860
+    { 0x10DE, 0x00FD, D_VERSION(6,14,10,6573), OS_WINXP },
+
+    // Nvidia GeForce 6200 TurboCache(TM)
+    // Reason: workaround for 6588384
+    { 0x10DE, 0x0161, NO_VERSION, OS_VISTA },
+
+    // any Matrox board
+    // Reason: there are no known Matrox boards with proper Direct3D support
+    { 0x102B, ALL_DEVICEIDS, NO_VERSION, OS_ALL },
+
+    // any SiS board
+    // Reason: there aren't many PS2.0-capable SiS boards and they weren't
+    // tested
+    { 0x1039, ALL_DEVICEIDS, NO_VERSION, OS_ALL },
+
+    // any S3 board
+    // Reason: no available S3 Chrome (the only S3 boards with PS2.0 support)
+    // for testing
+    { 0x5333, ALL_DEVICEIDS, NO_VERSION, OS_ALL },
+
+    // any S3 board (in VIA motherboards)
+    // Reason: These are S3 chips in VIA motherboards
+    { 0x1106, ALL_DEVICEIDS, NO_VERSION, OS_ALL },
+
+    // last record must be empty
+    { 0x0000, 0x0000, NO_VERSION, OS_ALL }
+};
+
+#endif // D3DBADHARDWARE_H
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DBlitLoops.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DBlitLoops.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DBlitLoops.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DBlitLoops.cpp	2011-01-08 01:26:50.471202211 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,116 +23,1092 @@
  * questions.
  */
 
-#include <stdlib.h>
 #include <jni.h>
 #include "jlong.h"
-#include <sun_java2d_d3d_D3DBlitLoops.h>
-#include "ddrawUtils.h"
-#include "GraphicsPrimitiveMgr.h"
-#include "Region.h"
 
-#include "D3DUtils.h"
-#include "D3DContext.h"
+#include "D3DPipeline.h"
+
+#include "SurfaceData.h"
+#include "D3DBlitLoops.h"
+#include "D3DRenderQueue.h"
 #include "D3DSurfaceData.h"
+#include "GraphicsPrimitiveMgr.h"
+
+#include "IntArgb.h"
+#include "IntArgbPre.h"
+#include "IntRgb.h"
+#include "IntBgr.h"
+#include "Ushort555Rgb.h"
+#include "Ushort565Rgb.h"
+#include "ByteIndexed.h"
 
-extern CriticalSection windowMoveLock;
 
-extern "C" {
+extern "C" BlitFunc IntArgbToIntArgbPreConvert;
+extern "C" BlitFunc IntArgbPreToIntArgbConvert;
+extern "C" BlitFunc IntArgbBmToIntArgbConvert;
+extern "C" BlitFunc IntRgbToIntArgbConvert;
+extern "C" BlitFunc Ushort565RgbToIntArgbConvert;
+extern "C" BlitFunc Ushort555RgbToIntArgbConvert;
+extern "C" BlitFunc IntBgrToIntArgbConvert;
+extern "C" BlitFunc AnyIntIsomorphicCopy;
+extern "C" BlitFunc ByteIndexedToIntArgbConvert;
+extern "C" BlitFunc ByteIndexedToIntArgbPreConvert;
+
+#define GETMIN(v1, v2)    (((v1) > (t=(v2))) && ((v1) = t))
+#define GETMAX(v1, v2)    (((v1) < (t=(v2))) && ((v1) = t))
+
+#ifdef D3D_PPL_DLL
 
 JNIEXPORT void JNICALL
-Java_sun_java2d_d3d_D3DBlitLoops_doTransform
-    (JNIEnv *env, jclass d3dbl,
-     jlong pSrcData, jlong pDstData,
-     jlong pCtx,
-     jint hint,
-     jint sx1, jint sy1, jint sx2, jint sy2,
-     jfloat dx1, jfloat dy1, jfloat dx2, jfloat dy2)
-{
-    static J2DLVERTEX quadVerts[4] = {
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f }
-    };
-
-    J2dTraceLn(J2D_TRACE_INFO, "D3DBlitLoops_doTransform");
-    J2dTraceLn4(J2D_TRACE_VERBOSE, "  sx1=%-4d sy1=%-4d sx2=%-4d sy2=%-4d ",
-                sx1, sy1, sx2, sy2);
+SurfaceData_IntersectBounds(SurfaceDataBounds *dst, SurfaceDataBounds *src)
+{
+    int t;
+    GETMAX(dst->x1, src->x1);
+    GETMAX(dst->y1, src->y1);
+    GETMIN(dst->x2, src->x2);
+    GETMIN(dst->y2, src->y2);
+}
+
+JNIEXPORT void JNICALL
+SurfaceData_IntersectBoundsXYXY(SurfaceDataBounds *bounds,
+                                jint x1, jint y1, jint x2, jint y2)
+{
+    int t;
+    GETMAX(bounds->x1, x1);
+    GETMAX(bounds->y1, y1);
+    GETMIN(bounds->x2, x2);
+    GETMIN(bounds->y2, y2);
+}
+
+JNIEXPORT void JNICALL
+SurfaceData_IntersectBoundsXYWH(SurfaceDataBounds *bounds,
+                                jint x, jint y, jint w, jint h)
+{
+    w = (w <= 0) ? x : x+w;
+    if (w < x) {
+        w = 0x7fffffff;
+    }
+    if (bounds->x1 < x) {
+        bounds->x1 = x;
+    }
+    if (bounds->x2 > w) {
+        bounds->x2 = w;
+    }
+    h = (h <= 0) ? y : y+h;
+    if (h < y) {
+        h = 0x7fffffff;
+    }
+    if (bounds->y1 < y) {
+        bounds->y1 = y;
+    }
+    if (bounds->y2 > h) {
+        bounds->y2 = h;
+    }
+}
+
+JNIEXPORT void JNICALL
+SurfaceData_IntersectBlitBounds(SurfaceDataBounds *src,
+                                SurfaceDataBounds *dst,
+                                jint dx, jint dy)
+{
+    int t;
+    GETMAX(dst->x1, src->x1 + dx);
+    GETMAX(dst->y1, src->y1 + dy);
+    GETMIN(dst->x2, src->x2 + dx);
+    GETMIN(dst->y2, src->y2 + dy);
+    GETMAX(src->x1, dst->x1 - dx);
+    GETMAX(src->y1, dst->y1 - dy);
+    GETMIN(src->x2, dst->x2 - dx);
+    GETMIN(src->y2, dst->y2 - dy);
+}
+
+#endif /* D3D_PPL_DLL */
+
+D3DPIPELINE_API HRESULT
+D3DBL_CopySurfaceToIntArgbImage(IDirect3DSurface9 *pSurface,
+                                SurfaceDataRasInfo *pDstInfo,
+                                jint srcx, jint srcy,
+                                jint srcWidth, jint srcHeight,
+                                jint dstx, jint dsty)
+{
+    HRESULT res = S_OK;
+    D3DLOCKED_RECT lockedRect;
+    RECT r = { srcx, srcy, srcx+srcWidth, srcy+srcHeight };
+    D3DSURFACE_DESC desc;
+    SurfaceDataRasInfo srcInfo;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBL_CopySurfaceToIntArgbImage");
     J2dTraceLn4(J2D_TRACE_VERBOSE,
-                "  dx1=%4f dy1=%4f dx2=%4f dy2=%4f", dx1, dy1, dx2, dy2);
+                " rect={%-4d, %-4d, %-4d, %-4d}",
+                r.left, r.top, r.right, r.bottom);
+
+    res = pSurface->LockRect(&lockedRect, &r, D3DLOCK_NOSYSLOCK);
+    RETURN_STATUS_IF_FAILED(res);
+    pSurface->GetDesc(&desc);
+
+    ZeroMemory(&srcInfo, sizeof(SurfaceDataRasInfo));
+    // srcInfo.bounds.x1 = 0;
+    // srcInfo.bounds.y1 = 0;
+    srcInfo.bounds.x2 = srcWidth;
+    srcInfo.bounds.y2 = srcHeight;
+    srcInfo.scanStride = lockedRect.Pitch;
 
-    if (sx2 <= sx1 || sy2 <= sy1 || dx2 <= dx1 || dy2 <= dy1) {
+    void *pSrcBase = lockedRect.pBits;
+    void *pDstBase = PtrCoord(pDstInfo->rasBase,
+                              dstx, pDstInfo->pixelStride,
+                              dsty, pDstInfo->scanStride);
+
+    switch (desc.Format) {
+        case D3DFMT_A8R8G8B8:
+            srcInfo.pixelStride = 4;
+            IntArgbPreToIntArgbConvert(pSrcBase, pDstBase,
+                                       srcWidth, srcHeight,
+                                       &srcInfo, pDstInfo, NULL, NULL);
+            break;
+        case D3DFMT_X8R8G8B8:
+            srcInfo.pixelStride = 4;
+            IntRgbToIntArgbConvert(pSrcBase, pDstBase,
+                                   srcWidth, srcHeight,
+                                   &srcInfo, pDstInfo, NULL, NULL);
+            break;
+        case D3DFMT_X8B8G8R8:
+            srcInfo.pixelStride = 4;
+            IntBgrToIntArgbConvert(pSrcBase, pDstBase,
+                                   srcWidth, srcHeight,
+                                   &srcInfo, pDstInfo, NULL, NULL);
+            break;
+        case D3DFMT_X1R5G5B5:
+            srcInfo.pixelStride = 2;
+            Ushort555RgbToIntArgbConvert(pSrcBase, pDstBase,
+                                         srcWidth, srcHeight,
+                                         &srcInfo, pDstInfo, NULL, NULL);
+            break;
+        case D3DFMT_R5G6B5:
+            srcInfo.pixelStride = 2;
+            Ushort565RgbToIntArgbConvert(pSrcBase, pDstBase,
+                                         srcWidth, srcHeight,
+                                         &srcInfo, pDstInfo, NULL, NULL);
+            break;
+        default:
+            J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                "D3DBL_CopySurfaceToIntArgbImage: unknown format %d",
+                desc.Format);
+    }
+
+    return pSurface->UnlockRect();
+}
+
+D3DPIPELINE_API HRESULT
+D3DBL_CopyImageToIntXrgbSurface(SurfaceDataRasInfo *pSrcInfo,
+                                int srctype,
+                                D3DResource *pDstSurfaceRes,
+                                jint srcx, jint srcy,
+                                jint srcWidth, jint srcHeight,
+                                jint dstx, jint dsty)
+{
+    HRESULT res = S_OK;
+    D3DLOCKED_RECT lockedRect;
+    RECT r = { dstx, dsty, dstx+srcWidth, dsty+srcHeight };
+    RECT *pR = &r;
+    SurfaceDataRasInfo dstInfo;
+    IDirect3DSurface9 *pDstSurface = pDstSurfaceRes->GetSurface();
+    D3DSURFACE_DESC *pDesc = pDstSurfaceRes->GetDesc();
+    DWORD dwLockFlags = D3DLOCK_NOSYSLOCK;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBL_CopyImageToIntXrgbSurface");
+    J2dTraceLn5(J2D_TRACE_VERBOSE,
+                " srctype=%d rect={%-4d, %-4d, %-4d, %-4d}",
+                srctype, r.left, r.top, r.right, r.bottom);
+
+    if (pDesc->Usage == D3DUSAGE_DYNAMIC &&
+        dstx == 0 && dstx == 0 &&
+        srcWidth == pDesc->Width && srcHeight == pDesc->Height)
+    {
+        dwLockFlags |= D3DLOCK_DISCARD;
+        pR = NULL;
+    }
+
+    res = pDstSurface->LockRect(&lockedRect, pR, dwLockFlags);
+    RETURN_STATUS_IF_FAILED(res);
+
+    ZeroMemory(&dstInfo, sizeof(SurfaceDataRasInfo));
+    // dstInfo.bounds.x1 = 0;
+    // dstInfo.bounds.y1 = 0;
+    dstInfo.bounds.x2 = srcWidth;
+    dstInfo.bounds.y2 = srcHeight;
+    dstInfo.scanStride = lockedRect.Pitch;
+    dstInfo.pixelStride = 4;
+
+    void *pSrcBase = PtrCoord(pSrcInfo->rasBase,
+                              srcx, pSrcInfo->pixelStride,
+                              srcy, pSrcInfo->scanStride);
+    void *pDstBase = lockedRect.pBits;
+
+    switch (srctype) {
+        case ST_INT_ARGB:
+            IntArgbToIntArgbPreConvert(pSrcBase, pDstBase,
+                                       srcWidth, srcHeight,
+                                       pSrcInfo, &dstInfo, NULL, NULL);
+            break;
+        case ST_INT_ARGB_PRE:
+        case ST_INT_RGB:
+            AnyIntIsomorphicCopy(pSrcBase, pDstBase,
+                                 srcWidth, srcHeight,
+                                 pSrcInfo, &dstInfo, NULL, NULL);
+            break;
+        case ST_INT_ARGB_BM:
+            // REMIND: we don't have such sw loop
+            // so this path is disabled for now on java level
+//            IntArgbBmToIntArgbPreConvert(pSrcBase, pDstBase,
+//                                         srcWidth, srcHeight,
+//                                         pSrcInfo, &dstInfo, NULL, NULL);
+            break;
+        case ST_INT_BGR:
+            IntBgrToIntArgbConvert(pSrcBase, pDstBase,
+                                   srcWidth, srcHeight,
+                                   pSrcInfo, &dstInfo, NULL, NULL);
+            break;
+        case ST_USHORT_555_RGB:
+            Ushort555RgbToIntArgbConvert(pSrcBase, pDstBase,
+                                         srcWidth, srcHeight,
+                                         pSrcInfo, &dstInfo, NULL, NULL);
+            break;
+        case ST_USHORT_565_RGB:
+            Ushort565RgbToIntArgbConvert(pSrcBase, pDstBase,
+                                         srcWidth, srcHeight,
+                                         pSrcInfo, &dstInfo, NULL, NULL);
+            break;
+        case ST_BYTE_INDEXED:
+            ByteIndexedToIntArgbPreConvert(pSrcBase, pDstBase,
+                                           srcWidth, srcHeight,
+                                           pSrcInfo, &dstInfo, NULL, NULL);
+            break;
+        case ST_BYTE_INDEXED_BM:
+            // REMIND: we don't have such sw loop
+            // so this path is disabled for now on java level
+//            ByteIndexedBmToIntArgbPreConvert(pSrcBase, pDstBase,
+//                                             srcWidth, srcHeight,
+//                                             pSrcInfo, &dstInfo, NULL, NULL);
+            break;
+        default:
+            J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                           "D3DBL_CopyImageToIntXrgbSurface: unknown type %d",
+                           srctype);
+    }
+
+    return pDstSurface->UnlockRect();
+}
+
+/**
+ * Inner loop used for copying a source "render-to" D3D "Surface" to a
+ * destination D3D "Surface".  Note that the same surface can
+ * not be used as both the source and destination, as is the case in a copyArea()
+ * operation.  This method is invoked from D3DBlitLoops_IsoBlit().
+ *
+ * The standard StretchRect() mechanism is used to copy the source region
+ * into the destination region.  If the regions have different dimensions,
+ * the source will be scaled into the destination as appropriate (only
+ * nearest neighbor filtering will be applied for simple scale operations).
+ */
+HRESULT
+D3DBlitSurfaceToSurface(D3DContext *d3dc, D3DSDOps *srcOps, D3DSDOps *dstOps,
+                        D3DTEXTUREFILTERTYPE hint,
+                        jint sx1, jint sy1, jint sx2, jint sy2,
+                        jint dx1, jint dy1, jint dx2, jint dy2)
+{
+    IDirect3DSurface9 *pSrc, *pDst;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBlitSurfaceToSurface");
+
+    RETURN_STATUS_IF_NULL(srcOps->pResource, E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps->pResource, E_FAIL);
+    RETURN_STATUS_IF_NULL(pSrc = srcOps->pResource->GetSurface(), E_FAIL);
+    RETURN_STATUS_IF_NULL(pDst = dstOps->pResource->GetSurface(), E_FAIL);
+
+    d3dc->UpdateState(STATE_OTHEROP);
+    IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+
+    // need to clip the destination bounds,
+    // otherwise StretchRect could fail
+    jint sw    = sx2 - sx1;
+    jint sh    = sy2 - sy1;
+    jdouble dw = dx2 - dx1;
+    jdouble dh = dy2 - dy1;
+
+    SurfaceDataBounds dstBounds;
+    dstBounds.x1 = dx1;
+    dstBounds.y1 = dy1;
+    dstBounds.x2 = dx2;
+    dstBounds.y2 = dy2;
+    SurfaceData_IntersectBoundsXYXY(&dstBounds, 0, 0,
+                                    dstOps->width, dstOps->height);
+    if (d3dc->GetClipType() == CLIP_RECT) {
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  rect clip, clip dest manually");
+        RECT clipRect;
+        pd3dDevice->GetScissorRect(&clipRect);
+        SurfaceData_IntersectBoundsXYXY(&dstBounds,
+                                        clipRect.left, clipRect.top,
+                                        clipRect.right, clipRect.bottom);
+    }
+
+    if (dstBounds.x1 != dx1) {
+        sx1 += (int)((dstBounds.x1 - dx1) * (sw / dw));
+    }
+    if (dstBounds.y1 != dy1) {
+        sy1 += (int)((dstBounds.y1 - dy1) * (sh / dh));
+    }
+    if (dstBounds.x2 != dx2) {
+        sx2 += (int)((dstBounds.x2 - dx2) * (sw / dw));
+    }
+    if (dstBounds.y2 != dy2) {
+        sy2 += (int)((dstBounds.y2 - dy2) * (sh / dh));
+    }
+
+    // check if the rects are empty (StretchRect will fail if so)
+    if (dstBounds.x1 >= dstBounds.x2 || dstBounds.y1 >= dstBounds.y2 ||
+        sx1 >= sx2 || sy1 >= sy2)
+    {
+        return S_OK;
+    }
+
+    RECT srcRect = { sx1, sy1, sx2, sy2 };
+    RECT dstRect = { dstBounds.x1, dstBounds.y1, dstBounds.x2, dstBounds.y2 };
+
+    return pd3dDevice->StretchRect(pSrc, &srcRect, pDst, &dstRect, hint);
+}
+
+/**
+ * A convenience method for issuing DrawTexture calls depending on the
+ * hint. See detailed explanation below.
+ */
+static inline HRESULT
+D3DDrawTextureWithHint(D3DContext *d3dc, D3DTEXTUREFILTERTYPE hint,
+                       jint srcWidth, jint srcHeight,
+                       float tw, float th,
+                       jint sx1, jint sy1, jint sx2, jint sy2,
+                       float dx1, float dy1, float dx2, float dy2,
+                       float tx1, float ty1, float tx2, float ty2)
+{
+    HRESULT res;
+
+    if (hint == D3DTEXF_LINEAR &&
+        (srcWidth != tw  || srcHeight != th ||
+         srcWidth != sx2 || srcHeight != sy2 ))
+    {
+        /*
+         * When the image bounds are smaller than the bounds of the
+         * texture that the image resides in, D3DTEXF_LINEAR will use pixels
+         * from outside the valid image bounds, which could result in garbage
+         * pixels showing up at the edges of the transformed result.  We set
+         * the texture wrap mode to D3DTADDRESS_CLAMP, which solves the problem
+         * for the top and left edges.  But when the source bounds do not
+         * match the texture bounds, we need to perform this as a four-part
+         * operation in order to prevent the filter used by D3D from using
+         * invalid pixels at the bottom and right edges.
+         *
+         * Note that we only need to apply this technique when the source
+         * bounds are equal to the actual image bounds.  If the source bounds
+         * fall within the image bounds there is no need to apply this hack
+         * because the filter used by D3D will access valid pixels.
+         * Likewise, if the image bounds are equal to the texture bounds,
+         * then the edge conditions are handled properly by D3DTADDRESS_CLAMP.
+         */
+
+        // These values represent the bottom-right corner of source texture
+        // region pulled in by 1/2 of a source texel.
+        float tx2adj = tx2 - (1.0f / (2.0f * tw));
+        float ty2adj = ty2 - (1.0f / (2.0f * th));
+
+        // These values represent the above coordinates pulled in by a
+        // tiny fraction.  As an example, if we sample the tiny area from
+        // tx2adj2 to tx2adj, the result should be the solid color at the
+        // texel center corresponding to tx2adj.
+        float tx2adj2 = tx2adj - 0.0001f;
+        float ty2adj2 = ty2adj - 0.0001f;
+
+        // These values represent the bottom-right corner of the destination
+        // region pulled in by 1/2 of a destination pixel.
+        float dx2adj = dx2 - 0.5f;
+        float dy2adj = dy2 - 0.5f;
+
+        // First, render a majority of the source texture, from the top-left
+        // corner to the bottom-right, but not including the right or bottom
+        // edges.
+        d3dc->pVCacher->DrawTexture(dx1, dy1, dx2adj, dy2adj,
+                                    tx1, ty1, tx2adj, ty2adj);
+
+        // Second, render the remaining sliver on the right edge.
+        d3dc->pVCacher->DrawTexture(dx2adj, dy1, dx2, dy2adj,
+                                    tx2adj2, ty1, tx2adj, ty2adj);
+
+        // Third, render the remaining sliver on the bottom edge.
+        d3dc->pVCacher->DrawTexture(dx1, dy2adj, dx2adj, dy2,
+                                    tx1, ty2adj2, tx2adj, ty2adj);
+
+        // Finally, render the remaining speck at the bottom-right corner.
+        res = d3dc->pVCacher->DrawTexture(dx2adj, dy2adj, dx2, dy2,
+                                          tx2adj2, ty2adj2, tx2adj, ty2adj);
+    } else {
+        /*
+         * As mentioned above, we can issue a simple textured quad if:
+         *   - the hint is D3DTEXF_POINT or
+         *   - the source bounds are sufficiently inside the texture bounds or
+         *   - the image bounds are equal to the texture bounds (as is the
+         *     case when the image has power-of-two dimensions, or when the
+         *     device supports non-pow2 textures)
+         */
+        res =  d3dc->pVCacher->DrawTexture(dx1, dy1, dx2, dy2,
+                                           tx1, ty1, tx2, ty2);
+    }
+    return res;
+}
+
+/**
+ * Inner loop used for copying a source D3D "Texture" to a destination
+ * D3D "Surface".  This method is invoked from D3DBlitLoops_IsoBlit().
+ *
+ * This method will copy, scale, or transform the source texture into the
+ * destination depending on the transform state, as established in
+ * and D3DContext::SetTransform().  If the source texture is
+ * transformed in any way when rendered into the destination, the filtering
+ * method applied is determined by the hint parameter.
+ */
+static HRESULT
+D3DBlitTextureToSurface(D3DContext *d3dc,
+                        D3DSDOps *srcOps, D3DSDOps *dstOps,
+                        jboolean rtt, D3DTEXTUREFILTERTYPE hint,
+                        jint sx1, jint sy1, jint sx2, jint sy2,
+                        float dx1, float dy1, float dx2, float dy2)
+{
+    HRESULT res;
+    IDirect3DTexture9 *pSrc;
+    IDirect3DDevice9 *pd3dDevice;
+    float tx1, ty1, tx2, ty2;
+    float tw, th;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBlitTextureToSurface");
+
+    RETURN_STATUS_IF_NULL(srcOps->pResource, E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps->pResource, E_FAIL);
+
+    if ((pSrc = srcOps->pResource->GetTexture()) == NULL ||
+        FAILED(res = d3dc->BeginScene(STATE_TEXTUREOP)   ||
+        FAILED(res = d3dc->SetTexture(pSrc))))
+    {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+                      "D3DBlitTextureToSurface: BeginScene or SetTexture failed");
+        return res;
+    }
+
+    pd3dDevice = d3dc->Get3DDevice();
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, hint);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, hint);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
+
+    tw = (float)srcOps->pResource->GetDesc()->Width;
+    th = (float)srcOps->pResource->GetDesc()->Height;
+
+    // convert the source bounds into the range [0,1]
+    tx1 = ((float)sx1) / tw;
+    ty1 = ((float)sy1) / th;
+    tx2 = ((float)sx2) / tw;
+    ty2 = ((float)sy2) / th;
+
+    return D3DDrawTextureWithHint(d3dc, hint,
+                                  srcOps->width, srcOps->height,
+                                  tw, th,
+                                  sx1, sy1, sx2, sy2,
+                                  dx1, dy1, dx2, dy2,
+                                  tx1, ty1, tx2, ty2);
+}
+
+/**
+ * Inner loop used for copying a source system memory ("Sw") surface or
+ * D3D "Surface" to a destination D3D "Surface", using an D3D texture
+ * tile as an intermediate surface.  This method is invoked from
+ * D3DBlitLoops_Blit() for "Sw" surfaces and D3DBlitLoops_IsoBlit() for
+ * "Surface" surfaces.
+ *
+ * This method is used to transform the source surface into the destination.
+ * Pixel rectangles cannot be arbitrarily transformed.  However, texture
+ * mapped quads do respect the modelview transform matrix, so we use
+ * textures here to perform the transform operation.  This method uses a
+ * tile-based approach in which a small subregion of the source surface is
+ * copied into a cached texture tile.  The texture tile is then mapped
+ * into the appropriate location in the destination surface.
+ *
+ */
+D3DPIPELINE_API HRESULT
+D3DBlitToSurfaceViaTexture(D3DContext *d3dc, SurfaceDataRasInfo *srcInfo,
+                           int srctype, D3DSDOps *srcOps,
+                           jboolean swsurface, jint hint,
+                           jint sx1, jint sy1, jint sx2, jint sy2,
+                           jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
+{
+    double tx1, ty1, tx2, ty2;
+    double dx, dy, dw, dh, cdw, cdh;
+    jint tw, th;
+    jint sx, sy, sw, sh;
+    HRESULT res = S_OK;
+    D3DResource *pBlitTextureRes = NULL;
+    IDirect3DTexture9 *pBlitTexture = NULL;
+    IDirect3DSurface9 *pBlitSurface = NULL, *pSrc = NULL;
+    D3DTEXTUREFILTERTYPE fhint =
+            (hint == D3DSD_XFORM_BILINEAR) ? D3DTEXF_LINEAR : D3DTEXF_POINT;
+    fhint = d3dc->IsTextureFilteringSupported(fhint) ? fhint : D3DTEXF_NONE;
+
+    if (swsurface) {
+        res = d3dc->GetResourceManager()->GetBlitTexture(&pBlitTextureRes);
+    } else {
+        RETURN_STATUS_IF_NULL(srcOps->pResource, E_FAIL);
+        RETURN_STATUS_IF_NULL(pSrc = srcOps->pResource->GetSurface(), E_FAIL);
+
+        res = d3dc->GetResourceManager()->
+                GetBlitRTTexture(D3DC_BLIT_TILE_SIZE, D3DC_BLIT_TILE_SIZE,
+                                 srcOps->pResource->GetDesc()->Format,
+                                 &pBlitTextureRes);
+    }
+    if (FAILED(res)) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+            "D3DBlitToSurfaceViaTexture: could not init blit tile");
+        return res;
+    }
+    pBlitSurface = pBlitTextureRes->GetSurface();
+    pBlitTexture = pBlitTextureRes->GetTexture();
+
+    D3DSURFACE_DESC *pDesc = pBlitTextureRes->GetDesc();
+
+    tx1 = 0.0f;
+    ty1 = 0.0f;
+    tw = pDesc->Width;
+    th = pDesc->Height;
+    cdw = (dx2-dx1) / (((double)(sx2-sx1)) / tw);
+    cdh = (dy2-dy1) / (((double)(sy2-sy1)) / th);
+
+    res = d3dc->BeginScene(STATE_TEXTUREOP);
+    RETURN_STATUS_IF_FAILED(res);
+    res = d3dc->SetTexture(pBlitTexture);
+    RETURN_STATUS_IF_FAILED(res);
+
+    IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, fhint);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, fhint);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
+
+    for (sy = sy1, dy = dy1; sy < sy2; sy += th, dy += cdh) {
+        sh = ((sy + th) > sy2) ? (sy2 - sy) : th;
+        dh = ((dy + cdh) > dy2) ? (dy2 - dy) : cdh;
+
+        for (sx = sx1, dx = dx1; sx < sx2; sx += tw, dx += cdw) {
+            sw = ((sx + tw) > sx2) ? (sx2 - sx) : tw;
+            dw = ((dx + cdw) > dx2) ? (dx2 - dx) : cdw;
+
+            tx2 = ((double)sw) / tw;
+            ty2 = ((double)sh) / th;
+
+            if (swsurface) {
+                D3DBL_CopyImageToIntXrgbSurface(srcInfo,
+                        srctype, pBlitTextureRes,
+                        sx, sy, sw, sh,
+                        0, 0);
+            } else {
+                RECT srcRect = { (LONG)sx, (LONG)sy,
+                                 (LONG)(sx+dw), (LONG)(sy+dh) };
+                RECT dstRect = { 0l, 0l, (LONG)dw, (LONG)dh };
+                pd3dDevice->StretchRect(pSrc,
+                                        &srcRect, pBlitSurface, &dstRect,
+                                        D3DTEXF_NONE);
+            }
+            D3DDrawTextureWithHint(d3dc, fhint,
+                   tw, th,
+                   (float)tw, (float)th,
+                   sx, sy, sw, sh,
+                   (float)dx, (float)dy, (float)(dx+dw), (float)(dy+dh),
+                   (float)tx1, (float)ty1, (float)tx2, (float)ty2);
+            res = d3dc->pVCacher->Render();
+        }
+    }
+    return res;
+}
+
+/**
+ * Inner loop used for copying a source system memory ("Sw") surface to a
+ * destination D3D "Texture".  This method is invoked from
+ * D3DBlitLoops_Blit().
+ *
+ * The source surface is effectively loaded into the D3D texture object,
+ * which must have already been initialized by D3DSD_initTexture().  Note
+ * that this method is only capable of copying the source surface into the
+ * destination surface (i.e. no scaling or general transform is allowed).
+ * This restriction should not be an issue as this method is only used
+ * currently to cache a static system memory image into an D3D texture in
+ * a hidden-acceleration situation.
+ */
+static HRESULT
+D3DBlitSwToTexture(D3DContext *d3dc,
+                   SurfaceDataRasInfo *srcInfo, int srctype,
+                   D3DSDOps *dstOps,
+                   jint sx1, jint sy1, jint sx2, jint sy2)
+{
+    RETURN_STATUS_IF_NULL(dstOps->pResource, E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps->pResource->GetSurface(), E_FAIL);
+
+    return D3DBL_CopyImageToIntXrgbSurface(srcInfo, srctype,
+                                           dstOps->pResource,
+                                           sx1, sy1, sx2-sx1, sy2-sy1,
+                                           0, 0);
+}
+
+/**
+ * General blit method for copying a native D3D surface (of type "Surface"
+ * or "Texture") to another D3D "Surface".  If texture is JNI_TRUE, this
+ * method will invoke the Texture->Surface inner loop; otherwise, one of the
+ * Surface->Surface inner loops will be invoked, depending on the transform
+ * state.
+ */
+D3DPIPELINE_API HRESULT
+D3DBlitLoops_IsoBlit(JNIEnv *env,
+                     D3DContext *d3dc, jlong pSrcOps, jlong pDstOps,
+                     jboolean xform, jint hint,
+                     jboolean texture, jboolean rtt,
+                     jint sx1, jint sy1, jint sx2, jint sy2,
+                     jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
+{
+    D3DSDOps *srcOps = (D3DSDOps *)jlong_to_ptr(pSrcOps);
+    D3DSDOps *dstOps = (D3DSDOps *)jlong_to_ptr(pDstOps);
+    SurfaceDataRasInfo srcInfo;
+    jint sw    = sx2 - sx1;
+    jint sh    = sy2 - sy1;
+    jdouble dw = dx2 - dx1;
+    jdouble dh = dy2 - dy1;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBlitLoops_IsoBlit");
+
+    if (sw <= 0 || sh <= 0 || dw <= 0 || dh <= 0) {
         J2dTraceLn(J2D_TRACE_WARNING,
-                   "D3DBlitLoops_doTransform: invalid dimensions");
-        return;
+                   "D3DBlitLoops_IsoBlit: invalid dimensions");
+        return E_FAIL;
+    }
+
+    RETURN_STATUS_IF_NULL(srcOps, E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps, E_FAIL);
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    RETURN_STATUS_IF_NULL(d3dc->Get3DDevice(), E_FAIL);
+
+    srcInfo.bounds.x1 = sx1;
+    srcInfo.bounds.y1 = sy1;
+    srcInfo.bounds.x2 = sx2;
+    srcInfo.bounds.y2 = sy2;
+
+    SurfaceData_IntersectBoundsXYXY(&srcInfo.bounds,
+                                    0, 0, srcOps->width, srcOps->height);
+
+
+    HRESULT res = S_OK;
+    if (srcInfo.bounds.x2 > srcInfo.bounds.x1 &&
+        srcInfo.bounds.y2 > srcInfo.bounds.y1)
+    {
+        if (srcInfo.bounds.x1 != sx1) {
+            dx1 += (srcInfo.bounds.x1 - sx1) * (dw / sw);
+            sx1 = srcInfo.bounds.x1;
+        }
+        if (srcInfo.bounds.y1 != sy1) {
+            dy1 += (srcInfo.bounds.y1 - sy1) * (dh / sh);
+            sy1 = srcInfo.bounds.y1;
+        }
+        if (srcInfo.bounds.x2 != sx2) {
+            dx2 += (srcInfo.bounds.x2 - sx2) * (dw / sw);
+            sx2 = srcInfo.bounds.x2;
+        }
+        if (srcInfo.bounds.y2 != sy2) {
+            dy2 += (srcInfo.bounds.y2 - sy2) * (dh / sh);
+            sy2 = srcInfo.bounds.y2;
+        }
+
+        J2dTraceLn2(J2D_TRACE_VERBOSE, "  texture=%d hint=%d", texture, hint);
+        J2dTraceLn4(J2D_TRACE_VERBOSE, "  sx1=%d sy1=%d sx2=%d sy2=%d",
+                    sx1, sy1, sx2, sy2);
+        J2dTraceLn4(J2D_TRACE_VERBOSE, "  dx1=%f dy1=%f dx2=%f dy2=%f",
+                    dx1, dy1, dx2, dy2);
+
+        D3DTEXTUREFILTERTYPE fhint =
+            (hint == D3DSD_XFORM_BILINEAR) ? D3DTEXF_LINEAR : D3DTEXF_POINT;
+        if (texture) {
+            fhint = d3dc->IsTextureFilteringSupported(fhint) ?
+                fhint : D3DTEXF_NONE;
+            res = D3DBlitTextureToSurface(d3dc, srcOps, dstOps, rtt, fhint,
+                                          sx1, sy1, sx2, sy2,
+                                          (float)dx1, (float)dy1,
+                                          (float)dx2, (float)dy2);
+        } else {
+            // StretchRect does not do compositing or clipping
+            IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+            DWORD abEnabled = 0;
+
+            pd3dDevice->GetRenderState(D3DRS_ALPHABLENDENABLE, &abEnabled);
+            J2dTraceLn3(J2D_TRACE_VERBOSE, "  xform=%d clip=%d abEnabled=%d",
+                        xform, d3dc->GetClipType(), abEnabled);
+            if (!xform && d3dc->GetClipType() != CLIP_SHAPE && !abEnabled) {
+                fhint = d3dc->IsStretchRectFilteringSupported(fhint) ?
+                    fhint : D3DTEXF_NONE;
+
+                res = D3DBlitSurfaceToSurface(d3dc, srcOps, dstOps, fhint,
+                                              sx1, sy1, sx2, sy2,
+                                              (int)dx1, (int)dy1,
+                                               (int)dx2, (int)dy2);
+            } else {
+                res = D3DBlitToSurfaceViaTexture(d3dc, &srcInfo,
+                                                 // surface type is unused here
+                                                 ST_INT_ARGB_PRE,
+                                                 srcOps,
+                                                 JNI_FALSE, hint,
+                                                 sx1, sy1, sx2, sy2,
+                                                 dx1, dy1, dx2, dy2);
+            }
+        }
     }
+    return res;
+}
+
+/**
+ * General blit method for copying a system memory ("Sw") surface to a native
+ * D3D surface (of type "Surface" or "Texture").  If texture is JNI_TRUE,
+ * this method will invoke the Sw->Texture inner loop; otherwise, one of the
+ * Sw->Surface inner loops will be invoked, depending on the transform state.
+ */
+HRESULT
+D3DBlitLoops_Blit(JNIEnv *env,
+                  D3DContext *d3dc, jlong pSrcOps, jlong pDstOps,
+                  jboolean xform, jint hint,
+                  jint srctype, jboolean texture,
+                  jint sx1, jint sy1, jint sx2, jint sy2,
+                  jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
+{
+    SurfaceDataOps *srcOps = (SurfaceDataOps *)jlong_to_ptr(pSrcOps);
+    D3DSDOps *dstOps = (D3DSDOps *)jlong_to_ptr(pDstOps);
+    SurfaceDataRasInfo srcInfo;
+    HRESULT res = S_OK;
+    jint sw    = sx2 - sx1;
+    jint sh    = sy2 - sy1;
+    jdouble dw = dx2 - dx1;
+    jdouble dh = dy2 - dy1;
+    jint lockFlags = SD_LOCK_READ;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBlitLoops_Blit");
 
-    D3DContext *d3dc = (D3DContext *)jlong_to_ptr(pCtx);
-    if (d3dc == NULL) {
+    if (sw <= 0 || sh <= 0 || dw <= 0 || dh <= 0 || srctype < 0) {
         J2dTraceLn(J2D_TRACE_WARNING,
-                   "D3DBlitLoops_doTransform: null device context");
-        return;
+                   "D3DBlitLoops_Blit: invalid dimensions or srctype");
+        return E_FAIL;
     }
-    Win32SDOps *srcOps = (Win32SDOps *)jlong_to_ptr(pSrcData);
-    Win32SDOps *dstOps = (Win32SDOps *)jlong_to_ptr(pDstData);
 
-    if (!srcOps->ddInstance || !dstOps->ddInstance) {
-        // Some situations can cause us to fail on primary
-        // creation, resulting in null lpSurface and null ddInstance
-        // for a Win32Surface object.. Just noop this call in that case.
-        return;
-    }
-
-    DDrawSurface *ddTargetSurface = d3dc->GetTargetSurface();
-    DDrawSurface *ddSrcSurface = srcOps->lpSurface;
-    if (ddTargetSurface == NULL || ddSrcSurface == NULL) {
-        return;
-    }
-    ddTargetSurface->GetExclusiveAccess();
-    d3dc->GetExclusiveAccess();
-
-    IDirect3DDevice7 *d3dDevice = d3dc->Get3DDevice();
-    if (d3dDevice == NULL) {
-        d3dc->ReleaseExclusiveAccess();
-        ddTargetSurface->ReleaseExclusiveAccess();
-        return;
-    }
-
-    float tw = (float)ddSrcSurface->GetDXSurface()->GetWidth();
-    float th = (float)ddSrcSurface->GetDXSurface()->GetHeight();
-    float tx1 = ((float)sx1) / tw;
-    float ty1 = ((float)sy1) / th;
-    float tx2 = ((float)sx2) / tw;
-    float ty2 = ((float)sy2) / th;
-
-    D3DU_INIT_VERTEX_QUAD(quadVerts, dx1, dy1, dx2, dy2,
-                          d3dc->blitPolygonPixel,
-                          tx1, ty1, tx2, ty2);
-
-    if (hint == D3DSD_XFORM_BILINEAR) {
-        d3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTFG_LINEAR);
-        d3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTFG_LINEAR);
-    } else if (hint == D3DSD_XFORM_NEAREST_NEIGHBOR) {
-        d3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTFG_POINT);
-        d3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTFG_POINT);
+    RETURN_STATUS_IF_NULL(srcOps, E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps, E_FAIL);
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    RETURN_STATUS_IF_NULL(d3dc->Get3DDevice(), E_FAIL);
+
+    srcInfo.bounds.x1 = sx1;
+    srcInfo.bounds.y1 = sy1;
+    srcInfo.bounds.x2 = sx2;
+    srcInfo.bounds.y2 = sy2;
+
+    if (srctype == ST_BYTE_INDEXED || srctype == ST_BYTE_INDEXED_BM) {
+        lockFlags |= SD_LOCK_LUT;
+    }
+    if (srcOps->Lock(env, srcOps, &srcInfo, lockFlags) != SD_SUCCESS) {
+        J2dTraceLn(J2D_TRACE_WARNING,
+                   "D3DBlitLoops_Blit: could not acquire lock");
+        return E_FAIL;
     }
 
-    HRESULT res;
-    D3DU_PRIM2_LOOP_BEGIN(res, srcOps, dstOps);
-    if (SUCCEEDED(res = d3dc->BeginScene(STATE_BLITOP))) {
-        DXSurface *dxSurface = ddSrcSurface->GetDXSurface();
-        if (SUCCEEDED(res = d3dc->SetTexture(dxSurface)))
-        {
-            res = d3dDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, D3DFVF_J2DLVERTEX,
-                                           quadVerts, 4, 0);
+    if (srcInfo.bounds.x2 > srcInfo.bounds.x1 &&
+        srcInfo.bounds.y2 > srcInfo.bounds.y1)
+    {
+        srcOps->GetRasInfo(env, srcOps, &srcInfo);
+        if (srcInfo.rasBase) {
+            if (srcInfo.bounds.x1 != sx1) {
+                dx1 += (srcInfo.bounds.x1 - sx1) * (dw / sw);
+                sx1 = srcInfo.bounds.x1;
+            }
+            if (srcInfo.bounds.y1 != sy1) {
+                dy1 += (srcInfo.bounds.y1 - sy1) * (dh / sh);
+                sy1 = srcInfo.bounds.y1;
+            }
+            if (srcInfo.bounds.x2 != sx2) {
+                dx2 += (srcInfo.bounds.x2 - sx2) * (dw / sw);
+                sx2 = srcInfo.bounds.x2;
+            }
+            if (srcInfo.bounds.y2 != sy2) {
+                dy2 += (srcInfo.bounds.y2 - sy2) * (dh / sh);
+                sy2 = srcInfo.bounds.y2;
+            }
+
+            J2dTraceLn3(J2D_TRACE_VERBOSE, "  texture=%d srctype=%d hint=%d",
+                        texture, srctype, hint);
+            J2dTraceLn4(J2D_TRACE_VERBOSE, "  sx1=%d sy1=%d sx2=%d sy2=%d",
+                        sx1, sy1, sx2, sy2);
+            J2dTraceLn4(J2D_TRACE_VERBOSE, "  dx1=%f dy1=%f dx2=%f dy2=%f",
+                        dx1, dy1, dx2, dy2);
+
+            if (texture) {
+                // These coordinates will always be integers since we
+                // only ever do a straight copy from sw to texture.
+                // Thus these casts are "safe" - no loss of precision.
+                res = D3DBlitSwToTexture(d3dc, &srcInfo, srctype, dstOps,
+                                        (jint)dx1, (jint)dy1,
+                                        (jint)dx2, (jint)dy2);
+            } else {
+                res = D3DBlitToSurfaceViaTexture(d3dc, &srcInfo, srctype, NULL,
+                                                 JNI_TRUE, hint,
+                                                 sx1, sy1, sx2, sy2,
+                                                 dx1, dy1, dx2, dy2);
+            }
         }
-        d3dc->EndScene(res);
+        SurfaceData_InvokeRelease(env, srcOps, &srcInfo);
     }
-    D3DU_PRIM2_LOOP_END(env, res, srcOps, dstOps,
-                        "DrawPrimitive(D3DPT_TRIANGLEFAN)");
+    SurfaceData_InvokeUnlock(env, srcOps, &srcInfo);
+    return res;
+}
+
+/**
+ * Specialized blit method for copying a native D3D "Surface" (pbuffer,
+ * window, etc.) to a system memory ("Sw") surface.
+ */
+HRESULT
+D3DBlitLoops_SurfaceToSwBlit(JNIEnv *env, D3DContext *d3dc,
+                             jlong pSrcOps, jlong pDstOps, jint dsttype,
+                             jint srcx, jint srcy, jint dstx, jint dsty,
+                             jint width, jint height)
+{
+    D3DSDOps *srcOps = (D3DSDOps *)jlong_to_ptr(pSrcOps);
+    SurfaceDataOps *dstOps = (SurfaceDataOps *)jlong_to_ptr(pDstOps);
+    SurfaceDataRasInfo srcInfo, dstInfo;
+    HRESULT res = S_OK;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBlitLoops_SurfaceToSwBlit");
+
+    if (width <= 0 || height <= 0) {
+        J2dTraceLn(J2D_TRACE_WARNING,
+            "D3DBlitLoops_SurfaceToSwBlit: dimensions are non-positive");
+        return S_OK;
+    }
+
+    RETURN_STATUS_IF_NULL(srcOps, E_FAIL);
+    RETURN_STATUS_IF_NULL(srcOps->pResource, E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps, E_FAIL);
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    RETURN_STATUS_IF_NULL(d3dc->Get3DDevice(), E_FAIL);
+
+    srcInfo.bounds.x1 = srcx;
+    srcInfo.bounds.y1 = srcy;
+    srcInfo.bounds.x2 = srcx + width;
+    srcInfo.bounds.y2 = srcy + height;
+    dstInfo.bounds.x1 = dstx;
+    dstInfo.bounds.y1 = dsty;
+    dstInfo.bounds.x2 = dstx + width;
+    dstInfo.bounds.y2 = dsty + height;
+
+    if (dstOps->Lock(env, dstOps, &dstInfo, SD_LOCK_WRITE) != SD_SUCCESS) {
+        J2dTraceLn(J2D_TRACE_WARNING,
+            "D3DBlitLoops_SurfaceToSwBlit: could not acquire dst lock");
+        return S_OK;
+    }
+
+    SurfaceData_IntersectBoundsXYXY(&srcInfo.bounds,
+                                    0, 0, srcOps->width, srcOps->height);
+    SurfaceData_IntersectBlitBounds(&dstInfo.bounds, &srcInfo.bounds,
+                                    srcx - dstx, srcy - dsty);
+
+    if (srcInfo.bounds.x2 > srcInfo.bounds.x1 &&
+        srcInfo.bounds.y2 > srcInfo.bounds.y1)
+    {
+        dstOps->GetRasInfo(env, dstOps, &dstInfo);
+        if (dstInfo.rasBase) {
+            IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+            IDirect3DSurface9 *pSrc = srcOps->pResource->GetSurface();
+            D3DFORMAT srcFmt = srcOps->pResource->GetDesc()->Format;
+            UINT srcw = srcOps->pResource->GetDesc()->Width;
+            UINT srch = srcOps->pResource->GetDesc()->Height;
+            D3DResource *pLockableRes;
+
+            srcx = srcInfo.bounds.x1;
+            srcy = srcInfo.bounds.y1;
+            dstx = dstInfo.bounds.x1;
+            dsty = dstInfo.bounds.y1;
+            width = srcInfo.bounds.x2 - srcInfo.bounds.x1;
+            height = srcInfo.bounds.y2 - srcInfo.bounds.y1;
+
+            J2dTraceLn4(J2D_TRACE_VERBOSE, "  sx=%d sy=%d w=%d h=%d",
+                        srcx, srcy, width, height);
+            J2dTraceLn2(J2D_TRACE_VERBOSE, "  dx=%d dy=%d",
+                        dstx, dsty);
+
+            d3dc->UpdateState(STATE_OTHEROP);
+
+            // if we read more than 50% of the image it is faster
+            // to get the whole thing (50% is pulled out of a hat)
+            BOOL fullRead = ((width * height) >= (srcw * srch * 0.5f));
+            UINT lockSrcX = 0, lockSrcY = 0;
 
-    d3dc->ReleaseExclusiveAccess();
-    ddTargetSurface->ReleaseExclusiveAccess();
+            if (fullRead) {
+                // read whole surface into a sysmem surface
+                lockSrcX = srcx;
+                lockSrcY = srcy;
+                // the dest surface must have the same dimensions and format as
+                // the source, GetBlitOSPSurface ensures that
+                res = d3dc->GetResourceManager()->
+                    GetBlitOSPSurface(srcw, srch, srcFmt, &pLockableRes);
+            } else {
+                // we first copy the source region to a temp
+                // render target surface of the same format as the
+                // source, then copy the pixels to the
+                // target buffered image surface
+                res = d3dc->GetResourceManager()->
+                    GetLockableRTSurface(width, height, srcFmt, &pLockableRes);
+            }
+            if (SUCCEEDED(res)) {
+                IDirect3DSurface9 *pTmpSurface = pLockableRes->GetSurface();
+
+                if (fullRead) {
+                    res = pd3dDevice->GetRenderTargetData(pSrc, pTmpSurface);
+                } else {
+                    RECT srcRect = { srcx, srcy, srcx+width, srcy+height};
+                    RECT dstRect = { 0l, 0l, width, height };
+
+                    res = pd3dDevice->StretchRect(pSrc,
+                                                  &srcRect, pTmpSurface,
+                                                  &dstRect, D3DTEXF_NONE);
+                }
+
+                if (SUCCEEDED(res)) {
+                    res = D3DBL_CopySurfaceToIntArgbImage(
+                            pTmpSurface,                       /* src surface */
+                            &dstInfo,                          /* dst info    */
+                            lockSrcX, lockSrcY, width, height, /* src rect    */
+                            dstx, dsty);                       /* dst coords  */
+                }
+            }
+        }
+        SurfaceData_InvokeRelease(env, dstOps, &dstInfo);
+    }
+    SurfaceData_InvokeUnlock(env, dstOps, &dstInfo);
+    return res;
 }
 
+HRESULT
+D3DBlitLoops_CopyArea(JNIEnv *env,
+                      D3DContext *d3dc, D3DSDOps *dstOps,
+                      jint x, jint y, jint width, jint height,
+                      jint dx, jint dy)
+{
+    SurfaceDataBounds srcBounds, dstBounds;
+    HRESULT res = S_OK;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBlitLoops_CopyArea");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps, E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps->pResource, E_FAIL);
+
+    J2dTraceLn4(J2D_TRACE_VERBOSE, "  x=%d y=%d w=%d h=%d",
+                x, y, width, height);
+    J2dTraceLn2(J2D_TRACE_VERBOSE, "  dx=%d dy=%d",
+                dx, dy);
+
+    IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+    RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
+    ClipType clipType = d3dc->GetClipType();
+
+    srcBounds.x1 = x;
+    srcBounds.y1 = y;
+    srcBounds.x2 = srcBounds.x1 + width;
+    srcBounds.y2 = srcBounds.y1 + height;
+    dstBounds.x1 = x + dx;
+    dstBounds.y1 = y + dy;
+    dstBounds.x2 = dstBounds.x1 + width;
+    dstBounds.y2 = dstBounds.y1 + height;
+
+    SurfaceData_IntersectBoundsXYXY(&srcBounds,
+                                    0, 0, dstOps->width, dstOps->height);
+    if (clipType == CLIP_RECT) {
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  rect clip, clip dest manually");
+        RECT clipRect;
+        pd3dDevice->GetScissorRect(&clipRect);
+        SurfaceData_IntersectBoundsXYXY(&dstBounds,
+                                        clipRect.left, clipRect.top,
+                                        clipRect.right, clipRect.bottom);
+    }
+    SurfaceData_IntersectBoundsXYXY(&dstBounds,
+                                    0, 0, dstOps->width, dstOps->height);
+    SurfaceData_IntersectBlitBounds(&dstBounds, &srcBounds, -dx, -dy);
+
+    if (dstBounds.x1 < dstBounds.x2 && dstBounds.y1 < dstBounds.y2) {
+        jint sx1 = srcBounds.x1, sy1 = srcBounds.y1,
+             sx2 = srcBounds.x2, sy2 = srcBounds.y2;
+        jint dx1 = dstBounds.x1, dy1 = dstBounds.y1,
+             dx2 = dstBounds.x2, dy2 = dstBounds.y2;
+        jint dw = dx2 - dx1, dh = dy2 - dy1;
+
+        IDirect3DTexture9 *pBlitTexture = NULL;
+        IDirect3DSurface9 *pBlitSurface = NULL;
+        D3DResource *pBlitTextureRes;
+
+        res = d3dc->GetResourceManager()->
+            GetBlitRTTexture(dw, dh,
+                             dstOps->pResource->GetDesc()->Format,
+                             &pBlitTextureRes);
+        if (SUCCEEDED(res)) {
+            pBlitSurface = pBlitTextureRes->GetSurface();
+            pBlitTexture = pBlitTextureRes->GetTexture();
+        }
+        if (!pBlitTexture || !pBlitSurface) {
+            J2dRlsTraceLn(J2D_TRACE_ERROR,
+                "D3DBlitLoops_CopyArea: could not init blit tile");
+            return E_FAIL;
+        }
+
+        // flush the rendering first
+        d3dc->UpdateState(STATE_OTHEROP);
+
+        // REMIND: see if we could always use texture mapping;
+        // the assumption here is that StretchRect is faster,
+        // if it's not, then we should always use texture mapping
+
+        // from src surface to the temp texture
+        RECT srcRect =    { sx1, sy1, sx2, sy2 };
+        RECT tmpDstRect = { 0l, 0l,  0+dw,  0+dh };
+        res = pd3dDevice->StretchRect(dstOps->pResource->GetSurface(), &srcRect,
+                                      pBlitSurface, &tmpDstRect,
+                                      D3DTEXF_NONE);
+        if (clipType != CLIP_SHAPE) {
+            J2dTraceLn(J2D_TRACE_VERBOSE, "  rect or no clip, use StretchRect");
+            // just do stretch rect to the destination
+            RECT dstRect = { dx1, dy1, dx2, dy2 };
+            // from temp surface to the destination
+            res = pd3dDevice->StretchRect(pBlitSurface, &tmpDstRect,
+                                          dstOps->pResource->GetSurface(),
+                                          &dstRect,
+                                          D3DTEXF_NONE);
+        } else {
+            J2dTraceLn(J2D_TRACE_VERBOSE, "  shape clip, use texture mapping");
+            // shape clip - have to use texture mapping
+            D3DTEXTUREFILTERTYPE fhint =
+                d3dc->IsTextureFilteringSupported(D3DTEXF_NONE) ?
+                    D3DTEXF_NONE: D3DTEXF_POINT;
+            pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, fhint);
+            pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, fhint);
+            res = d3dc->BeginScene(STATE_TEXTUREOP);
+            RETURN_STATUS_IF_FAILED(res);
+            res = d3dc->SetTexture(pBlitTexture);
+
+            float tx2 = (float)dw/(float)pBlitTextureRes->GetDesc()->Width;
+            float ty2 = (float)dh/(float)pBlitTextureRes->GetDesc()->Height;
+            res = d3dc->pVCacher->DrawTexture(
+                                (float)dx1, (float)dy1, (float)dx2, (float)dy2,
+                                0.0f, 0.0f, tx2, ty2);
+        }
+    }
+    return res;
 }
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DBlitLoops.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DBlitLoops.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DBlitLoops.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DBlitLoops.h	2011-01-08 01:26:50.471202211 +0000
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef D3DBlitLoops_h_Included
+#define D3DBlitLoops_h_Included
+
+#include "sun_java2d_d3d_D3DBlitLoops.h"
+#include "D3DSurfaceData.h"
+#include "D3DContext.h"
+
+#define OFFSET_SRCTYPE sun_java2d_d3d_D3DBlitLoops_OFFSET_SRCTYPE
+#define OFFSET_HINT    sun_java2d_d3d_D3DBlitLoops_OFFSET_HINT
+#define OFFSET_TEXTURE sun_java2d_d3d_D3DBlitLoops_OFFSET_TEXTURE
+#define OFFSET_RTT     sun_java2d_d3d_D3DBlitLoops_OFFSET_RTT
+#define OFFSET_XFORM   sun_java2d_d3d_D3DBlitLoops_OFFSET_XFORM
+#define OFFSET_ISOBLIT sun_java2d_d3d_D3DBlitLoops_OFFSET_ISOBLIT
+
+D3DPIPELINE_API HRESULT
+D3DBlitLoops_IsoBlit(JNIEnv *env,
+                     D3DContext *d3dc, jlong pSrcOps, jlong pDstOps,
+                     jboolean xform, jint hint,
+                     jboolean texture, jboolean rtt,
+                     jint sx1, jint sy1,
+                     jint sx2, jint sy2,
+                     jdouble dx1, jdouble dy1,
+                     jdouble dx2, jdouble dy2);
+
+D3DPIPELINE_API HRESULT
+D3DBL_CopySurfaceToIntArgbImage(IDirect3DSurface9 *pSurface,
+                                SurfaceDataRasInfo *pDstInfo,
+                                jint srcx, jint srcy,
+                                jint srcWidth, jint srcHeight,
+                                jint dstx, jint dsty);
+
+D3DPIPELINE_API HRESULT
+D3DBL_CopyImageToIntXrgbSurface(SurfaceDataRasInfo *pSrcInfo,
+                                int srctype,
+                                D3DResource *pDstSurfaceRes,
+                                jint srcx, jint srcy,
+                                jint srcWidth, jint srcHeight,
+                                jint dstx, jint dsty);
+
+HRESULT
+D3DBlitLoops_Blit(JNIEnv *env,
+                  D3DContext *d3dc, jlong pSrcOps, jlong pDstOps,
+                  jboolean xform, jint hint,
+                  jint srctype, jboolean texture,
+                  jint sx1, jint sy1,
+                  jint sx2, jint sy2,
+                  jdouble dx1, jdouble dy1,
+                  jdouble dx2, jdouble dy2);
+
+HRESULT
+D3DBlitLoops_SurfaceToSwBlit(JNIEnv *env, D3DContext *d3dc,
+                             jlong pSrcOps, jlong pDstOps, jint dsttype,
+                             jint srcx, jint srcy,
+                             jint dstx, jint dsty,
+                             jint width, jint height);
+
+HRESULT
+D3DBlitLoops_CopyArea(JNIEnv *env,
+                      D3DContext *d3dc, D3DSDOps *dstOps,
+                      jint x, jint y,
+                      jint width, jint height,
+                      jint dx, jint dy);
+
+#endif /* D3DBlitLoops_h_Included */
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DBufImgOps.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DBufImgOps.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DBufImgOps.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DBufImgOps.cpp	2011-01-08 01:26:50.471202211 +0000
@@ -0,0 +1,306 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include <jlong.h>
+
+#include "D3DBufImgOps.h"
+#include "D3DContext.h"
+#include "D3DRenderQueue.h"
+#include "D3DSurfaceData.h"
+#include "GraphicsPrimitiveMgr.h"
+
+/**************************** ConvolveOp support ****************************/
+
+/**
+ * The maximum kernel size supported by the ConvolveOp shader.
+ */
+#define MAX_KERNEL_SIZE 25
+
+HRESULT
+D3DBufImgOps_EnableConvolveOp(D3DContext *d3dc, jlong pSrcOps,
+                              jboolean edgeZeroFill,
+                              jint kernelWidth, jint kernelHeight,
+                              unsigned char *kernel)
+{
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice;
+    D3DSDOps *srcOps = (D3DSDOps *)jlong_to_ptr(pSrcOps);
+    jint kernelSize = kernelWidth * kernelHeight;
+    jint texW, texH;
+    jfloat xoff, yoff;
+    jfloat edgeX, edgeY;
+    jfloat imgEdge[4];
+    jfloat kernelVals[MAX_KERNEL_SIZE*4];
+    jint i, j, kIndex;
+    jint flags = 0;
+
+    J2dTraceLn2(J2D_TRACE_INFO,
+                "D3DBufImgOps_EnableConvolveOp: kernelW=%d kernelH=%d",
+                kernelWidth, kernelHeight);
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    RETURN_STATUS_IF_NULL(srcOps, E_FAIL);
+
+    d3dc->UpdateState(STATE_CHANGE);
+
+    // texcoords are specified in the range [0,1], so to achieve an
+    // x/y offset of approximately one pixel we have to normalize
+    // to that range here
+    texW = srcOps->pResource->GetDesc()->Width;
+    texH = srcOps->pResource->GetDesc()->Height;
+    xoff = 1.0f / texW;
+    yoff = 1.0f / texH;
+
+    if (edgeZeroFill) {
+        flags |= CONVOLVE_EDGE_ZERO_FILL;
+    }
+    if (kernelWidth == 5 && kernelHeight == 5) {
+        flags |= CONVOLVE_5X5;
+    }
+
+    // locate/enable the shader program for the given flags
+    res = d3dc->EnableConvolveProgram(flags);
+    RETURN_STATUS_IF_FAILED(res);
+
+    // update the "uniform" image min/max values
+    // (texcoords are in the range [0,1])
+    //   imgEdge[0] = imgMin.x
+    //   imgEdge[1] = imgMin.y
+    //   imgEdge[2] = imgMax.x
+    //   imgEdge[3] = imgMax.y
+    edgeX = (kernelWidth/2) * xoff;
+    edgeY = (kernelHeight/2) * yoff;
+    imgEdge[0] = edgeX;
+    imgEdge[1] = edgeY;
+    imgEdge[2] = (((jfloat)srcOps->width)  / texW) - edgeX;
+    imgEdge[3] = (((jfloat)srcOps->height) / texH) - edgeY;
+    pd3dDevice = d3dc->Get3DDevice();
+    pd3dDevice->SetPixelShaderConstantF(0, imgEdge, 1);
+
+    // update the "uniform" kernel offsets and values
+    kIndex = 0;
+    for (i = -kernelHeight/2; i < kernelHeight/2+1; i++) {
+        for (j = -kernelWidth/2; j < kernelWidth/2+1; j++) {
+            kernelVals[kIndex+0] = j*xoff;
+            kernelVals[kIndex+1] = i*yoff;
+            kernelVals[kIndex+2] = NEXT_FLOAT(kernel);
+            kernelVals[kIndex+3] = 0.0f; // unused
+            kIndex += 4;
+        }
+    }
+    return pd3dDevice->SetPixelShaderConstantF(1, kernelVals, kernelSize);
+}
+
+HRESULT
+D3DBufImgOps_DisableConvolveOp(D3DContext *d3dc)
+{
+    IDirect3DDevice9 *pd3dDevice;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBufImgOps_DisableConvolveOp");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    d3dc->UpdateState(STATE_CHANGE);
+
+    // disable the ConvolveOp shader
+    pd3dDevice = d3dc->Get3DDevice();
+    return pd3dDevice->SetPixelShader(NULL);
+}
+
+/**************************** RescaleOp support *****************************/
+
+HRESULT
+D3DBufImgOps_EnableRescaleOp(D3DContext *d3dc,
+                             jboolean nonPremult,
+                             unsigned char *scaleFactors,
+                             unsigned char *offsets)
+{
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice;
+    jint flags = 0;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBufImgOps_EnableRescaleOp");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+
+    d3dc->UpdateState(STATE_CHANGE);
+
+    // choose the appropriate shader, depending on the source image
+    if (nonPremult) {
+        flags |= RESCALE_NON_PREMULT;
+    }
+
+    // locate/enable the shader program for the given flags
+    res = d3dc->EnableRescaleProgram(flags);
+    RETURN_STATUS_IF_FAILED(res);
+
+    // update the "uniform" scale factor values (note that the Java-level
+    // dispatching code always passes down 4 values here, regardless of
+    // the original source image type)
+    pd3dDevice = d3dc->Get3DDevice();
+    pd3dDevice->SetPixelShaderConstantF(0, (float *)scaleFactors, 1);
+
+    // update the "uniform" offset values (note that the Java-level
+    // dispatching code always passes down 4 values here, and that the
+    // offsets will have already been normalized to the range [0,1])
+    return pd3dDevice->SetPixelShaderConstantF(1, (float *)offsets, 1);
+}
+
+HRESULT
+D3DBufImgOps_DisableRescaleOp(D3DContext *d3dc)
+{
+    IDirect3DDevice9 *pd3dDevice;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBufImgOps_DisableRescaleOp");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+
+    d3dc->UpdateState(STATE_CHANGE);
+
+    // disable the RescaleOp shader
+    pd3dDevice = d3dc->Get3DDevice();
+    return pd3dDevice->SetPixelShader(NULL);
+}
+
+/**************************** LookupOp support ******************************/
+
+HRESULT
+D3DBufImgOps_EnableLookupOp(D3DContext *d3dc,
+                            jboolean nonPremult, jboolean shortData,
+                            jint numBands, jint bandLength, jint offset,
+                            void *tableValues)
+{
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice;
+    D3DResource *pLutTexRes;
+    IDirect3DTexture9 *pLutTex;
+    int bytesPerElem = (shortData ? 2 : 1);
+    jfloat foffsets[4];
+    void *bands[4];
+    int i;
+    jint flags = 0;
+
+    J2dTraceLn4(J2D_TRACE_INFO,
+                "D3DBufImgOps_EnableLookupOp: short=%d num=%d len=%d off=%d",
+                shortData, numBands, bandLength, offset);
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+
+    d3dc->UpdateState(STATE_CHANGE);
+
+    // choose the appropriate shader, depending on the source image
+    // and the number of bands involved
+    if (numBands != 4) {
+        flags |= LOOKUP_USE_SRC_ALPHA;
+    }
+    if (nonPremult) {
+        flags |= LOOKUP_NON_PREMULT;
+    }
+
+    // locate/enable the shader program for the given flags
+    res = d3dc->EnableLookupProgram(flags);
+    RETURN_STATUS_IF_FAILED(res);
+
+    // update the "uniform" offset value
+    for (i = 0; i < 4; i++) {
+        foffsets[i] = offset / 255.0f;
+    }
+    pd3dDevice = d3dc->Get3DDevice();
+    pd3dDevice->SetPixelShaderConstantF(0, foffsets, 1);
+
+    res = d3dc->GetResourceManager()->GetLookupOpLutTexture(&pLutTexRes);
+    RETURN_STATUS_IF_FAILED(res);
+    pLutTex = pLutTexRes->GetTexture();
+
+    // update the lookup table with the user-provided values
+    if (numBands == 1) {
+        // replicate the single band for R/G/B; alpha band is unused
+        for (i = 0; i < 3; i++) {
+            bands[i] = tableValues;
+        }
+        bands[3] = NULL;
+    } else if (numBands == 3) {
+        // user supplied band for each of R/G/B; alpha band is unused
+        for (i = 0; i < 3; i++) {
+            bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);
+        }
+        bands[3] = NULL;
+    } else if (numBands == 4) {
+        // user supplied band for each of R/G/B/A
+        for (i = 0; i < 4; i++) {
+            bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);
+        }
+    }
+
+    // upload the bands one row at a time into our lookup table texture
+    D3DLOCKED_RECT lockedRect;
+    res = pLutTex->LockRect(0, &lockedRect, NULL, D3DLOCK_NOSYSLOCK);
+    RETURN_STATUS_IF_FAILED(res);
+
+    jushort *pBase = (jushort*)lockedRect.pBits;
+    for (i = 0; i < 4; i++) {
+        jushort *pDst;
+        if (bands[i] == NULL) {
+            continue;
+        }
+        pDst = pBase + (i * 256);
+        if (shortData) {
+            memcpy(pDst, bands[i], bandLength*sizeof(jushort));
+        } else {
+            int j;
+            jubyte *pSrc = (jubyte *)bands[i];
+            for (j = 0; j < bandLength; j++) {
+                pDst[j] = (jushort)(pSrc[j] << 8);
+            }
+        }
+    }
+    pLutTex->UnlockRect(0);
+
+    // bind the lookup table to texture unit 1 and enable texturing
+    res = d3dc->SetTexture(pLutTex, 1);
+    pd3dDevice->SetSamplerState(1, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
+    pd3dDevice->SetSamplerState(1, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
+    pd3dDevice->SetSamplerState(1, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
+    pd3dDevice->SetSamplerState(1, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
+    return res;
+}
+
+HRESULT
+D3DBufImgOps_DisableLookupOp(D3DContext *d3dc)
+{
+    IDirect3DDevice9 *pd3dDevice;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DBufImgOps_DisableLookupOp");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+
+    d3dc->UpdateState(STATE_CHANGE);
+
+    // disable the LookupOp shader
+    pd3dDevice = d3dc->Get3DDevice();
+    pd3dDevice->SetPixelShader(NULL);
+
+    // disable the lookup table on texture unit 1
+    return d3dc->SetTexture(NULL, 1);
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DBufImgOps.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DBufImgOps.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DBufImgOps.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DBufImgOps.h	2011-01-08 01:26:50.471202211 +0000
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef D3DBufImgOps_h_Included
+#define D3DBufImgOps_h_Included
+
+#include "D3DContext.h"
+
+/**************************** ConvolveOp support ****************************/
+
+/**
+ * Flags that can be bitwise-or'ed together to control how the shader
+ * source code is generated.
+ */
+#define CONVOLVE_EDGE_ZERO_FILL (1 << 0)
+#define CONVOLVE_5X5            (1 << 1)
+#define MAX_CONVOLVE            (1 << 2)
+
+HRESULT D3DBufImgOps_EnableConvolveOp(D3DContext *oglc, jlong pSrcOps,
+                                      jboolean edgeZeroFill,
+                                      jint kernelWidth, jint KernelHeight,
+                                      unsigned char *kernelVals);
+HRESULT D3DBufImgOps_DisableConvolveOp(D3DContext *oglc);
+
+/**************************** RescaleOp support *****************************/
+
+/**
+ * Flags that can be bitwise-or'ed together to control how the shader
+ * source code is generated.
+ */
+#define RESCALE_NON_PREMULT (1 << 0)
+#define MAX_RESCALE         (1 << 1)
+
+HRESULT D3DBufImgOps_EnableRescaleOp(D3DContext *oglc,
+                                     jboolean nonPremult,
+                                     unsigned char *scaleFactors,
+                                     unsigned char *offsets);
+HRESULT D3DBufImgOps_DisableRescaleOp(D3DContext *oglc);
+
+/**************************** LookupOp support ******************************/
+
+/**
+ * Flags that can be bitwise-or'ed together to control how the shader
+ * source code is generated.
+ */
+#define LOOKUP_USE_SRC_ALPHA (1 << 0)
+#define LOOKUP_NON_PREMULT   (1 << 1)
+#define MAX_LOOKUP           (1 << 2)
+
+HRESULT D3DBufImgOps_EnableLookupOp(D3DContext *oglc,
+                                    jboolean nonPremult, jboolean shortData,
+                                    jint numBands, jint bandLength, jint offset,
+                                    void *tableValues);
+HRESULT D3DBufImgOps_DisableLookupOp(D3DContext *oglc);
+
+#endif /* D3DBufImgOps_h_Included */
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DContext.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DContext.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DContext.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DContext.cpp	2011-01-08 01:26:50.475202254 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,29 +23,19 @@
  * questions.
  */
 
-#include "sun_java2d_d3d_D3DContext.h"
+#include "D3DPipeline.h"
 #include "jlong.h"
-#include "jni_util.h"
-#include "Trace.h"
-
-#include "ddrawUtils.h"
-#include "awt_Win32GraphicsDevice.h"
-#include "sun_java2d_SunGraphics2D.h"
 
 #include "GraphicsPrimitiveMgr.h"
-
-#include "RegistryKey.h"
-#include "WindowsFlags.h"
-
-#include "Win32SurfaceData.h"
-#include "D3DSurfaceData.h"
-#include "D3DUtils.h"
 #include "D3DContext.h"
-#include "D3DRuntimeTest.h"
-
-#include "IntDcm.h"
-#include "IntArgb.h"
-#include "Region.h"
+#include "D3DSurfaceData.h"
+#include "D3DBufImgOps.h"
+#include "D3DPaints.h"
+#include "D3DRenderQueue.h"
+#include "D3DShaders.h"
+#include "D3DTextRenderer.h"
+#include "D3DPipelineManager.h"
+#include "D3DGlyphCache.h"
 
 typedef struct {
     D3DBLEND src;
@@ -73,472 +63,907 @@
     { D3DBLEND_INVDESTALPHA, D3DBLEND_INVSRCALPHA }, /*12 - RULE_AlphaXor*/
 };
 
-/**
- * D3DContext
- */
-D3DContext* D3DContext::CreateD3DContext(DDraw *ddObject, DXObject* dxObject)
+void
+D3DUtils_SetOrthoMatrixOffCenterLH(D3DMATRIX *m,
+                                   float width, float height)
 {
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::CreateD3DContext");
-    // create and test the d3d context
-    D3DContext *d3dContext = new D3DContext(ddObject, dxObject);
-    // if there was a failure while creating or testing the device,
-    // dispose of it and return NULL
-    if (!(d3dContext->GetDeviceCaps() & J2D_D3D_ENABLED_OK)) {
-        delete d3dContext;
-        d3dContext = NULL;
-    }
-    return d3dContext;
-}
-
-D3DContext::D3DContext(DDraw *ddObject, DXObject* dxObject)
-{
-    GetExclusiveAccess();
-    J2dRlsTraceLn(J2D_TRACE_INFO, "D3DContext::D3DContext");
-    J2dTraceLn2(J2D_TRACE_VERBOSE, "  ddObject=0x%d dxObject=0x%x",
-                ddObject, dxObject);
-    d3dDevice = NULL;
-    d3dObject = NULL;
-    ddTargetSurface = NULL;
-    lpMaskTexture = NULL;
-    lpGlyphCacheTexture = NULL;
-    glyphCache = NULL;
-    glyphCacheAvailable = TRUE;
-    deviceCaps = J2D_D3D_FAILURE;
-    bBeginScenePending = FALSE;
-    jD3DContext = NULL;
+    ZeroMemory(m, sizeof(D3DMATRIX));
+    m->_11 =  2.0f/width;
+    m->_22 = -2.0f/height;
+    m->_33 =  0.5f;
+    m->_44 =  1.0f;
+
+    m->_41 = -1.0f;
+    m->_42 =  1.0f;
+    m->_43 =  0.5f;
+}
 
-    this->dxObject = dxObject;
-    this->ddObject = ddObject;
+void
+D3DUtils_SetIdentityMatrix(D3DMATRIX *m)
+{
+    m->_12 = m->_13 = m->_14 = m->_21 = m->_23 = m->_24 = 0.0f;
+    m->_31 = m->_32 = m->_34 = m->_41 = m->_42 = m->_43 = 0.0f;
+    m->_11 = m->_22 = m->_33 = m->_44 = 1.0f;
+}
 
-    if (SUCCEEDED(dxObject->CreateD3DObject(&d3dObject))) {
+// the following methods are copies of the AffineTransform's class
+// corresponding methods, with these changes to the indexes:
+// 00 -> 11
+// 11 -> 22
+// 01 -> 21
+// 10 -> 12
+// 02 -> 41
+// 12 -> 42
 
-        // The device type we choose to use doesn't change over time
-        pDeviceGUID = D3DUtils_SelectDeviceGUID(d3dObject);
-        if (pDeviceGUID) {
-            bIsHWRasterizer = (*pDeviceGUID == IID_IDirect3DHALDevice ||
-                               *pDeviceGUID == IID_IDirect3DTnLHalDevice);
-            CreateD3DDevice();
-        } else {
-            J2dRlsTraceLn(J2D_TRACE_ERROR,
-                          "D3CCoD3DContext::D3DContext: Can't find "\
-                          "suitable D3D device");
-        }
+void
+D3DUtils_2DConcatenateM(D3DMATRIX *m, D3DMATRIX *m1)
+{
+    float M0, M1;
+    float T00, T10, T01, T11;
+    float T02, T12;
+
+    T00 = m1->_11; T01 = m1->_21; T02 = m1->_41;
+    T10 = m1->_12; T11 = m1->_22; T12 = m1->_42;
+
+    M0 = m->_11;
+    M1 = m->_21;
+    m->_11  = T00 * M0 + T10 * M1;
+    m->_21  = T01 * M0 + T11 * M1;
+    m->_41 += T02 * M0 + T12 * M1;
+
+    M0 = m->_12;
+    M1 = m->_22;
+    m->_12  = T00 * M0 + T10 * M1;
+    m->_22  = T01 * M0 + T11 * M1;
+    m->_42 += T02 * M0 + T12 * M1;
+}
+
+#ifdef UPDATE_TX
+
+void
+D3DUtils_2DScaleM(D3DMATRIX *m, float sx, float sy)
+{
+    m->_11 *= sx;
+    m->_22 *= sy;
+}
+
+void
+D3DUtils_2DInvertM(D3DMATRIX *m)
+{
+    float M11, M21, M41;
+    float M12, M22, M42;
+    float det;
+
+    M11 = m->_11; M21 = m->_21; M41 = m->_41;
+    M12 = m->_12; M22 = m->_22; M42 = m->_42;
+    det = M11 * M22 - M21 * M12;
+    if (fabs(det) <= 0.0000000001f) {
+        memset(m, 0, sizeof(D3DMATRIX));
+        return;
+    }
+    m->_11 =  M22 / det;
+    m->_12 = -M12 / det;
+    m->_21 = -M21 / det;
+    m->_22 =  M11 / det;
+    m->_41 = (M21 * M42 - M22 * M41) / det;
+    m->_42 = (M12 * M41 - M11 * M42) / det;
+}
+
+void
+D3DUtils_2DTranslateM(D3DMATRIX *m, float tx, float ty)
+{
+    m->_41 = tx * m->_11 + ty * m->_21 + m->_41;
+    m->_42 = tx * m->_12 + ty * m->_22 + m->_42;
+}
+
+void
+D3DUtils_2DTransformXY(D3DMATRIX *m, float *px, float *py)
+{
+    float x = *px;
+    float y = *py;
+
+    *px = x * m->_11 + y * m->_21 + m->_41;
+    *py = x * m->_12 + y * m->_22 + m->_42;
+}
+
+void
+D3DUtils_2DInverseTransformXY(D3DMATRIX *m, float *px, float *py)
+{
+    float x = *px, y = *py;
+
+    x -= m->_41;
+    y -= m->_42;
+
+    float det = m->_11 * m->_22 - m->_21 * m->_12;
+    if (fabs(det) < 0.0000000001f) {
+        *px = 0.0f;
+        *py = 0.0f;
     } else {
-        J2dRlsTraceLn(J2D_TRACE_ERROR,
-                      "D3DContext::D3DContext: Can't "\
-                      "create IDirect3D7 interface");
+        *px = (x * m->_22 - y * m->_21) / det;
+        *py = (y * m->_11 - x * m->_12) / det;
     }
+}
 
-    compState = sun_java2d_SunGraphics2D_COMP_ISCOPY;
-    extraAlpha = 1.0f;
-    colorPixel = 0xffffffff;
+#endif // UPDATE_TX
 
-    ReleaseExclusiveAccess();
+static void
+D3DContext_DisposeShader(jlong programID)
+{
+    IDirect3DPixelShader9 *shader =
+        (IDirect3DPixelShader9 *)jlong_to_ptr(programID);
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_DisposeShader");
+
+    SAFE_RELEASE(shader);
 }
 
-void D3DContext::SetJavaContext(JNIEnv *env, jobject newD3Dc) {
-    GetExclusiveAccess();
+// static
+HRESULT
+D3DContext::CreateInstance(IDirect3D9 *pd3d9, UINT adapter, D3DContext **ppCtx)
+{
+    HRESULT res;
+    *ppCtx = new D3DContext(pd3d9, adapter);
+    if (FAILED(res = (*ppCtx)->InitContext())) {
+        delete *ppCtx;
+        *ppCtx = NULL;
+    }
+    return res;
+}
 
-    // Only bother if the new D3DContext object is different
-    // from the one we already have reference to.
-    if (env->IsSameObject(newD3Dc, jD3DContext) == FALSE) {
-        J2dTraceLn(J2D_TRACE_VERBOSE, "D3DContext:SetJavaContext: "\
-                   "setting new java context object");
-        // invalidate the old context, since we've got a new one
-        InvalidateIfTarget(env, ddTargetSurface);
+D3DContext::D3DContext(IDirect3D9 *pd3d, UINT adapter)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::D3DContext");
+    J2dTraceLn1(J2D_TRACE_VERBOSE, "  pd3d=0x%x", pd3d);
+    pd3dObject = pd3d;
+    pd3dDevice = NULL;
+    adapterOrdinal = adapter;
+
+    pResourceMgr = NULL;
+    pMaskCache = NULL;
+    pVCacher = NULL;
+
+    pSyncQuery = NULL;
+    pSyncRTRes = NULL;
+    pStateBlock = NULL;
+
+    D3DC_INIT_SHADER_LIST(convolvePrograms,   MAX_CONVOLVE);
+    D3DC_INIT_SHADER_LIST(rescalePrograms,    MAX_RESCALE);
+    D3DC_INIT_SHADER_LIST(lookupPrograms,     MAX_LOOKUP);
+    D3DC_INIT_SHADER_LIST(basicGradPrograms,  4);
+    D3DC_INIT_SHADER_LIST(linearGradPrograms, 8);
+    D3DC_INIT_SHADER_LIST(radialGradPrograms, 8);
+
+    pLCDGlyphCache= NULL;
+    pGrayscaleGlyphCache= NULL;
+    lcdTextProgram = NULL;
+    aaPgramProgram = NULL;
 
-        if (jD3DContext != NULL) {
-            env->DeleteWeakGlobalRef(jD3DContext);
+    contextCaps = CAPS_EMPTY;
+    bBeginScenePending = FALSE;
+
+    ZeroMemory(&devCaps, sizeof(D3DCAPS9));
+    ZeroMemory(&curParams, sizeof(curParams));
+
+    extraAlpha = 1.0f;
+}
+
+void D3DContext::ReleaseDefPoolResources()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::ReleaseDefPoolResources");
+
+    EndScene();
+
+    D3DPipelineManager::NotifyAdapterEventListeners(devCaps.AdapterOrdinal,
+                                                    DEVICE_RESET);
+
+    contextCaps = CAPS_EMPTY;
+
+    SAFE_RELEASE(pSyncQuery);
+    SAFE_RELEASE(pStateBlock);
+
+    if (pVCacher != NULL) {
+        pVCacher->ReleaseDefPoolResources();
+    }
+    if (pMaskCache != NULL) {
+        pMaskCache->ReleaseDefPoolResources();
+    }
+    if (pLCDGlyphCache != NULL) {
+        pLCDGlyphCache->ReleaseDefPoolResources();
+    }
+    if (pGrayscaleGlyphCache != NULL) {
+        pGrayscaleGlyphCache->ReleaseDefPoolResources();
+    }
+    if (pResourceMgr != NULL) {
+        if (pSyncRTRes != NULL) {
+            pResourceMgr->ReleaseResource(pSyncRTRes);
+            pSyncRTRes = NULL;
         }
-        // set the new java-level context object
-        jD3DContext = env->NewWeakGlobalRef(newD3Dc);
+        pResourceMgr->ReleaseDefPoolResources();
     }
-    ReleaseExclusiveAccess();
+    ZeroMemory(lastTexture, sizeof(lastTexture));
+    ZeroMemory(lastTextureColorState, sizeof(lastTextureColorState));
 }
 
-void D3DContext::Release3DDevice() {
-    GetExclusiveAccess();
+void D3DContext::ReleaseContextResources()
+{
     J2dTraceLn1(J2D_TRACE_INFO,
-                "D3DContext::Release3DDevice: d3dDevice = 0x%x",
-                d3dDevice);
+                "D3DContext::ReleaseContextResources: pd3dDevice = 0x%x",
+                pd3dDevice);
 
-    // make sure we do EndScene if one is pending
-    FlushD3DQueueForTarget(ddTargetSurface);
+    ReleaseDefPoolResources();
 
-    // Let the java-level object know that the context
-    // state is no longer valid, forcing it to be reinitialized
-    // later.
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    InvalidateIfTarget(env, ddTargetSurface);
-
-    // We don't need to release it since we didn't create it
-    ddTargetSurface = NULL;
-
-    // disable the use of this context until we ensure the capabilities
-    // of the new device and run the tests
-    deviceCaps = J2D_D3D_FAILURE;
-
-    if (lpMaskTexture != NULL) {
-        lpMaskTexture->Release();
-        delete lpMaskTexture;
-        lpMaskTexture = NULL;
-    }
-
-    // reset the depth buffer format
-    memset(&depthBufferFormat, 0, sizeof(depthBufferFormat));
-
-    if (d3dDevice) {
-        // setting the texture increases its reference number, so
-        // we should reset the textures for all stages to make sure
-        // they're released
-        for (int stage = 0; stage <= MAX_USED_TEXTURE_STAGE; stage++) {
-            d3dDevice->SetTexture(stage, NULL);
-            lastTexture[stage] = NULL;
-        }
-        d3dDevice->Release();
-        d3dDevice = NULL;
-    }
-    ReleaseExclusiveAccess();
+    D3DPipelineManager::NotifyAdapterEventListeners(devCaps.AdapterOrdinal,
+                                                    DEVICE_DISPOSED);
+
+    // dispose shader lists
+    ShaderList_Dispose(&convolvePrograms);
+    ShaderList_Dispose(&rescalePrograms);
+    ShaderList_Dispose(&lookupPrograms);
+    ShaderList_Dispose(&basicGradPrograms);
+    ShaderList_Dispose(&linearGradPrograms);
+    ShaderList_Dispose(&radialGradPrograms);
+
+    SAFE_DELETE(pLCDGlyphCache);
+    SAFE_DELETE(pGrayscaleGlyphCache);
+
+    SAFE_RELEASE(lcdTextProgram);
+    SAFE_RELEASE(aaPgramProgram);
+
+    SAFE_DELETE(pVCacher);
+    SAFE_DELETE(pMaskCache);
+    SAFE_DELETE(pResourceMgr);
 }
 
 D3DContext::~D3DContext() {
     J2dTraceLn2(J2D_TRACE_INFO,
-                "~D3DContext: d3dDevice=0x%x, d3dObject =0x%x",
-                d3dDevice, d3dObject);
-    GetExclusiveAccess();
-    if (lpGlyphCacheTexture != NULL) {
-        lpGlyphCacheTexture->Release();
-        delete lpGlyphCacheTexture;
-        lpGlyphCacheTexture = NULL;
-    }
-    Release3DDevice();
-    if (d3dObject != NULL) {
-        d3dObject->Release();
-        d3dObject = NULL;
-    }
-    ReleaseExclusiveAccess();
+                "~D3DContext: pd3dDevice=0x%x, pd3dObject =0x%x",
+                pd3dDevice, pd3dObject);
+    ReleaseContextResources();
+    SAFE_RELEASE(pd3dDevice);
 }
 
 HRESULT
-D3DContext::InitD3DDevice(IDirect3DDevice7 *d3dDevice)
+D3DContext::InitDevice(IDirect3DDevice9 *pd3dDevice)
 {
-    HRESULT res = D3D_OK;
+    HRESULT res = S_OK;
+
+    pd3dDevice->GetDeviceCaps(&devCaps);
+
     J2dRlsTraceLn1(J2D_TRACE_INFO,
-                   "D3DContext::InitD3DDevice: d3dDevice=Ox%x", d3dDevice);
+                   "D3DContext::InitDevice: device %d", adapterOrdinal);
 
-    d3dDevice->GetCaps(&d3dDevDesc);
     // disable some of the unneeded and costly d3d functionality
-    d3dDevice->SetRenderState(D3DRENDERSTATE_CULLMODE, D3DCULL_NONE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, FALSE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_SPECULARENABLE, FALSE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_LIGHTING,  FALSE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_CLIPPING,  FALSE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_ZENABLE, D3DZB_FALSE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_COLORVERTEX, FALSE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_STENCILENABLE, FALSE);
-
-    d3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTFG_POINT);
-    d3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTFG_POINT);
+    pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
+    pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
+    pd3dDevice->SetRenderState(D3DRS_LIGHTING,  FALSE);
+    pd3dDevice->SetRenderState(D3DRS_CLIPPING,  FALSE);
+    pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
+    pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, D3DZB_FALSE);
+    pd3dDevice->SetRenderState(D3DRS_COLORVERTEX, FALSE);
+    pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
+
+    // set the default texture addressing mode
+    pd3dDevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
+
+    // REMIND: check supported filters with
+    // IDirect3D9::CheckDeviceFormat with D3DUSAGE_QUERY_FILTER
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);
 
     // these states never change
-    d3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
-    d3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
-    d3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
-    d3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
+    pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
+    pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
+    pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
+    pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
+    pd3dDevice->SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
+    pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_MODULATE);
+    pd3dDevice->SetTextureStageState(1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
+    pd3dDevice->SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);
+
     // init the array of latest textures
-    memset(&lastTexture, 0, sizeof(lastTexture));
-    // this will force the state initialization on first UpdateState
-    opState = STATE_UNDEFINED;
+    ZeroMemory(lastTexture, sizeof(lastTexture));
+    ZeroMemory(lastTextureColorState, sizeof(lastTextureColorState));
+
+    opState = STATE_CHANGE;
+
+    if (pResourceMgr == NULL) {
+        res = D3DResourceManager::CreateInstance(this, &pResourceMgr);
+    } else {
+        res = pResourceMgr->Init(this);
+    }
+    RETURN_STATUS_IF_FAILED(res);
+
+    if (pVCacher == NULL) {
+        res = D3DVertexCacher::CreateInstance(this, &pVCacher);
+    } else {
+        res = pVCacher->Init(this);
+    }
+    RETURN_STATUS_IF_FAILED(res);
+
+    if (pMaskCache == NULL) {
+        res = D3DMaskCache::CreateInstance(this, &pMaskCache);
+    } else{
+        res = pMaskCache->Init(this);
+    }
+    RETURN_STATUS_IF_FAILED(res);
+
+    if (pLCDGlyphCache != NULL) {
+        if (FAILED(res = pLCDGlyphCache->Init(this))) {
+            // we can live without the cache
+            SAFE_DELETE(pLCDGlyphCache);
+            res = S_OK;
+        }
+    }
+
+    if (pGrayscaleGlyphCache != NULL) {
+        if (FAILED(res = pGrayscaleGlyphCache->Init(this))) {
+            // we can live without the cache
+            SAFE_DELETE(pGrayscaleGlyphCache);
+            res = S_OK;
+        }
+    }
 
     D3DMATRIX tx;
     D3DUtils_SetIdentityMatrix(&tx);
-    d3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD, &tx);
+    pd3dDevice->SetTransform(D3DTS_WORLD, &tx);
+    bIsIdentityTx = TRUE;
+
+    if (pSyncQuery == NULL) {
+        // this is allowed to fail, do not propagate the error
+        if (FAILED(pd3dDevice->CreateQuery(D3DQUERYTYPE_EVENT, &pSyncQuery))) {
+            J2dRlsTraceLn(J2D_TRACE_WARNING,
+                          "D3DContext::InitDevice: sync query not available");
+            pSyncQuery = NULL;
+        }
+    }
+    if (pSyncRTRes == NULL) {
+        D3DFORMAT format;
+        if (FAILED(GetResourceManager()->
+                   CreateRTSurface(32, 32, TRUE, TRUE, &format, &pSyncRTRes))) {
+            J2dRlsTraceLn(J2D_TRACE_WARNING,
+                          "D3DContext::InitDevice: "
+                          "error creating sync surface");
+        }
+    }
 
     bBeginScenePending = FALSE;
 
-    D3DUtils_SetupTextureFormats(d3dDevice, textureTable);
+    J2dRlsTraceLn1(J2D_TRACE_INFO,
+                   "D3DContext::InitDefice: successfully initialized device %d",
+                   adapterOrdinal);
 
-    // REMIND: debugging: allows testing the argb path in
-    // UploadImageToTexture on devices with alpha texture support
-    if ((getenv("J2D_D3D_NOALPHATEXTURE") != NULL) ||
-         FAILED(res = D3DUtils_FindMaskTileTextureFormat(d3dDevice,
-                                                         &maskTileTexFormat)))
-    {
-        // use ARGB if can't find alpha texture (or in case argb
-        // was specifically requested)
-        J2dTraceLn(J2D_TRACE_VERBOSE,
-                   "D3DContext::InitD3DDevice: "\
-                   "Using IntARBG instead of Alpha texture");
-        if (textureTable[TR_TRANSLUCENT_IDX][DEPTH32_IDX].pfType != PF_INVALID)
-        {
-            memcpy(&maskTileTexFormat,
-                   &textureTable[TR_TRANSLUCENT_IDX][DEPTH32_IDX].pddpf,
-                   sizeof(maskTileTexFormat));
-            res = D3D_OK;
+    return res;
+}
+
+HRESULT
+D3DContext::CheckAndResetDevice()
+{
+    HRESULT res = E_FAIL;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::CheckAndResetDevice");
+
+    if (pd3dDevice != NULL) {
+        if (FAILED(res = pd3dDevice->TestCooperativeLevel())) {
+            if (res == D3DERR_DEVICELOST) {
+                J2dTraceLn1(J2D_TRACE_VERBOSE, "  device %d is still lost",
+                            adapterOrdinal);
+                // nothing to be done here, wait for D3DERR_DEVICENOTRESET
+                return res;
+            } else if (res == D3DERR_DEVICENOTRESET) {
+                J2dTraceLn1(J2D_TRACE_VERBOSE, "  device %d needs to be reset",
+                            adapterOrdinal);
+                res = ResetContext();
+            } else {
+                // some unexpected error
+                DebugPrintD3DError(res, "D3DContext::CheckAndResetDevice: "\
+                                   "unknown error %x from TestCooperativeLevel");
+            }
+        } else {
+            J2dTraceLn1(J2D_TRACE_VERBOSE, "  device %d is not lost",
+                        adapterOrdinal);
         }
     } else {
-        J2dTraceLn(J2D_TRACE_VERBOSE,
-                   "D3DContext::InitD3DDevice: Found Alpha-texture format");
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  null device");
     }
     return res;
 }
 
 HRESULT
-D3DContext::CreateAndTestD3DDevice(DxCapabilities *dxCaps)
+D3DContext::ResetContext()
 {
-    J2dRlsTraceLn(J2D_TRACE_INFO, "D3DContext::CreateAndTestD3DDevice");
-    HRESULT res;
-    if (pDeviceGUID == NULL) {
-        J2dRlsTraceLn(J2D_TRACE_ERROR,
-                      "D3DContext::CreateAndTestD3DDevice: "\
-                      "No usable d3d device");
-        deviceCaps = J2D_D3D_FAILURE;
-        return DDERR_GENERIC;
+    HRESULT res = E_FAIL;
+
+    J2dRlsTraceLn(J2D_TRACE_INFO, "D3DContext::ResetContext");
+    if (pd3dDevice != NULL) {
+        D3DPRESENT_PARAMETERS newParams;
+
+        newParams = curParams;
+
+        if (newParams.Windowed) {
+            // reset to the current display mode if we're windowed,
+            // otherwise to the display mode we were in when the device
+            // was lost
+            newParams.BackBufferFormat = D3DFMT_UNKNOWN;
+            newParams.FullScreen_RefreshRateInHz = 0;
+            newParams.BackBufferWidth = 0;
+            newParams.BackBufferHeight = 0;
+        }
+        res = ConfigureContext(&newParams);
     }
+    return res;
+}
 
-    Release3DDevice();
-
-    // Create a temp surface so we can use it when creating a device
-    DXSurface *target = NULL;
-    if (FAILED(res = CreateSurface(NULL, 10, 10, 32, TR_OPAQUE,
-                                   D3D_PLAIN_SURFACE|D3D_RENDER_TARGET,
-                                   &target, NULL)))
-    {
-        DebugPrintDirectDrawError(res,
-                                  "D3DContext::CreateAndTestD3DDevice: "\
-                                  "can't create scratch surface");
-        return res;
+HRESULT
+D3DContext::ConfigureContext(D3DPRESENT_PARAMETERS *pNewParams)
+{
+    J2dRlsTraceLn1(J2D_TRACE_INFO, "D3DContext::ConfigureContext device %d",
+                   adapterOrdinal);
+    HRESULT res = S_OK;
+    D3DFORMAT stencilFormat;
+    HWND focusHWND = D3DPipelineManager::GetInstance()->GetCurrentFocusWindow();
+    D3DDEVTYPE devType = D3DPipelineManager::GetInstance()->GetDeviceType();
+    // this is needed so that we can find the stencil buffer format
+    if (pNewParams->BackBufferFormat == D3DFMT_UNKNOWN) {
+        D3DDISPLAYMODE dm;
+
+        pd3dObject->GetAdapterDisplayMode(adapterOrdinal, &dm);
+        pNewParams->BackBufferFormat = dm.Format;
+    }
+
+    stencilFormat =
+        D3DPipelineManager::GetInstance()->GetMatchingDepthStencilFormat(
+            adapterOrdinal,
+            pNewParams->BackBufferFormat, pNewParams->BackBufferFormat);
+
+    pNewParams->EnableAutoDepthStencil = TRUE;
+    pNewParams->AutoDepthStencilFormat = stencilFormat;
+
+    // do not set device window in the windowed mode, we use additional
+    // swap chains for rendering, the default chain is not used. otherwise
+    // our scratch focus window will be made visible
+    J2dTraceLn1(J2D_TRACE_VERBOSE, "  windowed=%d",pNewParams->Windowed);
+    if (pNewParams->Windowed) {
+        pNewParams->hDeviceWindow = (HWND)0;
+    }
+
+    // The focus window may change when we're entering/exiting the full-screen
+    // mode. It may either be set to the default focus window (when there are
+    // no more devices in fs mode), or to fs window for another device
+    // in fs mode. See D3DPipelineManager::GetCurrentFocusWindow.
+    if (pd3dDevice != NULL) {
+        D3DDEVICE_CREATION_PARAMETERS cParams;
+        pd3dDevice->GetCreationParameters(&cParams);
+        if (cParams.hFocusWindow != focusHWND) {
+            J2dTraceLn(J2D_TRACE_VERBOSE,
+                       "  focus window changed, need to recreate the device");
+
+            // if fs -> windowed, first exit fs, then recreate, otherwise
+            // the screen might be left in a different display mode
+            if (pNewParams->Windowed && !curParams.Windowed) {
+                J2dTraceLn(J2D_TRACE_VERBOSE,
+                            "  exiting full-screen mode, reset the device");
+                curParams.Windowed = FALSE;
+                ReleaseDefPoolResources();
+                res = pd3dDevice->Reset(&curParams);
+
+                if (FAILED(res)) {
+                    DebugPrintD3DError(res, "D3DContext::ConfigureContext: "\
+                                       "cound not reset the device");
+                }
+            }
+
+            // note that here we should release all device resources, not only
+            // thos in the default pool since the device is released
+            ReleaseContextResources();
+            SAFE_RELEASE(pd3dDevice);
+        }
     }
 
-    if (FAILED(res = d3dObject->CreateDevice(*pDeviceGUID,
-                                             target->GetDDSurface(),
-                                             &d3dDevice)))
-    {
-        DebugPrintDirectDrawError(res,
-                                  "D3DContext::CreateAndTestD3DDevice: "\
-                                  "error creating d3d device");
-    } else if (FAILED(res = InitD3DDevice(d3dDevice))) {
-        DebugPrintDirectDrawError(res,
-                                  "D3DContext::CreateAndTestD3DDevice: "\
-                                  "error initializing D3D device");
+    if (pd3dDevice != NULL) {
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  resetting the device");
+
+        ReleaseDefPoolResources();
+
+        if (pNewParams->PresentationInterval == D3DPRESENT_INTERVAL_IMMEDIATE &&
+            !IsImmediateIntervalSupported())
+        {
+            pNewParams->PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
+        }
+
+        res = pd3dDevice->Reset(pNewParams);
+        if (FAILED(res)) {
+            DebugPrintD3DError(res,
+                "D3DContext::ConfigureContext: cound not reset the device");
+            return res;
+        }
+        J2dRlsTraceLn1(J2D_TRACE_INFO,
+            "D3DContext::ConfigureContext: successfully reset device: %d",
+            adapterOrdinal);
     } else {
-        J2dRlsTraceLn(J2D_TRACE_VERBOSE,
-                      "D3DContext::CreateAndTestD3DDevice: "\
-                      "D3D device creation/initialization successful");
-        // the device is successfully created and initialized,
-        // now run some tests on it
-        deviceCaps = TestD3DDevice(ddObject, this, dxCaps);
+        D3DCAPS9 d3dCaps;
+        DWORD dwBehaviorFlags;
+
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  creating a new device");
+
+        if (FAILED(res = pd3dObject->GetDeviceCaps(adapterOrdinal,
+                                                   devType, &d3dCaps)))
+        {
+            DebugPrintD3DError(res,
+                "D3DContext::ConfigureContext: failed to get caps");
+            return res;
+        }
+
+        if (pNewParams->PresentationInterval == D3DPRESENT_INTERVAL_IMMEDIATE &&
+            !(d3dCaps.PresentationIntervals & D3DPRESENT_INTERVAL_IMMEDIATE))
+        {
+            pNewParams->PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
+        }
+
+        // not preserving fpu control word could cause issues (4860749)
+        dwBehaviorFlags = D3DCREATE_FPU_PRESERVE;
+
+        J2dRlsTrace(J2D_TRACE_VERBOSE,
+                    "[V] dwBehaviorFlags=D3DCREATE_FPU_PRESERVE|");
+        if (d3dCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) {
+            J2dRlsTrace(J2D_TRACE_VERBOSE,
+                        "D3DCREATE_HARDWARE_VERTEXPROCESSING");
+            dwBehaviorFlags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;
+        } else {
+            J2dRlsTrace(J2D_TRACE_VERBOSE,
+                        "D3DCREATE_SOFTWARE_VERTEXPROCESSING");
+            dwBehaviorFlags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;
+        }
+        // Handling focus changes by ourselves proved to be problematic,
+        // so we're reverting back to D3D handling
+        // dwBehaviorFlags |= D3DCREATE_NOWINDOWCHANGES;
+        J2dRlsTrace(J2D_TRACE_VERBOSE,"\n");
+
+        if (FAILED(res = pd3dObject->CreateDevice(adapterOrdinal, devType,
+                                                  focusHWND,
+                                                  dwBehaviorFlags,
+                                                  pNewParams, &pd3dDevice)))
+        {
+            DebugPrintD3DError(res,
+                "D3DContext::ConfigureContext: error creating d3d device");
+            return res;
+        }
+        J2dRlsTraceLn1(J2D_TRACE_INFO,
+            "D3DContext::ConfigureContext: successfully created device: %d",
+            adapterOrdinal);
+        bIsHWRasterizer = (devType == D3DDEVTYPE_HAL);
     }
 
-    // We can safely dispose the scratch surface here
-    if (target != NULL) {
-        target->Release();
-        delete target;
+    curParams = *pNewParams;
+    // during the creation of the device d3d modifies this field, we reset
+    // it back to 0
+    curParams.Flags = 0;
+
+    if (FAILED(res = InitDevice(pd3dDevice))) {
+        ReleaseContextResources();
+        return res;
     }
 
+    res = InitContextCaps();
+
     return res;
 }
 
-void
-D3DContext::CreateD3DDevice()
+HRESULT
+D3DContext::InitContext()
 {
-    GetExclusiveAccess();
-    J2dRlsTraceLn(J2D_TRACE_INFO, "D3DContext::CreateD3DDevice");
-    // this is a weird way of getting a handle on the ddInstance
-    HMONITOR hMonitor = dxObject->GetHMonitor();
-    DxCapabilities *dxCaps =
-        AwtWin32GraphicsDevice::GetDxCapsForDevice(hMonitor);
-
-    int d3dCapsValidity = dxCaps->GetD3dCapsValidity();
-    // Always run the test unless we crashed doing so the last time.
-    // The reasons:
-    //   - the user may have disabled d3d acceleration in the display panel
-    //     since the last run
-    //   - the user may have installed the new drivers, which may cause BSODs
-    //   - if the test had failed previously because of quality issues, the
-    //     new driver may have fixed the problem, but we'd never know since we
-    //     never try again
-    //   - user (or developer, rather) may have specified a
-    //     different rasterizer via env. variable
-    if (d3dCapsValidity != J2D_ACCEL_TESTING) {
-        dxCaps->SetD3dCapsValidity(J2D_ACCEL_TESTING);
-
-        // this will create the device, test it and set the
-        // deviceCaps
-        CreateAndTestD3DDevice(dxCaps);
-
-        dxCaps->SetD3dDeviceCaps(deviceCaps);
-        dxCaps->SetD3dCapsValidity(J2D_ACCEL_SUCCESS);
-    }
-    int requiredResults = forceD3DUsage ?
-        J2D_D3D_REQUIRED_RESULTS : J2D_D3D_DESIRED_RESULTS;
-
-#ifdef DEBUG
-    J2dTraceLn(J2D_TRACE_VERBOSE, "CreateD3DDevice: requested caps:");
-    PrintD3DCaps(requiredResults);
-    J2dTraceLn(J2D_TRACE_VERBOSE, " caps supported by the device:");
-    PrintD3DCaps(deviceCaps);
-    J2dTraceLn(J2D_TRACE_VERBOSE, " missing caps:");
-    PrintD3DCaps(requiredResults & ~deviceCaps);
-#endif // DEBUG
-
-    if ((deviceCaps & requiredResults) != requiredResults) {
-        if (!(deviceCaps & J2D_D3D_HW_OK)) {
-            // disable d3d for all devices, because we've encountered
-            // known bad hardware. See comment in TestForBadHardware().
-            J2dRlsTraceLn(J2D_TRACE_ERROR,
-                          "CreateD3DDevice: bad hardware found,"\
-                          " disabling d3d for all devices.");
-            SetD3DEnabledFlag(NULL, FALSE, FALSE);
-        } else {
-            J2dRlsTraceLn(J2D_TRACE_ERROR,
-                          "CreateD3DDevice: tests FAILED, d3d disabled.");
+    J2dRlsTraceLn1(J2D_TRACE_INFO, "D3DContext::InitContext device %d",
+                   adapterOrdinal);
+
+    D3DPRESENT_PARAMETERS params;
+    ZeroMemory(&params, sizeof(D3DPRESENT_PARAMETERS));
+
+    params.hDeviceWindow = 0;
+    params.Windowed = TRUE;
+    params.BackBufferCount = 1;
+    params.BackBufferFormat = D3DFMT_UNKNOWN;
+    params.SwapEffect = D3DSWAPEFFECT_DISCARD;
+    params.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
+
+    return ConfigureContext(&params);
+}
+
+HRESULT
+D3DContext::Sync()
+{
+    HRESULT res = S_OK;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::Sync");
+
+    if (pSyncQuery != NULL) {
+        J2dTrace(J2D_TRACE_VERBOSE, "  flushing the device queue..");
+        while (S_FALSE ==
+               (res = pSyncQuery->GetData(NULL, 0, D3DGETDATA_FLUSH))) ;
+        J2dTrace(J2D_TRACE_VERBOSE, ".. done\n");
+    }
+    if (pSyncRTRes != NULL) {
+        D3DLOCKED_RECT lr;
+        IDirect3DSurface9 *pSurface = pSyncRTRes->GetSurface();
+        if (SUCCEEDED(pSurface->LockRect(&lr, NULL, D3DLOCK_NOSYSLOCK))) {
+            pSurface->UnlockRect();
         }
-        // REMIND: the first time the context initialization fails,
-        // deviceUseD3D is set to FALSE in DDrawObjectStruct, and because of
-        // this we never attempt to initialize it again later.
-        // For example, if the app switches to a display mode where
-        // d3d is not supported, we disable d3d, but it stays disabled
-        // even when the display mode is switched back to a supported one.
-        // May be we should disable it only in case of a hard error.
-        ddObject->DisableD3D();
-        Release3DDevice();
-    } else {
-        deviceCaps |= J2D_D3D_ENABLED_OK;
-        J2dRlsTraceLn1(J2D_TRACE_INFO,
-                       "CreateD3DDevice: tests PASSED, "\
-                       "d3d enabled (forced: %s).",
-                       forceD3DUsage ? "yes" : "no");
     }
-
-    ReleaseExclusiveAccess();
+    return res;
 }
 
 HRESULT
-D3DContext::SetRenderTarget(DDrawSurface *ddSurface)
+D3DContext::SaveState()
 {
-    static D3DVIEWPORT7 vp = { 0, 0, 0, 0, 0.0f, 1.0f };
-    static D3DMATRIX tx;
-    BOOL bSetProjectionMatrix = FALSE;
-    HRESULT res = DDERR_GENERIC;
-    GetExclusiveAccess();
+    HRESULT res;
 
-    J2dTraceLn2(J2D_TRACE_INFO,
-                "D3DContext::SetRenderTarget: old=0x%x new=0x%x",
-                ddTargetSurface, ddSurface);
+    RETURN_STATUS_IF_NULL(pd3dDevice, S_OK);
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::SaveState");
+
+    FlushVertexQueue();
+    UpdateState(STATE_CHANGE);
 
-    ddTargetSurface = NULL;
+    if (pStateBlock != NULL) {
+        J2dTraceLn(J2D_TRACE_WARNING,
+                   "D3DContext::SaveState: existing state block!");
+        SAFE_RELEASE(pStateBlock);
+    }
 
-    DXSurface *dxSurface = NULL;
-    if (d3dDevice == NULL || ddSurface == NULL ||
-        (dxSurface = ddSurface->GetDXSurface()) == NULL)
+    if (SUCCEEDED(res =
+            pd3dDevice->CreateStateBlock(D3DSBT_ALL, &pStateBlock)))
     {
-        ReleaseExclusiveAccess();
-        J2dTraceLn3(J2D_TRACE_WARNING,
-                    "D3DContext::SetRenderTarget invalid state:"\
-                    "d3dDevice=0x%x ddSurface=0x%x dxSurface=0x%x",
-                    d3dDevice, ddSurface, dxSurface);
-        return res;
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  created state block");
+    } else {
+        J2dTraceLn(J2D_TRACE_WARNING,
+                   "D3DContext::SaveState: failed to create state block");
     }
+    ZeroMemory(lastTexture, sizeof(lastTexture));
 
-    if (FAILED(res = ddSurface->IsLost())) {
-        ReleaseExclusiveAccess();
-        DebugPrintDirectDrawError(res, "D3DContext::SetRenderTarget: "\
-                                  "target surface (and/or depth buffer) lost");
-        return res;
+    return res;
+}
+
+HRESULT
+D3DContext::RestoreState()
+{
+    HRESULT res = S_OK;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::RestoreState");
+
+    FlushVertexQueue();
+    UpdateState(STATE_CHANGE);
+
+    if (pStateBlock != NULL) {
+        if (SUCCEEDED(res = pStateBlock->Apply())) {
+            J2dTraceLn(J2D_TRACE_VERBOSE, "  restored device state");
+        } else {
+            J2dTraceLn(J2D_TRACE_WARNING,
+                       "D3DContext::RestoreState: failed to restore state");
+        }
+        SAFE_RELEASE(pStateBlock);
+    } else {
+        J2dTraceLn(J2D_TRACE_WARNING,
+                   "D3DContext::RestoreState: empty state block!");
     }
+    ZeroMemory(lastTexture, sizeof(lastTexture));
 
-    ForceEndScene();
+    return res;
+}
 
-    if (FAILED(res = d3dDevice->SetRenderTarget(dxSurface->GetDDSurface(), 0)))
-    {
-        ReleaseExclusiveAccess();
-        DebugPrintDirectDrawError(res, "D3DContext::SetRenderTarget: "\
-                                  "error setting render target");
-        return res;
+#define POINT_FILTER_CAP (D3DPTFILTERCAPS_MAGFPOINT|D3DPTFILTERCAPS_MINFPOINT)
+#define LINEAR_FILTER_CAP (D3DPTFILTERCAPS_MAGFLINEAR|D3DPTFILTERCAPS_MINFLINEAR)
+
+BOOL
+D3DContext::IsStretchRectFilteringSupported(D3DTEXTUREFILTERTYPE fType)
+{
+    if (fType == D3DTEXF_POINT) {
+        return ((devCaps.StretchRectFilterCaps & POINT_FILTER_CAP) != 0);
     }
+    if (fType == D3DTEXF_LINEAR) {
+        return ((devCaps.StretchRectFilterCaps & LINEAR_FILTER_CAP) != 0);
+    }
+    return FALSE;
+}
 
-    int width = dxSurface->GetWidth();
-    int height = dxSurface->GetHeight();
-    // set the projection matrix if the the dimensions of the new
-    // rendertarget are different from the old one.
-    if (FAILED(d3dDevice->GetViewport(&vp)) ||
-        (int)vp.dwWidth != width  || (int)vp.dwHeight != height)
-    {
-        bSetProjectionMatrix = TRUE;
+BOOL
+D3DContext::IsTextureFilteringSupported(D3DTEXTUREFILTERTYPE fType)
+{
+    if (fType == D3DTEXF_POINT) {
+        return ((devCaps.TextureFilterCaps & POINT_FILTER_CAP) != 0);
+    }
+    if (fType == D3DTEXF_LINEAR) {
+        return ((devCaps.TextureFilterCaps & LINEAR_FILTER_CAP) != 0);
     }
+    return FALSE;
+}
 
-    vp.dwX = vp.dwY = 0;
-    vp.dwWidth  = width;
-    vp.dwHeight = height;
-    vp.dvMinZ = 0.0f;
-    vp.dvMaxZ = 1.0f;
-
-    if (FAILED(res = d3dDevice->SetViewport(&vp))) {
-        DebugPrintDirectDrawError(res, "D3DContext::SetRenderTarget: "\
-                                  "error setting viewport");
-        ReleaseExclusiveAccess();
-        return res;
+BOOL
+D3DContext::IsTextureFormatSupported(D3DFORMAT format, DWORD usage)
+{
+    HRESULT hr = pd3dObject->CheckDeviceFormat(adapterOrdinal,
+                                               devCaps.DeviceType,
+                                               curParams.BackBufferFormat,
+                                               usage,
+                                               D3DRTYPE_TEXTURE,
+                                               format);
+    return SUCCEEDED( hr );
+}
+
+BOOL
+D3DContext::IsDepthStencilBufferOk(D3DSURFACE_DESC *pTargetDesc)
+{
+    IDirect3DSurface9 *pStencil;
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::IsDepthStencilBufferOk");
+
+    if (SUCCEEDED(pd3dDevice->GetDepthStencilSurface(&pStencil))) {
+        D3DSURFACE_DESC descStencil;
+        pStencil->GetDesc(&descStencil);
+        pStencil->Release();
+
+        D3DDISPLAYMODE dm;
+        return
+            (SUCCEEDED(pd3dDevice->GetDisplayMode(0, &dm)) &&
+             pTargetDesc->Width <= descStencil.Width &&
+             pTargetDesc->Height <= descStencil.Height &&
+             SUCCEEDED(pd3dObject->CheckDepthStencilMatch(
+                   adapterOrdinal,
+                   devCaps.DeviceType,
+                   dm.Format, pTargetDesc->Format,
+                   descStencil.Format)));
     }
+    J2dTraceLn(J2D_TRACE_VERBOSE,
+        "  current stencil buffer is not compatible with new Render Target");
+
+    return false;
+}
 
-    if (bSetProjectionMatrix) {
-        D3DUtils_SetOrthoMatrixOffCenterLH(&tx, (float)width, (float)height);
-        res = d3dDevice->SetTransform(D3DTRANSFORMSTATE_PROJECTION, &tx);
+
+
+HRESULT
+D3DContext::InitDepthStencilBuffer(D3DSURFACE_DESC *pTargetDesc)
+{
+    HRESULT res;
+    IDirect3DSurface9 *pBB;
+    D3DDISPLAYMODE dm;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::InitDepthStencilBuffer");
+
+    if (FAILED(res = pd3dDevice->GetDisplayMode(0, &dm))) {
+        return res;
     }
 
+    D3DFORMAT newFormat =
+        D3DPipelineManager::GetInstance()->GetMatchingDepthStencilFormat(
+            adapterOrdinal, dm.Format, pTargetDesc->Format);
+
+    res = pd3dDevice->CreateDepthStencilSurface(
+        pTargetDesc->Width, pTargetDesc->Height,
+        newFormat, D3DMULTISAMPLE_NONE, 0, false, &pBB, 0);
     if (SUCCEEDED(res)) {
-        ddTargetSurface = ddSurface;
-        J2dTraceLn1(J2D_TRACE_VERBOSE,
-                    "D3DContext::SetRenderTarget: succeeded, "\
-                    "new target=0x%x", ddTargetSurface);
-    } else {
-        DebugPrintDirectDrawError(res, "D3DContext::SetRenderTarget: failed");
+        res = pd3dDevice->SetDepthStencilSurface(pBB);
+        pBB->Release();
     }
 
-    ReleaseExclusiveAccess();
     return res;
 }
 
+
 HRESULT
-D3DContext::SetTransform(jobject xform,
-                         jdouble m00, jdouble m10,
+D3DContext::SetRenderTarget(IDirect3DSurface9 *pSurface)
+{
+    static D3DMATRIX tx;
+    HRESULT res;
+    D3DSURFACE_DESC descNew;
+    IDirect3DSurface9 *pCurrentTarget;
+
+    J2dTraceLn1(J2D_TRACE_INFO,
+                "D3DContext::SetRenderTarget: pSurface=0x%x",
+                pSurface);
+
+    RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
+    RETURN_STATUS_IF_NULL(pSurface, E_FAIL);
+
+    pSurface->GetDesc(&descNew);
+
+    if (SUCCEEDED(res = pd3dDevice->GetRenderTarget(0, &pCurrentTarget))) {
+        if (pCurrentTarget != pSurface) {
+            FlushVertexQueue();
+            if (FAILED(res = pd3dDevice->SetRenderTarget(0, pSurface))) {
+                DebugPrintD3DError(res, "D3DContext::SetRenderTarget: "\
+                                        "error setting render target");
+                SAFE_RELEASE(pCurrentTarget);
+                return res;
+            }
+
+            if (!IsDepthStencilBufferOk(&descNew)) {
+                if (FAILED(res = InitDepthStencilBuffer(&descNew))) {
+                    SAFE_RELEASE(pCurrentTarget);
+                    return res;
+                }
+            }
+        }
+        SAFE_RELEASE(pCurrentTarget);
+    }
+    // we set the transform even if the render target didn't change;
+    // this is because in some cases (fs mode) we use the default SwapChain of
+    // the device, and its render target will be the same as the device's, and
+    // we have to set the matrix correctly. This shouldn't be a performance
+    // issue as render target changes are relatively rare
+    D3DUtils_SetOrthoMatrixOffCenterLH(&tx,
+                       (float)descNew.Width,
+                       (float)descNew.Height);
+    pd3dDevice->SetTransform(D3DTS_PROJECTION, &tx);
+
+    J2dTraceLn1(J2D_TRACE_VERBOSE, "  current render target=0x%x", pSurface);
+    return res;
+}
+
+HRESULT
+D3DContext::ResetTransform()
+{
+    HRESULT res = S_OK;
+    D3DMATRIX tx;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::ResetTransform");
+    if (pd3dDevice == NULL) {
+        return E_FAIL;
+    }
+
+    // no need for state change, just flush the queue
+    FlushVertexQueue();
+
+    D3DUtils_SetIdentityMatrix(&tx);
+    if (FAILED(res = pd3dDevice->SetTransform(D3DTS_WORLD, &tx))) {
+        DebugPrintD3DError(res, "D3DContext::SetTransform failed");
+    }
+    bIsIdentityTx = TRUE;
+    return res;
+}
+
+HRESULT
+D3DContext::SetTransform(jdouble m00, jdouble m10,
                          jdouble m01, jdouble m11,
                          jdouble m02, jdouble m12)
 {
-    GetExclusiveAccess();
+    HRESULT res = S_OK;
+    D3DMATRIX tx, tx1;
 
     J2dTraceLn(J2D_TRACE_INFO, "D3DContext::SetTransform");
-    if (d3dDevice == NULL) {
-        ReleaseExclusiveAccess();
-        return DDERR_GENERIC;
+    if (pd3dDevice == NULL) {
+        return E_FAIL;
     }
-    HRESULT res = D3D_OK;
-    D3DMATRIX tx;
 
-    if (xform == NULL) {
-        J2dTraceLn(J2D_TRACE_VERBOSE, "  disabling transform");
-        D3DUtils_SetIdentityMatrix(&tx);
-    } else {
-        J2dTraceLn(J2D_TRACE_VERBOSE, "  enabling transform");
+    // no need for state change, just flush the queue
+    FlushVertexQueue();
 
-        // copy values from AffineTransform object into native matrix array
-        memset(&tx, 0, sizeof(D3DMATRIX));
-        tx._11 = (float)m00;
-        tx._12 = (float)m10;
-        tx._21 = (float)m01;
-        tx._22 = (float)m11;
-        // The -0.5 adjustment is needed to correctly align texels to
-        // pixels with orgthogonal projection matrix.
-        // Note that we readjust vertex coordinates for cases
-        // when we don't do texture mapping or use D3DPT_LINESTRIP.
-        tx._41 = (float)m02-0.5f;
-        tx._42 = (float)m12-0.5f;
+    // In order to correctly map texels to pixels we need to
+    // adjust geometry by -0.5f in the transformed space.
+    // In order to do that we first create a translated matrix
+    // and then concatenate it with the world transform.
+    //
+    // Note that we only use non-id transform with DrawTexture,
+    // the rest is rendered pre-transformed.
+    //
+    // The identity transform for textures is handled in
+    // D3DVertexCacher::DrawTexture() because shifting by -0.5 for id
+    // transform breaks lines rendering.
+
+    ZeroMemory(&tx1, sizeof(D3DMATRIX));
+
+    tx1._11 = (float)m00;
+    tx1._12 = (float)m10;
+    tx1._21 = (float)m01;
+    tx1._22 = (float)m11;
+    tx1._41 = (float)m02;
+    tx1._42 = (float)m12;
 
-        tx._33 = 1.0f;
-        tx._44 = 1.0f;
-    }
+    tx1._33 = 1.0f;
+    tx1._44 = 1.0f;
+
+    D3DUtils_SetIdentityMatrix(&tx);
+    tx._41 = -0.5f;
+    tx._42 = -0.5f;
+    D3DUtils_2DConcatenateM(&tx, &tx1);
 
-    J2dTraceLn(J2D_TRACE_VERBOSE, "  setting new tx matrix");
     J2dTraceLn4(J2D_TRACE_VERBOSE,
                 "  %5f %5f %5f %5f", tx._11, tx._12, tx._13, tx._14);
     J2dTraceLn4(J2D_TRACE_VERBOSE,
@@ -547,651 +972,518 @@
                 "  %5f %5f %5f %5f", tx._31, tx._32, tx._33, tx._34);
     J2dTraceLn4(J2D_TRACE_VERBOSE,
                 "  %5f %5f %5f %5f", tx._41, tx._42, tx._43, tx._44);
-    if (FAILED(res = d3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD, &tx))) {
-        DebugPrintDirectDrawError(res, "D3DContext::SetTransform failed");
+    if (FAILED(res = pd3dDevice->SetTransform(D3DTS_WORLD, &tx))) {
+        DebugPrintD3DError(res, "D3DContext::SetTransform failed");
     }
+    bIsIdentityTx = FALSE;
 
-    ReleaseExclusiveAccess();
     return res;
 }
 
+HRESULT
+D3DContext::SetRectClip(int x1, int y1, int x2, int y2)
+{
+    HRESULT res = S_OK;
+    D3DSURFACE_DESC desc;
+    IDirect3DSurface9 *pCurrentTarget;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::SetRectClip");
+    J2dTraceLn4(J2D_TRACE_VERBOSE,
+                "  x1=%-4d y1=%-4d x2=%-4d y2=%-4d",
+                x1, y1, x2, y2);
+
+    RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
+
+    // no need for state change, just flush the queue
+    FlushVertexQueue();
+
+    pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
+
+    res = pd3dDevice->GetRenderTarget(0, &pCurrentTarget);
+    RETURN_STATUS_IF_FAILED(res);
+
+    pCurrentTarget->GetDesc(&desc);
+    SAFE_RELEASE(pCurrentTarget);
+
+    if (x1 <= 0 && y1 <= 0 &&
+        (UINT)x2 >= desc.Width && (UINT)y2 >= desc.Height)
+    {
+        J2dTraceLn(J2D_TRACE_VERBOSE,
+                   "  disabling clip (== render target dimensions)");
+        return pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
+    }
+
+    // clip to the dimensions of the target surface, otherwise
+    // SetScissorRect will fail
+    if (x1 < 0)                 x1 = 0;
+    if (y1 < 0)                 y1 = 0;
+    if ((UINT)x2 > desc.Width)  x2 = desc.Width;
+    if ((UINT)y2 > desc.Height) y2 = desc.Height;
+    if (x1 > x2)                x2 = x1 = 0;
+    if (y1 > y2)                y2 = y1 = 0;
+    RECT newRect = { x1, y1, x2, y2 };
+    if (SUCCEEDED(res = pd3dDevice->SetScissorRect(&newRect))) {
+        res = pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
+    } else {
+        DebugPrintD3DError(res, "Error setting scissor rect");
+        J2dRlsTraceLn4(J2D_TRACE_ERROR,
+                       "  x1=%-4d y1=%-4d x2=%-4d y2=%-4d",
+                       x1, y1, x2, y2);
+    }
+
+    return res;
+}
+
+HRESULT
+D3DContext::ResetClip()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::ResetClip");
+    // no need for state change, just flush the queue
+    FlushVertexQueue();
+    pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
+    return pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
+}
+
+ClipType
+D3DContext::GetClipType()
+{
+    // REMIND: this method could be optimized: we could keep the
+    // clip state around when re/setting the clip instead of asking
+    // every time.
+    DWORD zEnabled = 0;
+    DWORD stEnabled = 0;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::GetClipType");
+    pd3dDevice->GetRenderState(D3DRS_SCISSORTESTENABLE, &stEnabled);
+    if (stEnabled) {
+        return CLIP_RECT;
+    }
+    pd3dDevice->GetRenderState(D3DRS_ZENABLE, &zEnabled);
+    if (zEnabled) {
+        return CLIP_SHAPE;
+    }
+    return CLIP_NONE;
+}
+
+
 /**
  * This method assumes that ::SetRenderTarget has already
  * been called. SetRenderTarget creates and attaches a
  * depth buffer to the target surface prior to setting it
  * as target surface to the device.
  */
+DWORD dwAlphaSt, dwSrcBlendSt, dwDestBlendSt;
+D3DMATRIX tx, idTx;
+
 HRESULT
-D3DContext::SetClip(JNIEnv *env, jobject clip,
-                    jboolean isRect,
-                    int x1, int y1,
-                    int x2, int y2)
+D3DContext::BeginShapeClip()
 {
-    HRESULT res;
-    static J2D_XY_VERTEX clipRect[] = {
-#ifdef USE_SINGLE_VERTEX_FORMAT
-        { 0.0f, 0.0f, 1.0f, 0xffffffff, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 1.0f, 0xffffffff, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 1.0f, 0xffffffff, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 1.0f, 0xffffffff, 0.0f, 0.0f }
-#else
-        // Note that we use D3DFVF_XYZ vertex format
-        // implies 0xffffffff diffuse color, so we don't
-        // have to specify it.
-        { 0.0f, 0.0f, 1.0f },
-        { 0.0f, 0.0f, 1.0f },
-        { 0.0f, 0.0f, 1.0f },
-        { 0.0f, 0.0f, 1.0f },
-#endif // USE_SINGLE_VERTEX_FORMAT
-    };
-    static J2DXY_HEXA spanVx[MAX_CACHED_SPAN_VX_NUM];
-
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::SetClip");
-    J2dTraceLn5(J2D_TRACE_VERBOSE,
-                "  x1=%-4d y1=%-4d x2=%-4d y2=%-4d isRect=%-2d",
-                x1, y1, x2, y2, isRect);
-    GetExclusiveAccess();
-    // the target surface must already be set
-    if (d3dDevice == NULL || ddTargetSurface == NULL) {
-        ReleaseExclusiveAccess();
-        return DDERR_GENERIC;
-    }
+    HRESULT res = S_OK;
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::BeginShapeClip");
 
+    UpdateState(STATE_CHANGE);
 
-    // Must do EndScene prior to setting a new clip, otherwise the
-    // primitives which are already in the pipeline will be rendered with
-    // the new clip when we do EndScene.
-    ForceEndScene();
+    pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
 
-    if (clip == NULL) {
-        J2dTraceLn(J2D_TRACE_VERBOSE,
-                   "D3DContext::SetClip: disabling clip (== NULL)");
-        res = d3dDevice->SetRenderState(D3DRENDERSTATE_ZENABLE, D3DZB_FALSE);
-        ReleaseExclusiveAccess();
-        return res;
-    } else if (isRect) {
-        // optimization: disable depth buffer if the clip is equal to
-        // the size of the viewport
-        int w = ddTargetSurface->GetDXSurface()->GetWidth();
-        int h = ddTargetSurface->GetDXSurface()->GetHeight();
-        if (x1 == 0 && y1 == 0 && x2 == w && y2 == h) {
-            J2dTraceLn(J2D_TRACE_VERBOSE,
-                       "D3DContext::SetClip: disabling clip (== viewport)");
-            res = d3dDevice->SetRenderState(D3DRENDERSTATE_ZENABLE, D3DZB_FALSE);
-            ReleaseExclusiveAccess();
-            return res;
-        }
-    }
+    // save alpha blending state
+    pd3dDevice->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlphaSt);
+    pd3dDevice->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlendSt);
+    pd3dDevice->GetRenderState(D3DRS_DESTBLEND, &dwDestBlendSt);
 
-    // save the old settings
-    DWORD dwAlphaSt, dwSrcBlendSt, dwDestBlendSt;
-    d3dDevice->GetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, &dwAlphaSt);
-    d3dDevice->GetRenderState(D3DRENDERSTATE_SRCBLEND, &dwSrcBlendSt);
-    d3dDevice->GetRenderState(D3DRENDERSTATE_DESTBLEND, &dwDestBlendSt);
-
-    d3dDevice->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, TRUE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_SRCBLEND, D3DBLEND_ZERO);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_DESTBLEND, D3DBLEND_ONE);
-
-    // disable texturing
-    if (lastTexture[0] != NULL) {
-        // note that we do not restore the texture after we set the clip,
-        // it will be reset the next time a texturing operation is performed
-        SetTexture(NULL);
-    }
+    pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
+    pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);
+    pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
 
-    D3DMATRIX tx, idTx;
-    d3dDevice->GetTransform(D3DTRANSFORMSTATE_WORLD, &tx);
+    pd3dDevice->GetTransform(D3DTS_WORLD, &tx);
     D3DUtils_SetIdentityMatrix(&idTx);
-    d3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD, &idTx);
+    // translate the clip spans by 1.0f in z direction so that the
+    // clip spans are rendered to the z buffer
+    idTx._43 = 1.0f;
+    pd3dDevice->SetTransform(D3DTS_WORLD, &idTx);
 
     // The depth buffer is first cleared with zeroes, which is the farthest
-    // plane from the viewer (our projection matrix is an inversed orthogonal
-    // transform).
-    // To set the clip we'll render the clip spans with Z coordinates of 1.0f
-    // (the closest to the viewer). Since all rendering primitives
-    // have their vertices' Z coordinate set to 0.0, they will effectively be
-    // clipped because the Z depth test for them will fail (vertex with 1.0
-    // depth is closer than the one with 0.0f)
-    d3dDevice->SetRenderState(D3DRENDERSTATE_ZENABLE, D3DZB_TRUE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, TRUE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_ZFUNC, D3DCMP_ALWAYS);
-    d3dDevice->Clear(0, NULL, D3DCLEAR_ZBUFFER, 0L, 0.0f, 0x0L);
-
-    float fx1, fy1, fx2, fy2;
-    if (SUCCEEDED(d3dDevice->BeginScene())) {
-        if (isRect) {
-            fx1 = (float)x1; fy1 = (float)y1;
-            fx2 = (float)x2; fy2 = (float)y2;
-            D3DU_INIT_VERTEX_QUAD_XY(clipRect, fx1, fy1, fx2, fy2);
-            res = d3dDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, D3DFVF_XY_VERTEX,
-                                           clipRect, 4, NULL);
-        } else {
-            RegionData clipInfo;
-            Region_GetInfo(env, clip, &clipInfo);
-            SurfaceDataBounds span;
-            J2DXY_HEXA *pHexa = (J2DXY_HEXA*)spanVx;
-            jint numOfCachedSpans = 0;
-
-            Region_StartIteration(env, &clipInfo);
-            while (Region_NextIteration(&clipInfo, &span)) {
-                fx1 = (float)(span.x1); fy1 = (float)(span.y1);
-                fx2 = (float)(span.x2); fy2 = (float)(span.y2);
-                D3DU_INIT_VERTEX_XYZ_6(*pHexa, fx1, fy1, fx2, fy2, 1.0f);
-                numOfCachedSpans++;
-                pHexa = (J2DXY_HEXA*)PtrAddBytes(pHexa, sizeof(J2DXY_HEXA));
-                if (numOfCachedSpans >= MAX_CACHED_SPAN_VX_NUM) {
-                    res = d3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST,
-                                                   D3DFVF_XY_VERTEX,
-                                                   (void*)spanVx,
-                                                   6*numOfCachedSpans, NULL);
-                    numOfCachedSpans = 0;
-                    pHexa = (J2DXY_HEXA*)spanVx;
-                    if (FAILED(res)) {
-                        break;
-                    }
-                }
-            }
-            if (numOfCachedSpans > 0) {
-                res = d3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST,
-                                               D3DFVF_XY_VERTEX,
-                                               (void*)spanVx,
-                                               6*numOfCachedSpans, NULL);
-            }
-            Region_EndIteration(env, &clipInfo);
-        }
-        res = d3dDevice->EndScene();
-    }
-
-    // reset the transform
-    d3dDevice->SetTransform(D3DTRANSFORMSTATE_WORLD, &tx);
-
-    // reset the alpha compositing
-    d3dDevice->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, dwAlphaSt);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_SRCBLEND, dwSrcBlendSt);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_DESTBLEND, dwDestBlendSt);
+    // plane from the viewer (our projection matrix is an inversed orthogonal
+    // transform).
+    // To set the clip we'll render the clip spans with Z coordinates of 1.0f
+    // (the closest to the viewer). Since all rendering primitives
+    // have their vertices' Z coordinate set to 0.0, they will effectively be
+    // clipped because the Z depth test for them will fail (vertex with 1.0
+    // depth is closer than the one with 0.0f)
+    pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
+    pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
+    pd3dDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);
+    pd3dDevice->Clear(0, NULL, D3DCLEAR_ZBUFFER, 0L, 0.0f, 0x0L);
 
-    // Setup the depth buffer.
-    // We disable further updates to the depth buffer: it should only
-    // be updated in SetClip method.
-    d3dDevice->SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, FALSE);
-    d3dDevice->SetRenderState(D3DRENDERSTATE_ZFUNC, D3DCMP_LESS);
+    //res = BeginScene(STATE_SHAPE_CLIPOP);
 
-    ReleaseExclusiveAccess();
     return res;
 }
 
-DXSurface *
-D3DContext::GetMaskTexture()
-{
-    if (lpMaskTexture != NULL) {
-        // This in theory should never happen since
-        // we're using managed textures, but in case
-        // we switch to using something else.
-        if (FAILED(lpMaskTexture->IsLost())) {
-            lpMaskTexture->Restore();
-        }
-        return lpMaskTexture;
-    }
-    InitMaskTileTexture();
-    return lpMaskTexture;
-}
-
-
 HRESULT
-D3DContext::InitMaskTileTexture()
+D3DContext::EndShapeClip()
 {
     HRESULT res;
 
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::InitMaskTileTexture");
-    if (lpMaskTexture != NULL) {
-        lpMaskTexture->Release();
-    }
-    lpMaskTexture = NULL;
-
-    DWORD caps2 = 0, caps = DDSCAPS_TEXTURE;
-    if (bIsHWRasterizer) {
-        caps2 = DDSCAPS2_TEXTUREMANAGE;
-    } else {
-        caps |= DDSCAPS_SYSTEMMEMORY;
-    }
+    // no need for state change, just flush the queue
+    res = FlushVertexQueue();
+
+    // restore alpha blending state
+    pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaSt);
+    pd3dDevice->SetRenderState(D3DRS_SRCBLEND, dwSrcBlendSt);
+    pd3dDevice->SetRenderState(D3DRS_DESTBLEND, dwDestBlendSt);
+
+    // resore the transform
+    pd3dDevice->SetTransform(D3DTS_WORLD, &tx);
+
+    // Enable the depth buffer.
+    // We disable further updates to the depth buffer: it should only
+    // be updated in SetClip method.
+    pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
+    pd3dDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESS);
 
-    if (FAILED(res =
-               dxObject->CreateSurface(DDSD_WIDTH|DDSD_HEIGHT|DDSD_CAPS|
-                                       DDSD_PIXELFORMAT|DDSD_TEXTURESTAGE,
-                                       caps,
-                                       caps2,
-                                       &maskTileTexFormat,
-                                       D3DSD_MASK_TILE_SIZE, D3DSD_MASK_TILE_SIZE,
-                                       (DXSurface **)&lpMaskTexture, 0)))
-    {
-        // in case we want to do something here later..
-        DebugPrintDirectDrawError(res,
-                                  "D3DContext::InitMaskTileTexture: "\
-                                  "failed to create mask tile texture");
-    }
     return res;
 }
 
 HRESULT
-D3DContext::UploadImageToTexture(DXSurface *texture, jubyte *pixels,
-                                 jint dstx, jint dsty,
-                                 jint srcx, jint srcy,
-                                 jint srcWidth, jint srcHeight,
-                                 jint srcStride)
-{
-    HRESULT res = D3D_OK;
-    SurfaceDataRasInfo rasInfo;
-
-
+D3DContext::UploadTileToTexture(D3DResource *pTextureRes, void *pixels,
+                                jint dstx, jint dsty,
+                                jint srcx, jint srcy,
+                                jint srcWidth, jint srcHeight,
+                                jint srcStride,
+                                TileFormat srcFormat,
+                                jint *pPixelsTouchedL,
+                                jint* pPixelsTouchedR)
+{
+#ifndef PtrAddBytes
+#define PtrAddBytes(p, b)               ((void *) (((intptr_t) (p)) + (b)))
+#define PtrCoord(p, x, xinc, y, yinc)   PtrAddBytes(p, (y)*(yinc) + (x)*(xinc))
+#endif // PtrAddBytes
+
+    HRESULT res = S_OK;
+    IDirect3DTexture9 *pTexture = pTextureRes->GetTexture();
+    D3DSURFACE_DESC *pDesc = pTextureRes->GetDesc();
     RECT r = { dstx, dsty, dstx+srcWidth, dsty+srcHeight };
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::UploadImageToTexture");
+    RECT *pR = &r;
+    D3DLOCKED_RECT lockedRect;
+    DWORD dwLockFlags = D3DLOCK_NOSYSLOCK;
+    // these are only counted for LCD glyph uploads
+    jint pixelsTouchedL = 0, pixelsTouchedR = 0;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::UploadTileToTexture");
     J2dTraceLn4(J2D_TRACE_VERBOSE,
-                " rect={%-4d, %-4d, %-4d, %-4d}",
-                r.left, r.top, r.right, r.bottom);
-    // REMIND: it may be faster to lock for NULL instead of
-    // rect, need to test later.
-    if (FAILED(res = texture->Lock(&r, &rasInfo,
-                                   DDLOCK_WAIT|DDLOCK_NOSYSLOCK, NULL)))
+        " rect={%-4d, %-4d, %-4d, %-4d}",
+        r.left, r.top, r.right, r.bottom);
+
+    // REMIND: we should also check for dstx, dsty being 0 here,
+    // but they're always 0 in dynamic texture case
+    if (pDesc->Usage == D3DUSAGE_DYNAMIC &&
+        srcWidth == pDesc->Width && srcHeight == pDesc->Height)
     {
-        DebugPrintDirectDrawError(res,
-                                  "D3DContext::UploadImageToTexture: could "\
-                                  "not lock texture");
+        dwLockFlags |= D3DLOCK_DISCARD;
+        pR = NULL;
+    }
+
+    if (FAILED(res = pTexture->LockRect(0, &lockedRect, pR, dwLockFlags))) {
+        DebugPrintD3DError(res,
+            "D3DContext::UploadImageToTexture: could "\
+            "not lock texture");
         return res;
     }
 
-    if (rasInfo.pixelStride == 1) {
-        // 8bpp alpha texture
-        void *pSrcPixels = PtrCoord(pixels, srcx, 1, srcy, srcStride);
-        void *pDstPixels = rasInfo.rasBase;
-        do {
-            memcpy(pDstPixels, pSrcPixels, srcWidth);
-            pSrcPixels = PtrAddBytes(pSrcPixels, srcStride);
-            pDstPixels = PtrAddBytes(pDstPixels, rasInfo.scanStride);
-        } while (--srcHeight > 0);
-    } else {
-        // ARGB texture
-        jubyte *pSrcPixels = (jubyte*)PtrCoord(pixels, srcx, 1, srcy, srcStride);
-        jint *pDstPixels = (jint*)rasInfo.rasBase;
-        for (int yy = 0; yy < srcHeight; yy++) {
-            for (int xx = 0; xx < srcWidth; xx++) {
-                jubyte pix = pSrcPixels[xx];
-                StoreIntArgbFrom4ByteArgb(pDstPixels, 0, xx,
-                                          pix, pix, pix, pix);
+    if (srcFormat == TILEFMT_1BYTE_ALPHA) {
+        // either a MaskFill tile, or a grayscale glyph
+        if (pDesc->Format == D3DFMT_A8) {
+            void *pSrcPixels = PtrCoord(pixels, srcx, 1, srcy, srcStride);
+            void *pDstPixels = lockedRect.pBits;
+            do {
+                memcpy(pDstPixels, pSrcPixels, srcWidth);
+                pSrcPixels = PtrAddBytes(pSrcPixels, srcStride);
+                pDstPixels = PtrAddBytes(pDstPixels, lockedRect.Pitch);
+            } while (--srcHeight > 0);
+        }
+        else if (pDesc->Format == D3DFMT_A8R8G8B8) {
+            jubyte *pSrcPixels = (jubyte*)
+                PtrCoord(pixels, srcx, 1, srcy, srcStride);
+            jint *pDstPixels = (jint*)lockedRect.pBits;
+            for (int yy = 0; yy < srcHeight; yy++) {
+                for (int xx = 0; xx < srcWidth; xx++) {
+                    // only need to set the alpha channel (the D3D texture
+                    // state will be setup in this case to replicate the
+                    // alpha channel as needed)
+                    pDstPixels[xx] = pSrcPixels[xx] << 24;
+                }
+                pSrcPixels = (jubyte*)PtrAddBytes(pSrcPixels, srcStride);
+                pDstPixels = (jint*)PtrAddBytes(pDstPixels, lockedRect.Pitch);
             }
-            pSrcPixels = (jubyte*)PtrAddBytes(pSrcPixels, srcStride);
-            pDstPixels = (jint*)PtrAddBytes(pDstPixels, rasInfo.scanStride);
         }
-    }
-    return texture->Unlock(&r);
-}
-
-HRESULT
-D3DContext::InitGlyphCache()
-{
-    HRESULT res = D3D_OK;
-
-    if (glyphCache != NULL) {
-        return D3D_OK;
-    }
+    } else if (srcFormat == TILEFMT_3BYTE_RGB) {
+        // LCD glyph with RGB order
+        if (pDesc->Format == D3DFMT_R8G8B8) {
+            jubyte *pSrcPixels = (jubyte*)
+                PtrCoord(pixels, srcx, 3, srcy, srcStride);
+            jubyte *pDstPixels = (jubyte*)lockedRect.pBits;
+            for (int yy = 0; yy < srcHeight; yy++) {
+                for (int xx = 0; xx < srcWidth*3; xx+=3) {
+                    // alpha channel is ignored in this case
+                    // (note that this is backwards from what one might
+                    // expect; it appears that D3DFMT_R8G8B8 is actually
+                    // laid out in BGR order in memory)
+                    pDstPixels[xx+0] = pSrcPixels[xx+2];
+                    pDstPixels[xx+1] = pSrcPixels[xx+1];
+                    pDstPixels[xx+2] = pSrcPixels[xx+0];
+                }
+                pixelsTouchedL +=
+                    (pDstPixels[0+0]|pDstPixels[0+1]|pDstPixels[0+2]) ? 1 : 0;
+                jint i = 3*(srcWidth-1);
+                pixelsTouchedR +=
+                    (pDstPixels[i+0]|pDstPixels[i+1]|pDstPixels[i+2]) ? 1 : 0;
 
-    if (!glyphCacheAvailable) {
-        return DDERR_GENERIC;
-    }
+                pSrcPixels = (jubyte*)PtrAddBytes(pSrcPixels, srcStride);
+                pDstPixels = (jubyte*)PtrAddBytes(pDstPixels, lockedRect.Pitch);
+            }
+        }
+        else if (pDesc->Format == D3DFMT_A8R8G8B8) {
+            jubyte *pSrcPixels = (jubyte*)
+                PtrCoord(pixels, srcx, 3, srcy, srcStride);
+            jint *pDstPixels = (jint*)lockedRect.pBits;
+            for (int yy = 0; yy < srcHeight; yy++) {
+                for (int dx = 0, sx = 0; dx < srcWidth; dx++, sx+=3) {
+                    // alpha channel is ignored in this case
+                    jubyte r = pSrcPixels[sx+0];
+                    jubyte g = pSrcPixels[sx+1];
+                    jubyte b = pSrcPixels[sx+2];
+                    pDstPixels[dx] = (r << 16) | (g << 8) | (b);
+                }
+                pixelsTouchedL += (pDstPixels[0]          ? 1 : 0);
+                pixelsTouchedR += (pDstPixels[srcWidth-1] ? 1 : 0);
 
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::InitGlyphCache");
+                pSrcPixels = (jubyte*)PtrAddBytes(pSrcPixels, srcStride);
+                pDstPixels = (jint*)PtrAddBytes(pDstPixels, lockedRect.Pitch);
+            }
+        }
+    } else if (srcFormat == TILEFMT_3BYTE_BGR) {
+        // LCD glyph with BGR order
+        if (pDesc->Format == D3DFMT_R8G8B8) {
+            void *pSrcPixels = PtrCoord(pixels, srcx, 3, srcy, srcStride);
+            void *pDstPixels = lockedRect.pBits;
+            jubyte *pbDst;
+            do {
+                // alpha channel is ignored in this case
+                // (note that this is backwards from what one might
+                // expect; it appears that D3DFMT_R8G8B8 is actually
+                // laid out in BGR order in memory)
+                memcpy(pDstPixels, pSrcPixels, srcWidth * 3);
+
+                pbDst = (jubyte*)pDstPixels;
+                pixelsTouchedL +=(pbDst[0+0]|pbDst[0+1]|pbDst[0+2]) ? 1 : 0;
+                jint i = 3*(srcWidth-1);
+                pixelsTouchedR +=(pbDst[i+0]|pbDst[i+1]|pbDst[i+2]) ? 1 : 0;
+
+                pSrcPixels = PtrAddBytes(pSrcPixels, srcStride);
+                pDstPixels = PtrAddBytes(pDstPixels, lockedRect.Pitch);
+            } while (--srcHeight > 0);
+        }
+        else if (pDesc->Format == D3DFMT_A8R8G8B8) {
+            jubyte *pSrcPixels = (jubyte*)
+                PtrCoord(pixels, srcx, 3, srcy, srcStride);
+            jint *pDstPixels = (jint*)lockedRect.pBits;
+            for (int yy = 0; yy < srcHeight; yy++) {
+                for (int dx = 0, sx = 0; dx < srcWidth; dx++, sx+=3) {
+                    // alpha channel is ignored in this case
+                    jubyte b = pSrcPixels[sx+0];
+                    jubyte g = pSrcPixels[sx+1];
+                    jubyte r = pSrcPixels[sx+2];
+                    pDstPixels[dx] = (r << 16) | (g << 8) | (b);
+                }
+                pixelsTouchedL += (pDstPixels[0]          ? 1 : 0);
+                pixelsTouchedR += (pDstPixels[srcWidth-1] ? 1 : 0);
 
-    // init glyph cache data structure
-    glyphCache = AccelGlyphCache_Init(D3D_GCACHE_WIDTH,
-                                      D3D_GCACHE_HEIGHT,
-                                      D3D_GCACHE_CELL_WIDTH,
-                                      D3D_GCACHE_CELL_HEIGHT,
-                                      NULL);
-    if (glyphCache == NULL) {
-        J2dRlsTraceLn(J2D_TRACE_ERROR,
-                      "D3DContext::InitGlyphCache: "\
-                      "could not init D3D glyph cache");
-        glyphCacheAvailable = FALSE;
-        return DDERR_GENERIC;
+                pSrcPixels = (jubyte*)PtrAddBytes(pSrcPixels, srcStride);
+                pDstPixels = (jint*)PtrAddBytes(pDstPixels, lockedRect.Pitch);
+            }
+        }
+    } else if (srcFormat == TILEFMT_4BYTE_ARGB_PRE) {
+        // MaskBlit tile
+        if (pDesc->Format == D3DFMT_A8R8G8B8) {
+            void *pSrcPixels = PtrCoord(pixels, srcx, 4, srcy, srcStride);
+            void *pDstPixels = lockedRect.pBits;
+            do {
+                memcpy(pDstPixels, pSrcPixels, srcWidth * 4);
+                pSrcPixels = PtrAddBytes(pSrcPixels, srcStride);
+                pDstPixels = PtrAddBytes(pDstPixels, lockedRect.Pitch);
+            } while (--srcHeight > 0);
+        }
+    } else {
+        // should not happen, no-op just in case...
     }
 
-    DWORD caps2 = 0, caps = DDSCAPS_TEXTURE;
-    if (bIsHWRasterizer) {
-        caps2 = DDSCAPS2_TEXTUREMANAGE;
-    } else {
-        caps |= DDSCAPS_SYSTEMMEMORY;
+    if (pPixelsTouchedL) {
+        *pPixelsTouchedL  = pixelsTouchedL;
     }
-    if (FAILED(res =
-               dxObject->CreateSurface(DDSD_WIDTH|DDSD_HEIGHT|DDSD_CAPS|
-                                       DDSD_PIXELFORMAT|DDSD_TEXTURESTAGE,
-                                       caps,
-                                       caps2,
-                                       &maskTileTexFormat,
-                                       D3D_GCACHE_WIDTH, D3D_GCACHE_HEIGHT,
-                                       (DXSurface **)&lpGlyphCacheTexture, 0)))
-    {
-        DebugPrintDirectDrawError(res,
-                                  "D3DContext::InitGlyphCache: glyph cache "\
-                                  "texture creation failed");
-        glyphCacheAvailable = FALSE;
-        return res;
+    if (pPixelsTouchedR) {
+        *pPixelsTouchedR = pixelsTouchedR;
     }
-    return res;
+
+    return pTexture->UnlockRect(0);
 }
 
 HRESULT
-D3DContext::GlyphCacheAdd(JNIEnv *env, GlyphInfo *glyph)
+D3DContext::InitLCDGlyphCache()
 {
-    HRESULT res = D3D_OK;
-    if (!glyphCacheAvailable || glyph->image == NULL) {
-        return DDERR_GENERIC;
-    }
-
-    AccelGlyphCache_AddGlyph(glyphCache, glyph);
-
-    if (glyph->cellInfo != NULL) {
-        // store glyph image in texture cell
-        res = UploadImageToTexture(lpGlyphCacheTexture, (jubyte*)glyph->image,
-                                   glyph->cellInfo->x, glyph->cellInfo->y,
-                                   0, 0,
-                                   glyph->width, glyph->height,
-                                   glyph->width);
+    if (pLCDGlyphCache == NULL) {
+        return D3DGlyphCache::CreateInstance(this, CACHE_LCD, &pLCDGlyphCache);
     }
-
-    return res;
+    return S_OK;
 }
 
-void
-D3DContext::SetColor(jint eargb, jint flags)
+HRESULT
+D3DContext::InitGrayscaleGlyphCache()
 {
-    J2dTraceLn2(J2D_TRACE_INFO,
-                "D3DContext::SetColor: eargb=%08x flags=%d", eargb, flags);
-
-    /*
-     * The colorPixel field is a 32-bit ARGB premultiplied color
-     * value.  The incoming eargb field is a 32-bit ARGB value
-     * that is not premultiplied.  If the alpha is not 1.0 (255)
-     * then we need to premultiply the color components before
-     * storing it in the colorPixel field.
-     */
-    jint a = (eargb >> 24) & 0xff;
-
-    if (a == 0xff) {
-        colorPixel = eargb;
-    } else {
-        jint a2 = a + (a >> 7);
-        jint r = (((eargb >> 16) & 0xff) * a2) >> 8;
-        jint g = (((eargb >>  8) & 0xff) * a2) >> 8;
-        jint b = (((eargb      ) & 0xff) * a2) >> 8;
-        colorPixel = (a << 24) | (r << 16) | (g << 8) | (b << 0);
+    if (pGrayscaleGlyphCache == NULL) {
+        return D3DGlyphCache::CreateInstance(this, CACHE_GRAY,
+                                             &pGrayscaleGlyphCache);
     }
-    J2dTraceLn1(J2D_TRACE_VERBOSE, "  updated color: colorPixel=%08x",
-                colorPixel);
+    return S_OK;
 }
 
-void
+HRESULT
 D3DContext::ResetComposite()
 {
     J2dTraceLn(J2D_TRACE_INFO, "D3DContext::ResetComposite");
-    GetExclusiveAccess();
-    if (d3dDevice == NULL) {
-        ReleaseExclusiveAccess();
-        return;
-    }
-    d3dDevice->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, TRUE);
-    compState = sun_java2d_SunGraphics2D_COMP_ISCOPY;
+
+    RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
+
+    HRESULT res = UpdateState(STATE_CHANGE);
+    pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
     extraAlpha = 1.0f;
-    ReleaseExclusiveAccess();
+    return res;
 }
 
-void
+HRESULT
 D3DContext::SetAlphaComposite(jint rule, jfloat ea, jint flags)
 {
+    HRESULT res;
     J2dTraceLn3(J2D_TRACE_INFO,
                 "D3DContext::SetAlphaComposite: rule=%-1d ea=%f flags=%d",
                 rule, ea, flags);
-    GetExclusiveAccess();
 
-    if (d3dDevice == NULL) {
-        ReleaseExclusiveAccess();
-        return;
-    }
+    RETURN_STATUS_IF_NULL(pd3dDevice, E_FAIL);
+
+    res = UpdateState(STATE_CHANGE);
 
     // we can safely disable blending when:
     //   - comp is SrcNoEa or SrcOverNoEa, and
     //   - the source is opaque
-    // (turning off blending can have a large positive impact on
-    // performance);
+    // (turning off blending can have a large positive impact on performance)
     if ((rule == RULE_Src || rule == RULE_SrcOver) &&
         (ea == 1.0f) &&
         (flags & D3DC_SRC_IS_OPAQUE))
-     {
-         J2dTraceLn1(J2D_TRACE_VERBOSE,
-                     "  disabling alpha comp rule=%-1d ea=1.0 src=opq)", rule);
-         d3dDevice->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
-     } else {
+    {
+        J2dTraceLn1(J2D_TRACE_VERBOSE,
+                    "  disabling alpha comp rule=%-1d ea=1.0 src=opq)", rule);
+        pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
+    } else {
         J2dTraceLn2(J2D_TRACE_VERBOSE,
                     "  enabling alpha comp (rule=%-1d ea=%f)", rule, ea);
-        d3dDevice->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, TRUE);
-
-        d3dDevice->SetRenderState(D3DRENDERSTATE_SRCBLEND,
-                                  StdBlendRules[rule].src);
-        d3dDevice->SetRenderState(D3DRENDERSTATE_DESTBLEND,
-                                  StdBlendRules[rule].dst);
-     }
-
-    // update state
-    compState = sun_java2d_SunGraphics2D_COMP_ALPHA;
-    extraAlpha = ea;
-
-    if (extraAlpha == 1.0f) {
-        blitPolygonPixel = 0xffffffff;
-    } else {
-        // the 0xffffffff pixel needs to be premultiplied by extraAlpha
-        jint ea = (jint)(extraAlpha * 255.0f + 0.5f) & 0xff;
-        blitPolygonPixel = (ea << 24) | (ea << 16) | (ea << 8) | (ea << 0);
-    }
-
-    ReleaseExclusiveAccess();
-}
-
-HRESULT D3DContext::CreateSurface(JNIEnv *env, jint width, jint height,
-                                  jint depth, jint transparency,
-                                  jint d3dSurfaceType,
-                                  DXSurface **dxSurface, jint* pType)
-{
-    DWORD dwFlags = 0, ddsCaps = 0, ddsCaps2 = 0;
-    D3DTextureTableCell *cell = NULL;
-    DXSurface *lpRetSurface = NULL;
-    HRESULT res;
-
-    GetExclusiveAccess();
+        pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
 
-    dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
-
-    if (d3dSurfaceType & D3D_TEXTURE_SURFACE) {
-        ddsCaps |= DDSCAPS_TEXTURE;
-        dwFlags |= DDSD_PIXELFORMAT | DDSD_TEXTURESTAGE;
-
-        jint trIdx = D3D_TR_IDX(transparency);
-        jint depthIdx = D3D_DEPTH_IDX(depth);
-        cell = &textureTable[trIdx][depthIdx];
-        if (cell->pfType == PF_INVALID) {
-            ReleaseExclusiveAccess();
-            J2dTraceLn2(J2D_TRACE_ERROR,
-                        "D3DContext::CreateSurface: no texture "\
-                        "pixel format for depth: %d transparency=%d",
-                        depth, transparency);
-            return DDERR_NOTFOUND;
-        }
-        if (pType != NULL) *pType = cell->pfType;
-        if (d3dSurfaceType & D3D_RENDER_TARGET) {
-            // RTT is requested => must be allocated non-managed and
-            // non-systemmemory pool.
-            // REMIND: must check if this is supported by
-            // the device, as it may not have a local video memory, only AGP
-            // may be we should just use VIDEOMEMORY
-            // NOTE: this will likely fail if the device is not accelerated
-            ddsCaps |= DDSCAPS_LOCALVIDMEM;
-        } else {
-            // This is a normal texture, allocate in managed pool if the device
-            // is accelerated, otherwise must use system memory.
-            if (bIsHWRasterizer) {
-                ddsCaps2 |= DDSCAPS2_TEXTUREMANAGE;
-            } else {
-                ddsCaps |= DDSCAPS_SYSTEMMEMORY;
-            }
-        }
-
-        if (IsPow2TexturesOnly()) {
-            jint w, h;
-            for (w = 1; width  > w; w <<= 1);
-            for (h = 1; height > h; h <<= 1);
-            width = w;
-            height = h;
-        }
-        if (IsSquareTexturesOnly()) {
-            if (width > height) {
-                height = width;
-            } else {
-                width = height;
-            }
-        }
-
-        DWORD dwRatio = GetMaxTextureAspectRatio();
-        // Note: Reference rasterizer returns ratio '0',
-        // which presumably means 'any'.
-        if ((DWORD)width  > GetMaxTextureWidth()    ||
-            (DWORD)height > GetMaxTextureHeight()   ||
-            (DWORD)width  < GetMinTextureWidth()    ||
-            (DWORD)height < GetMinTextureHeight()   ||
-            ((dwRatio > 0) && ((DWORD)(width/height) > dwRatio ||
-                               (DWORD)(height/width) > dwRatio)))
-        {
-            ReleaseExclusiveAccess();
-            J2dRlsTraceLn2(J2D_TRACE_ERROR,
-                           "D3DContext::CreateSurface: failed to create"\
-                           " texture: dimensions %dx%d not supported.",
-                           width, height);
-            J2dRlsTraceLn5(J2D_TRACE_ERROR,
-                           "  Supported texture dimensions: %dx%d-%dxd% "\
-                           " with max ratio %f.",
-                           GetMinTextureWidth(), GetMinTextureHeight(),
-                           GetMaxTextureWidth(), GetMaxTextureHeight(),
-                           GetMaxTextureAspectRatio());
-            return D3DERR_TEXTURE_BADSIZE;
-        }
-    } else if (d3dSurfaceType & D3D_PLAIN_SURFACE) {
-        ddsCaps |= DDSCAPS_OFFSCREENPLAIN |
-            (bIsHWRasterizer ? DDSCAPS_VIDEOMEMORY : DDSCAPS_SYSTEMMEMORY);
-    } else if (d3dSurfaceType & D3D_ATTACHED_SURFACE) {
-        // can't handle this for now
-        J2dRlsTraceLn(J2D_TRACE_ERROR,
-                      "D3DContext::CreateSurface: Can't create attached"\
-                      " surfaces using this code path yet");
-        ReleaseExclusiveAccess();
-        return DDERR_GENERIC;
-    }
-    if (d3dSurfaceType & D3D_RENDER_TARGET) {
-        ddsCaps |= DDSCAPS_3DDEVICE;
-    }
-
-    if (SUCCEEDED(res = dxObject->CreateSurface(dwFlags, ddsCaps, ddsCaps2,
-                                                (cell != NULL) ?
-                                                    &cell->pddpf : NULL,
-                                                width, height,
-                                                &lpRetSurface,
-                                                0/*backbuffers*/)))
-    {
-        if (d3dSurfaceType & D3D_RENDER_TARGET) {
-            if (FAILED(res = AttachDepthBuffer(lpRetSurface))) {
-                lpRetSurface->Release();
-                delete lpRetSurface;
-                ReleaseExclusiveAccess();
-                return res;
-            }
-            // Attempt to set the new surface as a temporary render target;
-            // in some cases this may fail. For example, if undocumented maximum
-            // Direct3D target surface dimensions were exceeded (2048 in some
-            // cases).
-            if (d3dDevice != NULL) {
-                FlushD3DQueueForTarget(NULL);
-
-                IDirectDrawSurface7 *lpDDSurface = NULL;
-                HRESULT res1 = d3dDevice->GetRenderTarget(&lpDDSurface);
-
-                // we are holding a lock for the context, so we can
-                // change/restore the current render target safely
-                res = d3dDevice->SetRenderTarget(lpRetSurface->GetDDSurface(), 0);
-                if (SUCCEEDED(res1) && lpDDSurface != NULL) {
-                    d3dDevice->SetRenderTarget(lpDDSurface, 0);
-                }
-                if (FAILED(res)) {
-                    DebugPrintDirectDrawError(res,
-                        "D3DContext::CreateSurface: cannot set new surface as "\
-                        "temp. render target");
-                    lpRetSurface->Release();
-                    delete lpRetSurface;
-                    ReleaseExclusiveAccess();
-                    return res;
-                }
-            }
-        }
-        *dxSurface = lpRetSurface;
-    } else {
-        DebugPrintDirectDrawError(res,
-                                  "D3DContext::CreateSurface: error"\
-                                  " creating surface");
+        pd3dDevice->SetRenderState(D3DRS_SRCBLEND,
+                                   StdBlendRules[rule].src);
+        pd3dDevice->SetRenderState(D3DRS_DESTBLEND,
+                                   StdBlendRules[rule].dst);
     }
 
-    ReleaseExclusiveAccess();
+    extraAlpha = ea;
     return res;
 }
 
+#ifdef UPDATE_TX
+
+// Note: this method of adjusting pixel to texel mapping proved to be
+// difficult to perfect. The current variation works great for id,
+// scale (including all kinds of flips) transforms, but not still not
+// for generic transforms.
+//
+// Since we currently only do DrawTexture with non-id transform we instead
+// adjust the geometry (see D3DVertexCacher::DrawTexture(), SetTransform())
+//
+// In order to enable this code path UpdateTextureTransforms needs to
+// be called in SetTexture(), SetTransform() and ResetTranform().
 HRESULT
-D3DContext::AttachDepthBuffer(DXSurface *dxSurface)
+D3DContext::UpdateTextureTransforms(DWORD dwSamplerToUpdate)
 {
-    HRESULT res;
+    HRESULT res = S_OK;
+    DWORD dwSampler, dwMaxSampler;
 
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::AttachDepthBuffer");
+    if (dwSamplerToUpdate == -1) {
+        // update all used samplers, dwMaxSampler will be set to max
+        dwSampler = 0;
+        dwSampler = MAX_USED_TEXTURE_SAMPLER;
+        J2dTraceLn(J2D_TRACE_INFO, "D3DContext::UpdateTextureTransforms: "\
+                                   "updating all samplers");
+    } else {
+        // update only given sampler, dwMaxSampler will be set to it as well
+        dwSampler = dwSamplerToUpdate;
+        dwMaxSampler = dwSamplerToUpdate;
+        J2dTraceLn1(J2D_TRACE_INFO, "D3DContext::UpdateTextureTransforms: "\
+                                    "updating sampler %d", dwSampler);
+    }
+
+    do {
+        D3DTRANSFORMSTATETYPE state =
+            (D3DTRANSFORMSTATETYPE)(D3DTS_TEXTURE0 + dwSampler);
+        IDirect3DTexture9 *pTexture = lastTexture[dwSampler];
+
+        if (pTexture != NULL) {
+            D3DMATRIX mt, tx;
+            D3DSURFACE_DESC texDesc;
+
+            pd3dDevice->GetTransform(D3DTS_WORLD, &tx);
+            J2dTraceLn4(10,
+                        "  %5f %5f %5f %5f", tx._11, tx._12, tx._13, tx._14);
+            J2dTraceLn4(10,
+                        "  %5f %5f %5f %5f", tx._21, tx._22, tx._23, tx._24);
+            J2dTraceLn4(10,
+                        "  %5f %5f %5f %5f", tx._31, tx._32, tx._33, tx._34);
+            J2dTraceLn4(10,
+                        "  %5f %5f %5f %5f", tx._41, tx._42, tx._43, tx._44);
+
+            // this formula works for scales and flips
+            if (tx._11 == 0.0f) {
+                tx._11 = tx._12;
+            }
+            if (tx._22 == 0.0f) {
+                tx._22 = tx._21;
+            }
 
-    if (dxSurface == NULL) {
-        return DDERR_GENERIC;
-    }
+            pTexture->GetLevelDesc(0, &texDesc);
 
-    GetExclusiveAccess();
+            // shift by .5 texel, but take into account
+            // the scale factor of the device transform
 
-    // initialize the depth buffer format it needed
-    if (depthBufferFormat.dwSize == 0) {
-        // Some hardware has a restriction that the target surface and the
-        // attached depth buffer must have the same bit depth, so we should
-        // attempt to find a depth pixel format with the same depth as
-        // the target.
-        DWORD prefDepth = dxSurface->ddsd.ddpfPixelFormat.dwRGBBitCount;
-        if (FAILED(res = D3DUtils_FindDepthBufferFormat(d3dObject,
-                                                        prefDepth,
-                                                        &depthBufferFormat,
-                                                        pDeviceGUID)))
-        {
-            DebugPrintDirectDrawError(res,
-                                      "D3DContext::AttachDepthBuffer: "\
-                                      "can't find depth buffer format");
-            ReleaseExclusiveAccess();
-            return res;
+            // REMIND: this approach is not entirely correct,
+            // as it only takes into account the scale of the device
+            // transform.
+            mt._31 = (1.0f / (2.0f * texDesc.Width  * tx._11));
+            mt._32 = (1.0f / (2.0f * texDesc.Height * tx._22));
+            J2dTraceLn2(J2D_TRACE_VERBOSE, "  offsets: tx=%f ty=%f",
+                        mt._31, mt._32);
+
+            pd3dDevice->SetTextureStageState(dwSampler,
+                                             D3DTSS_TEXTURETRANSFORMFLAGS,
+                                             D3DTTFF_COUNT2);
+            res = pd3dDevice->SetTransform(state, &mt);
+        } else {
+            res = pd3dDevice->SetTextureStageState(dwSampler,
+                                                   D3DTSS_TEXTURETRANSFORMFLAGS,
+                                                   D3DTTFF_DISABLE);
         }
-    }
-    if (FAILED(res = dxSurface->AttachDepthBuffer(dxObject,
-                                                  bIsHWRasterizer,
-                                                  &depthBufferFormat)))
-    {
-        DebugPrintDirectDrawError(res,
-                                  "D3DContext::AttachDepthBuffer: "\
-                                  "can't attach depth buffer or it is lost");
-    }
+        dwSampler++;
+    } while (dwSampler <= dwMaxSampler);
 
-    ReleaseExclusiveAccess();
     return res;
 }
+#endif // UPDATE_TX
 
 /**
  * We go into the pains of maintaining the list of set textures
@@ -1200,399 +1492,412 @@
  * GetTexture() (note that we'd have to then call Release() on the
  * texture since GetTexture() increases texture's ref. count).
  */
-HRESULT /*NOLOCK*/
-D3DContext::SetTexture(DXSurface *dxSurface, DWORD dwStage)
+HRESULT
+D3DContext::SetTexture(IDirect3DTexture9 *pTexture, DWORD dwSampler)
 {
-    HRESULT res = D3D_OK;
-    IDirectDrawSurface7 *newTexture =
-        dxSurface == NULL ? NULL : dxSurface->GetDDSurface();
+    HRESULT res = S_OK;
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::SetTexture");
 
-    if (dwStage < 0 || dwStage > MAX_USED_TEXTURE_STAGE) {
+    if (dwSampler < 0 || dwSampler > MAX_USED_TEXTURE_SAMPLER) {
         J2dTraceLn1(J2D_TRACE_ERROR,
-                    "D3DContext::SetTexture: incorrect stage: %d", dwStage);
-        return DDERR_GENERIC;
+                    "D3DContext::SetTexture: incorrect sampler: %d", dwSampler);
+        return E_FAIL;
     }
-    if (lastTexture[dwStage] != newTexture) {
-        J2dTraceLn1(J2D_TRACE_VERBOSE,
-                    "D3DContext::SetTexture: new texture=0x%x", newTexture);
-        res = d3dDevice->SetTexture(dwStage, newTexture);
-        lastTexture[dwStage] = SUCCEEDED(res) ? newTexture : NULL;
+    if (lastTexture[dwSampler] != pTexture) {
+        if (FAILED(res = FlushVertexQueue())) {
+            return res;
+        }
+        J2dTraceLn2(J2D_TRACE_VERBOSE,
+                    "  new texture=0x%x on sampler %d", pTexture, dwSampler);
+        res = pd3dDevice->SetTexture(dwSampler, pTexture);
+        if (SUCCEEDED(res)) {
+            lastTexture[dwSampler] = pTexture;
+            // REMIND: see comment at UpdateTextureTransforms
+#ifdef UPDATE_TX
+            res = UpdateTextureTransforms(dwSampler);
+#endif
+        }  else {
+            lastTexture[dwSampler] = NULL;
+        }
     }
     return res;
 }
 
-void
-D3DContext::FlushD3DQueueForTarget(DDrawSurface *ddSurface)
+HRESULT
+D3DContext::UpdateTextureColorState(DWORD dwState, DWORD dwSampler)
 {
-    GetExclusiveAccess();
-    J2dTraceLn2(J2D_TRACE_VERBOSE,
-                "D3DContext::FlushD3DQueueForTarget surface=0x%x target=0x%x",
-                ddSurface, ddTargetSurface);
+    HRESULT res = S_OK;
 
-    if ((ddSurface == ddTargetSurface || ddSurface == NULL) &&
-        d3dDevice != NULL)
-    {
-        ForceEndScene();
+    if (dwState != lastTextureColorState[dwSampler]) {
+        res = pd3dDevice->SetTextureStageState(dwSampler,
+                                               D3DTSS_ALPHAARG1, dwState);
+        res = pd3dDevice->SetTextureStageState(dwSampler,
+                                               D3DTSS_COLORARG1, dwState);
+        lastTextureColorState[dwSampler] = dwState;
     }
-    ReleaseExclusiveAccess();
+
+    return res;
 }
 
-void
-D3DContext::InvalidateIfTarget(JNIEnv *env, DDrawSurface *ddSurface)
+HRESULT /*NOLOCK*/
+D3DContext::UpdateState(jbyte newState)
 {
-    GetExclusiveAccess();
-    if ((ddSurface == ddTargetSurface) && d3dDevice != NULL &&
-        jD3DContext != NULL)
-    {
-        J2dTraceLn(J2D_TRACE_VERBOSE,
-                   "D3DContext:InvalidateIfTarget: invalidating java context");
+    HRESULT res = S_OK;
+
+    if (opState == newState) {
+        // The op is the same as last time, so we can return immediately.
+        return res;
+    } else if (opState != STATE_CHANGE) {
+        res = FlushVertexQueue();
+    }
 
-        jobject jD3DContext_tmp = env->NewLocalRef(jD3DContext);
-        if (jD3DContext_tmp != NULL) {
-            JNU_CallMethodByName(env, NULL, jD3DContext_tmp,
-                                 "invalidateContext", "()V");
-            env->DeleteLocalRef(jD3DContext_tmp);
+    switch (opState) {
+    case STATE_MASKOP:
+        pMaskCache->Disable();
+        break;
+    case STATE_GLYPHOP:
+        D3DTR_DisableGlyphVertexCache(this);
+        break;
+    case STATE_TEXTUREOP:
+        // optimization: certain state changes (those marked STATE_CHANGE)
+        // are allowed while texturing is enabled.
+        // In this case, we can allow previousOp to remain as it is and
+        // then return early.
+        if (newState == STATE_CHANGE) {
+            return res;
         }
+        // REMIND: not necessary if we are switching to MASKOP or GLYPHOP
+        // (or a complex paint, for that matter), but would that be a
+        // worthwhile optimization?
+        SetTexture(NULL);
+        break;
+    case STATE_AAPGRAMOP:
+        res = DisableAAParallelogramProgram();
+        break;
+    default:
+        break;
+    }
+
+    switch (newState) {
+    case STATE_MASKOP:
+        pMaskCache->Enable();
+        UpdateTextureColorState(D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE);
+        break;
+    case STATE_GLYPHOP:
+        D3DTR_EnableGlyphVertexCache(this);
+        UpdateTextureColorState(D3DTA_TEXTURE | D3DTA_ALPHAREPLICATE);
+        break;
+    case STATE_TEXTUREOP:
+        UpdateTextureColorState(D3DTA_TEXTURE);
+        break;
+    case STATE_AAPGRAMOP:
+        res = EnableAAParallelogramProgram();
+        break;
+    default:
+        break;
     }
-    ReleaseExclusiveAccess();
+
+    opState = newState;
+
+    return res;
 }
 
-void /*NOLOCK*/
-D3DContext::UpdateState(jbyte newState)
+HRESULT D3DContext::FlushVertexQueue()
 {
-    // Try to minimize context switching by only changing
-    // attributes when necessary.
-    if (newState != opState) {
-        // if the new context is texture rendering
-        if (newState & STATE_TEXTURE) {
-            // we can be here because of two reasons:
-            // old context wasn't STATE_TEXTURE or
-            // the new STATE_TEXTURE_STAGE is different
-
-            // do the appropriate texture stage setup if needed
-            DWORD dwAA1, dwCA1;
-            BOOL bUpdateStateNeeded = FALSE;
-            if ((newState & STATE_TEXTURE_STAGE_MASK) &&
-                !(opState & STATE_TEXTURE_STAGE_MASK))
-            {
-                // setup mask rendering
-                dwAA1 = (D3DTA_TEXTURE|D3DTA_ALPHAREPLICATE);
-                dwCA1 = (D3DTA_TEXTURE|D3DTA_ALPHAREPLICATE);
-                bUpdateStateNeeded = TRUE;
-                J2dTraceLn(J2D_TRACE_VERBOSE,
-                           "UpdateState: STATE_TEXTURE_STAGE_MASK");
-            } else if ((newState & STATE_TEXTURE_STAGE_BLIT) &&
-                       !(opState & STATE_TEXTURE_STAGE_BLIT))
-            {
-                // setup blit rendering
-                dwAA1 = D3DTA_TEXTURE;
-                dwCA1 = D3DTA_TEXTURE;
-                bUpdateStateNeeded = TRUE;
-                J2dTraceLn(J2D_TRACE_VERBOSE,
-                           "UpdateState: STATE_TEXTURE_STAGE_BLIT");
-            }
-
-            // this optimization makes sense because if the state
-            // is changing from non-texture to texture, we don't necessarily
-            // need to update the texture stage state
-            if (bUpdateStateNeeded) {
-                d3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAA1);
-                d3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, dwCA1);
-            } else {
-                J2dTraceLn2(J2D_TRACE_WARNING,
-                            "UpdateState: no context changes were made! "\
-                            "current=0x%x new=0x%x", opState, newState);
-            }
-        } else {
-            J2dTraceLn(J2D_TRACE_VERBOSE,
-                       "UpdateState: STATE_RENDEROP");
-            // if switching from a texture rendering state
-            if (opState & STATE_TEXTURE) {
-                // disable texture rendering
-                // we don't need to change texture stage states
-                // because they're irrelevant if the texture
-                // is not set
-                // REMIND: another possible optimiziation: instead of
-                // setting texture to NULL, change the texture stage state
-                SetTexture(NULL);
-            }
-        }
-        opState = newState;
+    if (pVCacher != NULL) {
+        return pVCacher->Render();
     }
+    return E_FAIL;
 }
 
 HRESULT D3DContext::BeginScene(jbyte newState)
 {
-    if (!d3dDevice) {
-        return DDERR_GENERIC;
+    if (!pd3dDevice) {
+        return E_FAIL;
     } else {
         UpdateState(newState);
         if (!bBeginScenePending) {
             bBeginScenePending = TRUE;
-#ifdef DEBUG
-            endSceneQueueDepth = 0;
-#endif /* DEBUG */
-            HRESULT res = d3dDevice->BeginScene();
+            HRESULT res = pd3dDevice->BeginScene();
             J2dTraceLn(J2D_TRACE_INFO, "D3DContext::BeginScene");
             if (FAILED(res)) {
                 // this will cause context reinitialization
-                opState = STATE_UNDEFINED;
+                opState = STATE_CHANGE;
             }
             return res;
         }
-        return D3D_OK;
-    }
-}
-
-HRESULT D3DContext::EndScene(HRESULT ddResult) {
-    if (FAILED(ddResult)) {
-        return ForceEndScene();
+        return S_OK;
     }
-#ifdef DEBUG
-    endSceneQueueDepth++;
-#endif /* DEBUG */
-    return D3D_OK;
 }
 
-HRESULT D3DContext::ForceEndScene() {
+HRESULT D3DContext::EndScene() {
     if (bBeginScenePending) {
+        FlushVertexQueue();
         bBeginScenePending = FALSE;
-        J2dTraceLn(J2D_TRACE_INFO, "D3DContext::ForceEndScene");
-#ifdef DEBUG
-        J2dTraceLn1(J2D_TRACE_VERBOSE, "  queue depth=%d",
-                    endSceneQueueDepth);
-        endSceneQueueDepth = 0;
-#endif /* DEBUG */
-        return d3dDevice->EndScene();
+        J2dTraceLn(J2D_TRACE_INFO, "D3DContext::EndScene");
+        return pd3dDevice->EndScene();
     }
-    return D3D_OK;
+    return S_OK;
 }
 
 /**
- * Utility function: checks the result, calls RestoreSurface
- * on the destination surface, and throws InvalidPipeException.
+ * Compiles and links the given fragment shader program.  If
+ * successful, this function returns a handle to the newly created shader
+ * program; otherwise returns 0.
  */
-static void
-D3DContext_CheckResult(JNIEnv *env, HRESULT res, jlong pDest) {
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_CheckResult");
-    if (FAILED(res)) {
-        J2dTraceLn(J2D_TRACE_ERROR,
-                   "D3DContext_CheckResult: failed, restoring dest surface");
-        Win32SDOps *dstOps = (Win32SDOps *)jlong_to_ptr(pDest);
-        if (dstOps != NULL) {
-            // RestoreSurface for surfaces associated
-            // with VolatileImages only marks them lost, not
-            // attempting to restore. This is done later
-            // when VolatileImage.validate() is called.
-            dstOps->RestoreSurface(env, dstOps);
-
-            // if this is an "unexpected" error, disable acceleration
-            // of this image to avoid an infinite recreate/render/error loop
-            if (res != DDERR_SURFACELOST && res != DDERR_INVALIDMODE &&
-                res != DDERR_GENERIC && res != DDERR_WASSTILLDRAWING &&
-                res != DDERR_SURFACEBUSY)
-            {
-                jobject sdObject = env->NewLocalRef(dstOps->sdOps.sdObject);
-                if (sdObject != NULL) {
-                    JNU_CallMethodByName(env, NULL, sdObject,
-                                         "disableD3D", "()V");
-                    env->DeleteLocalRef(sdObject);
-                }
-            }
+IDirect3DPixelShader9 *D3DContext::CreateFragmentProgram(DWORD **shaders,
+                                                       ShaderList *programs,
+                                                       jint flags)
+{
+    DWORD *sourceCode;
+    IDirect3DPixelShader9 *pProgram;
 
-        }
-        SurfaceData_ThrowInvalidPipeException(env, "Surface Lost");
+    J2dTraceLn1(J2D_TRACE_INFO,
+                "D3DContext::CreateFragmentProgram: flags=%d",
+                flags);
+
+    sourceCode = shaders[flags];
+    if (FAILED(pd3dDevice->CreatePixelShader(sourceCode, &pProgram))) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+            "D3DContext::CreateFragmentProgram: error creating program");
+        return NULL;
     }
+
+    // add it to the cache
+    ShaderList_AddProgram(programs, ptr_to_jlong(pProgram),
+                          0 /*unused*/, 0 /*unused*/, flags);
+
+    return pProgram;
 }
 
-/*
- * Class:     sun_java2d_d3d_D3DContext
- * Method:    setTransform
- * Signature: (JLLjava/awt/geom/AffineTransform;DDDDDD)V
+/**
+ * Locates and enables a fragment program given a list of shader programs
+ * (ShaderInfos), using this context's state and flags as search
+ * parameters.  The "flags" parameter is a bitwise-or'd value that helps
+ * differentiate one program for another; the interpretation of this value
+ * varies depending on the type of shader (BufImgOp, Paint, etc) but here
+ * it is only used to find another ShaderInfo with that same "flags" value.
  */
-JNIEXPORT void JNICALL Java_sun_java2d_d3d_D3DContext_setTransform
-    (JNIEnv *env, jobject d3dc, jlong pCtx, jlong pDest, jobject xform,
-     jdouble m00, jdouble m10,
-     jdouble m01, jdouble m11,
-     jdouble m02, jdouble m12)
-{
-    D3DContext *pd3dc = (D3DContext *)jlong_to_ptr(pCtx);
-
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_setTransform");
-    if (pd3dc != NULL) {
-        HRESULT res = pd3dc->SetTransform(xform,
-                                          m00,  m10,
-                                          m01,  m11,
-                                          m02,  m12);
-        D3DContext_CheckResult(env, res, pDest);
+HRESULT D3DContext::EnableFragmentProgram(DWORD **shaders,
+                                          ShaderList *programList,
+                                          jint flags)
+{
+    HRESULT res;
+    jlong programID;
+    IDirect3DPixelShader9 *pProgram;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::EnableFragmentProgram");
+
+    programID =
+        ShaderList_FindProgram(programList,
+                               0 /*unused*/, 0 /*unused*/, flags);
+
+    pProgram = (IDirect3DPixelShader9 *)jlong_to_ptr(programID);
+    if (pProgram == NULL) {
+        pProgram = CreateFragmentProgram(shaders, programList, flags);
+        if (pProgram == NULL) {
+            return E_FAIL;
+        }
+    }
+
+    if (FAILED(res = pd3dDevice->SetPixelShader(pProgram))) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+            "D3DContext::EnableFragmentProgram: error setting pixel shader");
+        return res;
     }
+
+    return S_OK;
 }
 
-/*
- * Class:     sun_java2d_d3d_D3DContext
- * Method:    resetTransform
- * Signature: (JLL)V
- */
-JNIEXPORT void JNICALL Java_sun_java2d_d3d_D3DContext_resetTransform
-    (JNIEnv *env, jobject d3dc, jlong pCtx, jlong pDest)
+HRESULT D3DContext::EnableBasicGradientProgram(jint flags)
 {
-    D3DContext *pd3dc = (D3DContext *)jlong_to_ptr(pCtx);
+    return EnableFragmentProgram((DWORD **)gradShaders,
+                                 &basicGradPrograms, flags);
+}
 
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_resetTransform");
-    if (pd3dc != NULL) {
-        HRESULT res = pd3dc->SetTransform(NULL, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-        D3DContext_CheckResult(env, res, pDest);
-    }
+HRESULT D3DContext::EnableLinearGradientProgram(jint flags)
+{
+    return EnableFragmentProgram((DWORD **)linearShaders,
+                                 &linearGradPrograms, flags);
 }
 
-/*
- * Class:     sun_java2d_d3d_D3DContext
- * Method:    setClip
- * Signature: (JLLsun/java2d/pipe/Region;ZIIII)V
- */
-JNIEXPORT void JNICALL Java_sun_java2d_d3d_D3DContext_setClip
-    (JNIEnv *env, jobject d3dc, jlong pCtx, jlong pDest,
-     jobject clip, jboolean isRect,
-     jint x1, jint y1, jint x2, jint y2)
-{
-    D3DContext *pd3dc = (D3DContext *)jlong_to_ptr(pCtx);
-
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_setClip");
-    if (pd3dc != NULL) {
-        HRESULT res = pd3dc->SetClip(env, clip, isRect, x1, y1, x2, y2);
-        D3DContext_CheckResult(env, res, pDest);
-    }
+HRESULT D3DContext::EnableRadialGradientProgram(jint flags)
+{
+    return EnableFragmentProgram((DWORD **)radialShaders,
+                                 &radialGradPrograms, flags);
 }
 
-/*
- * Class:     sun_java2d_d3d_D3DContext
- * Method:    resetClip
- * Signature: (JLLsun/java2d/pipe/Region;Z)V
- */
-JNIEXPORT void JNICALL Java_sun_java2d_d3d_D3DContext_resetClip
-    (JNIEnv *env, jobject d3dc, jlong pCtx, jlong pDest)
+HRESULT D3DContext::EnableConvolveProgram(jint flags)
 {
-    D3DContext *pd3dc = (D3DContext *)jlong_to_ptr(pCtx);
+    return EnableFragmentProgram((DWORD **)convolveShaders,
+                                 &convolvePrograms, flags);
+}
 
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_resetClip");
-    if (pd3dc != NULL) {
-        HRESULT res = pd3dc->SetClip(env, NULL, JNI_FALSE, 0, 0, 0, 0);
-        D3DContext_CheckResult(env, res, pDest);
-    }
+HRESULT D3DContext::EnableRescaleProgram(jint flags)
+{
+    return EnableFragmentProgram((DWORD **)rescaleShaders,
+                                 &rescalePrograms, flags);
 }
 
-/*
- * Class:     sun_java2d_d3d_D3DContext
- * Method:    setRenderTarget
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_sun_java2d_d3d_D3DContext_setRenderTarget
-    (JNIEnv *env, jobject d3dc, jlong pCtx, jlong pDest)
+HRESULT D3DContext::EnableLookupProgram(jint flags)
+{
+    return EnableFragmentProgram((DWORD **)lookupShaders,
+                                 &lookupPrograms, flags);
+}
+
+HRESULT D3DContext::EnableLCDTextProgram()
 {
-    D3DContext *pd3dc = (D3DContext *)jlong_to_ptr(pCtx);
-    Win32SDOps *dstOps = (Win32SDOps *)jlong_to_ptr(pDest);
+    HRESULT res;
 
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_setRenderTarget");
-    if (pd3dc != NULL && dstOps != NULL) {
-        HRESULT res = pd3dc->SetRenderTarget(dstOps->lpSurface);
-        D3DContext_CheckResult(env, res, pDest);
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::EnableLCDTextProgram");
+
+    if (lcdTextProgram == NULL) {
+        if (FAILED(res = pd3dDevice->CreatePixelShader(lcdtext0,
+                                                       &lcdTextProgram)))
+        {
+            return res;
+        }
     }
-}
 
-/*
- * Class:     sun_java2d_d3d_D3DContext
- * Method:    setColor
- * Signature: (JII)V
- */
-JNIEXPORT void JNICALL
-Java_sun_java2d_d3d_D3DContext_setColor(JNIEnv *env, jobject oc,
-                                        jlong pCtx,
-                                        jint pixel, jint flags)
-{
-    D3DContext *d3dc = (D3DContext *)jlong_to_ptr(pCtx);
-
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_setColor");
-    if (d3dc != NULL) {
-        d3dc->SetColor(pixel, flags);
+    if (FAILED(res = pd3dDevice->SetPixelShader(lcdTextProgram))) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+            "D3DContext::EnableLCDTextProgram: error setting pixel shader");
+        return res;
     }
+
+    return S_OK;
 }
 
-/*
- * Class:     sun_java2d_d3d_D3DContext
- * Method:    setAlphaComposite
- * Signature: (JIFI)V
- */
-JNIEXPORT void JNICALL
-Java_sun_java2d_d3d_D3DContext_setAlphaComposite(JNIEnv *env, jobject oc,
-                                                 jlong pCtx,
-                                                 jint rule,
-                                                 jfloat extraAlpha,
-                                                 jint flags)
+HRESULT D3DContext::EnableAAParallelogramProgram()
 {
-    D3DContext *d3dc = (D3DContext *)jlong_to_ptr(pCtx);
+    HRESULT res;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::EnableAAParallelogramProgram");
+
+    if (aaPgramProgram == NULL) {
+        if (FAILED(res = pd3dDevice->CreatePixelShader(aapgram0,
+                                                       &aaPgramProgram))) {
+            DebugPrintD3DError(res, "D3DContext::EnableAAParallelogramProgram: "
+                               "error creating pixel shader");
+            return res;
+        }
+    }
 
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_setAlphaComposite");
-    if (d3dc != NULL) {
-        d3dc->SetAlphaComposite(rule, extraAlpha, flags);
+    if (FAILED(res = pd3dDevice->SetPixelShader(aaPgramProgram))) {
+        DebugPrintD3DError(res, "D3DContext::EnableAAParallelogramProgram: "
+                           "error setting pixel shader");
+        return res;
     }
 
+    return S_OK;
 }
 
-JNIEXPORT void JNICALL
-Java_sun_java2d_d3d_D3DContext_resetComposite(JNIEnv *env, jobject oc,
-                                              jlong pCtx)
+HRESULT D3DContext::DisableAAParallelogramProgram()
 {
-    D3DContext *d3dc = (D3DContext *)jlong_to_ptr(pCtx);
+    HRESULT res;
 
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_resetComposite");
-    if (d3dc != NULL) {
-        d3dc->ResetComposite();
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::DisableAAParallelogramProgram");
+
+    if (aaPgramProgram != NULL) {
+        if (FAILED(res = pd3dDevice->SetPixelShader(NULL))) {
+            DebugPrintD3DError(res,
+                               "D3DContext::DisableAAParallelogramProgram: "
+                               "error clearing pixel shader");
+            return res;
+        }
     }
+
+    return S_OK;
 }
 
-/*
- * Class:     sun_java2d_d3d_D3DContext
- * Method:    initNativeContext
- * Signature: (I)J
- */
-JNIEXPORT jlong JNICALL
-Java_sun_java2d_d3d_D3DContext_initNativeContext
-  (JNIEnv *env, jobject d3dc, jint screen)
-{
-    J2dTraceLn1(J2D_TRACE_INFO, "D3DContext_initNativeContext screen=%d",
-                screen);
-
-    HMONITOR hMon = (HMONITOR)AwtWin32GraphicsDevice::GetMonitor(screen);
-    DDrawObjectStruct *tmpDdInstance = GetDDInstanceForDevice(hMon);
-    D3DContext *d3dContext = NULL;
-
-    if (tmpDdInstance != NULL && tmpDdInstance->ddObject != NULL) {
-        AwtToolkit::GetInstance().SendMessage(WM_AWT_D3D_CREATE_DEVICE,
-                                              (WPARAM)tmpDdInstance->ddObject,
-                                              NULL);
-        d3dContext = tmpDdInstance->ddObject->GetD3dContext();
-    }
-    J2dTraceLn1(J2D_TRACE_VERBOSE,
-                "D3DContext_initNativeContext created d3dContext=0x%x",
-                d3dContext);
+BOOL D3DContext::IsAlphaRTSurfaceSupported()
+{
+    HRESULT res = pd3dObject->CheckDeviceFormat(adapterOrdinal,
+            devCaps.DeviceType,
+            curParams.BackBufferFormat,
+            D3DUSAGE_RENDERTARGET,
+            D3DRTYPE_SURFACE,
+            D3DFMT_A8R8G8B8);
+    return SUCCEEDED(res);
+}
 
-    return ptr_to_jlong(d3dContext);
+BOOL D3DContext::IsAlphaRTTSupported()
+{
+    HRESULT res = pd3dObject->CheckDeviceFormat(adapterOrdinal,
+            devCaps.DeviceType,
+            curParams.BackBufferFormat,
+            D3DUSAGE_RENDERTARGET,
+            D3DRTYPE_TEXTURE,
+            D3DFMT_A8R8G8B8);
+    return SUCCEEDED(res);
 }
 
-/*
- * Class:     sun_java2d_d3d_D3DContext
- * Method:    getNativeDeviceCaps
- * Signature: (J)I
- */
-JNIEXPORT jint JNICALL Java_sun_java2d_d3d_D3DContext_getNativeDeviceCaps
-  (JNIEnv *env, jobject d3dc, jlong pCtx)
+BOOL D3DContext::IsOpaqueRTTSupported()
 {
-    D3DContext *d3dContext = (D3DContext *)jlong_to_ptr(pCtx);
+    HRESULT res = pd3dObject->CheckDeviceFormat(adapterOrdinal,
+            devCaps.DeviceType,
+            curParams.BackBufferFormat,
+            D3DUSAGE_RENDERTARGET,
+            D3DRTYPE_TEXTURE,
+            curParams.BackBufferFormat);
+    return SUCCEEDED(res);
+}
+
+HRESULT D3DContext::InitContextCaps() {
+    J2dTraceLn(J2D_TRACE_INFO, "D3DContext::InitContextCaps");
+    J2dTraceLn1(J2D_TRACE_VERBOSE, "  caps for adapter %d :", adapterOrdinal);
+
+    if (pd3dDevice == NULL || pd3dObject == NULL) {
+        contextCaps = CAPS_EMPTY;
+        J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_EMPTY");
+        return E_FAIL;
+    }
+
+    contextCaps = CAPS_DEVICE_OK;
+    J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_DEVICE_OK");
 
-    J2dTraceLn(J2D_TRACE_INFO, "D3DContext_getNativeDeviceCaps");
-    if (d3dContext != NULL) {
-        d3dContext->SetJavaContext(env, d3dc);
-        return (jint)d3dContext->GetDeviceCaps();
+    if (IsAlphaRTSurfaceSupported()) {
+        contextCaps |= CAPS_RT_PLAIN_ALPHA;
+        J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_RT_PLAIN_ALPHA");
+    }
+    if (IsAlphaRTTSupported()) {
+        contextCaps |= CAPS_RT_TEXTURE_ALPHA;
+        J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_RT_TEXTURE_ALPHA");
+    }
+    if (IsOpaqueRTTSupported()) {
+        contextCaps |= CAPS_RT_TEXTURE_OPAQUE;
+        J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_RT_TEXTURE_OPAQUE");
+    }
+    if (IsPixelShader20Supported()) {
+        contextCaps |= CAPS_LCD_SHADER | CAPS_BIOP_SHADER | CAPS_PS20;
+        J2dRlsTraceLn(J2D_TRACE_VERBOSE,
+                      "  | CAPS_LCD_SHADER | CAPS_BIOP_SHADER | CAPS_PS20");
+        // Pre-PS3.0 video boards are very slow with the AA shader, so
+        // we will require PS30 hw even though the shader is compiled for 2.0a
+//        if (IsGradientInstructionExtensionSupported()) {
+//            contextCaps |= CAPS_AA_SHADER;
+//            J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_AA_SHADER");
+//        }
+    }
+    if (IsPixelShader30Supported()) {
+        if ((contextCaps & CAPS_AA_SHADER) == 0) {
+            // This flag was not already mentioned above...
+            J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_AA_SHADER");
+        }
+        contextCaps |= CAPS_PS30 | CAPS_AA_SHADER;
+        J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_PS30");
+    }
+    if (IsMultiTexturingSupported()) {
+        contextCaps |= CAPS_MULTITEXTURE;
+        J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_MULTITEXTURE");
+    }
+    if (!IsPow2TexturesOnly()) {
+        contextCaps |= CAPS_TEXNONPOW2;
+        J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_TEXNONPOW2");
+    }
+    if (!IsSquareTexturesOnly()) {
+        contextCaps |= CAPS_TEXNONSQUARE;
+        J2dRlsTraceLn(J2D_TRACE_VERBOSE, "  | CAPS_TEXNONSQUARE");
     }
-    return J2D_D3D_FAILURE;
+    return S_OK;
 }
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DContext.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DContext.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DContext.h	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DContext.h	2011-01-08 01:26:50.475202254 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,14 +27,33 @@
 #define D3DCONTEXT_H
 
 #include "java_awt_Transparency.h"
+#include "sun_java2d_pipe_BufferedContext.h"
 #include "sun_java2d_d3d_D3DContext.h"
-#include "ddrawObject.h"
-extern "C" {
-#include "glyphblitting.h"
-#include "AccelGlyphCache.h"
-}
+#include "sun_java2d_d3d_D3DContext_D3DContextCaps.h"
+#include "sun_java2d_d3d_D3DSurfaceData.h"
+#include "sun_java2d_pipe_hw_AccelDeviceEventNotifier.h"
+
+#include "ShaderList.h"
+#include "D3DPipeline.h"
+#include "D3DMaskCache.h"
+#include "D3DVertexCacher.h"
+#include "D3DResourceManager.h"
+
 #include "j2d_md.h"
 
+typedef enum {
+    TILEFMT_UNKNOWN,
+    TILEFMT_1BYTE_ALPHA,
+    TILEFMT_3BYTE_RGB,
+    TILEFMT_3BYTE_BGR,
+    TILEFMT_4BYTE_ARGB_PRE,
+} TileFormat;
+
+typedef enum {
+    CLIP_NONE,
+    CLIP_RECT,
+    CLIP_SHAPE,
+} ClipType;
 
 // - State switching optimizations -----------------------------------
 
@@ -52,58 +71,28 @@
  * See D3DContext::UpdateState() and D3DContext::BeginScene() for
  * more information.
  */
-
-// The state is undefined, assume that complete initialization is
-// needed.
-#define STATE_UNDEFINED          (0 << 0)
-// Current state uses texture mapping
-#define STATE_TEXTURE            (1 << 0)
-// Texture stage state which is used when mask is involved
-// (text rendering, maskfill)
-#define STATE_TEXTURE_STAGE_MASK (1 << 1)
-// Texture stage state which is used when doing texture
-// mapping in blits
-#define STATE_TEXTURE_STAGE_BLIT (1 << 2)
-// Texture stage state which is used when not doing
-// texture mapping, only use diffuse color
-#define STATE_TEXTURE_STAGE_POLY (1 << 3)
-// Texture mapping operation which involves mask texture
-#define STATE_MASKOP             (STATE_TEXTURE|STATE_TEXTURE_STAGE_MASK)
-// Texture mapping operation which involves image texture
-#define STATE_BLITOP             (STATE_TEXTURE|STATE_TEXTURE_STAGE_BLIT)
-// Rendering operation which doesn't use texture mapping
-#define STATE_RENDEROP           (STATE_TEXTURE_STAGE_POLY)
+#define STATE_CHANGE    (0 << 0)
+#define STATE_RENDEROP  (1 << 0)
+#define STATE_MASKOP    (1 << 1)
+#define STATE_GLYPHOP   (1 << 2)
+#define STATE_TEXTUREOP (1 << 3)
+#define STATE_AAPGRAMOP (1 << 4)
+#define STATE_OTHEROP   (1 << 5)
 
 // The max. stage number we currently use (could not be
 // larger than 7)
-#define MAX_USED_TEXTURE_STAGE 0
+#define MAX_USED_TEXTURE_SAMPLER 1
 
 // - Texture pixel format table  -------------------------------------
 #define TR_OPAQUE      java_awt_Transparency_OPAQUE
 #define TR_BITMASK     java_awt_Transparency_BITMASK
 #define TR_TRANSLUCENT java_awt_Transparency_TRANSLUCENT
 
-// depth indices for the D3DTextureTable type
-#define DEPTH16_IDX 0
-#define DEPTH24_IDX 1
-#define DEPTH32_IDX 2
-#define DEPTH_MAX_IDX 3
-
-// corresponding transparency indices for the D3DTextureTable type
-#define TR_OPAQUE_IDX 0
-#define TR_BITMASK_IDX 1
-#define TR_TRANSLUCENT_IDX 2
-#define TR_MAX_IDX 3
-
-typedef struct
-{
-    DDPIXELFORMAT pddpf;
-    jint  pfType;
-} D3DTextureTableCell;
-
-// texture table:
-// [transparency={OPAQUE,BITMASK,TRANCLUCENT},depth={16,24,32}]
-typedef D3DTextureTableCell D3DTextureTable[TR_MAX_IDX][DEPTH_MAX_IDX];
+class D3DResource;
+class D3DResourceManager;
+class D3DMaskCache;
+class D3DVertexCacher;
+class D3DGlyphCache;
 
 // - D3DContext class  -----------------------------------------------
 
@@ -111,7 +100,7 @@
  * This class provides the following functionality:
  *  - holds the state of D3DContext java class (current pixel color,
  *    alpha compositing mode, extra alpha)
- *  - provides access to IDirect3DDevice7 interface (creation,
+ *  - provides access to IDirect3DDevice9 interface (creation,
  *    disposal, exclusive access)
  *  - handles state changes of the direct3d device (transform,
  *    compositing mode, current texture)
@@ -119,15 +108,9 @@
  *  - holds a glyph cache texture for the associated device
  *  - implements primitives batching mechanism
  */
-class D3DContext {
+class D3DPIPELINE_API D3DContext {
 public:
     /**
-     * Creates and returns D3DContext instance. If created context was
-     * unable to initialize d3d device or if the device tests failed,
-     * returns NULL.
-     */
-    static D3DContext* CreateD3DContext(DDraw *ddObject, DXObject* dxObject);
-    /**
      * Releases the old device (if there was one) and all associated
      * resources, re-creates, initializes and tests the new device.
      *
@@ -141,140 +124,153 @@
      * to initialize and test the device last time, it doesn't attempt
      * to create/init/test the device.
      */
-    void    CreateD3DDevice();
-    void    Release3DDevice();
+    static
+    HRESULT CreateInstance(IDirect3D9 *pd3d9, UINT adapter, D3DContext **ppCtx);
+    // creates a new D3D windowed device with swap copy effect and default
+    // present interval
+    HRESULT InitContext();
+    // creates or resets a D3D device given the parameters
+    HRESULT ConfigureContext(D3DPRESENT_PARAMETERS *pNewParams);
+    // resets existing D3D device with the current presentation parameters
+    HRESULT ResetContext();
+    HRESULT CheckAndResetDevice();
+
+    // saves the state of the D3D device in a state block, resets
+    // context's state to STATE_CHANGE
+    HRESULT SaveState();
+    // restores the state of the D3D device from existing state block,
+    // resets context's state to STATE_CHANGE
+    HRESULT RestoreState();
+
+    void    ReleaseContextResources();
+    void    ReleaseDefPoolResources();
     virtual ~D3DContext();
 
-    /**
-     * Stores a weak reference of passed D3DContext object.
-     * This method is called from _getNativeDeviceCaps method, and does the
-     * association of the native D3DContext with the corresponding java object.
-     * We need a reference to the java object so it can be notified when
-     * the native context is released or recreated.
-     *
-     * See jobject jD3DContext field
-     */
-    void SetJavaContext(JNIEnv *env, jobject jd3dc);
+    // methods replicating java-level D3DContext objext
+    HRESULT SetAlphaComposite(jint rule, jfloat extraAlpha, jint flags);
+    HRESULT ResetComposite();
 
     /**
-     * Methods to get/release exclusive access to the direct3d device
-     * interface. Note that some methods of this class assume that the
-     * lock is already taken. They're marked with 'NOLOCK' comment.
-     * Those methods not dealing with the d3d device interface are not
-     * required to obtain the lock (and not marked with NOLOCK)
-     */
-    void GetExclusiveAccess() { CRITICAL_SECTION_ENTER(deviceLock);}
-    void ReleaseExclusiveAccess() { CRITICAL_SECTION_LEAVE(deviceLock);}
-
-    // methods replicating java-level D3DContext objext
-    void SetColor(jint eargb, jint flags);
-    void SetAlphaComposite(jint rule, jfloat extraAlpha, jint flags);
-    void ResetComposite();
-
-    // Glyph cache-related methods
-    HRESULT /*NOLOCK*/ InitGlyphCache();
-    HRESULT /*NOLOCK*/ GlyphCacheAdd(JNIEnv *env, GlyphInfo *glyph);
-    HRESULT /*NOLOCK*/ UploadImageToTexture(DXSurface *texture, jubyte *pixels,
-                                            jint dstx, jint dsty,
-                                            jint srcx, jint srcy,
-                                            jint srcWidth, jint srcHeight,
-                                            jint srcStride);
-    DXSurface /*NOLOCK*/ *GetGlyphCacheTexture() { return lpGlyphCacheTexture; }
-    DXSurface /*NOLOCK*/ *GetMaskTexture();
-    GlyphCacheInfo *GetGlyphCache() { return glyphCache; }
-
-    HRESULT CreateSurface(JNIEnv *env,
-                          jint width, jint height, jint depth,
-                          jint transparency, jint d3dSurfaceType,
-                          DXSurface** dxSurface, jint* pType);
-
-    /**
-     * Attaches a depth buffer to the specified dxSurface.
-     * If depthBufferFormat is not initialized (depthBufferFormat.dwSize == 0),
-     * it will be initialized at the time of the call.
-     *
-     * If the buffer for this surface already exists, a "lost" status of the
-     * depth buffer is returned.
+     * Glyph cache-related methods
      */
-    HRESULT AttachDepthBuffer(DXSurface *dxSurface);
+    HRESULT InitGrayscaleGlyphCache();
+    HRESULT InitLCDGlyphCache();
+    D3DGlyphCache* GetGrayscaleGlyphCache() { return pGrayscaleGlyphCache; }
+    D3DGlyphCache* GetLCDGlyphCache() { return pLCDGlyphCache; }
+
+    D3DResourceManager *GetResourceManager() { return pResourceMgr; }
+    D3DMaskCache       *GetMaskCache() { return pMaskCache; }
+
+    HRESULT UploadTileToTexture(D3DResource *pTextureRes, void *pixels,
+                                jint dstx, jint dsty,
+                                jint srcx, jint srcy,
+                                jint srcWidth, jint srcHeight,
+                                jint srcStride,
+                                TileFormat srcFormat,
+                                // out: num of pixels in first and last
+                                // columns, only counted for LCD glyph uploads
+                                jint *pPixelsTouchedL = NULL,
+                                jint *pPixelsTouchedR = NULL);
+
+    // returns capabilities of the Direct3D device
+    D3DCAPS9 *GetDeviceCaps() { return &devCaps; }
+    // returns caps in terms of the D3DContext
+    int GetContextCaps() { return contextCaps; }
+    D3DPRESENT_PARAMETERS *GetPresentationParams() { return &curParams; }
 
-    // methods for dealing with device capabilities as determined by
-    // methods in D3DRuntimeTest
-    int GetDeviceCaps() { return deviceCaps; }
-    void SetDeviceCaps(int caps) { deviceCaps = caps; }
-
-    // Returns the texture pixel format table
-    D3DTextureTable &GetTextureTable() { return textureTable; }
-
-    DDrawSurface *GetTargetSurface() { return ddTargetSurface; }
-    IDirect3DDevice7 *Get3DDevice() { return d3dDevice; }
-
-    // IDirect3DDevice7-delegation methods
+    IDirect3DDevice9 *Get3DDevice() { return pd3dDevice; }
+    IDirect3D9 *Get3DObject() { return pd3dObject; }
 
     /**
      * This method only sets the texture if it's not already set.
      */
-    HRESULT /*NOLOCK*/ SetTexture(DXSurface *dxSurface, DWORD dwStage = 0);
-    HRESULT SetRenderTarget(DDrawSurface *lpSurface);
-    HRESULT SetTransform(jobject xform,
-                         jdouble m00, jdouble m10,
+    HRESULT SetTexture(IDirect3DTexture9 *pTexture, DWORD dwSampler = 0);
+
+    /**
+     * This method only updates the texture color state if it hasn't changed.
+     */
+    HRESULT UpdateTextureColorState(DWORD dwState, DWORD dwSampler = 0);
+
+    HRESULT SetRenderTarget(IDirect3DSurface9 *pSurface);
+    HRESULT SetTransform(jdouble m00, jdouble m10,
                          jdouble m01, jdouble m11,
                          jdouble m02, jdouble m12);
-    HRESULT SetClip(JNIEnv *env, jobject clip,
-                    jboolean isRect,
-                    int x1, int y1, int x2, int y2);
-
-    DWORD GetMinTextureWidth() { return d3dDevDesc.dwMinTextureWidth; }
-    DWORD GetMinTextureHeight() { return d3dDevDesc.dwMinTextureHeight; }
-    DWORD GetMaxTextureWidth() { return d3dDevDesc.dwMaxTextureWidth; }
-    DWORD GetMaxTextureHeight() { return d3dDevDesc.dwMaxTextureHeight; }
-    DWORD GetMaxTextureAspectRatio()
-        { return d3dDevDesc.dwMaxTextureAspectRatio; };
+    HRESULT ResetTransform();
+
+    // clipping-related methods
+    HRESULT SetRectClip(int x1, int y1, int x2, int y2);
+    HRESULT BeginShapeClip();
+    HRESULT EndShapeClip();
+    HRESULT ResetClip();
+    ClipType GetClipType();
+
+    /**
+     * Shader-related methods
+     */
+    HRESULT EnableBasicGradientProgram(jint flags);
+    HRESULT EnableLinearGradientProgram(jint flags);
+    HRESULT EnableRadialGradientProgram(jint flags);
+    HRESULT EnableConvolveProgram(jint flags);
+    HRESULT EnableRescaleProgram(jint flags);
+    HRESULT EnableLookupProgram(jint flags);
+    HRESULT EnableLCDTextProgram();
+    HRESULT EnableAAParallelogramProgram();
+    HRESULT DisableAAParallelogramProgram();
+
+    BOOL IsTextureFilteringSupported(D3DTEXTUREFILTERTYPE fType);
+    BOOL IsStretchRectFilteringSupported(D3DTEXTUREFILTERTYPE fType);
     BOOL IsPow2TexturesOnly()
-        { return d3dDevDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_POW2; };
+        { return devCaps.TextureCaps & D3DPTEXTURECAPS_POW2; };
     BOOL IsSquareTexturesOnly()
-        { return d3dDevDesc.dpcTriCaps.dwTextureCaps &
-              D3DPTEXTURECAPS_SQUAREONLY; }
+        { return devCaps.TextureCaps & D3DPTEXTURECAPS_SQUAREONLY; }
+    BOOL IsHWRasterizer() { return bIsHWRasterizer; }
+    BOOL IsTextureFormatSupported(D3DFORMAT format, DWORD usage = 0);
+    BOOL IsDynamicTextureSupported()
+        { return devCaps.Caps2 & D3DCAPS2_DYNAMICTEXTURES; }
+// REMIND: for now for performance testing
+//        { return (getenv("J2D_D3D_USE_DYNAMIC_TEX") != NULL); }
+    BOOL IsImmediateIntervalSupported()
+        { return devCaps.PresentationIntervals & D3DPRESENT_INTERVAL_IMMEDIATE;}
+    BOOL IsPixelShader20Supported()
+        { return (devCaps.PixelShaderVersion >= D3DPS_VERSION(2,0)); }
+    BOOL IsGradientInstructionExtensionSupported()
+        { return devCaps.PS20Caps.Caps & D3DPS20CAPS_GRADIENTINSTRUCTIONS; }
+    BOOL IsPixelShader30Supported()
+        { return (devCaps.PixelShaderVersion >= D3DPS_VERSION(3,0)); }
+    BOOL IsMultiTexturingSupported()
+        { return (devCaps.MaxSimultaneousTextures > 1); }
+    BOOL IsAlphaRTSurfaceSupported();
+    BOOL IsAlphaRTTSupported();
+    BOOL IsOpaqueRTTSupported();
+
+    jint GetPaintState() { return paintState; }
+    void SetPaintState(jint state) { this->paintState = state; }
+    BOOL IsIdentityTx() { return bIsIdentityTx; }
+
+    HRESULT FlushVertexQueue();
+    D3DVertexCacher *pVCacher;
+    HRESULT UpdateState(jbyte newState);
 
-    /**
-     * This method invalidates the java-level D3DContext object if
-     * the passed DDrawSurface is the current render target.
-     * The invalidation needs to be done so that the D3DContext object
-     * resets itself in case the native d3d device has been recreated, or
-     * the target surface has been lost (in which case this method is called
-     * from D3DSD_RestoreSurface function, see D3DSD_RestoreSurface for
-     * more info).
-     */
-    void InvalidateIfTarget(JNIEnv *env, DDrawSurface *lpSurface);
+    HRESULT Sync();
 
     // primitives batching-related methods
     /**
      * Calls devices's BeginScene if there weren't one already pending,
      * sets the pending flag.
      */
-    HRESULT /*NOLOCK*/ BeginScene(jbyte newState);
-    /**
-     * Only calls device's EndScene if ddResult is an error.
-     */
-    HRESULT /*NOLOCK*/ EndScene(HRESULT ddResult);
+    HRESULT BeginScene(jbyte newState);
     /**
-     * forces the end of batching by calling EndScene if
-     * there was BeginScene pending.
+     * Flushes the vertex queue and does end scene if
+     * a BeginScene is pending
      */
-    HRESULT /*NOLOCK*/ ForceEndScene();
+    HRESULT EndScene();
+
     /**
-     * flushes the queue if the argument is this device's render target
+     * Fields that track native-specific state.
      */
-    void    FlushD3DQueueForTarget(DDrawSurface *ddSurface);
-
-    // fields replicating D3DContext class' fields
-    jint       compState;
+    jint       paintState;
+    jboolean   useMask;
     jfloat     extraAlpha;
-    jint       colorPixel;
-
-    // pixel for vertices used in blits via texture mapping,
-    // set in SetAlphaComposite()
-    jint       blitPolygonPixel;
 
     /**
      * Current operation state.
@@ -283,164 +279,144 @@
     jbyte      opState;
 
 private:
-    D3DContext(DDraw *ddObject, DXObject* dxObject);
-    HRESULT InitD3DDevice(IDirect3DDevice7 *d3dDevice);
+
     /**
-     * This method releases an old device, creates a new one,
-     * runs d3d caps tests on it and sets the device caps according
-     * to the results.
-     */
-    HRESULT /*NOLOCK*/ CreateAndTestD3DDevice(DxCapabilities *dxCaps);
-    HRESULT /*NOLOCK*/ InitMaskTileTexture();
-    void    /*NOLOCK*/ UpdateState(jbyte newState);
-
-    IDirect3DDevice7        *d3dDevice;
-    IDirect3D7              *d3dObject;
-    DDraw                   *ddObject;
-    DXObject                *dxObject;
-    const GUID              *pDeviceGUID;
-    DDrawSurface            *ddTargetSurface;
-    DXSurface               *lpMaskTexture;
-    DXSurface               *lpGlyphCacheTexture;
-    D3DTextureTable         textureTable;
-    DDPIXELFORMAT           depthBufferFormat;
-    DDPIXELFORMAT           maskTileTexFormat;
-    GlyphCacheInfo          *glyphCache;
-    BOOL                    glyphCacheAvailable;
-    // array of the textures currently set to the device
-    IDirectDrawSurface7     *lastTexture[MAX_USED_TEXTURE_STAGE+1];
+     * Glyph cache-related methods/fields...
+     */
+    D3DGlyphCache *pGrayscaleGlyphCache;
+    D3DGlyphCache *pLCDGlyphCache;
 
     /**
-     * A weak reference to the java-level D3DContext object.
-     * Used to invalidate the java D3DContext object if the device has been
-     * recreated.
-     * See SetJavaContext() method.
+     * The handle to the LCD text pixel shader program.
      */
-    jobject jD3DContext;
+    IDirect3DPixelShader9 *lcdTextProgram;
+
+    /**
+     * The handle to the AA pixel and vertex shader programs.
+     */
+    IDirect3DPixelShader9 *aaPgramProgram;
+
+    IDirect3DPixelShader9 *CreateFragmentProgram(DWORD **shaders,
+                                                 ShaderList *programs,
+                                                 jint flags);
+    HRESULT EnableFragmentProgram(DWORD **shaders,
+                                  ShaderList *programList,
+                                  jint flags);
+
+    // finds appropriate to the target surface depth format,
+    // creates the depth buffer and installs it onto the device
+    HRESULT InitDepthStencilBuffer(D3DSURFACE_DESC *pTargetDesc);
+    // returns true if the current depth buffer is compatible
+    // with the new target, and the dimensions fit, false otherwise
+    BOOL IsDepthStencilBufferOk(D3DSURFACE_DESC *pTargetDesc);
+
+    D3DContext(IDirect3D9 *pd3dObject, UINT adapter);
+    HRESULT InitDevice(IDirect3DDevice9 *d3dDevice);
+    HRESULT InitContextCaps();
+    // updates the texture transform(s) used for better texel to pixel mapping
+    // for the passed in sampler;
+    // if -1 is passed as the sampler, texture transforms for
+    // samplers [0..MAX_USED_TEXTURE_SAMPLER] are updated
+    // REMIND: see the comment in the method implementation before enabling.
+#undef UPDATE_TX
+#ifdef UPDATE_TX
+    HRESULT UpdateTextureTransforms(DWORD dwSamplerToUpdate);
+#endif // UPDATE_TX
+    IDirect3DDevice9        *pd3dDevice;
+    IDirect3D9              *pd3dObject;
+
+    D3DResourceManager      *pResourceMgr;
+    D3DMaskCache            *pMaskCache;
+
+    ShaderList convolvePrograms;
+    ShaderList rescalePrograms;
+    ShaderList lookupPrograms;
+    ShaderList basicGradPrograms;
+    ShaderList linearGradPrograms;
+    ShaderList radialGradPrograms;
 
-    D3DDEVICEDESC7 d3dDevDesc;
-    int deviceCaps;
+    // array of the textures currently set to the device
+    IDirect3DTexture9     *lastTexture[MAX_USED_TEXTURE_SAMPLER+1];
+
+    DWORD lastTextureColorState[MAX_USED_TEXTURE_SAMPLER+1];
+
+    UINT adapterOrdinal;
+    D3DPRESENT_PARAMETERS   curParams;
+    D3DCAPS9 devCaps;
+    int contextCaps;
     BOOL bIsHWRasterizer;
 
+    BOOL bIsIdentityTx;
+
+    IDirect3DQuery9* pSyncQuery;
+    D3DResource* pSyncRTRes;
+
+    IDirect3DStateBlock9* pStateBlock;
+
     /**
      * Used to implement simple primitive batching.
      * See BeginScene/EndScene/ForceEndScene.
      */
     BOOL    bBeginScenePending;
-#ifdef DEBUG
-    int endSceneQueueDepth;
-#endif /* DEBUG */
-
-    CriticalSection deviceLock;
 };
 
-// - Various vertex formats -------------------------------------------
+// - Helper Macros ---------------------------------------------------
 
-#define D3DFVF_J2DLVERTEX (D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1)
-typedef struct _J2DLVERTEX {
-    float x, y, z;
-    DWORD color;
-    float tu, tv;
-} J2DLVERTEX;
+#define D3DC_INIT_SHADER_LIST(list, max) \
+    do { \
+        (list).head     = NULL; \
+        (list).maxItems = (max); \
+        (list).dispose  = D3DContext_DisposeShader; \
+    } while (0)
 
 /**
- * We're still debating whether to use a single vertex format
- * for all primitives or specific per-primitive formats.
- * Using different vertex formats reduces the amount of
- * data being sent to the video board, and this shows
- * benetits when running Java2D benchmarks.
- *
- * However, in a typical Swing application the number
- * of primitives of the same type rendered in a row is
- * relatively small, which means that the driver has
- * to spend more time state switching to account for different
- * vertex formats (and according to MSDN, switching vertex format
- * is a very expensive operation). So for this kind of application
- * it's better to stick with a single vertex format.
+ * This constant determines the size of the shared tile texture used
+ * by a number of image rendering methods.  For example, the blit tile texture
+ * will have dimensions with width D3DC_BLIT_TILE_SIZE and height
+ * D3DC_BLIT_TILE_SIZE (the tile will always be square).
  */
-#define USE_SINGLE_VERTEX_FORMAT
-
-#ifndef USE_SINGLE_VERTEX_FORMAT
-
-#define D3DFVF_J2D_XY_C (D3DFVF_XYZ | D3DFVF_DIFFUSE)
-#define D3DFVF_XY_VERTEX D3DFVF_XYZ
-
-typedef struct _J2D_XY_C_VERTEX {
-    float x, y, z;
-    DWORD color;
-} J2D_XY_C_VERTEX;
-typedef struct _J2D_XY_VERTEX {
-    float x, y, z;
-} J2D_XY_VERTEX;
-
-#else // USE_SINGLE_VERTEX_FORMAT
-
-// When using a single vertex format, define
-// every format as J2DLVERTEX
-
-#define D3DFVF_J2D_XY_C D3DFVF_J2DLVERTEX
-#define D3DFVF_XY_VERTEX D3DFVF_J2DLVERTEX
-typedef J2DLVERTEX J2D_XY_C_VERTEX;
-typedef J2DLVERTEX J2D_XY_VERTEX;
-
-#endif // USE_SINGLE_VERTEX_FORMAT
-
-typedef J2DLVERTEX      J2DLV_QUAD[4];
-typedef J2DLVERTEX      J2DLV_HEXA[6];
-typedef J2D_XY_C_VERTEX J2DXYC_HEXA[6];
-typedef J2D_XY_VERTEX   J2DXY_HEXA[6];
-#define MAX_CACHED_SPAN_VX_NUM 100
-
-// - Helper Macros ---------------------------------------------------
-
-#define D3D_DEPTH_IDX(DEPTH) \
-  (((DEPTH) <= 16) ? DEPTH16_IDX : \
-    (((DEPTH) <= 24) ? DEPTH24_IDX : DEPTH32_IDX))
-
-#define D3D_TR_IDX(TRAN) ((TRAN) - 1)
-
-#define D3DSD_MASK_TILE_SIZE 32
-#define D3D_GCACHE_WIDTH 512
-#define D3D_GCACHE_HEIGHT 512
-#define D3D_GCACHE_CELL_WIDTH 16
-#define D3D_GCACHE_CELL_HEIGHT 16
+#define D3DC_BLIT_TILE_SIZE 256
 
+/**
+ * See BufferedContext.java for more on these flags...
+ */
 #define D3DC_NO_CONTEXT_FLAGS \
-    sun_java2d_d3d_D3DContext_NO_CONTEXT_FLAGS
+    sun_java2d_pipe_BufferedContext_NO_CONTEXT_FLAGS
 #define D3DC_SRC_IS_OPAQUE    \
-    sun_java2d_d3d_D3DContext_SRC_IS_OPAQUE
-
-#define J2D_D3D_FAILURE \
-    sun_java2d_d3d_D3DContext_J2D_D3D_FAILURE
-#define J2D_D3D_PLAIN_SURFACE_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_PLAIN_SURFACE_OK
-#define J2D_D3D_OP_TEXTURE_SURFACE_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_OP_TEXTURE_SURFACE_OK
-#define J2D_D3D_BM_TEXTURE_SURFACE_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_BM_TEXTURE_SURFACE_OK
-#define J2D_D3D_TR_TEXTURE_SURFACE_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_TR_TEXTURE_SURFACE_OK
-#define J2D_D3D_DEPTH_SURFACE_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_DEPTH_SURFACE_OK
-#define J2D_D3D_OP_RTT_SURFACE_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_OP_RTT_SURFACE_OK
-#define J2D_D3D_LINES_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_LINES_OK
-#define J2D_D3D_TEXTURE_BLIT_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_TEXTURE_BLIT_OK
-#define J2D_D3D_TEXTURE_TRANSFORM_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_TEXTURE_TRANSFORM_OK
-#define J2D_D3D_LINE_CLIPPING_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_LINE_CLIPPING_OK
-#define J2D_D3D_DEVICE_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_DEVICE_OK
-#define J2D_D3D_PIXEL_FORMATS_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_PIXEL_FORMATS_OK
-#define J2D_D3D_SET_TRANSFORM_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_SET_TRANSFORM_OK
-#define J2D_D3D_HW_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_HW_OK
-#define J2D_D3D_ENABLED_OK \
-    sun_java2d_d3d_D3DContext_J2D_D3D_ENABLED_OK
+    sun_java2d_pipe_BufferedContext_SRC_IS_OPAQUE
+#define D3DC_USE_MASK         \
+    sun_java2d_pipe_BufferedContext_USE_MASK
+
+#define CAPS_EMPTY          \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_EMPTY
+#define CAPS_RT_PLAIN_ALPHA \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_RT_PLAIN_ALPHA
+#define CAPS_RT_TEXTURE_ALPHA      \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_RT_TEXTURE_ALPHA
+#define CAPS_RT_TEXTURE_OPAQUE     \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_RT_TEXTURE_OPAQUE
+#define CAPS_MULTITEXTURE   \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_MULTITEXTURE
+#define CAPS_TEXNONPOW2     \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_TEXNONPOW2
+#define CAPS_TEXNONSQUARE   \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_TEXNONSQUARE
+#define CAPS_LCD_SHADER     \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_LCD_SHADER
+#define CAPS_BIOP_SHADER    \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_BIOP_SHADER
+#define CAPS_AA_SHADER    \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_AA_SHADER
+#define CAPS_DEVICE_OK      \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_DEVICE_OK
+#define CAPS_PS20           \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_PS20
+#define CAPS_PS30           \
+    sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_PS30
+
+#define DEVICE_RESET    \
+    sun_java2d_pipe_hw_AccelDeviceEventNotifier_DEVICE_RESET
+#define DEVICE_DISPOSED \
+    sun_java2d_pipe_hw_AccelDeviceEventNotifier_DEVICE_DISPOSED
 
-#endif D3DCONTEXT_H
+#endif // D3DCONTEXT_H
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DGlyphCache.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DGlyphCache.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DGlyphCache.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DGlyphCache.cpp	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,207 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "D3DGlyphCache.h"
+#include "D3DTextRenderer.h"
+#include "D3DRenderQueue.h"
+
+void D3DGlyphCache_FlushGlyphVertexCache();
+
+// static
+HRESULT
+D3DGlyphCache::CreateInstance(D3DContext *pCtx, GlyphCacheType gcType,
+                              D3DGlyphCache **ppGlyphCache)
+{
+    HRESULT res;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGlyphCache::CreateInstance");
+
+    *ppGlyphCache = new D3DGlyphCache(gcType);
+    if (FAILED(res = (*ppGlyphCache)->Init(pCtx))) {
+        delete *ppGlyphCache;
+        *ppGlyphCache = NULL;
+    }
+    return res;
+}
+
+D3DGlyphCache::D3DGlyphCache(GlyphCacheType type)
+{
+    J2dTraceLn1(J2D_TRACE_INFO, "D3DGlyphCache::D3DGlyphCache gcType=%d", type);
+
+    pCtx = NULL;
+    gcType = type;
+    pGlyphCacheRes = NULL;
+    pGlyphCache = NULL;
+    tileFormat = (gcType == CACHE_GRAY) ? TILEFMT_1BYTE_ALPHA : TILEFMT_UNKNOWN;
+    lastRGBOrder = JNI_FALSE;
+}
+
+D3DGlyphCache::~D3DGlyphCache()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGlyphCache::~D3DGlyphCache");
+
+    ReleaseDefPoolResources();
+
+    pCtx = NULL;
+    if (pGlyphCache != NULL) {
+        AccelGlyphCache_Free(pGlyphCache);
+        pGlyphCache = NULL;
+    }
+}
+
+void
+D3DGlyphCache::ReleaseDefPoolResources()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGlyphCache::ReleaseDefPoolResources");
+
+    AccelGlyphCache_Invalidate(pGlyphCache);
+    // REMIND: the glyph cache texture is not in the default pool, so
+    // this can be optimized not to release the texture
+    pCtx->GetResourceManager()->ReleaseResource(pGlyphCacheRes);
+    pGlyphCacheRes = NULL;
+}
+
+HRESULT
+D3DGlyphCache::Init(D3DContext *pCtx)
+{
+    D3DFORMAT format;
+
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+
+    J2dTraceLn1(J2D_TRACE_INFO, "D3DGlyphCache::Init pCtx=%x", pCtx);
+
+    this->pCtx = pCtx;
+
+    if (pGlyphCache == NULL) {
+        // init glyph cache data structure
+        pGlyphCache = AccelGlyphCache_Init(D3DTR_CACHE_WIDTH,
+                                           D3DTR_CACHE_HEIGHT,
+                                           D3DTR_CACHE_CELL_WIDTH,
+                                           D3DTR_CACHE_CELL_HEIGHT,
+                                           D3DGlyphCache_FlushGlyphVertexCache);
+        if (pGlyphCache == NULL) {
+            J2dRlsTraceLn(J2D_TRACE_ERROR,
+                          "D3DGlyphCache::Init: "\
+                          "could not init D3D glyph cache");
+            return E_FAIL;
+        }
+    }
+
+    if (gcType == CACHE_GRAY) {
+        format = pCtx->IsTextureFormatSupported(D3DFMT_A8) ?
+            D3DFMT_A8 : D3DFMT_A8R8G8B8;
+    } else { // gcType == CACHE_LCD
+        format = pCtx->IsTextureFormatSupported(D3DFMT_R8G8B8) ?
+            D3DFMT_R8G8B8 : D3DFMT_A8R8G8B8;
+    }
+
+    HRESULT res = pCtx->GetResourceManager()->
+        CreateTexture(D3DTR_CACHE_WIDTH, D3DTR_CACHE_HEIGHT,
+                      FALSE/*isRTT*/, FALSE/*isOpaque*/, &format, 0/*usage*/,
+                      &pGlyphCacheRes);
+    if (FAILED(res)) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+                      "D3DGlyphCache::Init: "\
+                      "could not create glyph cache texture");
+    }
+
+    return res;
+}
+
+HRESULT
+D3DGlyphCache::AddGlyph(GlyphInfo *glyph)
+{
+    HRESULT res = S_OK;
+
+    RETURN_STATUS_IF_NULL(pGlyphCacheRes, E_FAIL);
+
+    CacheCellInfo *cellInfo = AccelGlyphCache_AddGlyph(pGlyphCache, glyph);
+    if (cellInfo != NULL) {
+        jint pixelsTouchedL = 0, pixelsTouchedR = 0;
+        // store glyph image in texture cell
+        res = pCtx->UploadTileToTexture(pGlyphCacheRes,
+                                        glyph->image,
+                                        cellInfo->x, cellInfo->y,
+                                        0, 0,
+                                        glyph->width, glyph->height,
+                                        glyph->rowBytes, tileFormat,
+                                        &pixelsTouchedL,
+                                        &pixelsTouchedR);
+        // LCD text rendering optimization: if the number of pixels touched on
+        // the first or last column of the glyph image is less than 1/3 of the
+        // height of the glyph we do not consider them touched.
+        // See D3DTextRenderer.cpp:UpdateCachedDestination for more information.
+        // The leftOff/rightOff are only used in LCD cache case.
+        if (gcType == CACHE_LCD) {
+            jint threshold = glyph->height/3;
+
+            cellInfo->leftOff  = pixelsTouchedL < threshold ?  1 : 0;
+            cellInfo->rightOff = pixelsTouchedR < threshold ? -1 : 0;
+        } else {
+            cellInfo->leftOff  = 0;
+            cellInfo->rightOff = 0;
+        }
+    }
+
+    return res;
+}
+
+HRESULT
+D3DGlyphCache::CheckGlyphCacheByteOrder(jboolean rgbOrder)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGlyphCache::CheckGlyphCacheByteOrder");
+
+    if (gcType != CACHE_LCD) {
+        J2dTraceLn(J2D_TRACE_ERROR, "D3DGlyphCache::CheckGlyphCacheByteOrder"\
+                   " invoked on CACHE_GRAY cache type instance!");
+        return E_FAIL;
+    }
+
+    if (rgbOrder != lastRGBOrder) {
+        // need to invalidate the cache in this case; see comments
+        // for lastRGBOrder
+        AccelGlyphCache_Invalidate(pGlyphCache);
+        lastRGBOrder = rgbOrder;
+    }
+    tileFormat = rgbOrder ? TILEFMT_3BYTE_RGB : TILEFMT_3BYTE_BGR;
+
+    return S_OK;
+}
+
+/**
+ * This method is invoked in the (relatively rare) case where one or
+ * more glyphs is about to be kicked out of the glyph cache texture.
+ * Here we simply flush the vertex queue of the current context in case
+ * any pending vertices are dependent upon the current glyph cache layout.
+ */
+static void
+D3DGlyphCache_FlushGlyphVertexCache()
+{
+    D3DContext *d3dc = D3DRQ_GetCurrentContext();
+    if (d3dc != NULL) {
+        J2dTraceLn(J2D_TRACE_INFO, "D3DGlyphCache_FlushGlyphVertexCache");
+        d3dc->FlushVertexQueue();
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DGlyphCache.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DGlyphCache.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DGlyphCache.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DGlyphCache.h	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef D3DGLYPHCACHE_H
+#define D3DGLYPHCACHE_H
+
+#include "AccelGlyphCache.h"
+#include "D3DContext.h"
+#include "D3DResourceManager.h"
+
+typedef enum {
+    CACHE_GRAY,
+    CACHE_LCD
+} GlyphCacheType;
+
+class D3DContext;
+class D3DResource;
+
+class D3DGlyphCache {
+public:
+    // creates accel. glyph cache if it wasn't created, and the glyph
+    // cache texure
+    HRESULT Init(D3DContext *pCtx);
+    // releases the glyph cache texture, invalidates the accel. glyph cache
+    void    ReleaseDefPoolResources();
+    // releases texture and deletes the accel. glyph cache
+           ~D3DGlyphCache();
+
+    // adds the glyph to the accel. glyph cache and uploads it into the glyph
+    // cache texture
+    HRESULT AddGlyph(GlyphInfo *glyph);
+
+    GlyphCacheInfo* GetGlyphCache() { return pGlyphCache; }
+    D3DResource* GetGlyphCacheTexture() { return pGlyphCacheRes; }
+
+    // Note: only applicable to CACHE_LCD type of the cache
+    // if the new rgb order doesn't match the current one, invalidates
+    // the accel. glyph cache, also resets the current tileFormat
+    HRESULT CheckGlyphCacheByteOrder(jboolean rgbOrder);
+
+static
+    HRESULT CreateInstance(D3DContext *pCtx,
+                           GlyphCacheType gcType,
+                           D3DGlyphCache **ppGlyphCache);
+
+private:
+    D3DGlyphCache(GlyphCacheType gcType);
+
+    D3DContext *pCtx;
+    GlyphCacheType gcType;
+    D3DResource *pGlyphCacheRes;
+    GlyphCacheInfo *pGlyphCache;
+    TileFormat tileFormat;
+    /**
+     * Relevant only for the CACHE_LCD cache type.
+     *
+     * This value tracks the previous LCD rgbOrder setting, so if the rgbOrder
+     * value has changed since the last time, it indicates that we need to
+     * invalidate the cache, which may already store glyph images in the
+     * reverse order.  Note that in most real world applications this value
+     * will not change over the course of the application, but tests like
+     * Font2DTest allow for changing the ordering at runtime, so we need to
+     * handle that case.
+     */
+    jboolean lastRGBOrder;
+};
+#endif // D3DGLYPHCACHE_H
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DGraphicsDevice.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DGraphicsDevice.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DGraphicsDevice.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DGraphicsDevice.cpp	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,507 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "sun_java2d_d3d_D3DGraphicsDevice.h"
+#include "D3DGraphicsDevice.h"
+#include "D3DPipelineManager.h"
+#include "D3DRenderQueue.h"
+#include "Trace.h"
+#include "awt_Toolkit.h"
+#include "awt_Window.h"
+
+extern jobject CreateDisplayMode(JNIEnv* env, jint width, jint height,
+                                 jint bitDepth, jint refreshRate);
+extern void addDisplayMode(JNIEnv* env, jobject arrayList, jint width,
+                           jint height, jint bitDepth, jint refreshRate);
+
+void InitD3D(void *pReturn)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "InitD3D");
+
+    jboolean *pRet = (jboolean *)pReturn;
+
+    D3DPipelineManager *pMgr = D3DPipelineManager::CreateInstance();
+    if (pMgr == NULL) {
+        J2dTraceLn(J2D_TRACE_ERROR, "InitD3D: could not create or init d3d");
+        *pRet = JNI_FALSE;
+    } else {
+        J2dTraceLn(J2D_TRACE_INFO, "InitD3D: successfully initialized d3d");
+        *pRet = JNI_TRUE;
+    }
+}
+
+extern "C" {
+/*
+ * Class:     sun_java2d_d3d_D3DGraphicsDevice
+ * Method:    initD3D
+ * Signature: ()Z
+ */
+JNIEXPORT jboolean JNICALL Java_sun_java2d_d3d_D3DGraphicsDevice_initD3D
+  (JNIEnv *env, jclass)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGD_initD3D");
+
+    jboolean result = JNI_FALSE;
+    AwtToolkit::GetInstance().InvokeFunction(InitD3D, &result);
+    J2dTraceLn1(J2D_TRACE_INFO, "D3DGD_initD3D: result=%x", result);
+    return result;
+}
+
+/*
+ * Class:     sun_java2d_d3d_D3DGraphicsDevice
+ * Method:    getDeviceIdNative
+ * Signature: (I)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_sun_java2d_d3d_D3DGraphicsDevice_getDeviceIdNative
+  (JNIEnv *env, jclass d3dsdc, jint gdiScreen)
+{
+    D3DPipelineManager *pMgr;
+    UINT adapter;
+    D3DADAPTER_IDENTIFIER9 aid;
+    IDirect3D9 *pd3d9;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGD_getDeviceIdNative");
+
+    pMgr = D3DPipelineManager::GetInstance();
+    RETURN_STATUS_IF_NULL(pMgr, NULL);
+    pd3d9 = pMgr->GetD3DObject();
+    RETURN_STATUS_IF_NULL(pd3d9, NULL);
+
+    adapter = pMgr->GetAdapterOrdinalForScreen(gdiScreen);
+    if (FAILED(pd3d9->GetAdapterIdentifier(adapter, 0, &aid))) {
+        return NULL;
+    }
+
+    // ('%d.' will take no more than 6+1 chars since we are printing a WORD)
+    //            AAAA&BBBB MAX_DEVICE_IDENTIFIER_STRING (%d.%d.%d.%d)0
+    size_t len = (4+1+4  +1+MAX_DEVICE_IDENTIFIER_STRING+1 +1+(6+1)*4+1 +1);
+    WCHAR *pAdapterId = new WCHAR[len];
+    RETURN_STATUS_IF_NULL(pAdapterId, NULL);
+
+    _snwprintf(pAdapterId, len, L"%x&%x %S (%d.%d.%d.%d)",
+               0xffff & aid.VendorId, 0xffff & aid.DeviceId, aid.Description,
+               HIWORD(aid.DriverVersion.HighPart),
+               LOWORD(aid.DriverVersion.HighPart),
+               HIWORD(aid.DriverVersion.LowPart),
+               LOWORD(aid.DriverVersion.LowPart));
+    // _snwprintf doesn't add 0 at the end if the formatted string didn't fit
+    // in the buffer so we have to make sure it is null terminated
+    pAdapterId[len-1] = (WCHAR)0;
+
+    J2dTraceLn1(J2D_TRACE_VERBOSE, "  id=%S", pAdapterId);
+
+    jstring ret = JNU_NewStringPlatform(env, pAdapterId);
+
+    delete pAdapterId;
+
+    return ret;
+}
+
+/*
+ * Class:     sun_java2d_d3d_D3DGraphicsDevice
+ * Method:    getDeviceCapsNative
+ * Signature: (I)I
+ */
+JNIEXPORT jint JNICALL
+Java_sun_java2d_d3d_D3DGraphicsDevice_getDeviceCapsNative
+  (JNIEnv *env, jclass d3dsdc, jint gdiScreen)
+{
+    D3DPipelineManager *pMgr;
+    D3DContext *pCtx;
+    UINT adapter;
+
+    J2dRlsTraceLn(J2D_TRACE_INFO, "D3DGD_getDeviceCapsNative");
+
+    pMgr = D3DPipelineManager::GetInstance();
+    RETURN_STATUS_IF_NULL(pMgr, CAPS_EMPTY);
+    adapter = pMgr->GetAdapterOrdinalForScreen(gdiScreen);
+
+    if (FAILED(pMgr->GetD3DContext(adapter, &pCtx))) {
+        J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                      "D3DGD_getDeviceCapsNative: device %d disabled", adapter);
+        return CAPS_EMPTY;
+    }
+    return pCtx->GetContextCaps();
+}
+
+/*
+ * Class:     sun_java2d_d3d_D3DGraphicsDevice
+ * Method:    enterFullScreenExclusiveNative
+ * Signature: (IJ)V
+ */
+JNIEXPORT jboolean JNICALL
+Java_sun_java2d_d3d_D3DGraphicsDevice_enterFullScreenExclusiveNative
+  (JNIEnv *env, jclass gdc, jint gdiScreen, jlong window)
+{
+    HRESULT res;
+    D3DPipelineManager *pMgr;
+    D3DContext *pCtx;
+    HWND hWnd;
+    AwtWindow *w;
+    D3DPRESENT_PARAMETERS newParams, *pCurParams;
+    D3DDISPLAYMODE dm;
+    UINT adapter;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGD_enterFullScreenExclusiveNative");
+
+    RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), JNI_FALSE);
+    adapter = pMgr->GetAdapterOrdinalForScreen(gdiScreen);
+
+    if (FAILED(res = pMgr->GetD3DContext(adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, D3DRQ_GetCurrentDestination());
+        return JNI_FALSE;
+    }
+
+    w = (AwtWindow *)AwtComponent::GetComponent((HWND)window);
+    if (w == NULL || !::IsWindow(hWnd = w->GetTopLevelHWnd())) {
+        J2dTraceLn(J2D_TRACE_WARNING,
+                   "D3DGD_enterFullScreenExclusiveNative: disposed window");
+        return JNI_FALSE;
+    }
+
+    // REMIND: should we also move the non-topleve window from
+    // being on top here (it's moved to front in GraphicsDevice.setFSW())?
+
+    pCtx->Get3DObject()->GetAdapterDisplayMode(adapter, &dm);
+    pCurParams = pCtx->GetPresentationParams();
+
+    // let the mananger know that we're entering the fs mode, it will
+    // set the proper current focus window for us, which ConfigureContext will
+    // use when creating the device
+    pMgr->SetFSFocusWindow(adapter, hWnd);
+
+    newParams = *pCurParams;
+    newParams.hDeviceWindow = hWnd;
+    newParams.Windowed = FALSE;
+    newParams.BackBufferCount = 1;
+    newParams.BackBufferFormat = dm.Format;
+    newParams.FullScreen_RefreshRateInHz = dm.RefreshRate;
+    newParams.BackBufferWidth = dm.Width;
+    newParams.BackBufferHeight = dm.Height;
+    newParams.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
+    newParams.SwapEffect = D3DSWAPEFFECT_DISCARD;
+
+    res = pCtx->ConfigureContext(&newParams);
+    D3DRQ_MarkLostIfNeeded(res, D3DRQ_GetCurrentDestination());
+    return SUCCEEDED(res);
+}
+
+/*
+ * Class:     sun_java2d_d3d_D3DGraphicsDevice
+ * Method:    exitFullScreenExclusiveNative
+ * Signature: (I)V
+ */
+JNIEXPORT jboolean JNICALL
+Java_sun_java2d_d3d_D3DGraphicsDevice_exitFullScreenExclusiveNative
+  (JNIEnv *env, jclass gdc, jint gdiScreen)
+{
+    HRESULT res;
+    D3DPipelineManager *pMgr;
+    D3DContext *pCtx;
+    D3DPRESENT_PARAMETERS newParams, *pCurParams;
+    UINT adapter;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGD_exitFullScreenExclusiveNative");
+
+    RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), JNI_FALSE);
+    adapter = pMgr->GetAdapterOrdinalForScreen(gdiScreen);
+
+    if (FAILED(res = pMgr->GetD3DContext(adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, D3DRQ_GetCurrentDestination());
+        return JNI_FALSE;
+    }
+
+    pCurParams = pCtx->GetPresentationParams();
+
+    newParams = *pCurParams;
+    // we're exiting fs, the device window can be 0
+    newParams.hDeviceWindow = 0;
+    newParams.Windowed = TRUE;
+    newParams.BackBufferFormat = D3DFMT_UNKNOWN;
+    newParams.BackBufferCount = 1;
+    newParams.FullScreen_RefreshRateInHz = 0;
+    newParams.BackBufferWidth = 0;
+    newParams.BackBufferHeight = 0;
+    newParams.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
+    newParams.SwapEffect = D3DSWAPEFFECT_COPY;
+
+    res = pCtx->ConfigureContext(&newParams);
+    D3DRQ_MarkLostIfNeeded(res, D3DRQ_GetCurrentDestination());
+
+    // exited fs, update current focus window
+    // note that we call this after this adapter exited fs mode so that
+    // the rest of the adapters can be reset
+    pMgr->SetFSFocusWindow(adapter, 0);
+
+    return SUCCEEDED(res);
+}
+
+/*
+ * Class:     sun_java2d_d3d_D3DGraphicsDevice
+ * Method:    configDisplayModeNative
+ * Signature: (IJIIII)V
+ */
+JNIEXPORT void JNICALL
+Java_sun_java2d_d3d_D3DGraphicsDevice_configDisplayModeNative
+  (JNIEnv *env, jclass gdc, jint gdiScreen, jlong window,
+   jint width, jint height, jint bitDepth, jint refreshRate)
+{
+    HRESULT res;
+    D3DPipelineManager *pMgr;
+    D3DContext *pCtx;
+    D3DPRESENT_PARAMETERS newParams, *pCurParams;
+    UINT adapter;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGD_configDisplayModeNative");
+
+    RETURN_IF_NULL(pMgr = D3DPipelineManager::GetInstance());
+    adapter = pMgr->GetAdapterOrdinalForScreen(gdiScreen);
+
+    if (FAILED(res = pMgr->GetD3DContext(adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, D3DRQ_GetCurrentDestination());
+        return;
+    }
+
+    pCurParams = pCtx->GetPresentationParams();
+
+    newParams = *pCurParams;
+    newParams.BackBufferWidth = width;
+    newParams.BackBufferHeight = height;
+    newParams.FullScreen_RefreshRateInHz = refreshRate;
+    newParams.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
+    // we leave the swap effect so that it's more likely
+    // to be the one user selected initially
+//    newParams.SwapEffect = D3DSWAPEFFECT_DISCARD;
+
+    if (bitDepth == 32) {
+        newParams.BackBufferFormat = D3DFMT_X8R8G8B8;
+    } else if (bitDepth == 16) {
+        UINT modeNum;
+        D3DDISPLAYMODE mode;
+        IDirect3D9 *pd3d9;
+        UINT modesCount;
+
+        RETURN_IF_NULL(pd3d9 = pMgr->GetD3DObject());
+
+        modesCount = pd3d9->GetAdapterModeCount(adapter, D3DFMT_R5G6B5);
+        if (modesCount == 0) {
+            modesCount = pd3d9->GetAdapterModeCount(adapter, D3DFMT_X1R5G5B5);
+        }
+
+        newParams.BackBufferFormat = D3DFMT_UNKNOWN;
+        for (modeNum = 0; modeNum < modesCount; modeNum++) {
+            if (SUCCEEDED(pd3d9->EnumAdapterModes(adapter, D3DFMT_R5G6B5,
+                                                  modeNum, &mode)))
+            {
+                if (mode.Width == width && mode.Height == height &&
+                    mode.RefreshRate == refreshRate)
+                {
+                    // prefer 565 over 555
+                    if (mode.Format == D3DFMT_R5G6B5) {
+                        newParams.BackBufferFormat = D3DFMT_R5G6B5;
+                        break;
+                    } else if (mode.Format == D3DFMT_X1R5G5B5) {
+                        newParams.BackBufferFormat = D3DFMT_X1R5G5B5;
+                    }
+                }
+            }
+        }
+        if (newParams.BackBufferFormat == D3DFMT_UNKNOWN) {
+            J2dRlsTraceLn(J2D_TRACE_ERROR,
+                          "D3DGD_configDisplayModeNative: no 16-bit formats");
+            return;
+        }
+    } else {
+        J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                       "D3DGD_configDisplayModeNative: unsupported depth: %d",
+                       bitDepth);
+        return;
+    }
+
+    J2dTraceLn4(J2D_TRACE_VERBOSE, "  changing to dm: %dx%dx%d@%d",
+                newParams.BackBufferWidth, newParams.BackBufferHeight,
+                bitDepth, refreshRate);
+    J2dTraceLn1(J2D_TRACE_VERBOSE, "  selected backbuffer format: %d",
+                newParams.BackBufferFormat);
+
+    res = pCtx->ConfigureContext(&newParams);
+    if (SUCCEEDED(res)) {
+        // the full screen window doesn't receive WM_SIZE event when
+        // the display mode changes (it does get resized though) so we need to
+        // generate the event ourselves
+        ::SendMessage(newParams.hDeviceWindow, WM_SIZE, width, height);
+    }
+    D3DRQ_MarkLostIfNeeded(res, D3DRQ_GetCurrentDestination());
+}
+
+
+/*
+ * Class:     sun_java2d_d3d_D3DGraphicsDevice
+ * Method:    getCurrentDisplayModeNative
+ * Signature: (I)Ljava/awt/DisplayMode;
+ */
+JNIEXPORT jobject JNICALL
+Java_sun_java2d_d3d_D3DGraphicsDevice_getCurrentDisplayModeNative
+  (JNIEnv *env, jclass gdc, jint gdiScreen)
+{
+    D3DPipelineManager *pMgr;
+    IDirect3D9 *pd3d9;
+    jobject ret = NULL;
+    D3DDISPLAYMODE mode;
+    UINT adapter;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGD_getCurrentDisplayModeNative");
+
+    RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), NULL);
+    RETURN_STATUS_IF_NULL(pd3d9 = pMgr->GetD3DObject(), NULL);
+    adapter = pMgr->GetAdapterOrdinalForScreen(gdiScreen);
+
+    if (SUCCEEDED(pd3d9->GetAdapterDisplayMode(adapter, &mode))) {
+        int bitDepth = -1;
+        // these are the only three valid screen formats
+        switch (mode.Format) {
+            case D3DFMT_X8R8G8B8: bitDepth = 32; break;
+            case D3DFMT_R5G6B5:
+            case D3DFMT_X1R5G5B5: bitDepth = 16; break;
+        }
+        J2dTraceLn4(J2D_TRACE_VERBOSE,
+                    "  current dm: %dx%dx%d@%d",
+                    mode.Width, mode.Height, bitDepth, mode.RefreshRate);
+        ret = CreateDisplayMode(env, mode.Width, mode.Height, bitDepth,
+                                mode.RefreshRate);
+    }
+    return ret;
+}
+
+/*
+ * Class:     sun_java2d_d3d_D3DGraphicsDevice
+ * Method:    enumDisplayModesNative
+ * Signature: (ILjava/util/ArrayList;)V
+ */
+JNIEXPORT void JNICALL
+Java_sun_java2d_d3d_D3DGraphicsDevice_enumDisplayModesNative
+  (JNIEnv *env, jclass gdc, jint gdiScreen, jobject arrayList)
+{
+    D3DPipelineManager *pMgr;
+    IDirect3D9 *pd3d9;
+    jobject ret = NULL;
+    D3DDISPLAYMODE mode;
+    UINT formatNum, modeNum, modesCount;
+    UINT adapter;
+    // EnumAdapterModes treats 555 and 565 formats as equivalents
+    static D3DFORMAT formats[] =
+        { D3DFMT_X8R8G8B8, D3DFMT_R5G6B5 };
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGD_enumDisplayModesNative");
+
+    RETURN_IF_NULL(pMgr = D3DPipelineManager::GetInstance());
+    RETURN_IF_NULL(pd3d9 = pMgr->GetD3DObject());
+    adapter = pMgr->GetAdapterOrdinalForScreen(gdiScreen);
+
+    for (formatNum = 0; formatNum < 3; formatNum++) {
+        modesCount = pd3d9->GetAdapterModeCount(adapter, formats[formatNum]);
+        for (modeNum = 0; modeNum < modesCount; modeNum++) {
+            if (SUCCEEDED(pd3d9->EnumAdapterModes(adapter, formats[formatNum],
+                                                  modeNum, &mode)))
+            {
+                int bitDepth = -1;
+                // these are the only three valid screen formats,
+                // 30-bit is returned as X8R8G8B8
+                switch (mode.Format) {
+                    case D3DFMT_X8R8G8B8: bitDepth = 32; break;
+                    case D3DFMT_R5G6B5:
+                    case D3DFMT_X1R5G5B5: bitDepth = 16; break;
+                }
+                J2dTraceLn4(J2D_TRACE_VERBOSE, "  found dm: %dx%dx%d@%d",
+                            mode.Width, mode.Height, bitDepth,mode.RefreshRate);
+                addDisplayMode(env, arrayList, mode.Width, mode.Height,
+                               bitDepth, mode.RefreshRate);
+            }
+        }
+    }
+}
+
+/*
+ * Class:     sun_java2d_d3d_D3DGraphicsDevice
+ * Method:    getAvailableAcceleratedMemoryNative
+ * Signature: (I)J
+ */
+JNIEXPORT jlong JNICALL
+Java_sun_java2d_d3d_D3DGraphicsDevice_getAvailableAcceleratedMemoryNative
+  (JNIEnv *env, jclass gdc, jint gdiScreen)
+{
+    // REMIND: looks like Direct3D provides information about texture memory
+    // only via IDirect3DDevice9::GetAvailableTextureMem, however, it
+    // seems to report the same amount as direct draw used to.
+    HRESULT res;
+    D3DPipelineManager *pMgr;
+    D3DContext *pCtx;
+    IDirect3DDevice9 *pd3dDevice;
+    UINT adapter;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGD_getAvailableAcceleratedMemoryNative");
+
+    RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), 0L);
+    adapter = pMgr->GetAdapterOrdinalForScreen(gdiScreen);
+
+    if (FAILED(res = pMgr->GetD3DContext(adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, D3DRQ_GetCurrentDestination());
+        return 0L;
+    }
+    RETURN_STATUS_IF_NULL(pd3dDevice = pCtx->Get3DDevice(), 0L);
+
+    UINT mem = pd3dDevice->GetAvailableTextureMem();
+    J2dTraceLn1(J2D_TRACE_VERBOSE, "  available memory=%d", mem);
+    return mem;
+}
+
+/*
+ * Class:     sun_java2d_d3d_D3DGraphicsDevice
+ * Method:    isD3DAvailableOnDeviceNative
+ * Signature: (I)Z
+ */
+JNIEXPORT jboolean JNICALL
+Java_sun_java2d_d3d_D3DGraphicsDevice_isD3DAvailableOnDeviceNative
+  (JNIEnv *env, jclass gdc, jint gdiScreen)
+{
+    HRESULT res;
+    D3DPipelineManager *pMgr;
+    D3DContext *pCtx;
+    UINT adapter;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DGD_isD3DAvailableOnDeviceNative");
+
+    RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), JNI_FALSE);
+    adapter = pMgr->GetAdapterOrdinalForScreen(gdiScreen);
+
+    if (FAILED(res = pMgr->GetD3DContext(adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, D3DRQ_GetCurrentDestination());
+        return JNI_FALSE;
+    }
+
+    return JNI_TRUE;
+}
+
+} // extern "C"
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DGraphicsDevice.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DGraphicsDevice.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DGraphicsDevice.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DGraphicsDevice.h	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef _D3DGRAPHICSDEVICE_H_
+#define _D3DGRAPHICSDEVICE_H_
+
+#endif /* _D3DGRAPHICSDEVICE_H_ */
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskBlit.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskBlit.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskBlit.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskBlit.cpp	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include <stdlib.h>
+#include <jlong.h>
+
+#include "D3DMaskBlit.h"
+#include "D3DRenderQueue.h"
+#include "D3DSurfaceData.h"
+
+/**
+ * REMIND: This method assumes that the dimensions of the incoming pixel
+ *         array are less than or equal to the cached blit texture tile;
+ *         these are rather fragile assumptions, and should be cleaned up...
+ */
+HRESULT
+D3DMaskBlit_MaskBlit(JNIEnv *env, D3DContext *d3dc,
+                     jint dstx, jint dsty,
+                     jint width, jint height,
+                     void *pPixels)
+{
+    HRESULT res = S_OK;
+    jfloat dx1, dy1, dx2, dy2;
+    jfloat tx1, ty1, tx2, ty2;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DMaskBlit_MaskBlit");
+
+    if (width <= 0 || height <= 0) {
+        J2dTraceLn(J2D_TRACE_WARNING,
+                   "D3DMaskBlit_MaskBlit: invalid dimensions");
+        return res;
+    }
+
+    RETURN_STATUS_IF_NULL(pPixels, E_FAIL);
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    if (FAILED(res = d3dc->BeginScene(STATE_TEXTUREOP))) {
+        return res;
+    }
+
+    D3DResource *pBlitTexRes;
+    if (FAILED(res =
+               d3dc->GetResourceManager()->GetBlitTexture(&pBlitTexRes)))
+    {
+        return res;
+    }
+    IDirect3DTexture9 *pBlitTex = pBlitTexRes->GetTexture();
+
+    if (FAILED(res = d3dc->SetTexture(pBlitTex, 0))) {
+        return res;
+    }
+
+    IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+    D3DTEXTUREFILTERTYPE fhint =
+        d3dc->IsTextureFilteringSupported(D3DTEXF_NONE) ?
+            D3DTEXF_NONE : D3DTEXF_POINT;
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, fhint);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, fhint);
+
+    // copy system memory IntArgbPre surface into cached texture
+    if (FAILED(res = d3dc->UploadTileToTexture(pBlitTexRes, pPixels,
+                                               0, 0, 0, 0,
+                                               width, height,
+                                               width*4,
+                                               TILEFMT_4BYTE_ARGB_PRE)))
+    {
+        return res;
+    }
+
+    dx1 = (jfloat)dstx;
+    dy1 = (jfloat)dsty;
+    dx2 = dx1 + width;
+    dy2 = dy1 + height;
+
+    tx1 = 0.0f;
+    ty1 = 0.0f;
+    tx2 = ((jfloat)width) / D3DC_BLIT_TILE_SIZE;
+    ty2 = ((jfloat)height) / D3DC_BLIT_TILE_SIZE;
+
+    // render cached texture to the destination surface
+    res = d3dc->pVCacher->DrawTexture(dx1, dy1, dx2, dy2,
+                                      tx1, ty1, tx2, ty2);
+    res = d3dc->pVCacher->Render();
+
+    return res;
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskBlit.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskBlit.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskBlit.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskBlit.h	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef D3DMaskBlit_h_Included
+#define D3DMaskBlit_h_Included
+
+#include "D3DContext.h"
+
+HRESULT D3DMaskBlit_MaskBlit(JNIEnv *env, D3DContext *d3dc,
+                             jint dstx, jint dsty,
+                             jint width, jint height,
+                             void *pPixels);
+
+#endif /* D3DMaskBlit_h_Included */
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskCache.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskCache.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskCache.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskCache.cpp	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "D3DMaskCache.h"
+
+HRESULT
+D3DMaskCache::CreateInstance(D3DContext *pCtx, D3DMaskCache **ppMaskCache)
+{
+    HRESULT res;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DMaskCache::CreateInstance");
+
+    *ppMaskCache = new D3DMaskCache();
+    if (FAILED(res = (*ppMaskCache)->Init(pCtx))) {
+        delete *ppMaskCache;
+        *ppMaskCache = NULL;
+    }
+    return res;
+}
+
+D3DMaskCache::D3DMaskCache()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DMaskCache::D3DMaskCache");
+    this->pCtx = NULL;
+    maskCacheIndex = 0;
+}
+
+D3DMaskCache::~D3DMaskCache()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DMaskCache::~D3DMaskCache");
+    pCtx = NULL;
+    maskCacheIndex = 0;
+}
+
+HRESULT
+D3DMaskCache::Init(D3DContext *pCtx)
+{
+    J2dTraceLn1(J2D_TRACE_INFO, "D3DMaskCache::Init pCtx=%x", pCtx);
+    this->pCtx = pCtx;
+    this->maskCacheIndex = 0;
+    return S_OK;
+}
+
+HRESULT D3DMaskCache::Enable()
+{
+    HRESULT res;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DMaskCache::Enable");
+
+    D3DResource *pMaskTexRes;
+    res = pCtx->GetResourceManager()->GetMaskTexture(&pMaskTexRes);
+    RETURN_STATUS_IF_FAILED(res);
+
+    res = pCtx->SetTexture(pMaskTexRes->GetTexture(), 0);
+
+    IDirect3DDevice9 *pd3dDevice = pCtx->Get3DDevice();
+    D3DTEXTUREFILTERTYPE fhint =
+        pCtx->IsTextureFilteringSupported(D3DTEXF_NONE) ?
+            D3DTEXF_NONE : D3DTEXF_POINT;
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, fhint);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, fhint);
+
+    return res;
+}
+
+HRESULT D3DMaskCache::Disable()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DMaskCache::Disable");
+
+    maskCacheIndex = 0;
+
+    return pCtx->SetTexture(NULL, 0);
+}
+
+HRESULT D3DMaskCache::AddMaskQuad(int srcx, int srcy,
+                                  int dstx, int dsty,
+                                  int width, int height,
+                                  int maskscan, void *mask)
+{
+    HRESULT res;
+    float tx1, ty1, tx2, ty2;
+    float dx1, dy1, dx2, dy2;
+
+    J2dTraceLn1(J2D_TRACE_INFO, "D3DVertexCacher::AddMaskQuad: %d",
+                maskCacheIndex);
+
+    if (maskCacheIndex >= D3D_MASK_CACHE_MAX_INDEX ||
+        pCtx->pVCacher->GetFreeVertices() < 6)
+    {
+        res = pCtx->pVCacher->Render();
+        RETURN_STATUS_IF_FAILED(res);
+        maskCacheIndex = 0;
+    }
+
+    if (mask != NULL) {
+        int texx = D3D_MASK_CACHE_TILE_WIDTH *
+            (maskCacheIndex % D3D_MASK_CACHE_WIDTH_IN_TILES);
+        int texy = D3D_MASK_CACHE_TILE_HEIGHT *
+            (maskCacheIndex / D3D_MASK_CACHE_WIDTH_IN_TILES);
+        D3DResource *pMaskTexRes;
+
+        res = pCtx->GetResourceManager()->GetMaskTexture(&pMaskTexRes);
+        RETURN_STATUS_IF_FAILED(res);
+
+        // copy alpha mask into texture tile
+        pCtx->UploadTileToTexture(pMaskTexRes, mask,
+                                  texx, texy,
+                                  srcx, srcy,
+                                  width, height,
+                                  maskscan,
+                                  TILEFMT_1BYTE_ALPHA);
+
+        tx1 = ((float)texx) / D3D_MASK_CACHE_WIDTH_IN_TEXELS;
+        ty1 = ((float)texy) / D3D_MASK_CACHE_HEIGHT_IN_TEXELS;
+
+        maskCacheIndex++;
+    } else {
+        // use special fully opaque tile
+        tx1 = ((float)D3D_MASK_CACHE_SPECIAL_TILE_X) /
+            D3D_MASK_CACHE_WIDTH_IN_TEXELS;
+        ty1 = ((float)D3D_MASK_CACHE_SPECIAL_TILE_Y) /
+            D3D_MASK_CACHE_HEIGHT_IN_TEXELS;
+    }
+
+    tx2 = tx1 + (((float)width) / D3D_MASK_CACHE_WIDTH_IN_TEXELS);
+    ty2 = ty1 + (((float)height) / D3D_MASK_CACHE_HEIGHT_IN_TEXELS);
+
+    dx1 = (float)dstx;
+    dy1 = (float)dsty;
+    dx2 = dx1 + width;
+    dy2 = dy1 + height;
+
+    return pCtx->pVCacher->DrawTexture(dx1, dy1, dx2, dy2,
+                                       tx1, ty1, tx2, ty2);
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskCache.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskCache.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskCache.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskCache.h	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef D3DMASKCACHE_H
+#define D3DMASKCACHE_H
+
+#include "jni.h"
+#include "D3DContext.h"
+
+/**
+ * Constants that control the size of the texture tile cache used for
+ * mask operations.
+ */
+#define D3D_MASK_CACHE_TILE_WIDTH       32
+#define D3D_MASK_CACHE_TILE_HEIGHT      32
+#define D3D_MASK_CACHE_TILE_SIZE \
+   (D3D_MASK_CACHE_TILE_WIDTH * D3D_MASK_CACHE_TILE_HEIGHT)
+
+#define D3D_MASK_CACHE_WIDTH_IN_TILES   8
+#define D3D_MASK_CACHE_HEIGHT_IN_TILES  4
+
+#define D3D_MASK_CACHE_WIDTH_IN_TEXELS \
+   (D3D_MASK_CACHE_TILE_WIDTH * D3D_MASK_CACHE_WIDTH_IN_TILES)
+#define D3D_MASK_CACHE_HEIGHT_IN_TEXELS \
+   (D3D_MASK_CACHE_TILE_HEIGHT * D3D_MASK_CACHE_HEIGHT_IN_TILES)
+
+/*
+ * We reserve one (fully opaque) tile in the upper-right corner for
+ * operations where the mask is null.
+ */
+#define D3D_MASK_CACHE_MAX_INDEX \
+   ((D3D_MASK_CACHE_WIDTH_IN_TILES * D3D_MASK_CACHE_HEIGHT_IN_TILES) - 1)
+#define D3D_MASK_CACHE_SPECIAL_TILE_X \
+   (D3D_MASK_CACHE_WIDTH_IN_TEXELS - D3D_MASK_CACHE_TILE_WIDTH)
+#define D3D_MASK_CACHE_SPECIAL_TILE_Y \
+   (D3D_MASK_CACHE_HEIGHT_IN_TEXELS - D3D_MASK_CACHE_TILE_HEIGHT)
+
+class D3DContext;
+
+class D3DMaskCache {
+public:
+    HRESULT Init(D3DContext *pCtx);
+    void    ReleaseDefPoolResources() {};
+            ~D3DMaskCache();
+    HRESULT Enable();
+    HRESULT Disable();
+    HRESULT AddMaskQuad(int srcx, int srcy,
+                        int dstx, int dsty,
+                        int width, int height,
+                        int maskscan, void *mask);
+
+static
+    HRESULT CreateInstance(D3DContext *pCtx, D3DMaskCache **ppMaskCache);
+
+private:
+               D3DMaskCache();
+    UINT       maskCacheIndex;
+    D3DContext *pCtx;
+};
+
+#endif // D3DMASKCACHE_H
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskFill.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskFill.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskFill.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskFill.cpp	2011-01-08 01:26:50.475202254 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,187 +23,102 @@
  * questions.
  */
 
-#include <stdlib.h>
-#include <jni.h>
-#include "ddrawUtils.h"
-#include "GraphicsPrimitiveMgr.h"
-#include "j2d_md.h"
-#include "jlong.h"
-
 #include "sun_java2d_d3d_D3DMaskFill.h"
 
-#include "Win32SurfaceData.h"
-
-#include "D3DContext.h"
-#include "D3DUtils.h"
-
-
-extern "C" {
-
-inline static HRESULT doMaskFill
-    (JNIEnv *env, jobject self,
-     Win32SDOps *wsdo, D3DContext *d3dc,
-     jint x, jint y, jint w, jint h,
-     jbyteArray maskArray,
-     jint maskoff, jint maskscan);
-
+#include "D3DMaskFill.h"
+#include "D3DRenderQueue.h"
 
-JNIEXPORT void JNICALL
-Java_sun_java2d_d3d_D3DMaskFill_MaskFill
-    (JNIEnv *env, jobject self,
-     jlong pData, jlong pCtx,
-     jint x, jint y, jint w, jint h,
-     jbyteArray maskArray,
-     jint maskoff, jint maskscan)
+/**
+ * This implementation first copies the alpha tile into a texture and then
+ * maps that texture to the destination surface.  This approach appears to
+ * offer the best performance despite being a two-step process.
+ *
+ * Here are some descriptions of the many variables used in this method:
+ *   x,y     - upper left corner of the tile destination
+ *   w,h     - width/height of the mask tile
+ *   x0      - placekeeper for the original destination x location
+ *   tw,th   - width/height of the actual texture tile in pixels
+ *   sx1,sy1 - upper left corner of the mask tile source region
+ *   sx2,sy2 - lower left corner of the mask tile source region
+ *   sx,sy   - "current" upper left corner of the mask tile region of interest
+ */
+HRESULT
+D3DMaskFill_MaskFill(D3DContext *d3dc,
+                     jint x, jint y, jint w, jint h,
+                     jint maskoff, jint maskscan, jint masklen,
+                     unsigned char *pMask)
 {
-    Win32SDOps *wsdo = (Win32SDOps *)jlong_to_ptr(pData);
-    D3DContext *d3dc = (D3DContext *)jlong_to_ptr(pCtx);
+    HRESULT res = S_OK;
 
     J2dTraceLn(J2D_TRACE_INFO, "D3DMaskFill_MaskFill");
-    J2dTraceLn4(J2D_TRACE_VERBOSE, "  x=%-4d y=%-4d w=%-4d h=%-4d",
-                x, y, w, h);
-    J2dTraceLn2(J2D_TRACE_VERBOSE, "  maskoff=%-4d maskscan=%-4d",
-                maskoff, maskscan);
-
-    if (d3dc == NULL || wsdo == NULL) {
-        J2dTraceLn(J2D_TRACE_WARNING,
-                   "D3DMaskFill_MaskFill: context is null");
-        return;
-    }
-
-    HRESULT res;
-    D3D_EXEC_PRIM_LOOP(env, res, wsdo,
-                  doMaskFill(env, self, wsdo, d3dc,
-                             x, y, w, h,
-                             maskArray, maskoff, maskscan));
-}
-
-inline static HRESULT doMaskFill
-    (JNIEnv *env, jobject self,
-     Win32SDOps *wsdo, D3DContext *d3dc,
-     jint x, jint y, jint w, jint h,
-     jbyteArray maskArray,
-     jint maskoff, jint maskscan)
-{
-    DXSurface *maskTexture;
-    static J2DLVERTEX quadVerts[4] = {
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f }
-    };
-
-    DDrawSurface *ddTargetSurface = d3dc->GetTargetSurface();
-    if (ddTargetSurface == NULL) {
-        return DDERR_GENERIC;
-    }
 
-    ddTargetSurface->GetExclusiveAccess();
-    d3dc->GetExclusiveAccess();
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
 
-    IDirect3DDevice7 *d3dDevice = d3dc->Get3DDevice();
+    J2dTraceLn4(J2D_TRACE_VERBOSE, "  x=%d y=%d w=%d h=%d", x, y, w, h);
+    J2dTraceLn2(J2D_TRACE_VERBOSE, "  maskoff=%d maskscan=%d",
+                maskoff, maskscan);
 
-    HRESULT res = D3D_OK;
-    if (maskArray) {
-        jubyte *pMask =
-            (jubyte*)env->GetPrimitiveArrayCritical(maskArray, 0);
-        float tx1, ty1, tx2, ty2;
+    {
+        D3DMaskCache *maskCache = d3dc->GetMaskCache();
         jint tw, th, x0;
         jint sx1, sy1, sx2, sy2;
         jint sx, sy, sw, sh;
 
-        if (pMask == NULL) {
-            d3dc->ReleaseExclusiveAccess();
-            ddTargetSurface->ReleaseExclusiveAccess();
-            return DDERR_GENERIC;
-        }
-
-        maskTexture = d3dc->GetMaskTexture();
-        if (maskTexture == NULL ||
-            FAILED(res = d3dc->BeginScene(STATE_MASKOP)))
-        {
-            env->ReleasePrimitiveArrayCritical(maskArray, pMask, JNI_ABORT);
-            d3dc->ReleaseExclusiveAccess();
-            ddTargetSurface->ReleaseExclusiveAccess();
-            return DDERR_GENERIC;
-        }
-
-        if (FAILED(res = d3dc->SetTexture(maskTexture))) {
-            d3dc->EndScene(res);
-            env->ReleasePrimitiveArrayCritical(maskArray, pMask, JNI_ABORT);
-            d3dc->ReleaseExclusiveAccess();
-            ddTargetSurface->ReleaseExclusiveAccess();
-            return res;
-        }
+        res = d3dc->BeginScene(STATE_MASKOP);
+        RETURN_STATUS_IF_FAILED(res);
 
         x0 = x;
-        tx1 = 0.0f;
-        ty1 = 0.0f;
-        tw = D3DSD_MASK_TILE_SIZE;
-        th = D3DSD_MASK_TILE_SIZE;
+        tw = D3D_MASK_CACHE_TILE_WIDTH;
+        th = D3D_MASK_CACHE_TILE_HEIGHT;
         sx1 = maskoff % maskscan;
         sy1 = maskoff / maskscan;
         sx2 = sx1 + w;
         sy2 = sy1 + h;
 
-        D3DU_INIT_VERTEX_QUAD_COLOR(quadVerts, d3dc->colorPixel);
-        for (sy = sy1; (sy < sy2) && SUCCEEDED(res); sy += th, y += th) {
+        for (sy = sy1; sy < sy2; sy += th, y += th) {
             x = x0;
             sh = ((sy + th) > sy2) ? (sy2 - sy) : th;
 
-            for (sx = sx1; (sx < sx2) && SUCCEEDED(res); sx += tw, x += tw) {
+            for (sx = sx1; sx < sx2; sx += tw, x += tw) {
                 sw = ((sx + tw) > sx2) ? (sx2 - sx) : tw;
 
-                if (FAILED(d3dc->UploadImageToTexture(maskTexture,
-                                                      pMask,
-                                                      0, 0, sx, sy, sw, sh,
-                                                      maskscan)))
-                {
-                    continue;
-                }
-
-                // update the lower right texture coordinates
-                tx2 = ((float)sw) / tw;
-                ty2 = ((float)sh) / th;
-
-                D3DU_INIT_VERTEX_QUAD_XYUV(quadVerts,
-                                           (float)x, (float)y,
-                                           (float)(x+sw), (float)(y+sh),
-                                           tx1, ty1, tx2, ty2);
-                if (SUCCEEDED(res = ddTargetSurface->IsLost())) {
-                    // render texture tile to the destination surface
-                    res = d3dDevice->DrawPrimitive(D3DPT_TRIANGLEFAN,
-                                                   D3DFVF_J2DLVERTEX,
-                                                   quadVerts, 4, 0);
-                }
-
+                res = maskCache->AddMaskQuad(sx, sy, x, y, sw, sh,
+                                             maskscan, pMask);
             }
         }
+    }
+    return res;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_java2d_d3d_D3DMaskFill_maskFill
+    (JNIEnv *env, jobject self,
+     jint x, jint y, jint w, jint h,
+     jint maskoff, jint maskscan, jint masklen,
+     jbyteArray maskArray)
+{
+    D3DContext *d3dc = D3DRQ_GetCurrentContext();
+    unsigned char *mask;
 
-        d3dc->EndScene(res);
+    J2dTraceLn(J2D_TRACE_ERROR, "D3DMaskFill_maskFill");
 
-        env->ReleasePrimitiveArrayCritical(maskArray, pMask, JNI_ABORT);
+    if (maskArray != NULL) {
+        mask = (unsigned char *)
+            env->GetPrimitiveArrayCritical(maskArray, NULL);
     } else {
-        float x1 = (float)x;
-        float y1 = (float)y;
-        float x2 = x1 + (float)w;
-        float y2 = y1 + (float)h;
-        D3DU_INIT_VERTEX_QUAD_COLOR(quadVerts, d3dc->colorPixel);
-        D3DU_INIT_VERTEX_QUAD_XY(quadVerts, x1, y1, x2, y2);
-        if (SUCCEEDED(res = d3dc->BeginScene(STATE_RENDEROP))) {
-            if (SUCCEEDED(res = ddTargetSurface->IsLost())) {
-                res = d3dDevice->DrawPrimitive(D3DPT_TRIANGLEFAN,
-                                               D3DFVF_J2DLVERTEX,
-                                               quadVerts, 4, 0);
-            }
-            d3dc->EndScene(res);
-        }
+        mask = NULL;
     }
 
-    d3dc->ReleaseExclusiveAccess();
-    ddTargetSurface->ReleaseExclusiveAccess();
-
-    return res;
-}
+    D3DMaskFill_MaskFill(d3dc,
+                         x, y, w, h,
+                         maskoff, maskscan, masklen, mask);
+
+    // reset current state, and ensure rendering is flushed to dest
+    if (d3dc != NULL) {
+        d3dc->FlushVertexQueue();
+    }
 
+    if (mask != NULL) {
+        env->ReleasePrimitiveArrayCritical(maskArray, mask, JNI_ABORT);
+    }
 }
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskFill.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskFill.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DMaskFill.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DMaskFill.h	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef D3DMaskFill_h_Included
+#define D3DMaskFill_h_Included
+
+#include "D3DContext.h"
+
+HRESULT D3DMaskFill_MaskFill(D3DContext *d3dc,
+                             jint x, jint y, jint w, jint h,
+                             jint maskoff, jint maskscan, jint masklen,
+                             unsigned char *pMask);
+
+#endif /* D3DMaskFill_h_Included */
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPaints.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPaints.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPaints.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPaints.cpp	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,532 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include <jlong.h>
+#include <string.h>
+
+#include "sun_java2d_d3d_D3DPaints_MultiGradient.h"
+
+#include "D3DPaints.h"
+#include "D3DContext.h"
+#include "D3DRenderQueue.h"
+#include "D3DSurfaceData.h"
+
+HRESULT
+D3DPaints_ResetPaint(D3DContext *d3dc)
+{
+    jint pixel, paintState;
+    jubyte ea;
+    HRESULT res;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPaints_ResetPaint");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+
+    paintState = d3dc->GetPaintState();
+    J2dTraceLn1(J2D_TRACE_VERBOSE, "  state=%d", paintState);
+
+    res = d3dc->UpdateState(STATE_OTHEROP);
+
+    // disable current complex paint state, if necessary
+    if (paintState > PAINT_ALPHACOLOR) {
+        IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+        DWORD sampler = d3dc->useMask ? 1 : 0;
+
+        d3dc->SetTexture(NULL, sampler);
+        pd3dDevice->SetSamplerState(sampler,
+                                    D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
+        pd3dDevice->SetSamplerState(sampler,
+                                    D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
+        pd3dDevice->SetTextureStageState(sampler,
+                                         D3DTSS_TEXCOORDINDEX, sampler);
+        res = pd3dDevice->SetTextureStageState(sampler,
+                                               D3DTSS_TEXTURETRANSFORMFLAGS,
+                                               D3DTTFF_DISABLE);
+
+        if (paintState == PAINT_GRADIENT     ||
+            paintState == PAINT_LIN_GRADIENT ||
+            paintState == PAINT_RAD_GRADIENT)
+        {
+            res = pd3dDevice->SetPixelShader(NULL);
+        }
+    }
+
+    // set each component of the current color state to the extra alpha
+    // value, which will effectively apply the extra alpha to each fragment
+    // in paint/texturing operations
+    ea = (jubyte)(d3dc->extraAlpha * 0xff + 0.5f);
+    pixel = (ea << 24) | (ea << 16) | (ea << 8) | (ea << 0);
+    d3dc->pVCacher->SetColor(pixel);
+    d3dc->useMask = JNI_FALSE;
+    d3dc->SetPaintState(-1);
+    return res;
+}
+
+HRESULT
+D3DPaints_SetColor(D3DContext *d3dc, jint pixel)
+{
+    HRESULT res = S_OK;
+
+    J2dTraceLn1(J2D_TRACE_INFO, "D3DPaints_SetColor: pixel=%08x", pixel);
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+
+    // no need to reset the current op state here unless the paint
+    // state really needs to be changed
+    if (d3dc->GetPaintState() > PAINT_ALPHACOLOR) {
+        res = D3DPaints_ResetPaint(d3dc);
+    }
+
+    d3dc->pVCacher->SetColor(pixel);
+    d3dc->useMask = JNI_FALSE;
+    d3dc->SetPaintState(PAINT_ALPHACOLOR);
+    return res;
+}
+
+/************************* GradientPaint support ****************************/
+
+HRESULT
+D3DPaints_SetGradientPaint(D3DContext *d3dc,
+                           jboolean useMask, jboolean cyclic,
+                           jdouble p0, jdouble p1, jdouble p3,
+                           jint pixel1, jint pixel2)
+{
+    IDirect3DDevice9 *pd3dDevice;
+    HRESULT res;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPaints_SetGradientPaint");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    D3DPaints_ResetPaint(d3dc);
+
+#if 0
+    /*
+     * REMIND: The following code represents the original fast gradient
+     *         implementation.  The problem is that it relies on LINEAR
+     *         texture filtering, which does not provide sufficient
+     *         precision on certain hardware (from ATI, notably), which
+     *         will cause visible banding (e.g. 64 shades of gray between
+     *         black and white, instead of the expected 256 shades.  For
+     *         correctness on such hardware, it is necessary to use a
+     *         shader-based approach that does not suffer from these
+     *         precision issues (see below).  This original implementation
+     *         is about 16x faster than software, whereas the shader-based
+     *         implementation is only about 4x faster than software (still
+     *         impressive).  For simplicity, we will always use the
+     *         shader-based version for now, but in the future we could
+     *         consider using the fast path for certain hardware (that does
+     *         not exhibit the problem) or provide a flag to allow developers
+     *         to control which path we take (for those that are less
+     *         concerned about quality).  Therefore, I'll leave this code
+     *         here (currently disabled) for future use.
+     */
+    D3DResource *pGradientTexRes;
+    IDirect3DTexture9 *pGradientTex;
+
+    // this will initialize the gradient texture, if necessary
+    res = d3dc->GetResourceManager()->GetGradientTexture(&pGradientTexRes);
+    RETURN_STATUS_IF_FAILED(res);
+
+    pGradientTex = pGradientTexRes->GetTexture();
+
+    // update the texture containing the gradient colors
+    {
+        D3DLOCKED_RECT lockedRect;
+        res = pGradientTex->LockRect(0, &lockedRect, NULL, D3DLOCK_NOSYSLOCK);
+        RETURN_STATUS_IF_FAILED(res);
+        jint *pPix = (jint*)lockedRect.pBits;
+        pPix[0] = pixel1;
+        pPix[1] = pixel2;
+        pGradientTex->UnlockRect(0);
+    }
+
+    DWORD sampler = useMask ? 1 : 0;
+    DWORD wrapMode = cyclic ? D3DTADDRESS_WRAP : D3DTADDRESS_CLAMP;
+    d3dc->SetTexture(pGradientTex, sampler);
+    d3dc->UpdateTextureColorState(D3DTA_TEXTURE, sampler);
+
+    pd3dDevice = d3dc->Get3DDevice();
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_ADDRESSU, wrapMode);
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_ADDRESSV, wrapMode);
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
+
+    D3DMATRIX mt;
+    ZeroMemory(&mt, sizeof(mt));
+    mt._11 = (float)p0;
+    mt._21 = (float)p1;
+    mt._31 = (float)0.0;
+    mt._41 = (float)p3;
+    mt._12 = 0.0f;
+    mt._22 = 1.0f;
+    mt._32 = 0.0f;
+    mt._42 = 0.0f;
+    pd3dDevice->SetTransform(useMask ? D3DTS_TEXTURE1 : D3DTS_TEXTURE0, &mt);
+    pd3dDevice->SetTextureStageState(sampler, D3DTSS_TEXCOORDINDEX,
+                                     D3DTSS_TCI_CAMERASPACEPOSITION);
+    res = pd3dDevice->SetTextureStageState(sampler,
+                                     D3DTSS_TEXTURETRANSFORMFLAGS,
+                                     D3DTTFF_COUNT2);
+#else
+    jfloat params[4];
+    jfloat color[4];
+    jint flags = 0;
+
+    if (cyclic)  flags |= BASIC_GRAD_IS_CYCLIC;
+    if (useMask) flags |= BASIC_GRAD_USE_MASK;
+
+    // locate/enable the shader program for the given flags
+    res = d3dc->EnableBasicGradientProgram(flags);
+    RETURN_STATUS_IF_FAILED(res);
+
+    // update the "uniform" values
+    params[0] = (jfloat)p0;
+    params[1] = (jfloat)p1;
+    params[2] = (jfloat)p3;
+    params[3] = 0.0f; // unused
+    pd3dDevice = d3dc->Get3DDevice();
+    res = pd3dDevice->SetPixelShaderConstantF(0, params, 1);
+
+    color[0] = ((pixel1 >> 16) & 0xff) / 255.0f; // r
+    color[1] = ((pixel1 >>  8) & 0xff) / 255.0f; // g
+    color[2] = ((pixel1 >>  0) & 0xff) / 255.0f; // b
+    color[3] = ((pixel1 >> 24) & 0xff) / 255.0f; // a
+    res = pd3dDevice->SetPixelShaderConstantF(1, color, 1);
+
+    color[0] = ((pixel2 >> 16) & 0xff) / 255.0f; // r
+    color[1] = ((pixel2 >>  8) & 0xff) / 255.0f; // g
+    color[2] = ((pixel2 >>  0) & 0xff) / 255.0f; // b
+    color[3] = ((pixel2 >> 24) & 0xff) / 255.0f; // a
+    res = pd3dDevice->SetPixelShaderConstantF(2, color, 1);
+
+    // set up texture coordinate transform with identity matrix, which
+    // will have the effect of passing the current window-space coordinates
+    // through to the TEXCOORD0/1 register used by the basic gradient
+    // pixel shader
+    DWORD sampler = useMask ? 1 : 0;
+    D3DMATRIX mt;
+    ZeroMemory(&mt, sizeof(mt));
+    mt._11 = 1.0f;
+    mt._21 = 0.0f;
+    mt._31 = 0.0f;
+    mt._41 = 0.0f;
+    mt._12 = 0.0f;
+    mt._22 = 1.0f;
+    mt._32 = 0.0f;
+    mt._42 = 0.0f;
+    pd3dDevice->SetTransform(useMask ? D3DTS_TEXTURE1 : D3DTS_TEXTURE0, &mt);
+    pd3dDevice->SetTextureStageState(sampler, D3DTSS_TEXCOORDINDEX,
+                                     D3DTSS_TCI_CAMERASPACEPOSITION);
+    pd3dDevice->SetTextureStageState(sampler, D3DTSS_TEXTURETRANSFORMFLAGS,
+                                     D3DTTFF_COUNT2);
+#endif
+
+    // pixel state has been set appropriately in D3DPaints_ResetPaint()
+    d3dc->useMask = useMask;
+    d3dc->SetPaintState(PAINT_GRADIENT);
+    return res;
+}
+
+/************************** TexturePaint support ****************************/
+
+HRESULT
+D3DPaints_SetTexturePaint(D3DContext *d3dc,
+                          jboolean useMask,
+                          jlong pSrcOps, jboolean filter,
+                          jdouble xp0, jdouble xp1, jdouble xp3,
+                          jdouble yp0, jdouble yp1, jdouble yp3)
+{
+    D3DSDOps *srcOps = (D3DSDOps *)jlong_to_ptr(pSrcOps);
+    IDirect3DDevice9 *pd3dDevice;
+    HRESULT res;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPaints_SetTexturePaint");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    RETURN_STATUS_IF_NULL(srcOps, E_FAIL);
+    RETURN_STATUS_IF_NULL(srcOps->pResource, E_FAIL);
+    D3DPaints_ResetPaint(d3dc);
+
+    DWORD sampler = useMask ? 1 : 0;
+    DWORD dwFilter = filter ? D3DTEXF_LINEAR : D3DTEXF_POINT;
+    res = d3dc->SetTexture(srcOps->pResource->GetTexture(), sampler);
+    d3dc->UpdateTextureColorState(D3DTA_TEXTURE, sampler);
+    pd3dDevice = d3dc->Get3DDevice();
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_MAGFILTER, dwFilter);
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_MINFILTER, dwFilter);
+
+    D3DMATRIX mt;
+    ZeroMemory(&mt, sizeof(mt));
+
+    // offset by a half texel to correctly map texels to pixels
+    //  m02 = tx * m00 + ty * m01 + m02;
+    //  m12 = tx * m10 + ty * m11 + m12;
+    jdouble tx = (1 / (2.0f * srcOps->pResource->GetDesc()->Width));
+    jdouble ty = (1 / (2.0f * srcOps->pResource->GetDesc()->Height));
+    xp3 = tx * xp0 + ty * xp1 + xp3;
+    yp3 = tx * yp0 + ty * yp1 + yp3;
+
+    mt._11 = (float)xp0;
+    mt._21 = (float)xp1;
+    mt._31 = (float)0.0;
+    mt._41 = (float)xp3;
+    mt._12 = (float)yp0;
+    mt._22 = (float)yp1;
+    mt._32 = (float)0.0;
+    mt._42 = (float)yp3;
+    pd3dDevice->SetTransform(useMask ? D3DTS_TEXTURE1 : D3DTS_TEXTURE0, &mt);
+    pd3dDevice->SetTextureStageState(sampler, D3DTSS_TEXCOORDINDEX,
+                                     D3DTSS_TCI_CAMERASPACEPOSITION);
+    pd3dDevice->SetTextureStageState(sampler, D3DTSS_TEXTURETRANSFORMFLAGS,
+                                     D3DTTFF_COUNT2);
+
+    // pixel state has been set appropriately in D3DPaints_ResetPaint()
+    d3dc->useMask = useMask;
+    d3dc->SetPaintState(PAINT_TEXTURE);
+    return res;
+}
+
+/****************** Shared MultipleGradientPaint support ********************/
+
+/** Composes the given parameters as flags into the given flags variable.*/
+#define COMPOSE_FLAGS(flags, cycleMethod, large, useMask, linear) \
+    do {                                                        \
+        flags |= ((cycleMethod) & MULTI_GRAD_CYCLE_METHOD);     \
+        if (large)   flags |= MULTI_GRAD_LARGE;                 \
+        if (useMask) flags |= MULTI_GRAD_USE_MASK;              \
+        if (linear)  flags |= MULTI_GRAD_LINEAR_RGB;            \
+    } while (0)
+
+/**
+ * The maximum number of gradient "stops" supported by the fragment shader
+ * and related code.  When the MULTI_GRAD_LARGE flag is set, we will use
+ * MAX_FRACTIONS_LARGE; otherwise, we use MAX_FRACTIONS_SMALL.  By having
+ * two separate values, we can have one highly optimized shader (SMALL) that
+ * supports only a few fractions/colors, and then another, less optimal
+ * shader that supports more stops.
+ */
+#define MAX_FRACTIONS \
+    sun_java2d_d3d_D3DPaints_MultiGradient_MULTI_MAX_FRACTIONS_D3D
+#define MAX_FRACTIONS_LARGE MAX_FRACTIONS
+#define MAX_FRACTIONS_SMALL 4
+
+/**
+ * Called from the D3DPaints_SetLinear/RadialGradientPaint() methods
+ * in order to setup the fraction/color values that are common to both.
+ */
+static HRESULT
+D3DPaints_SetMultiGradientPaint(D3DContext *d3dc,
+                                jboolean useMask, jint numStops,
+                                void *pFractions, void *pPixels)
+{
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice;
+    IDirect3DTexture9 *pMultiGradientTex;
+    D3DResource *pMultiGradientTexRes;
+    jint maxFractions = (numStops > MAX_FRACTIONS_SMALL) ?
+        MAX_FRACTIONS_LARGE : MAX_FRACTIONS_SMALL;
+    jfloat stopVals[MAX_FRACTIONS * 4];
+    jfloat *fractions = (jfloat *)pFractions;
+    juint *pixels = (juint *)pPixels;
+    int i;
+    int fIndex = 0;
+
+    pd3dDevice = d3dc->Get3DDevice();
+
+    // update the "uniform" fractions and scale factors
+    for (i = 0; i < maxFractions; i++) {
+        stopVals[fIndex+0] = (i < numStops)   ?
+            fractions[i] : 0.0f;
+        stopVals[fIndex+1] = (i < numStops-1) ?
+            1.0f / (fractions[i+1] - fractions[i]) : 0.0f;
+        stopVals[fIndex+2] = 0.0f; // unused
+        stopVals[fIndex+3] = 0.0f; // unused
+        fIndex += 4;
+    }
+    pd3dDevice->SetPixelShaderConstantF(0, stopVals, maxFractions);
+
+    // this will initialize the multi-gradient texture, if necessary
+    res = d3dc->GetResourceManager()->
+        GetMultiGradientTexture(&pMultiGradientTexRes);
+    RETURN_STATUS_IF_FAILED(res);
+
+    pMultiGradientTex = pMultiGradientTexRes->GetTexture();
+
+    // update the texture containing the gradient colors
+    D3DLOCKED_RECT lockedRect;
+    res = pMultiGradientTex->LockRect(0, &lockedRect, NULL, D3DLOCK_NOSYSLOCK);
+    RETURN_STATUS_IF_FAILED(res);
+
+    juint *pPix = (juint*)lockedRect.pBits;
+    memcpy(pPix, pixels, numStops*sizeof(juint));
+    if (numStops < MAX_MULTI_GRADIENT_COLORS) {
+        // when we don't have enough colors to fill the entire
+        // color gradient, we have to replicate the last color
+        // in the right-most texel for the NO_CYCLE case where the
+        // texcoord is sometimes forced to 1.0
+        pPix[MAX_MULTI_GRADIENT_COLORS-1] = pixels[numStops-1];
+    }
+    pMultiGradientTex->UnlockRect(0);
+
+    // set the gradient texture and update relevant state
+    DWORD sampler = useMask ? 1 : 0;
+    res = d3dc->SetTexture(pMultiGradientTex, sampler);
+    d3dc->UpdateTextureColorState(D3DTA_TEXTURE, sampler);
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
+    pd3dDevice->SetSamplerState(sampler, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
+
+    // set up texture coordinate transform with identity matrix, which
+    // will have the effect of passing the current window-space coordinates
+    // through to the TEXCOORD0/1 register used by the multi-stop
+    // gradient pixel shader
+    D3DMATRIX mt;
+    ZeroMemory(&mt, sizeof(mt));
+    mt._11 = 1.0f;
+    mt._21 = 0.0f;
+    mt._31 = 0.0f;
+    mt._41 = 0.0f;
+    mt._12 = 0.0f;
+    mt._22 = 1.0f;
+    mt._32 = 0.0f;
+    mt._42 = 0.0f;
+    pd3dDevice->SetTransform(useMask ? D3DTS_TEXTURE1 : D3DTS_TEXTURE0, &mt);
+    pd3dDevice->SetTextureStageState(sampler, D3DTSS_TEXCOORDINDEX,
+                                     D3DTSS_TCI_CAMERASPACEPOSITION);
+    pd3dDevice->SetTextureStageState(sampler, D3DTSS_TEXTURETRANSFORMFLAGS,
+                                     D3DTTFF_COUNT2);
+    return res;
+}
+
+/********************** LinearGradientPaint support *************************/
+
+HRESULT
+D3DPaints_SetLinearGradientPaint(D3DContext *d3dc, D3DSDOps *dstOps,
+                                 jboolean useMask, jboolean linear,
+                                 jint cycleMethod, jint numStops,
+                                 jfloat p0, jfloat p1, jfloat p3,
+                                 void *fractions, void *pixels)
+{
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice;
+    jfloat params[4];
+    jboolean large = (numStops > MAX_FRACTIONS_SMALL);
+    jint flags = 0;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPaints_SetLinearGradientPaint");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps, E_FAIL);
+    D3DPaints_ResetPaint(d3dc);
+
+    COMPOSE_FLAGS(flags, cycleMethod, large, useMask, linear);
+
+    // locate/enable the shader program for the given flags
+    res = d3dc->EnableLinearGradientProgram(flags);
+    RETURN_STATUS_IF_FAILED(res);
+
+    // update the common "uniform" values (fractions and colors)
+    D3DPaints_SetMultiGradientPaint(d3dc, useMask,
+                                    numStops, fractions, pixels);
+
+    // update the other "uniform" values
+    params[0] = p0;
+    params[1] = p1;
+    params[2] = p3;
+    params[3] = 0.0f; // unused
+    pd3dDevice = d3dc->Get3DDevice();
+    res = pd3dDevice->SetPixelShaderConstantF(16, params, 1);
+
+    // pixel state has been set appropriately in D3DPaints_ResetPaint()
+    d3dc->useMask = useMask;
+    d3dc->SetPaintState(PAINT_LIN_GRADIENT);
+    return res;
+}
+
+/********************** RadialGradientPaint support *************************/
+
+HRESULT
+D3DPaints_SetRadialGradientPaint(D3DContext *d3dc, D3DSDOps *dstOps,
+                                 jboolean useMask, jboolean linear,
+                                 jint cycleMethod, jint numStops,
+                                 jfloat m00, jfloat m01, jfloat m02,
+                                 jfloat m10, jfloat m11, jfloat m12,
+                                 jfloat focusX,
+                                 void *fractions, void *pixels)
+{
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice;
+    jfloat denom, inv_denom;
+    jfloat params[4];
+    jboolean large = (numStops > MAX_FRACTIONS_SMALL);
+    jint flags = 0;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPaints_SetRadialGradientPaint");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps, E_FAIL);
+    D3DPaints_ResetPaint(d3dc);
+
+    COMPOSE_FLAGS(flags, cycleMethod, large, useMask, linear);
+
+    // locate/enable the shader program for the given flags
+    res = d3dc->EnableRadialGradientProgram(flags);
+    RETURN_STATUS_IF_FAILED(res);
+
+    // update the common "uniform" values (fractions and colors)
+    D3DPaints_SetMultiGradientPaint(d3dc, useMask,
+                                    numStops, fractions, pixels);
+
+    // update the other "uniform" values
+    params[0] = m00;
+    params[1] = m01;
+    params[2] = m02;
+    params[3] = 0.0f; // unused
+    pd3dDevice = d3dc->Get3DDevice();
+    pd3dDevice->SetPixelShaderConstantF(16, params, 1);
+
+    params[0] = m10;
+    params[1] = m11;
+    params[2] = m12;
+    params[3] = 0.0f; // unused
+    pd3dDevice->SetPixelShaderConstantF(17, params, 1);
+
+    // pack a few unrelated, precalculated values into a single float4
+    denom = 1.0f - (focusX * focusX);
+    inv_denom = 1.0f / denom;
+    params[0] = focusX;
+    params[1] = denom;
+    params[2] = inv_denom;
+    params[3] = 0.0f; // unused
+    res = pd3dDevice->SetPixelShaderConstantF(18, params, 1);
+
+    // pixel state has been set appropriately in D3DPaints_ResetPaint()
+    d3dc->useMask = useMask;
+    d3dc->SetPaintState(PAINT_RAD_GRADIENT);
+    return res;
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPaints.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPaints.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPaints.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPaints.h	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef D3DPaints_h_Included
+#define D3DPaints_h_Included
+
+#include "sun_java2d_SunGraphics2D.h"
+
+#include "D3DContext.h"
+#include "D3DSurfaceData.h"
+
+HRESULT D3DPaints_ResetPaint(D3DContext *d3dc);
+HRESULT D3DPaints_SetColor(D3DContext *d3dc, jint pixel);
+
+/************************* GradientPaint support ****************************/
+
+/**
+ * Flags that can be bitwise-or'ed together to control how the shader
+ * source code is generated.
+ */
+#define BASIC_GRAD_IS_CYCLIC (1 << 0)
+#define BASIC_GRAD_USE_MASK  (1 << 1)
+
+HRESULT D3DPaints_SetGradientPaint(D3DContext *d3dc,
+                                jboolean useMask, jboolean cyclic,
+                                jdouble p0, jdouble p1, jdouble p3,
+                                jint pixel1, jint pixel2);
+
+/************************** TexturePaint support ****************************/
+
+HRESULT D3DPaints_SetTexturePaint(D3DContext *d3dc,
+                               jboolean useMask,
+                               jlong pSrcOps, jboolean filter,
+                               jdouble xp0, jdouble xp1, jdouble xp3,
+                               jdouble yp0, jdouble yp1, jdouble yp3);
+
+/****************** Shared MultipleGradientPaint support ********************/
+
+/**
+ * These constants are identical to those defined in the
+ * MultipleGradientPaint.CycleMethod enum; they are copied here for
+ * convenience (ideally we would pull them directly from the Java level,
+ * but that entails more hassle than it is worth).
+ */
+#define CYCLE_NONE    0
+#define CYCLE_REFLECT 1
+#define CYCLE_REPEAT  2
+
+/**
+ * The following constants are flags that can be bitwise-or'ed together
+ * to control how the MultipleGradientPaint shader source code is generated:
+ *
+ *   MULTI_GRAD_CYCLE_METHOD
+ *     Placeholder for the CycleMethod enum constant.
+ *
+ *   MULTI_GRAD_LARGE
+ *     If set, use the (slower) shader that supports a larger number of
+ *     gradient colors; otherwise, use the optimized codepath.  See
+ *     the MAX_FRACTIONS_SMALL/LARGE constants below for more details.
+ *
+ *   MULTI_GRAD_USE_MASK
+ *     If set, apply the alpha mask value from texture unit 1 to the
+ *     final color result (only used in the MaskFill case).
+ *
+ *   MULTI_GRAD_LINEAR_RGB
+ *     If set, convert the linear RGB result back into the sRGB color space.
+ */
+#define MULTI_GRAD_CYCLE_METHOD (3 << 0)
+#define MULTI_GRAD_LARGE        (1 << 2)
+#define MULTI_GRAD_USE_MASK     (1 << 3)
+#define MULTI_GRAD_LINEAR_RGB   (1 << 4)
+
+/**
+ * The maximum number of gradient colors supported by all of the gradient
+ * fragment shaders.  Note that this value must be a power of two, as it
+ * determines the size of the 1D texture created below.  It also must be
+ * greater than or equal to MAX_FRACTIONS (there is no strict requirement
+ * that the two values be equal).
+ */
+#define MAX_MULTI_GRADIENT_COLORS 16
+
+/********************** LinearGradientPaint support *************************/
+
+HRESULT D3DPaints_SetLinearGradientPaint(D3DContext *d3dc, D3DSDOps *dstOps,
+                                         jboolean useMask, jboolean linear,
+                                         jint cycleMethod, jint numStops,
+                                         jfloat p0, jfloat p1, jfloat p3,
+                                         void *fractions, void *pixels);
+
+/********************** RadialGradientPaint support *************************/
+
+HRESULT D3DPaints_SetRadialGradientPaint(D3DContext *d3dc, D3DSDOps *dstOps,
+                                         jboolean useMask, jboolean linear,
+                                         jint cycleMethod, jint numStops,
+                                         jfloat m00, jfloat m01, jfloat m02,
+                                         jfloat m10, jfloat m11, jfloat m12,
+                                         jfloat focusX,
+                                         void *fractions, void *pixels);
+
+/************************ SunGraphics2D constants ***************************/
+
+#define PAINT_CUSTOM       sun_java2d_SunGraphics2D_PAINT_CUSTOM
+#define PAINT_TEXTURE      sun_java2d_SunGraphics2D_PAINT_TEXTURE
+#define PAINT_RAD_GRADIENT sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT
+#define PAINT_LIN_GRADIENT sun_java2d_SunGraphics2D_PAINT_LIN_GRADIENT
+#define PAINT_GRADIENT     sun_java2d_SunGraphics2D_PAINT_GRADIENT
+#define PAINT_ALPHACOLOR   sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR
+#define PAINT_OPAQUECOLOR  sun_java2d_SunGraphics2D_PAINT_OPAQUECOLOR
+
+#endif /* D3DPaints_h_Included */
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPipeline.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPipeline.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPipeline.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPipeline.cpp	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "D3DPipeline.h"
+
+BOOL APIENTRY DllMain( HANDLE hModule,
+                       DWORD  ul_reason_for_call,
+                       LPVOID lpReserved)
+{
+    switch (ul_reason_for_call) {
+    case DLL_PROCESS_ATTACH:
+    case DLL_THREAD_ATTACH:
+    case DLL_THREAD_DETACH:
+    case DLL_PROCESS_DETACH:
+        break;
+    }
+    return TRUE;
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPipeline.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPipeline.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPipeline.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPipeline.h	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+#pragma once
+
+#ifdef DEBUG
+#define D3D_DEBUG_INFO
+#endif // DEBUG
+
+#ifdef D3D_PPL_DLL
+
+
+    #ifndef WIN32_LEAN_AND_MEAN
+    #define WIN32_LEAN_AND_MEAN
+    #endif
+
+    #ifdef D3DPIPELINE_EXPORTS
+    #define D3DPIPELINE_API __declspec(dllexport)
+    #else
+    #define D3DPIPELINE_API __declspec(dllimport)
+    #endif
+
+    #include <windows.h>
+    #include <d3d9.h>
+    #include <DDErr.h>
+    #include "..\Import\Trace.h"
+
+    #define DebugPrintD3DError(res, msg) \
+        DXTRACE_ERR(msg, res)
+
+#else
+
+    #define D3DPIPELINE_API __declspec(dllexport)
+
+    // this include ensures that with debug build we get
+    // awt's overridden debug "new" and "delete" operators
+    #include "awt.h"
+
+    #include <windows.h>
+    #include <d3d9.h>
+    #include "Trace.h"
+
+    #define DebugPrintD3DError(res, msg) \
+        J2dTraceLn1(J2D_TRACE_ERROR, "D3D Error: " ## msg ## " res=%d", res)
+
+#endif /*D3D_PPL_DLL*/
+
+// some helper macros
+#define SAFE_RELEASE(RES) \
+do {                      \
+    if ((RES)!= NULL) {   \
+        (RES)->Release(); \
+        (RES) = NULL;     \
+    }                     \
+} while (0);
+
+#define SAFE_DELETE(RES)  \
+do {                      \
+    if ((RES)!= NULL) {   \
+        delete (RES);     \
+        (RES) = NULL;     \
+    }                     \
+} while (0);
+
+#ifdef DEBUG
+#define SAFE_PRINTLN(RES) \
+do {                      \
+    if ((RES)!= NULL) {   \
+        J2dTraceLn1(J2D_TRACE_VERBOSE, "  " ## #RES ## "=0x%x", (RES)); \
+    } else {              \
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  " ## #RES ## "=NULL"); \
+    }                     \
+} while (0);
+#else // DEBUG
+#define SAFE_PRINTLN(RES)
+#endif // DEBUG
+
+/*
+ * The following macros allow the caller to return (or continue) if the
+ * provided value is NULL.  (The strange else clause is included below to
+ * allow for a trailing ';' after RETURN/CONTINUE_IF_NULL() invocations.)
+ */
+#define ACT_IF_NULL(ACTION, value)         \
+    if ((value) == NULL) {                 \
+        J2dTraceLn3(J2D_TRACE_ERROR,       \
+                    "%s is null in %s:%d", #value, __FILE__, __LINE__); \
+        ACTION;                            \
+    } else do { } while (0)
+#define RETURN_IF_NULL(value)   ACT_IF_NULL(return, value)
+#define CONTINUE_IF_NULL(value) ACT_IF_NULL(continue, value)
+#define RETURN_STATUS_IF_NULL(value, status) \
+        ACT_IF_NULL(return (status), value)
+
+#define RETURN_STATUS_IF_EXP_FAILED(EXPR) \
+    if (FAILED(res = (EXPR))) {                    \
+        DebugPrintD3DError(res, " " ## #EXPR ## " failed in " ## __FILE__); \
+        return res;                   \
+    } else do { } while (0)
+
+#define RETURN_STATUS_IF_FAILED(status) \
+    if (FAILED((status))) {                    \
+        DebugPrintD3DError((status), " failed in " ## __FILE__ ## ", return;");\
+        return (status);                   \
+    } else do { } while (0)
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPipelineManager.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPipelineManager.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPipelineManager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPipelineManager.cpp	2011-01-08 01:26:50.475202254 +0000
@@ -0,0 +1,936 @@
+/*
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "D3DBadHardware.h"
+#include "D3DPipelineManager.h"
+#include "D3DRenderQueue.h"
+#include "WindowsFlags.h"
+#include "awt_Win32GraphicsDevice.h"
+
+// state of the adapter prior to initialization
+#define CONTEXT_NOT_INITED 0
+// this state is set if adapter initialization had failed
+#define CONTEXT_INIT_FAILED (-1)
+// this state is set if adapter was successfully created
+#define CONTEXT_CREATED 1
+
+static BOOL bNoHwCheck = (getenv("J2D_D3D_NO_HWCHECK") != NULL);
+
+D3DPipelineManager *D3DPipelineManager::pMgr = NULL;
+
+D3DPipelineManager * D3DPipelineManager::CreateInstance(void)
+{
+    if (!IsD3DEnabled() ||
+        FAILED((D3DPipelineManager::CheckOSVersion())) ||
+        FAILED((D3DPipelineManager::GDICheckForBadHardware())))
+    {
+        return NULL;
+    }
+
+    if (pMgr == NULL) {
+        pMgr = new D3DPipelineManager();
+        if (FAILED(pMgr->InitD3D())) {
+            SAFE_DELETE(pMgr);
+        }
+    } else {
+        // this should never happen so to be on the safe side do not
+        // use this unexpected pointer, do not try to release it, just null
+        // it out and fail safely
+        J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                       "D3DPPLM::CreateInstance: unexpected instance: 0x%x,"\
+                       " abort.", pMgr);
+        pMgr = NULL;
+    }
+    return pMgr;
+}
+
+void D3DPipelineManager::DeleteInstance()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::DeleteInstance()");
+    SAFE_DELETE(pMgr);
+}
+
+D3DPipelineManager * D3DPipelineManager::GetInstance(void)
+{
+    return pMgr;
+}
+
+D3DPipelineManager::D3DPipelineManager(void)
+{
+    pd3d9 = NULL;
+    hLibD3D9 = NULL;
+    pAdapters = NULL;
+    adapterCount = 0;
+    currentFSFocusAdapter = -1;
+    defaultFocusWindow = 0;
+    devType = SelectDeviceType();
+}
+
+D3DPipelineManager::~D3DPipelineManager(void)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::~D3DPipelineManager()");
+    ReleaseD3D();
+}
+
+HRESULT D3DPipelineManager::ReleaseD3D(void)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::ReleaseD3D()");
+
+    ReleaseAdapters();
+
+    SAFE_RELEASE(pd3d9);
+
+    if (hLibD3D9 != NULL) {
+        ::FreeLibrary(hLibD3D9);
+        hLibD3D9 = NULL;
+    }
+
+    return S_OK;
+}
+
+// Creates a Direct3D9 object and initializes adapters.
+// If succeeded, returns S_OK, otherwise returns the error code.
+HRESULT D3DPipelineManager::InitD3D(void)
+{
+    typedef IDirect3D9 * WINAPI FnDirect3DCreate9(UINT SDKVersion);
+
+    hLibD3D9 = ::LoadLibrary(TEXT("d3d9.dll"));
+    if (hLibD3D9 == NULL) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR, "InitD3D: no d3d9.dll");
+        return E_FAIL;
+    }
+
+    FnDirect3DCreate9 *d3dcreate9 = NULL;
+    d3dcreate9 = (FnDirect3DCreate9*)
+        ::GetProcAddress(hLibD3D9, "Direct3DCreate9");
+    if (d3dcreate9 == NULL) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR, "InitD3D: no Direct3DCreate9");
+        ::FreeLibrary(hLibD3D9);
+        return E_FAIL;
+    }
+
+    pd3d9 = d3dcreate9(D3D_SDK_VERSION);
+    if (pd3d9 == NULL) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+            "InitD3D: unable to create IDirect3D9 object");
+        ::FreeLibrary(hLibD3D9);
+        return E_FAIL;
+    }
+
+    HRESULT res;
+    if (FAILED(res = InitAdapters())) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR, "InitD3D: failed to init adapters");
+        ReleaseD3D();
+        return res;
+    }
+
+    return S_OK;
+}
+
+HRESULT D3DPipelineManager::ReleaseAdapters()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::ReleaseAdapters()");
+
+    D3DRQ_ResetCurrentContextAndDestination();
+    if (pAdapters != NULL) {
+        for (UINT i = 0; i < adapterCount; i++) {
+            if (pAdapters[i].pd3dContext != NULL) {
+                delete pAdapters[i].pd3dContext;
+            }
+        }
+        delete[] pAdapters;
+        pAdapters = NULL;
+    }
+    if (defaultFocusWindow != 0) {
+        DestroyWindow(defaultFocusWindow);
+        UnregisterClass(L"D3DFocusWindow", GetModuleHandle(NULL));
+        defaultFocusWindow = 0;
+    }
+    currentFSFocusAdapter = -1;
+    return S_OK;
+}
+
+// static
+void D3DPipelineManager::NotifyAdapterEventListeners(UINT adapter,
+                                                     jint eventType)
+{
+    HMONITOR hMon;
+    int gdiScreen;
+    D3DPipelineManager *pMgr;
+    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+
+    pMgr = D3DPipelineManager::GetInstance();
+    RETURN_IF_NULL(pMgr);
+    hMon = pMgr->pd3d9->GetAdapterMonitor(adapter);
+    gdiScreen = AwtWin32GraphicsDevice::GetScreenFromMHND((MHND)hMon);
+
+    JNU_CallStaticMethodByName(env, NULL,
+        "sun/java2d/pipe/hw/AccelDeviceEventNotifier",
+        "eventOccured", "(II)V",
+        gdiScreen, eventType);
+}
+
+UINT D3DPipelineManager::GetAdapterOrdinalForScreen(jint gdiScreen)
+{
+    MHND mHnd = AwtWin32GraphicsDevice::GetMonitor(gdiScreen);
+    if (mHnd == (MHND)0) {
+        return D3DADAPTER_DEFAULT;
+    }
+    return GetAdapterOrdinalByHmon((HMONITOR)mHnd);
+}
+
+// static
+HRESULT D3DPipelineManager::HandleAdaptersChange(HMONITOR *pMHNDs, UINT monNum)
+{
+    HRESULT res = S_OK;
+    BOOL bResetD3D = FALSE, bFound;
+
+    D3DPipelineManager *pMgr = D3DPipelineManager::GetInstance();
+    RETURN_STATUS_IF_NULL(pMHNDs, E_FAIL);
+    if (pMgr == NULL) {
+        // NULL pMgr is valid when the pipeline is not enabled or if it hasn't
+        // been created yet
+        return S_OK;
+    }
+    RETURN_STATUS_IF_NULL(pMgr->pAdapters, E_FAIL);
+    RETURN_STATUS_IF_NULL(pMgr->pd3d9, E_FAIL);
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::HandleAdaptersChange");
+
+    if (monNum != pMgr->adapterCount) {
+        J2dTraceLn2(J2D_TRACE_VERBOSE,
+                   "  number of adapters changed (old=%d, new=%d)",
+                   pMgr->adapterCount, monNum);
+        bResetD3D = TRUE;
+    } else {
+        for (UINT i = 0; i < pMgr->adapterCount; i++) {
+            HMONITOR hMon = pMgr->pd3d9->GetAdapterMonitor(i);
+            if (hMon == (HMONITOR)0x0) {
+                J2dTraceLn1(J2D_TRACE_VERBOSE, "  adapter %d: removed", i);
+                bResetD3D = TRUE;
+                break;
+            }
+            bFound = FALSE;
+            for (UINT mon = 0; mon < monNum; mon++) {
+                if (pMHNDs[mon] == hMon) {
+                    J2dTraceLn3(J2D_TRACE_VERBOSE,
+                            "  adapter %d: found hmnd[%d]=0x%x", i, mon, hMon);
+                    bFound = TRUE;
+                    break;
+                }
+            }
+            if (!bFound) {
+                J2dTraceLn2(J2D_TRACE_VERBOSE,
+                            "  adapter %d: could not find hmnd=0x%x "\
+                            "in the list of new hmnds", i, hMon);
+                bResetD3D = TRUE;
+                break;
+            }
+        }
+    }
+
+    if (bResetD3D) {
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  adapters changed: resetting d3d");
+        pMgr->ReleaseD3D();
+        res = pMgr->InitD3D();
+    }
+    return res;
+}
+
+HRESULT D3DPipelineManager::HandleLostDevices()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::HandleLostDevices()");
+    BOOL bAllClear = TRUE;
+
+    HWND hwnd = GetCurrentFocusWindow();
+    if (hwnd != defaultFocusWindow) {
+        // we're in full-screen mode
+        WINDOWPLACEMENT wp;
+        ::ZeroMemory(&wp, sizeof(WINDOWPLACEMENT));
+        wp.length = sizeof(WINDOWPLACEMENT);
+        ::GetWindowPlacement(hwnd, &wp);
+
+        // Only attempt to restore the devices if we're in full-screen mode
+        // and the fs window is active; sleep otherwise.
+        // Restoring a window while minimized causes problems on Vista:
+        // sometimes we restore the window too quickly and it pops up back from
+        // minimized state when the device is restored.
+        //
+        // WARNING: this is a sleep on the Toolkit thread! We may reconsider
+        // this if we find any issues later.
+        if ((wp.showCmd & SW_SHOWMINNOACTIVE) && !(wp.showCmd & SW_SHOWNORMAL)){
+            static DWORD prevCallTime = 0;
+            J2dTraceLn(J2D_TRACE_VERBOSE, "  fs focus window is minimized");
+            DWORD currentTime = ::GetTickCount();
+            if ((currentTime - prevCallTime) < 100) {
+                J2dTraceLn(J2D_TRACE_VERBOSE, "  tight loop detected, sleep");
+                ::Sleep(100);
+            }
+            prevCallTime = currentTime;
+            return D3DERR_DEVICELOST;
+        }
+    }
+    if (pAdapters != NULL) {
+        for (UINT i = 0; i < adapterCount; i++) {
+            if (pAdapters[i].pd3dContext != NULL) {
+                J2dTraceLn1(J2D_TRACE_VERBOSE,
+                            "  HandleLostDevices: checking adapter %d", i);
+                D3DContext *d3dc = pAdapters[i].pd3dContext;
+                if (FAILED(d3dc->CheckAndResetDevice())) {
+                    bAllClear = FALSE;
+                }
+            }
+        }
+    }
+    return bAllClear ? S_OK : D3DERR_DEVICELOST;
+}
+
+HRESULT D3DPipelineManager::InitAdapters()
+{
+    HRESULT res = E_FAIL;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::InitAdapters()");
+    if (pAdapters != NULL) {
+        ReleaseAdapters();
+    }
+
+    adapterCount = pd3d9->GetAdapterCount();
+    pAdapters = new D3DAdapter[adapterCount];
+    if (pAdapters == NULL) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR, "InitAdapters: out of memory");
+        adapterCount = 0;
+        return E_FAIL;
+    }
+    ZeroMemory(pAdapters, adapterCount * sizeof(D3DAdapter));
+
+    res = CheckAdaptersInfo();
+    RETURN_STATUS_IF_FAILED(res);
+
+    currentFSFocusAdapter = -1;
+    if (CreateDefaultFocusWindow() == 0) {
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+// static
+HRESULT
+D3DPipelineManager::CheckOSVersion()
+{
+    // require Windows XP or newer client-class OS
+    if (IS_WINVER_ATLEAST(5, 1) &&
+        !D3DPPLM_OsVersionMatches(OS_WINSERV_2008|OS_WINSERV_2003))
+    {
+        J2dTraceLn(J2D_TRACE_INFO,
+                   "D3DPPLM::CheckOSVersion: Windows XP or newer client-classs"\
+                   " OS detected, passed");
+        return S_OK;
+    }
+    J2dRlsTraceLn(J2D_TRACE_ERROR,
+                  "D3DPPLM::CheckOSVersion: Windows 2000 or earlier (or a "\
+                  "server) OS detected, failed");
+    if (bNoHwCheck) {
+        J2dRlsTraceLn(J2D_TRACE_WARNING,
+                      "  OS check overridden via J2D_D3D_NO_HWCHECK");
+        return S_OK;
+    }
+    return E_FAIL;
+}
+
+// static
+HRESULT
+D3DPipelineManager::GDICheckForBadHardware()
+{
+    _DISPLAY_DEVICE dd;
+    dd.dwSize = sizeof(DISPLAY_DEVICE);
+
+    int failedDevices = 0;
+    int attachedDevices = 0;
+    int i = 0;
+    WCHAR *id;
+    WCHAR vendorId[5];
+    WCHAR deviceId[5];
+    DWORD dwDId, dwVId;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::GDICheckForBadHardware");
+
+    // i<20 is to guard against buggy drivers
+    while (EnumDisplayDevices(NULL, i, &dd, 0) && i < 20) {
+        if (dd.dwFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) {
+            attachedDevices++;
+            id = dd.deviceID;
+            if (wcslen(id) > 21) {
+                // get vendor ID
+                wcsncpy(vendorId, id+8, 4);
+                int args1 = swscanf(vendorId, L"%X", &dwVId);
+
+                // get device ID
+                wcsncpy(deviceId, id+17, 4);
+                int args2 = swscanf(deviceId, L"%X", &dwDId);
+
+                if (args1 == 1 && args2 == 1) {
+                    J2dTraceLn2(J2D_TRACE_VERBOSE,
+                                "  device: vendorID=0x%04x, deviceId=0x%04x",
+                                dwVId, dwDId);
+                    // since we don't have a driver version here we will
+                    // just ask to ignore the version for now; bad hw
+                    // entries with specific drivers information will be
+                    // processed later when d3d is initialized and we can
+                    // obtain a driver version
+                    if (FAILED(CheckForBadHardware(dwVId, dwDId, MAX_VERSION))){
+                        failedDevices++;
+                    }
+                }
+            }
+        }
+
+        i++;
+    }
+
+    if (failedDevices == attachedDevices) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+            "D3DPPLM::GDICheckForBadHardware: no suitable devices found");
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+BOOL D3DPPLM_OsVersionMatches(USHORT osInfo) {
+    static USHORT currentOS = OS_UNDEFINED;
+
+    if (currentOS == OS_UNDEFINED) {
+        BOOL bVersOk;
+        OSVERSIONINFOEX osvi;
+
+        ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
+        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
+
+        bVersOk = GetVersionEx((OSVERSIONINFO *) &osvi);
+
+        J2dRlsTrace(J2D_TRACE_INFO, "[I] OS Version = ");
+        if (bVersOk && osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
+            osvi.dwMajorVersion > 4)
+        {
+            if (osvi.dwMajorVersion >= 6 && osvi.dwMinorVersion >= 0) {
+                if (osvi.wProductType == VER_NT_WORKSTATION) {
+                    J2dRlsTrace(J2D_TRACE_INFO, "OS_VISTA or newer\n");
+                    currentOS = OS_VISTA;
+                } else {
+                    J2dRlsTrace(J2D_TRACE_INFO, "OS_WINSERV_2008 or newer\n");
+                    currentOS = OS_WINSERV_2008;
+                }
+            } else if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2) {
+                if (osvi.wProductType == VER_NT_WORKSTATION) {
+                    J2dRlsTrace(J2D_TRACE_INFO, "OS_WINXP_64\n");
+                    currentOS = OS_WINXP_64;
+                } else {
+                    J2dRlsTrace(J2D_TRACE_INFO, "OS_WINSERV_2003\n");
+                    currentOS = OS_WINSERV_2003;
+                }
+            } else if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1) {
+                J2dRlsTrace(J2D_TRACE_INFO, "OS_WINXP ");
+                currentOS = OS_WINXP;
+                if (osvi.wSuiteMask & VER_SUITE_PERSONAL) {
+                    J2dRlsTrace(J2D_TRACE_INFO, "Home\n");
+                } else {
+                    J2dRlsTrace(J2D_TRACE_INFO, "Pro\n");
+                }
+            } else {
+                J2dRlsTrace2(J2D_TRACE_INFO,
+                            "OS_UNKNOWN: dwMajorVersion=%d dwMinorVersion=%d\n",
+                             osvi.dwMajorVersion, osvi.dwMinorVersion);
+                currentOS = OS_UNKNOWN;
+            }
+        } else {
+            if (bVersOk) {
+                J2dRlsTrace2(J2D_TRACE_INFO,
+                             "OS_UNKNOWN: dwPlatformId=%d dwMajorVersion=%d\n",
+                             osvi.dwPlatformId, osvi.dwMajorVersion);
+            } else {
+                J2dRlsTrace(J2D_TRACE_INFO,"OS_UNKNOWN: GetVersionEx failed\n");
+            }
+            currentOS = OS_UNKNOWN;
+        }
+    }
+    return (currentOS & osInfo);
+}
+
+// static
+HRESULT
+D3DPipelineManager::CheckForBadHardware(DWORD vId, DWORD dId, LONGLONG version)
+{
+    DWORD vendorId, deviceId;
+    UINT adapterInfo = 0;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::CheckForBadHardware");
+
+    while ((vendorId = badHardware[adapterInfo].VendorId) != 0x0000 &&
+           (deviceId = badHardware[adapterInfo].DeviceId) != 0x0000)
+    {
+        if (vendorId == vId && (deviceId == dId || deviceId == ALL_DEVICEIDS)) {
+            LONGLONG goodVersion = badHardware[adapterInfo].DriverVersion;
+            USHORT osInfo = badHardware[adapterInfo].OsInfo;
+            // the hardware check fails if:
+            // - we have an entry for this OS and
+            // - hardware is bad for all driver versions (NO_VERSION), or
+            //   we have a driver version which is older than the
+            //   minimum required for this OS
+            if (D3DPPLM_OsVersionMatches(osInfo) &&
+                (goodVersion == NO_VERSION || version < goodVersion))
+            {
+                J2dRlsTraceLn2(J2D_TRACE_ERROR,
+                    "D3DPPLM::CheckForBadHardware: found matching "\
+                    "hardware: VendorId=0x%04x DeviceId=0x%04x",
+                    vendorId, deviceId);
+                if (goodVersion != NO_VERSION) {
+                    // this was a match by the driver version
+                    LARGE_INTEGER li;
+                    li.QuadPart = goodVersion;
+                    J2dRlsTraceLn(J2D_TRACE_ERROR,
+                                  "  bad driver found, device disabled");
+                    J2dRlsTraceLn4(J2D_TRACE_ERROR,
+                                   "  update your driver to at "\
+                                   "least version %d.%d.%d.%d",
+                                   HIWORD(li.HighPart), LOWORD(li.HighPart),
+                                   HIWORD(li.LowPart),  LOWORD(li.LowPart));
+                } else {
+                    // this was a match by the device (no good driver for this
+                    // device)
+                    J2dRlsTraceLn(J2D_TRACE_ERROR,
+                                  "D3DPPLM::CheckForBadHardware: bad hardware "\
+                                  "found, device disabled");
+                }
+                if (!bNoHwCheck) {
+                    return D3DERR_INVALIDDEVICE;
+                }
+                J2dRlsTraceLn(J2D_TRACE_WARNING, "  Warning: hw/driver match "\
+                              "overridden (via J2D_D3D_NO_HWCHECK)");
+            }
+        }
+        adapterInfo++;
+    }
+
+    return S_OK;
+}
+
+HRESULT D3DPipelineManager::CheckAdaptersInfo()
+{
+    D3DADAPTER_IDENTIFIER9 aid;
+    UINT failedAdaptersCount = 0;
+
+    J2dRlsTraceLn(J2D_TRACE_INFO, "CheckAdaptersInfo");
+    J2dRlsTraceLn(J2D_TRACE_INFO, "------------------");
+    for (UINT Adapter = 0; Adapter < adapterCount; Adapter++) {
+
+        if (FAILED(pd3d9->GetAdapterIdentifier(Adapter, 0, &aid))) {
+            pAdapters[Adapter].state = CONTEXT_INIT_FAILED;
+            failedAdaptersCount++;
+            continue;
+        }
+
+        J2dRlsTraceLn1(J2D_TRACE_INFO, "Adapter Ordinal  : %d", Adapter);
+        J2dRlsTraceLn1(J2D_TRACE_INFO, "Adapter Handle   : 0x%x",
+                       pd3d9->GetAdapterMonitor(Adapter));
+        J2dRlsTraceLn1(J2D_TRACE_INFO, "Description      : %s",
+                       aid.Description);
+        J2dRlsTraceLn2(J2D_TRACE_INFO, "GDI Name, Driver : %s, %s",
+                       aid.DeviceName, aid.Driver);
+        J2dRlsTraceLn1(J2D_TRACE_INFO, "Vendor Id        : 0x%04x",
+                       aid.VendorId);
+        J2dRlsTraceLn1(J2D_TRACE_INFO, "Device Id        : 0x%04x",
+                       aid.DeviceId);
+        J2dRlsTraceLn1(J2D_TRACE_INFO, "SubSys Id        : 0x%x",
+                       aid.SubSysId);
+        J2dRlsTraceLn4(J2D_TRACE_INFO, "Driver Version   : %d.%d.%d.%d",
+                       HIWORD(aid.DriverVersion.HighPart),
+                       LOWORD(aid.DriverVersion.HighPart),
+                       HIWORD(aid.DriverVersion.LowPart),
+                       LOWORD(aid.DriverVersion.LowPart));
+        J2dRlsTrace3(J2D_TRACE_INFO,
+                     "[I] GUID             : {%08X-%04X-%04X-",
+                       aid.DeviceIdentifier.Data1,
+                       aid.DeviceIdentifier.Data2,
+                       aid.DeviceIdentifier.Data3);
+        J2dRlsTrace4(J2D_TRACE_INFO, "%02X%02X-%02X%02X",
+                       aid.DeviceIdentifier.Data4[0],
+                       aid.DeviceIdentifier.Data4[1],
+                       aid.DeviceIdentifier.Data4[2],
+                       aid.DeviceIdentifier.Data4[3]);
+        J2dRlsTrace4(J2D_TRACE_INFO, "%02X%02X%02X%02X}\n",
+                       aid.DeviceIdentifier.Data4[4],
+                       aid.DeviceIdentifier.Data4[5],
+                       aid.DeviceIdentifier.Data4[6],
+                       aid.DeviceIdentifier.Data4[7]);
+
+        if (FAILED(CheckForBadHardware(aid.VendorId, aid.DeviceId,
+                                       aid.DriverVersion.QuadPart)) ||
+            FAILED(CheckDeviceCaps(Adapter))  ||
+            FAILED(D3DEnabledOnAdapter(Adapter)))
+        {
+            pAdapters[Adapter].state = CONTEXT_INIT_FAILED;
+            failedAdaptersCount++;
+        }
+        J2dRlsTraceLn(J2D_TRACE_INFO, "------------------");
+    }
+
+    if (failedAdaptersCount == adapterCount) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+                      "D3DPPLM::CheckAdaptersInfo: no suitable adapters found");
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+D3DDEVTYPE D3DPipelineManager::SelectDeviceType()
+{
+    char *pRas = getenv("J2D_D3D_RASTERIZER");
+    D3DDEVTYPE dtype = D3DDEVTYPE_HAL;
+    if (pRas != NULL) {
+        J2dRlsTrace(J2D_TRACE_WARNING, "[W] D3DPPLM::SelectDeviceType: ");
+        if (strncmp(pRas, "ref", 3) == 0 || strncmp(pRas, "rgb", 3) == 0) {
+            J2dRlsTrace(J2D_TRACE_WARNING, "ref rasterizer selected");
+            dtype = D3DDEVTYPE_REF;
+        } else if (strncmp(pRas, "hal",3) == 0 || strncmp(pRas, "tnl",3) == 0) {
+            J2dRlsTrace(J2D_TRACE_WARNING, "hal rasterizer selected");
+            dtype = D3DDEVTYPE_HAL;
+        } else if (strncmp(pRas, "nul", 3) == 0) {
+            J2dRlsTrace(J2D_TRACE_WARNING, "nullref rasterizer selected");
+            dtype = D3DDEVTYPE_NULLREF;
+        } else {
+            J2dRlsTrace1(J2D_TRACE_WARNING,
+                "unknown rasterizer: %s, only (ref|hal|nul) "\
+                "supported, hal selected instead", pRas);
+        }
+        J2dRlsTrace(J2D_TRACE_WARNING, "\n");
+    }
+    return dtype;
+}
+
+#define CHECK_CAP(FLAG, CAP) \
+    do {    \
+        if (!((FLAG)&CAP)) { \
+            J2dRlsTraceLn2(J2D_TRACE_ERROR, \
+                           "D3DPPLM::CheckDeviceCaps: adapter %d: Failed "\
+                           "(cap %s not supported)", \
+                           adapter, #CAP); \
+            return E_FAIL; \
+        } \
+    } while (0)
+
+HRESULT D3DPipelineManager::CheckDeviceCaps(UINT adapter)
+{
+    HRESULT res;
+    D3DCAPS9 d3dCaps;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::CheckDeviceCaps");
+
+    res = pd3d9->GetDeviceCaps(adapter, devType, &d3dCaps);
+    RETURN_STATUS_IF_FAILED(res);
+
+    CHECK_CAP(d3dCaps.DevCaps, D3DDEVCAPS_DRAWPRIMTLVERTEX);
+
+    // by requiring hardware tnl we are hoping for better drivers quality
+    if (!IsD3DForced()) {
+        // fail if not hw tnl unless d3d was forced
+        CHECK_CAP(d3dCaps.DevCaps, D3DDEVCAPS_HWTRANSFORMANDLIGHT);
+    }
+    if (d3dCaps.DeviceType == D3DDEVTYPE_HAL) {
+        CHECK_CAP(d3dCaps.DevCaps, D3DDEVCAPS_HWRASTERIZATION);
+    }
+
+    CHECK_CAP(d3dCaps.RasterCaps, D3DPRASTERCAPS_SCISSORTEST);
+
+    CHECK_CAP(d3dCaps.Caps3, D3DCAPS3_ALPHA_FULLSCREEN_FLIP_OR_DISCARD);
+
+    CHECK_CAP(d3dCaps.PrimitiveMiscCaps, D3DPMISCCAPS_CULLNONE);
+    CHECK_CAP(d3dCaps.PrimitiveMiscCaps, D3DPMISCCAPS_BLENDOP);
+    CHECK_CAP(d3dCaps.PrimitiveMiscCaps, D3DPMISCCAPS_MASKZ);
+
+    CHECK_CAP(d3dCaps.ZCmpCaps, D3DPCMPCAPS_ALWAYS);
+    CHECK_CAP(d3dCaps.ZCmpCaps, D3DPCMPCAPS_LESS);
+
+    CHECK_CAP(d3dCaps.SrcBlendCaps, D3DPBLENDCAPS_ZERO);
+    CHECK_CAP(d3dCaps.SrcBlendCaps, D3DPBLENDCAPS_ONE);
+    CHECK_CAP(d3dCaps.SrcBlendCaps, D3DPBLENDCAPS_SRCALPHA);
+    CHECK_CAP(d3dCaps.SrcBlendCaps, D3DPBLENDCAPS_DESTALPHA);
+    CHECK_CAP(d3dCaps.SrcBlendCaps, D3DPBLENDCAPS_INVSRCALPHA);
+    CHECK_CAP(d3dCaps.SrcBlendCaps, D3DPBLENDCAPS_INVDESTALPHA);
+
+    CHECK_CAP(d3dCaps.DestBlendCaps, D3DPBLENDCAPS_ZERO);
+    CHECK_CAP(d3dCaps.DestBlendCaps, D3DPBLENDCAPS_ONE);
+    CHECK_CAP(d3dCaps.DestBlendCaps, D3DPBLENDCAPS_SRCALPHA);
+    CHECK_CAP(d3dCaps.DestBlendCaps, D3DPBLENDCAPS_DESTALPHA);
+    CHECK_CAP(d3dCaps.DestBlendCaps, D3DPBLENDCAPS_INVSRCALPHA);
+    CHECK_CAP(d3dCaps.DestBlendCaps, D3DPBLENDCAPS_INVDESTALPHA);
+
+    CHECK_CAP(d3dCaps.TextureAddressCaps, D3DPTADDRESSCAPS_CLAMP);
+    CHECK_CAP(d3dCaps.TextureAddressCaps, D3DPTADDRESSCAPS_WRAP);
+
+    CHECK_CAP(d3dCaps.TextureOpCaps, D3DTEXOPCAPS_MODULATE);
+
+    if (d3dCaps.PixelShaderVersion < D3DPS_VERSION(2,0) && !IsD3DForced()) {
+        J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                       "D3DPPLM::CheckDeviceCaps: adapter %d: Failed "\
+                       "(pixel shaders 2.0 required)", adapter);
+        return E_FAIL;
+    }
+
+    J2dRlsTraceLn1(J2D_TRACE_INFO,
+                   "D3DPPLM::CheckDeviceCaps: adapter %d: Passed", adapter);
+    return S_OK;
+}
+
+
+HRESULT D3DPipelineManager::D3DEnabledOnAdapter(UINT adapter)
+{
+    HRESULT res;
+    D3DDISPLAYMODE dm;
+
+    res = pd3d9->GetAdapterDisplayMode(adapter, &dm);
+    RETURN_STATUS_IF_FAILED(res);
+
+    res = pd3d9->CheckDeviceType(adapter, devType, dm.Format, dm.Format, TRUE);
+    if (FAILED(res)) {
+        J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                "D3DPPLM::D3DEnabledOnAdapter: no " \
+                "suitable d3d device on adapter %d", adapter);
+    }
+
+    return res;
+}
+
+UINT D3DPipelineManager::GetAdapterOrdinalByHmon(HMONITOR hMon)
+{
+    UINT ret = D3DADAPTER_DEFAULT;
+
+    if (pd3d9 != NULL) {
+        UINT adapterCount = pd3d9->GetAdapterCount();
+        for (UINT adapter = 0; adapter < adapterCount; adapter++) {
+            HMONITOR hm = pd3d9->GetAdapterMonitor(adapter);
+            if (hm == hMon) {
+                ret = adapter;
+                break;
+            }
+        }
+    }
+    return ret;
+}
+
+D3DFORMAT
+D3DPipelineManager::GetMatchingDepthStencilFormat(UINT adapterOrdinal,
+                                                  D3DFORMAT adapterFormat,
+                                                  D3DFORMAT renderTargetFormat)
+{
+    static D3DFORMAT formats[] =
+        { D3DFMT_D16, D3DFMT_D32, D3DFMT_D24S8, D3DFMT_D24X8 };
+    D3DFORMAT newFormat = D3DFMT_UNKNOWN;
+    HRESULT res;
+    for (int i = 0; i < 4; i++) {
+        res = pd3d9->CheckDeviceFormat(adapterOrdinal,
+                devType, adapterFormat, D3DUSAGE_DEPTHSTENCIL,
+                D3DRTYPE_SURFACE, formats[i]);
+        if (FAILED(res)) continue;
+
+        res = pd3d9->CheckDepthStencilMatch(adapterOrdinal,
+                devType, adapterFormat, renderTargetFormat, formats[i]);
+        if (FAILED(res)) continue;
+        newFormat = formats[i];
+        break;
+    }
+    return newFormat;
+}
+
+HWND D3DPipelineManager::CreateDefaultFocusWindow()
+{
+    UINT adapterOrdinal = D3DADAPTER_DEFAULT;
+
+    J2dTraceLn1(J2D_TRACE_INFO,
+                "D3DPPLM::CreateDefaultFocusWindow: adapter=%d",
+                adapterOrdinal);
+
+    if (defaultFocusWindow != 0) {
+        J2dRlsTraceLn(J2D_TRACE_WARNING,
+                      "D3DPPLM::CreateDefaultFocusWindow: "\
+                      "existing default focus window!");
+        return defaultFocusWindow;
+    }
+
+    WNDCLASS wc;
+    ZeroMemory(&wc, sizeof(WNDCLASS));
+    wc.hInstance = GetModuleHandle(NULL);
+    wc.lpfnWndProc = DefWindowProc;
+    wc.lpszClassName = L"D3DFocusWindow";
+    if (RegisterClass(&wc) == 0) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+                      "D3DPPLM::CreateDefaultFocusWindow: "\
+                      "error registering window class");
+        return 0;
+    }
+
+    MONITORINFO mi;
+    ZeroMemory(&mi, sizeof(MONITORINFO));
+    mi.cbSize = sizeof(MONITORINFO);
+    HMONITOR hMon = pd3d9->GetAdapterMonitor(adapterOrdinal);
+    if (hMon == 0 || !GetMonitorInfo(hMon, (PMONITOR_INFO)&mi)) {
+        J2dRlsTraceLn1(J2D_TRACE_ERROR,
+            "D3DPPLM::CreateDefaultFocusWindow: "\
+            "error getting monitor info for adapter=%d", adapterOrdinal);
+        return 0;
+    }
+
+    HWND hWnd = CreateWindow(L"D3DFocusWindow", L"D3DFocusWindow", 0,
+        mi.rcMonitor.left, mi.rcMonitor.top, 1, 1,
+        NULL, NULL, GetModuleHandle(NULL), NULL);
+    if (hWnd == 0) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+            "D3DPPLM::CreateDefaultFocusWindow: CreateWindow failed");
+    } else {
+        J2dTraceLn2(J2D_TRACE_INFO,
+            "  Created default focus window %x for adapter %d",
+            hWnd, adapterOrdinal);
+        defaultFocusWindow = hWnd;
+    }
+    return hWnd;
+}
+
+HWND D3DPipelineManager::GetCurrentFocusWindow()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::GetCurrentFocusWindow");
+    if (currentFSFocusAdapter < 0) {
+        J2dTraceLn1(J2D_TRACE_VERBOSE,
+                    "  no fs windows, using default focus window=0x%x",
+                    defaultFocusWindow);
+        return defaultFocusWindow;
+    }
+    J2dTraceLn1(J2D_TRACE_VERBOSE, "  using fs window=0x%x",
+                pAdapters[currentFSFocusAdapter].fsFocusWindow);
+    return pAdapters[currentFSFocusAdapter].fsFocusWindow;
+}
+
+HWND D3DPipelineManager::SetFSFocusWindow(UINT adapterOrdinal, HWND hWnd)
+{
+    J2dTraceLn2(J2D_TRACE_INFO,"D3DPPLM::SetFSFocusWindow hwnd=0x%x adapter=%d",
+                hWnd, adapterOrdinal);
+
+    HWND prev = pAdapters[adapterOrdinal].fsFocusWindow;
+    pAdapters[adapterOrdinal].fsFocusWindow = hWnd;
+    if (currentFSFocusAdapter < 0) {
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  first full-screen window");
+        // first fs window
+        currentFSFocusAdapter = adapterOrdinal;
+        // REMIND: we might want to reset the rest of the context here as well
+        // like we do when the an adapter exits fs mode; currently they will
+        // be reset sometime later
+    } else {
+        // there's already a fs window
+        if (currentFSFocusAdapter == adapterOrdinal) {
+            // it's current fs window => we're exiting fs mode on this adapter;
+            // look for a new fs focus window
+            if (hWnd == 0) {
+                UINT i;
+                currentFSFocusAdapter = -1;
+                for (i = 0; i < adapterCount; i++) {
+                    if (pAdapters[i].fsFocusWindow != 0) {
+                        J2dTraceLn1(J2D_TRACE_VERBOSE,
+                                    "  adapter %d is still in fs mode", i);
+                        currentFSFocusAdapter = i;
+                        break;
+                    }
+                }
+                // we have to reset all devices any time current focus device
+                // exits fs mode, and also to prevent some of them being left in
+                // a lost state when the last device exits fs - when non-last
+                // adapters exit fs mode they would not be able to create the
+                // device and will be put in a lost state forever
+                HRESULT res;
+                J2dTraceLn(J2D_TRACE_VERBOSE,
+                           "  adapter exited full-screen, reset all adapters");
+                for (i = 0; i < adapterCount; i++) {
+                    if (pAdapters[i].pd3dContext != NULL) {
+                        res = pAdapters[i].pd3dContext->ResetContext();
+                        D3DRQ_MarkLostIfNeeded(res,
+                            D3DRQ_GetCurrentDestination());
+                    }
+                }
+            } else {
+                J2dTraceLn1(J2D_TRACE_WARNING,
+                            "D3DPM::SetFSFocusWindow: setting the fs "\
+                            "window again for adapter %d", adapterOrdinal);
+            }
+        }
+    }
+    return prev;
+}
+
+HRESULT D3DPipelineManager::GetD3DContext(UINT adapterOrdinal,
+                                          D3DContext **ppd3dContext)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DPPLM::GetD3DContext");
+
+    HRESULT res = S_OK;
+    if (adapterOrdinal < 0 || adapterOrdinal >= adapterCount ||
+        pAdapters == NULL ||
+        pAdapters[adapterOrdinal].state == CONTEXT_INIT_FAILED)
+    {
+        J2dRlsTraceLn1(J2D_TRACE_ERROR,
+            "D3DPPLM::GetD3DContext: invalid parameters or "\
+            "failed init for adapter %d", adapterOrdinal);
+        *ppd3dContext = NULL;
+        return E_FAIL;
+    }
+
+    if (pAdapters[adapterOrdinal].state == CONTEXT_NOT_INITED) {
+        D3DContext *pCtx = NULL;
+
+        if (pAdapters[adapterOrdinal].pd3dContext != NULL) {
+            J2dTraceLn1(J2D_TRACE_ERROR, "  non-null context in "\
+                        "uninitialized adapter %d", adapterOrdinal);
+            res = E_FAIL;
+        } else {
+            J2dTraceLn1(J2D_TRACE_VERBOSE,
+                        "  initializing context for adapter %d",adapterOrdinal);
+
+            if (SUCCEEDED(res = D3DEnabledOnAdapter(adapterOrdinal))) {
+                res = D3DContext::CreateInstance(pd3d9, adapterOrdinal, &pCtx);
+                if (FAILED(res)) {
+                    J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                        "D3DPPLM::GetD3DContext: failed to create context "\
+                        "for adapter=%d", adapterOrdinal);
+                }
+            } else {
+                J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                    "D3DPPLM::GetContext: no d3d on adapter %d",adapterOrdinal);
+            }
+        }
+        pAdapters[adapterOrdinal].state =
+            SUCCEEDED(res) ? CONTEXT_CREATED : CONTEXT_INIT_FAILED;
+        pAdapters[adapterOrdinal].pd3dContext = pCtx;
+    }
+    *ppd3dContext = pAdapters[adapterOrdinal].pd3dContext;
+    return res;
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPipelineManager.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPipelineManager.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DPipelineManager.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DPipelineManager.h	2011-01-08 01:26:50.479202297 +0000
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+#pragma once
+
+#include "D3DPipeline.h"
+#include "D3DContext.h"
+
+typedef class D3DPipelineManager *LPD3DPIPELINEMANAGER;
+
+typedef struct D3DAdapter
+{
+    D3DContext *pd3dContext;
+    DWORD state;
+    HWND fsFocusWindow;
+} D3DAdapter;
+
+class D3DPIPELINE_API D3DPipelineManager
+{
+public:
+    // creates and initializes instance of D3DPipelineManager, may return NULL
+    static D3DPipelineManager* CreateInstance(void);
+    // deletes the single instance of the manager
+    static void DeleteInstance();
+    // returns the single instance of the manager, may return NULL
+    static D3DPipelineManager* GetInstance(void);
+
+    HRESULT GetD3DContext(UINT adapterOrdinal, D3DContext **ppd3dContext);
+
+    HRESULT HandleLostDevices();
+    // Checks if adapters were added or removed, or if the order had changed
+    // (which may happen with primary display is changed). If that's the case
+    // releases current adapters and d3d9 instance, reinitializes the pipeline.
+    // @param *monHds list of monitor handles retrieved from GDI
+    // @param monNum number of gdi monitors
+    static
+    HRESULT HandleAdaptersChange(HMONITOR *monHds, UINT monNum);
+    // returns depth stencil buffer format matching adapterFormat and render target
+    // format for the device specified by adapterOrdinal/devType
+    D3DFORMAT GetMatchingDepthStencilFormat(UINT adapterOrdinal,
+                                            D3DFORMAT adapterFormat,
+                                            D3DFORMAT renderTargetFormat);
+
+    HWND GetCurrentFocusWindow();
+    // returns previous fs window
+    HWND SetFSFocusWindow(UINT, HWND);
+
+    LPDIRECT3D9 GetD3DObject() { return pd3d9; }
+    D3DDEVTYPE GetDeviceType() { return devType; }
+
+    // returns the d3d adapter ordinal given GDI screen number:
+    // these may differ depending on which display is primary
+    UINT GetAdapterOrdinalForScreen(jint gdiScreen);
+
+    // notifies adapter event listeners by calling
+    // AccelDeviceEventNotifier.eventOccured()
+    static
+    void NotifyAdapterEventListeners(UINT adapter, jint eventType);
+
+private:
+    D3DPipelineManager(void);
+   ~D3DPipelineManager(void);
+
+    // Creates a Direct3D9 object and initializes adapters.
+    HRESULT InitD3D(void);
+    // Releases adapters, Direct3D9 object and the d3d9 library.
+    HRESULT ReleaseD3D();
+
+    // selects the device type based on user input and available
+    // device types
+    D3DDEVTYPE SelectDeviceType();
+
+    // creates array of adapters (releases the old one first)
+    HRESULT InitAdapters();
+    // releases each adapter's context, and then releases the array
+    HRESULT ReleaseAdapters();
+
+    HWND    CreateDefaultFocusWindow();
+    // returns S_OK if the adapter is capable of running the Direct3D
+    // pipeline
+    HRESULT D3DEnabledOnAdapter(UINT Adapter);
+    // returns adapterOrdinal given a HMONITOR handle
+    UINT    GetAdapterOrdinalByHmon(HMONITOR hMon);
+    HRESULT CheckAdaptersInfo();
+    HRESULT CheckDeviceCaps(UINT Adapter);
+    // Check the OS, succeeds if the OS is XP or newer client-class OS
+static HRESULT CheckOSVersion();
+    // used to check attached adapters using GDI against known bad hw database
+    // prior to the instantiation of the pipeline manager
+static HRESULT GDICheckForBadHardware();
+    // given VendorId, DeviceId and driver version, checks against a database
+    // of known bad hardware/driver combinations.
+    // If the driver version is not known MAX_VERSION can be used
+    // which is guaranteed to satisfy the check
+static HRESULT CheckForBadHardware(DWORD vId, DWORD dId, LONGLONG version);
+
+private:
+
+    // current adapter count
+    UINT adapterCount;
+    // Pointer to Direct3D9 Object mainained by the pipeline manager
+    LPDIRECT3D9 pd3d9;
+    // d3d9.dll lib
+    HINSTANCE hLibD3D9;
+
+    int currentFSFocusAdapter;
+    HWND defaultFocusWindow;
+
+    D3DDEVTYPE devType;
+
+    D3DAdapter *pAdapters;
+    // instance of this object
+    static LPD3DPIPELINEMANAGER pMgr;
+};
+
+#define OS_UNDEFINED    (0 << 0)
+#define OS_VISTA        (1 << 0)
+#define OS_WINSERV_2008 (1 << 1)
+#define OS_WINXP        (1 << 2)
+#define OS_WINXP_64     (1 << 3)
+#define OS_WINSERV_2003 (1 << 4)
+#define OS_ALL (OS_VISTA|OS_WINSERV_2008|OS_WINXP|OS_WINXP_64|OS_WINSERV_2003)
+#define OS_UNKNOWN      (~OS_ALL)
+BOOL D3DPPLM_OsVersionMatches(USHORT osInfo);
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DRenderer.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DRenderer.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DRenderer.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DRenderer.cpp	2011-01-08 01:26:50.479202297 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,450 +24,367 @@
  */
 
 #include "sun_java2d_d3d_D3DRenderer.h"
-#include "sun_java2d_windows_DDRenderer.h"
-#include "Win32SurfaceData.h"
 
-#include <ddraw.h>
-
-#include "D3DUtils.h"
-#include "ddrawUtils.h"
-
-#include "j2d_md.h"
-#include "jlong.h"
-
-/*
- * Class:     sun_java2d_d3d_D3DRenderer
- * Method:    doDrawLineD3D
- * Signature: (Lsun/java2d/SurfaceData;IIIII)Z
- */
-JNIEXPORT jboolean JNICALL
-Java_sun_java2d_d3d_D3DRenderer_doDrawLineD3D
-    (JNIEnv *env, jobject d3dr,
-     jlong pData, jlong pCtx,
-     jint x1, jint y1, jint x2, jint y2)
+#include "D3DContext.h"
+#include "D3DRenderer.h"
+#include "D3DRenderQueue.h"
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawLine(D3DContext *d3dc,
+                     jint x1, jint y1, jint x2, jint y2)
 {
-    Win32SDOps *wsdo = (Win32SDOps *)jlong_to_ptr(pData);
-    D3DContext *d3dc = (D3DContext *)jlong_to_ptr(pCtx);
-    static J2D_XY_C_VERTEX lineVerts[] = {
-#ifdef USE_SINGLE_VERTEX_FORMAT
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-#else
-        // x, y, z, color
-        { 0, 0, 0, 0x0 },
-        { 0, 0, 0, 0x0 },
-#endif // USE_SINGLE_VERTEX_FORMAT
-    };
-
-    J2dTraceLn(J2D_TRACE_INFO, "D3DRenderer_doDrawLineD3D");
-    J2dTraceLn4(J2D_TRACE_VERBOSE,
-                "  x1=%-4d y1=%-4d x2=%-4d y2=%-4d",
+    J2dTraceLn4(J2D_TRACE_INFO,
+                "D3DRenderer_doDrawLineD3D x1=%-4d y1=%-4d x2=%-4d y2=%-4d",
                 x1, y1, x2, y2);
-    HRESULT res = DDERR_GENERIC;
-    if (d3dc != NULL) {
-        DDrawSurface *ddTargetSurface = d3dc->GetTargetSurface();
-        if (ddTargetSurface == NULL) {
-            return FALSE;
-        }
-        ddTargetSurface->GetExclusiveAccess();
-        d3dc->GetExclusiveAccess();
-
-        IDirect3DDevice7 *d3dDevice = d3dc->Get3DDevice();
-        if (d3dDevice == NULL) {
-            d3dc->ReleaseExclusiveAccess();
-            ddTargetSurface->ReleaseExclusiveAccess();
-            return FALSE;
-        }
-
-        // +0.5f is needed to compensate for the -0.5f we
-        // force when setting the transform
-        lineVerts[0].x = (float)x1 + 0.5f;
-        lineVerts[0].y = (float)y1 + 0.5f;
-        lineVerts[0].color = d3dc->colorPixel;
-        lineVerts[1].x = (float)x2 + 0.5f;
-        lineVerts[1].y = (float)y2 + 0.5f;
-        lineVerts[1].color = d3dc->colorPixel;
-
-        D3DU_PRIM_LOOP_BEGIN(res, wsdo);
-        if (SUCCEEDED(res = d3dc->BeginScene(STATE_RENDEROP))) {
-            res = d3dDevice->DrawPrimitive(D3DPT_LINESTRIP, D3DFVF_J2D_XY_C,
-                                           lineVerts, 2, 0);
-            // REMIND: need to be using the results of device testing
-            res = d3dDevice->DrawPrimitive(D3DPT_POINTLIST, D3DFVF_J2D_XY_C,
-                                           &(lineVerts[1]), 1, 0);
-            d3dc->EndScene(res);
-        }
-        D3DU_PRIM_LOOP_END(env, res, wsdo, "DrawPrimitive(D3DPT_LINESTRIP)");
-
-        d3dc->ReleaseExclusiveAccess();
-        ddTargetSurface->ReleaseExclusiveAccess();
-    }
-    return SUCCEEDED(res);
+    d3dc->BeginScene(STATE_RENDEROP);
+    return d3dc->pVCacher->DrawLine(x1, y1, x2, y2);
 }
 
-JNIEXPORT jboolean JNICALL
-Java_sun_java2d_d3d_D3DRenderer_doDrawRectD3D
-    (JNIEnv *env, jobject d3dr,
-     jlong pData, jlong pCtx,
-     jint x, jint y, jint w, jint h)
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawRect(D3DContext *d3dc,
+                     jint x, jint y, jint w, jint h)
 {
-    Win32SDOps *wsdo = (Win32SDOps *)jlong_to_ptr(pData);
-    D3DContext *d3dc = (D3DContext *)jlong_to_ptr(pCtx);
-    float x1, y1, x2, y2;
-    static J2D_XY_C_VERTEX lineVerts[] = {
-#ifdef USE_SINGLE_VERTEX_FORMAT
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-#else
-        // x, y, z, color
-        { 0, 0, 0, 0x0 },
-        { 0, 0, 0, 0x0 },
-        { 0, 0, 0, 0x0 },
-        { 0, 0, 0, 0x0 },
-        { 0, 0, 0, 0x0 },
-#endif // USE_SINGLE_VERTEX_FORMAT
-    };
-
-    J2dTraceLn(J2D_TRACE_INFO, "D3DRenderer_doDrawRectD3D");
-    J2dTraceLn4(J2D_TRACE_VERBOSE,
-                "  x=%-4d y=%-4d w=%-4d h=%-4d",
+    J2dTraceLn4(J2D_TRACE_INFO,
+                "D3DRenderer_DrawRect x=%-4d y=%-4d w=%-4d h=%-4d",
                 x, y, w, h);
 
-    HRESULT res = DDERR_GENERIC;
-    if (d3dc != NULL) {
-        DDrawSurface *ddTargetSurface = d3dc->GetTargetSurface();
-        if (ddTargetSurface == NULL) {
-            return FALSE;
-        }
-        ddTargetSurface->GetExclusiveAccess();
-        d3dc->GetExclusiveAccess();
-
-        IDirect3DDevice7 *d3dDevice = d3dc->Get3DDevice();
-        if (d3dDevice == NULL) {
-            d3dc->ReleaseExclusiveAccess();
-            ddTargetSurface->ReleaseExclusiveAccess();
-            return FALSE;
-        }
-
-        // +0.5f is needed to compensate for the -0.5f we
-        // force when setting the transform
-        x1 = (float)x + 0.5f;
-        y1 = (float)y + 0.5f;
-        x2 = x1 + (float)w;
-        y2 = y1 + (float)h;
-        D3DU_INIT_VERTEX_PENT_XY(lineVerts, x1, y1, x2, y2);
-        D3DU_INIT_VERTEX_PENT_COLOR(lineVerts, d3dc->colorPixel);
-
-        D3DU_PRIM_LOOP_BEGIN(res, wsdo);
-        if (SUCCEEDED(res = d3dc->BeginScene(STATE_RENDEROP))) {
-            res = d3dDevice->DrawPrimitive(D3DPT_LINESTRIP, D3DFVF_J2D_XY_C,
-                                           lineVerts, 5, 0);
-            d3dc->EndScene(res);
-        }
-        D3DU_PRIM_LOOP_END(env, res, wsdo, "DrawPrimitive(D3DPT_LINESTRIP)");
-
-        d3dc->ReleaseExclusiveAccess();
-        ddTargetSurface->ReleaseExclusiveAccess();
-    }
-    return SUCCEEDED(res);
+    d3dc->BeginScene(STATE_RENDEROP);
+    return d3dc->pVCacher->DrawRect(x, y, x + w, y + h);
 }
 
-/*
- * Class:     sun_java2d_d3d_D3DRenderer
- * Method:    doFillRectD3D
- * Signature: (JIIII)Z
- */
-JNIEXPORT jboolean JNICALL Java_sun_java2d_d3d_D3DRenderer_doFillRectD3D
-  (JNIEnv *env, jobject d3dr,
-   jlong pData, jlong pCtx,
-   jint x, jint y, jint w, jint h)
-{
-    Win32SDOps *wsdo = (Win32SDOps *)jlong_to_ptr(pData);
-    D3DContext *d3dc = (D3DContext *)jlong_to_ptr(pCtx);
-    HRESULT res = DDERR_GENERIC;
-    float x1, y1, x2, y2;
-    static J2D_XY_C_VERTEX quadVerts[] = {
-#ifdef USE_SINGLE_VERTEX_FORMAT
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f },
-        { 0.0f, 0.0f, 0.0f, 0x0, 0.0f, 0.0f }
-#else
-        // x, y, z, color
-        { 0, 0, 0, 0x0 },
-        { 0, 0, 0, 0x0 },
-        { 0, 0, 0, 0x0 },
-        { 0, 0, 0, 0x0 },
-#endif // USE_SINGLE_VERTEX_FORMAT
-    };
-
-    J2dTraceLn(J2D_TRACE_INFO, "doFillRectD3D");
-    J2dTraceLn4(J2D_TRACE_VERBOSE, "  x=%-4d y=%-4d w=%-4d h=%-4d", x, y, w, h);
-
-    if (d3dc != NULL) {
-        DDrawSurface *ddTargetSurface = d3dc->GetTargetSurface();
-        if (ddTargetSurface == NULL) {
-            return FALSE;
-        }
-        ddTargetSurface->GetExclusiveAccess();
-        d3dc->GetExclusiveAccess();
+HRESULT D3DPIPELINE_API
+D3DRenderer_FillRect(D3DContext *d3dc,
+                     jint x, jint y, jint w, jint h)
+{
+    J2dTraceLn4(J2D_TRACE_INFO,
+               "D3DRenderer_FillRect x=%-4d y=%-4d w=%-4d h=%-4d",
+                x, y, w, h);
 
-        IDirect3DDevice7 *d3dDevice = d3dc->Get3DDevice();
-        if (d3dDevice == NULL) {
-            d3dc->ReleaseExclusiveAccess();
-            ddTargetSurface->ReleaseExclusiveAccess();
-            return FALSE;
-        }
+    d3dc->BeginScene(STATE_RENDEROP);
+    return d3dc->pVCacher->FillRect(x, y, x + w, y + h);
+}
 
-        x1 = (float)x;
-        y1 = (float)y;
-        x2 = x1 + (float)w;
-        y2 = y1 + (float)h;
-        D3DU_INIT_VERTEX_QUAD_COLOR(quadVerts, d3dc->colorPixel);
-        D3DU_INIT_VERTEX_QUAD_XY(quadVerts, x1, y1, x2, y2);
-
-        D3DU_PRIM_LOOP_BEGIN(res, wsdo);
-        if (SUCCEEDED(res = d3dc->BeginScene(STATE_RENDEROP))) {
-            res = d3dDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, D3DFVF_J2D_XY_C,
-                                           quadVerts, 4, 0);
-            d3dc->EndScene(res);
-        }
-        D3DU_PRIM_LOOP_END(env, res, wsdo, "DrawPrimitive(D3DPT_TRIANGLEFAN)");
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawPoly(D3DContext *d3dc,
+                     jint nPoints, jboolean isClosed,
+                     jint transX, jint transY,
+                     jint *xPoints, jint *yPoints)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRenderer_DrawPoly");
 
-        d3dc->ReleaseExclusiveAccess();
-        ddTargetSurface->ReleaseExclusiveAccess();
+    if (d3dc == NULL || xPoints == NULL || yPoints == NULL) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+            "D3DRenderer_DrawPoly: d3dc, xPoints or yPoints is NULL");
+        return E_FAIL;
     }
-    return SUCCEEDED(res);
+
+    d3dc->BeginScene(STATE_RENDEROP);
+    return d3dc->pVCacher->DrawPoly(nPoints, isClosed, transX, transY,
+                                    xPoints, yPoints);
 }
 
-/*
- * Class:     sun_java2d_d3d_D3DRenderer
- * Method:    doDrawPoly
- * Signature: (JII[I[IIZ)V
- */
-JNIEXPORT void JNICALL Java_sun_java2d_d3d_D3DRenderer_doDrawPoly
-  (JNIEnv *env, jobject d3dr,
-   jlong pData, jlong pCtx,
-   jint transx, jint transy,
-   jintArray xcoordsArray, jintArray ycoordsArray, jint npoints,
-   jboolean needToClose)
-{
-    Win32SDOps *wsdo = (Win32SDOps *)jlong_to_ptr(pData);
-    D3DContext *d3dc = (D3DContext *)jlong_to_ptr(pCtx);
-    jint *xcoords, *ycoords;
-    jint i;
-
-    J2dTraceLn(J2D_TRACE_INFO, "D3DRenderer_doDrawPoly");
-    J2dTraceLn4(J2D_TRACE_VERBOSE,
-                "  transx=%-4d transy=%-4d "\
-                "npoints=%-4d needToClose=%-4d",
-                transx, transy, npoints, needToClose);
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawScanlines(D3DContext *d3dc,
+                          jint scanlineCount, jint *scanlines)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRenderer_DrawScanlines");
 
     if (d3dc == NULL) {
-        J2dTraceLn(J2D_TRACE_WARNING,
-                   "D3DRenderer_doDrawPoly: null device context");
-        return;
+       return E_FAIL;
     }
-
-    if (JNU_IsNull(env, xcoordsArray) || JNU_IsNull(env, ycoordsArray)) {
-        JNU_ThrowNullPointerException(env, "coordinate array");
-        return;
-    }
-    if (env->GetArrayLength(ycoordsArray) < npoints ||
-        env->GetArrayLength(xcoordsArray) < npoints)
-    {
-        JNU_ThrowArrayIndexOutOfBoundsException(env, "coordinate array");
-        return;
+    if (scanlines == NULL || scanlineCount <= 0) {
+        return D3D_OK;
     }
 
-    xcoords = (jint *)
-        env->GetPrimitiveArrayCritical(xcoordsArray, NULL);
-    if (xcoords == NULL) {
-        return;
-    }
+    d3dc->BeginScene(STATE_RENDEROP);
+    return d3dc->pVCacher->DrawScanlines(scanlineCount, scanlines);
+}
 
-    ycoords = (jint *)
-        env->GetPrimitiveArrayCritical(ycoordsArray, NULL);
-    if (ycoords == NULL) {
-        env->ReleasePrimitiveArrayCritical(xcoordsArray, xcoords, JNI_ABORT);
-        return;
+HRESULT D3DPIPELINE_API
+D3DRenderer_FillSpans(D3DContext *d3dc, jint spanCount, jint *spans)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRenderer_FillSpans");
+    if (d3dc == NULL) {
+        return E_FAIL;
     }
 
-    DDrawSurface *ddTargetSurface = d3dc->GetTargetSurface();
-    if (ddTargetSurface == NULL) {
-        env->ReleasePrimitiveArrayCritical(ycoordsArray, ycoords, JNI_ABORT);
-        env->ReleasePrimitiveArrayCritical(xcoordsArray, xcoords, JNI_ABORT);
-        return;
-    }
+    d3dc->BeginScene(STATE_RENDEROP);
+    return d3dc->pVCacher->FillSpans(spanCount, spans);
+}
 
-    ddTargetSurface->GetExclusiveAccess();
-    d3dc->GetExclusiveAccess();
-    IDirect3DDevice7 *d3dDevice = d3dc->Get3DDevice();
-    if (d3dDevice == NULL) {
-        d3dc->ReleaseExclusiveAccess();
-        ddTargetSurface->ReleaseExclusiveAccess();
-        env->ReleasePrimitiveArrayCritical(ycoordsArray, ycoords, JNI_ABORT);
-        env->ReleasePrimitiveArrayCritical(xcoordsArray, xcoords, JNI_ABORT);
-        return;
-    }
+HRESULT D3DPIPELINE_API
+D3DRenderer_FillParallelogram(D3DContext *d3dc,
+                              jfloat fx11, jfloat fy11,
+                              jfloat dx21, jfloat dy21,
+                              jfloat dx12, jfloat dy12)
+{
+    J2dTraceLn6(J2D_TRACE_INFO,
+                "D3DRenderer_FillParallelogram "
+                "x=%6.2f y=%6.2f "
+                "dx1=%6.2f dy1=%6.2f "
+                "dx2=%6.2f dy2=%6.2f ",
+                fx11, fy11,
+                dx21, dy21,
+                dx12, dy12);
+
+    d3dc->BeginScene(STATE_RENDEROP);
+    return d3dc->pVCacher->FillParallelogram(fx11, fy11,
+                                             dx21, dy21,
+                                             dx12, dy12);
+}
 
-    int totalPoints = npoints;
-    if (needToClose) {
-        if (xcoords[npoints - 1] != xcoords[0] ||
-            ycoords[npoints - 1] != ycoords[0])
-        {
-            totalPoints++;
-        } else {
-            needToClose = FALSE;
-        }
-    }
-    J2D_XY_C_VERTEX *lpVerts =
-        (J2D_XY_C_VERTEX *)safe_Malloc(totalPoints*sizeof(J2D_XY_C_VERTEX));
-    if (!lpVerts) {
-        d3dc->ReleaseExclusiveAccess();
-        ddTargetSurface->ReleaseExclusiveAccess();
-        env->ReleasePrimitiveArrayCritical(ycoordsArray, ycoords, JNI_ABORT);
-        env->ReleasePrimitiveArrayCritical(xcoordsArray, xcoords, JNI_ABORT);
-        return;
-    }
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawParallelogram(D3DContext *d3dc,
+                              jfloat fx11, jfloat fy11,
+                              jfloat dx21, jfloat dy21,
+                              jfloat dx12, jfloat dy12,
+                              jfloat lwr21, jfloat lwr12)
+{
+    HRESULT res;
 
-    ZeroMemory(lpVerts, totalPoints*sizeof(J2D_XY_C_VERTEX));
-    for (i = 0; i < npoints; i++) {
-        // +0.5f is needed to compensate for the -0.5f we
-        // force when setting the transform
-        lpVerts[i].x = (float)(xcoords[i] + transx) + 0.5f;
-        lpVerts[i].y = (float)(ycoords[i] + transy) + 0.5f;
-        lpVerts[i].color =  d3dc->colorPixel;
-    }
-    if (needToClose) {
-        lpVerts[npoints].x = (float)(xcoords[0] + transx) + 0.5f;
-        lpVerts[npoints].y = (float)(ycoords[0] + transy) + 0.5f;
-        lpVerts[npoints].color = d3dc->colorPixel;
+    J2dTraceLn8(J2D_TRACE_INFO,
+                "D3DRenderer_DrawParallelogram "
+                "x=%6.2f y=%6.2f "
+                "dx1=%6.2f dy1=%6.2f lwr1=%6.2f "
+                "dx2=%6.2f dy2=%6.2f lwr2=%6.2f ",
+                fx11, fy11,
+                dx21, dy21, lwr21,
+                dx12, dy12, lwr12);
+
+    // dx,dy for line width in the "21" and "12" directions.
+    jfloat ldx21 = dx21 * lwr21;
+    jfloat ldy21 = dy21 * lwr21;
+    jfloat ldx12 = dx12 * lwr12;
+    jfloat ldy12 = dy12 * lwr12;
+
+    // calculate origin of the outer parallelogram
+    jfloat ox11 = fx11 - (ldx21 + ldx12) / 2.0f;
+    jfloat oy11 = fy11 - (ldy21 + ldy12) / 2.0f;
+
+    res = d3dc->BeginScene(STATE_RENDEROP);
+    RETURN_STATUS_IF_FAILED(res);
+
+    // Only need to generate 4 quads if the interior still
+    // has a hole in it (i.e. if the line width ratio was
+    // less than 1.0)
+    if (lwr21 < 1.0f && lwr12 < 1.0f) {
+        // Note: "TOP", "BOTTOM", "LEFT" and "RIGHT" here are
+        // relative to whether the dxNN variables are positive
+        // and negative.  The math works fine regardless of
+        // their signs, but for conceptual simplicity the
+        // comments will refer to the sides as if the dxNN
+        // were all positive.  "TOP" and "BOTTOM" segments
+        // are defined by the dxy21 deltas.  "LEFT" and "RIGHT"
+        // segments are defined by the dxy12 deltas.
+
+        // Each segment includes its starting corner and comes
+        // to just short of the following corner.  Thus, each
+        // corner is included just once and the only lengths
+        // needed are the original parallelogram delta lengths
+        // and the "line width deltas".  The sides will cover
+        // the following relative territories:
+        //
+        //     T T T T T R
+        //      L         R
+        //       L         R
+        //        L         R
+        //         L         R
+        //          L B B B B B
+
+        // TOP segment, to left side of RIGHT edge
+        // "width" of original pgram, "height" of hor. line size
+        fx11 = ox11;
+        fy11 = oy11;
+        res = d3dc->pVCacher->FillParallelogram(fx11, fy11,
+                                                dx21, dy21,
+                                                ldx12, ldy12);
+
+        // RIGHT segment, to top of BOTTOM edge
+        // "width" of vert. line size , "height" of original pgram
+        fx11 = ox11 + dx21;
+        fy11 = oy11 + dy21;
+        res = d3dc->pVCacher->FillParallelogram(fx11, fy11,
+                                                ldx21, ldy21,
+                                                dx12, dy12);
+
+        // BOTTOM segment, from right side of LEFT edge
+        // "width" of original pgram, "height" of hor. line size
+        fx11 = ox11 + dx12 + ldx21;
+        fy11 = oy11 + dy12 + ldy21;
+        res = d3dc->pVCacher->FillParallelogram(fx11, fy11,
+                                                dx21, dy21,
+                                                ldx12, ldy12);
+
+        // LEFT segment, from bottom of TOP edge
+        // "width" of vert. line size , "height" of inner pgram
+        fx11 = ox11 + ldx12;
+        fy11 = oy11 + ldy12;
+        res = d3dc->pVCacher->FillParallelogram(fx11, fy11,
+                                                ldx21, ldy21,
+                                                dx12, dy12);
+    } else {
+        // The line width ratios were large enough to consume
+        // the entire hole in the middle of the parallelogram
+        // so we can just issue one large quad for the outer
+        // parallelogram.
+        dx21 += ldx21;
+        dy21 += ldy21;
+        dx12 += ldx12;
+        dy12 += ldy12;
+
+        res = d3dc->pVCacher->FillParallelogram(ox11, oy11,
+                                                dx21, dy21,
+                                                dx12, dy12);
     }
-    env->ReleasePrimitiveArrayCritical(ycoordsArray, ycoords, JNI_ABORT);
-    env->ReleasePrimitiveArrayCritical(xcoordsArray, xcoords, JNI_ABORT);
 
-    HRESULT res;
-    D3DU_PRIM_LOOP_BEGIN(res, wsdo);
-    if (SUCCEEDED(res = d3dc->BeginScene(STATE_RENDEROP))) {
-        res = d3dDevice->DrawPrimitive(D3DPT_LINESTRIP, D3DFVF_J2D_XY_C,
-                                       lpVerts, totalPoints, 0);
-        // REMIND: temp hack, need to be using the results of device testing
-        if (!needToClose) {
-            res = d3dDevice->DrawPrimitive(D3DPT_POINTLIST, D3DFVF_J2D_XY_C,
-                                           &(lpVerts[totalPoints-1]), 1, 0);
-        }
-        d3dc->EndScene(res);
-    }
-    D3DU_PRIM_LOOP_END(env, res, wsdo, "DrawPrimitive(D3DPT_LINESTRIP)");
+    return res;
+}
 
-    free(lpVerts);
+HRESULT D3DPIPELINE_API
+D3DRenderer_FillAAParallelogram(D3DContext *d3dc,
+                                jfloat fx11, jfloat fy11,
+                                jfloat dx21, jfloat dy21,
+                                jfloat dx12, jfloat dy12)
+{
+    IDirect3DDevice9 *pd3dDevice;
+    HRESULT res;
 
-    d3dc->ReleaseExclusiveAccess();
-    ddTargetSurface->ReleaseExclusiveAccess();
+    J2dTraceLn6(J2D_TRACE_INFO,
+                "D3DRenderer_FillAAParallelogram "
+                "x=%6.2f y=%6.2f "
+                "dx1=%6.2f dy1=%6.2f "
+                "dx2=%6.2f dy2=%6.2f ",
+                fx11, fy11,
+                dx21, dy21,
+                dx12, dy12);
+
+    res = d3dc->BeginScene(STATE_AAPGRAMOP);
+    RETURN_STATUS_IF_FAILED(res);
+
+    pd3dDevice = d3dc->Get3DDevice();
+    if (pd3dDevice == NULL) {
+        return E_FAIL;
+    }
+
+    res = d3dc->pVCacher->FillParallelogramAA(fx11, fy11,
+                                              dx21, dy21,
+                                              dx12, dy12);
+    return res;
 }
 
-JNIEXPORT void JNICALL
-Java_sun_java2d_d3d_D3DRenderer_devFillSpans
-    (JNIEnv *env, jobject d3dr,
-     jlong pData, jlong pCtx,
-     jobject si, jlong pIterator, jint transx, jint transy)
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawAAParallelogram(D3DContext *d3dc,
+                                jfloat fx11, jfloat fy11,
+                                jfloat dx21, jfloat dy21,
+                                jfloat dx12, jfloat dy12,
+                                jfloat lwr21, jfloat lwr12)
 {
-    Win32SDOps *wsdo = (Win32SDOps *)jlong_to_ptr(pData);
-    D3DContext *d3dc = (D3DContext *)jlong_to_ptr(pCtx);
-    SpanIteratorFuncs *pFuncs = (SpanIteratorFuncs *)jlong_to_ptr(pIterator);
-    void *srData;
-    float x1, y1, x2, y2;
-    jint spanbox[4];
-    J2dTraceLn(J2D_TRACE_INFO, "D3DRenderer_devFillSpans");
-    J2dTraceLn2(J2D_TRACE_VERBOSE,
-                "  transx=%-4d transy=%-4d", transx, transy);
-
-    if (JNU_IsNull(env, si)) {
-        JNU_ThrowNullPointerException(env, "span iterator");
-        return;
-    }
-    if (pFuncs == NULL) {
-        JNU_ThrowNullPointerException(env, "native iterator not supplied");
-        return;
-    }
+    IDirect3DDevice9 *pd3dDevice;
+    // dx,dy for line width in the "21" and "12" directions.
+    jfloat ldx21, ldy21, ldx12, ldy12;
+    // parameters for "outer" parallelogram
+    jfloat ofx11, ofy11, odx21, ody21, odx12, ody12;
+    // parameters for "inner" parallelogram
+    jfloat ifx11, ify11, idx21, idy21, idx12, idy12;
+    HRESULT res;
 
-    if (d3dc == NULL) {
-        J2dTraceLn(J2D_TRACE_WARNING,
-                   "D3DRenderer_devFillSpans: context is null");
-        return;
+    J2dTraceLn8(J2D_TRACE_INFO,
+                "D3DRenderer_DrawAAParallelogram "
+                "x=%6.2f y=%6.2f "
+                "dx1=%6.2f dy1=%6.2f lwr1=%6.2f "
+                "dx2=%6.2f dy2=%6.2f lwr2=%6.2f ",
+                fx11, fy11,
+                dx21, dy21, lwr21,
+                dx12, dy12, lwr12);
+
+    res = d3dc->BeginScene(STATE_AAPGRAMOP);
+    RETURN_STATUS_IF_FAILED(res);
+
+    pd3dDevice = d3dc->Get3DDevice();
+    if (pd3dDevice == NULL) {
+        return E_FAIL;
+    }
+
+    // calculate true dx,dy for line widths from the "line width ratios"
+    ldx21 = dx21 * lwr21;
+    ldy21 = dy21 * lwr21;
+    ldx12 = dx12 * lwr12;
+    ldy12 = dy12 * lwr12;
+
+    // calculate coordinates of the outer parallelogram
+    ofx11 = fx11 - (ldx21 + ldx12) / 2.0f;
+    ofy11 = fy11 - (ldy21 + ldy12) / 2.0f;
+    odx21 = dx21 + ldx21;
+    ody21 = dy21 + ldy21;
+    odx12 = dx12 + ldx12;
+    ody12 = dy12 + ldy12;
+
+    // Only process the inner parallelogram if the line width ratio
+    // did not consume the entire interior of the parallelogram
+    // (i.e. if the width ratio was less than 1.0)
+    if (lwr21 < 1.0f && lwr12 < 1.0f) {
+        // calculate coordinates of the inner parallelogram
+        ifx11 = fx11 + (ldx21 + ldx12) / 2.0f;
+        ify11 = fy11 + (ldy21 + ldy12) / 2.0f;
+        idx21 = dx21 - ldx21;
+        idy21 = dy21 - ldy21;
+        idx12 = dx12 - ldx12;
+        idy12 = dy12 - ldy12;
+
+        res = d3dc->pVCacher->DrawParallelogramAA(ofx11, ofy11,
+                                                  odx21, ody21,
+                                                  odx12, ody12,
+                                                  ifx11, ify11,
+                                                  idx21, idy21,
+                                                  idx12, idy12);
+    } else {
+        // Just invoke a regular fill on the outer parallelogram
+        res = d3dc->pVCacher->FillParallelogramAA(ofx11, ofy11,
+                                                  odx21, ody21,
+                                                  odx12, ody12);
     }
 
-    DDrawSurface *ddTargetSurface = d3dc->GetTargetSurface();
-    if (ddTargetSurface == NULL) {
-        return;
-    }
+    return res;
+}
 
-    ddTargetSurface->GetExclusiveAccess();
-    d3dc->GetExclusiveAccess();
+#ifndef D3D_PPL_DLL
 
-    IDirect3DDevice7 *d3dDevice = d3dc->Get3DDevice();
-    if (d3dDevice == NULL) {
-        d3dc->ReleaseExclusiveAccess();
-        ddTargetSurface->ReleaseExclusiveAccess();
-        return;
-    }
+extern "C"
+{
 
-    HRESULT res = D3D_OK;
+JNIEXPORT void JNICALL
+Java_sun_java2d_d3d_D3DRenderer_drawPoly
+    (JNIEnv *env, jobject d3dr,
+     jintArray xpointsArray, jintArray ypointsArray,
+     jint nPoints, jboolean isClosed,
+     jint transX, jint transY)
+{
+    jint *xPoints, *yPoints;
 
-    // buffer for the span vertexes (6 vertexes per span)
-    static J2DXYC_HEXA spanVx[MAX_CACHED_SPAN_VX_NUM];
-    J2DXYC_HEXA *pHexa = (J2DXYC_HEXA*)spanVx;
-    jint numOfCachedSpans = 0;
-
-    if (SUCCEEDED(res = d3dc->BeginScene(STATE_RENDEROP))) {
-        srData = (*pFuncs->open)(env, si);
-
-        // REMIND: this is wrong, if something has failed, we need to
-        // do a EndScene/BeginScene()
-        D3DU_PRIM_LOOP_BEGIN(res, wsdo);
-        while ((*pFuncs->nextSpan)(srData, spanbox)) {
-            x1 = (float)(spanbox[0] + transx);
-            y1 = (float)(spanbox[1] + transy);
-            x2 = (float)(spanbox[2] + transx);
-            y2 = (float)(spanbox[3] + transy);
-
-            D3DU_INIT_VERTEX_COLOR_6(*pHexa, d3dc->colorPixel);
-            D3DU_INIT_VERTEX_XY_6(*pHexa, x1, y1, x2, y2);
-            numOfCachedSpans++;
-            pHexa = (J2DXYC_HEXA*)PtrAddBytes(pHexa, sizeof(J2DXYC_HEXA));
-            if (numOfCachedSpans >= MAX_CACHED_SPAN_VX_NUM) {
-                if (FAILED(res = ddTargetSurface->IsLost())) {
-                    numOfCachedSpans = 0;
-                    break;
-                }
-
-                res = d3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST,
-                                               D3DFVF_J2D_XY_C,
-                                               (void*)spanVx,
-                                               6*numOfCachedSpans, 0);
-                numOfCachedSpans = 0;
-                pHexa = (J2DXYC_HEXA*)spanVx;
-                if (FAILED(res)) {
-                    break;
-                }
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRenderer_drawPoly");
+
+    xPoints = (jint *)env->GetPrimitiveArrayCritical(xpointsArray, NULL);
+    if (xPoints != NULL) {
+        yPoints = (jint *)env->GetPrimitiveArrayCritical(ypointsArray, NULL);
+        if (yPoints != NULL) {
+            D3DContext *d3dc = D3DRQ_GetCurrentContext();
+
+            D3DRenderer_DrawPoly(d3dc,
+                                 nPoints, isClosed,
+                                 transX, transY,
+                                 xPoints, yPoints);
+
+            if (d3dc != NULL) {
+                HRESULT res = d3dc->EndScene();
+                D3DRQ_MarkLostIfNeeded(res,
+                    D3DRQ_GetCurrentDestination());
             }
+            env->ReleasePrimitiveArrayCritical(ypointsArray, yPoints, JNI_ABORT);
         }
-        if (numOfCachedSpans > 0) {
-            res = d3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, D3DFVF_J2D_XY_C,
-                                           (void*)spanVx,
-                                           6*numOfCachedSpans, 0);
-        }
-        D3DU_PRIM_LOOP_END(env, res, wsdo, "DrawPrimitive(D3DPT_TRIANGLEFAN)");
-
-        (*pFuncs->close)(env, srData);
-
-        d3dc->EndScene(res);
+        env->ReleasePrimitiveArrayCritical(xpointsArray, xPoints, JNI_ABORT);
     }
+}
 
-    d3dc->ReleaseExclusiveAccess();
-    ddTargetSurface->ReleaseExclusiveAccess();
 }
+
+#endif // D3D_PPL_DLL
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DRenderer.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DRenderer.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DRenderer.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DRenderer.h	2011-01-08 01:26:50.479202297 +0000
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "sun_java2d_pipe_BufferedRenderPipe.h"
+#include "D3DContext.h"
+
+#define BYTES_PER_POLY_POINT \
+    sun_java2d_pipe_BufferedRenderPipe_BYTES_PER_POLY_POINT
+#define BYTES_PER_SCANLINE \
+    sun_java2d_pipe_BufferedRenderPipe_BYTES_PER_SCANLINE
+#define BYTES_PER_SPAN \
+    sun_java2d_pipe_BufferedRenderPipe_BYTES_PER_SPAN
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawLine(D3DContext *d3dc,
+                     jint x1, jint y1, jint x2, jint y2);
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawRect(D3DContext *d3dc,
+                     jint x, jint y, jint w, jint h);
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_FillRect(D3DContext *d3dc,
+                     jint x, jint y, jint w, jint h);
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawPoly(D3DContext *d3dc,
+                     jint nPoints, jboolean isClosed,
+                     jint transX, jint transY,
+                     jint *xPoints, jint *yPoints);
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawScanlines(D3DContext *d3dc,
+                          jint scanlineCount, jint *scanlines);
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_FillSpans(D3DContext *d3dc, jint spanCount, jint *spans);
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_FillParallelogram(D3DContext *d3dc,
+                              jfloat fx11, jfloat fy11,
+                              jfloat dx21, jfloat dy21,
+                              jfloat dx12, jfloat dy12);
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawParallelogram(D3DContext *d3dc,
+                              jfloat fx11, jfloat fy11,
+                              jfloat dx21, jfloat dy21,
+                              jfloat dx12, jfloat dy12,
+                              jfloat lw21, jfloat lw12);
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_FillAAParallelogram(D3DContext *d3dc,
+                                jfloat fx11, jfloat fy11,
+                                jfloat dx21, jfloat dy21,
+                                jfloat dx12, jfloat dy12);
+
+HRESULT D3DPIPELINE_API
+D3DRenderer_DrawAAParallelogram(D3DContext *d3dc,
+                                jfloat fx11, jfloat fy11,
+                                jfloat dx21, jfloat dy21,
+                                jfloat dx12, jfloat dy12,
+                                jfloat lw21, jfloat lw12);
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DRenderQueue.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DRenderQueue.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DRenderQueue.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DRenderQueue.cpp	2011-01-08 01:26:50.479202297 +0000
@@ -0,0 +1,954 @@
+/*
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <malloc.h>
+#include <jni.h>
+#include "sun_java2d_pipe_BufferedOpCodes.h"
+
+#include "jlong.h"
+#include "D3DBlitLoops.h"
+#include "D3DBufImgOps.h"
+#include "D3DPipelineManager.h"
+#include "D3DContext.h"
+#include "D3DMaskBlit.h"
+#include "D3DMaskFill.h"
+#include "D3DPaints.h"
+#include "D3DRenderQueue.h"
+#include "D3DRenderer.h"
+#include "D3DSurfaceData.h"
+#include "D3DTextRenderer.h"
+#include "Trace.h"
+#include "awt_Toolkit.h"
+
+BOOL DWMIsCompositionEnabled();
+
+/**
+ * References to the "current" context and destination surface.
+ */
+static D3DContext *d3dc = NULL;
+static D3DSDOps *dstOps = NULL;
+static BOOL bLostDevices = FALSE;
+
+typedef struct {
+    byte *buffer;
+    int limit;
+    jobject runnable;
+} FlushBufferStruct;
+
+HRESULT
+D3DRQ_SwapBuffers(D3DPipelineManager *pMgr, D3DSDOps *d3dsdo,
+                  int x1, int y1, int x2, int y2)
+{
+    HRESULT res;
+    D3DContext *pCtx;
+    IDirect3DSwapChain9 *pSwapChain;
+    RECT srcRect, dstRect, *pSrcRect, *pDstRect;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRQ_SwapBuffers");
+    J2dTraceLn4(J2D_TRACE_VERBOSE, "  x1=%d y1=%d x2=%d y2=%d",
+                x1, y1, x2, y2);
+
+    RETURN_STATUS_IF_NULL(d3dsdo, E_FAIL);
+    RETURN_STATUS_IF_NULL(d3dsdo->pResource, E_FAIL);
+    RETURN_STATUS_IF_NULL(pSwapChain=d3dsdo->pResource->GetSwapChain(), E_FAIL);
+
+    pCtx = D3DRQ_GetCurrentContext();
+    if (pCtx != NULL) {
+        // flush the current vertex queue here, just in case
+        res = d3dc->FlushVertexQueue();
+        D3DRQ_MarkLostIfNeeded(res, dstOps);
+        pCtx = NULL;
+    }
+    // end scene for this destination
+    res = pMgr->GetD3DContext(d3dsdo->adapter, &pCtx);
+    RETURN_STATUS_IF_FAILED(res);
+
+    pCtx->EndScene();
+
+    // This is a workaround for what apparently is a DWM bug.
+    // If the dimensions of the back-buffer don't match the dimensions of
+    // the window, Present() will flash the whole window with black.
+    // The workaround is to detect this situation and not do a present.
+    // It is ok to do so since a repaint event is coming due to the resize that
+    // just happened.
+    //
+    // REMIND: this will need to be updated if we switch to creating
+    // back-buffers of the size of the client area instead of the whole window
+    // (use GetClientRect() instead of GetWindowRect()).
+    if (DWMIsCompositionEnabled()) {
+        RECT r;
+        D3DPRESENT_PARAMETERS params;
+
+        pSwapChain->GetPresentParameters(&params);
+        GetWindowRect(params.hDeviceWindow, &r);
+        int ww = r.right - r.left;
+        int wh = r.bottom - r.top;
+        if (ww != params.BackBufferWidth || wh != params.BackBufferHeight) {
+            J2dTraceLn4(J2D_TRACE_WARNING,
+                "D3DRQ_SwapBuffers: surface/window dimensions mismatch: "\
+                "win: w=%d h=%d, bb: w=%d h=%d",
+                ww, wh, params.BackBufferWidth, params.BackBufferHeight);
+
+            return S_OK;
+        }
+    }
+
+    if (d3dsdo->swapEffect == D3DSWAPEFFECT_COPY) {
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  D3DSWAPEFFECT_COPY");
+        if (x1 < 0) x1 = 0;
+        if (y1 < 0) y1 = 0;
+        if (x2 > d3dsdo->width)  x2 = d3dsdo->width;
+        if (y2 > d3dsdo->height) y2 = d3dsdo->height;
+        if (x2 <= x1 || y2 <= y1) {
+            // nothing to present
+            return S_OK;
+        }
+        srcRect.left = x1;
+        srcRect.top = y1;
+        srcRect.right = x2;
+        srcRect.bottom = y2;
+
+        dstRect = srcRect;
+
+        pSrcRect = &srcRect;
+        pDstRect = &dstRect;
+        // only offset in windowed mode
+        if (pCtx!= NULL && pCtx->GetPresentationParams()->Windowed) {
+            OffsetRect(pDstRect, d3dsdo->xoff, d3dsdo->yoff);
+        } else {
+            // some boards (Nvidia) have problems with copy strategy and
+            // non-null src/dest rectangles in fs mode; unfortunately this
+            // means that we'll paint over fs window decorations
+            pSrcRect = NULL;
+            pDstRect = NULL;
+        }
+    } else {
+        if (d3dsdo->swapEffect == D3DSWAPEFFECT_FLIP) {
+            J2dTraceLn(J2D_TRACE_VERBOSE, "  D3DSWAPEFFECT_FLIP");
+        } else {
+            J2dTraceLn(J2D_TRACE_VERBOSE, "  D3DSWAPEFFECT_DISCARD");
+        }
+        // src and dest rectangles must be NULL for FLIP/DISCARD
+        pSrcRect = NULL;
+        pDstRect = NULL;
+    }
+
+    res = pSwapChain->Present(pSrcRect, pDstRect, 0, NULL, 0);
+    res = D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+
+    return res;
+}
+
+HRESULT
+D3DRQ_MarkLostIfNeeded(HRESULT res, D3DSDOps *d3dops)
+{
+    if (res == D3DERR_DEVICELOST || res == D3DERR_DEVICENOTRESET) {
+        D3DContext *pCtx;
+
+        J2dTraceLn(J2D_TRACE_WARNING, "D3DRQ_MarkLostIfNeeded: device lost");
+        bLostDevices = TRUE;
+
+        // only mark surfaces belonging to the lost device
+        if (d3dops != NULL &&
+            SUCCEEDED(res = D3DPipelineManager::GetInstance()->
+                GetD3DContext(d3dops->adapter, &pCtx)))
+        {
+            IDirect3DDevice9 *pd3dDevice = pCtx->Get3DDevice();
+            if (pd3dDevice) {
+                HRESULT res1 = pd3dDevice->TestCooperativeLevel();
+                if (res1 != D3DERR_DEVICELOST && res1 != D3DERR_DEVICENOTRESET){
+                    // this surface's device is not lost, do not mark it
+                    return res;
+                }
+            }
+        }
+        D3DSD_MarkLost(d3dops);
+    }
+    return res;
+}
+
+void D3DRQ_FlushBuffer(void *pParam)
+{
+    FlushBufferStruct *pFlush = (FlushBufferStruct*)pParam;
+    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+    unsigned char *b, *end;
+    int limit;
+    HRESULT res = S_OK;
+    BOOL bSync = FALSE;
+
+    b = pFlush->buffer;
+    limit = pFlush->limit;
+    J2dTraceLn1(J2D_TRACE_INFO, "D3DRQ_flushBuffer: limit=%d", limit);
+
+    end = b + limit;
+
+    D3DPipelineManager *pMgr = D3DPipelineManager::GetInstance();
+    if (pMgr == NULL) {
+        J2dRlsTraceLn(J2D_TRACE_WARNING, "D3DRQ_flushBuffer: null manager");
+        return;
+    }
+
+    if (bLostDevices) {
+        if (SUCCEEDED(res = pMgr->HandleLostDevices())) {
+            bLostDevices = FALSE;
+        }
+    }
+
+    while (b < end) {
+        jint opcode = NEXT_INT(b);
+
+        J2dTraceLn1(J2D_TRACE_VERBOSE, "D3DRQ_flushBuffer: opcode=%d", opcode);
+
+        switch (opcode) {
+
+        // draw ops
+        case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
+            {
+                jint x1 = NEXT_INT(b);
+                jint y1 = NEXT_INT(b);
+                jint x2 = NEXT_INT(b);
+                jint y2 = NEXT_INT(b);
+
+                CONTINUE_IF_NULL(d3dc);
+                res = D3DRenderer_DrawLine(d3dc, x1, y1, x2, y2);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
+            {
+                jint x = NEXT_INT(b);
+                jint y = NEXT_INT(b);
+                jint w = NEXT_INT(b);
+                jint h = NEXT_INT(b);
+                CONTINUE_IF_NULL(d3dc);
+                res = D3DRenderer_DrawRect(d3dc, x, y, w, h);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
+            {
+                jint nPoints      = NEXT_INT(b);
+                jboolean isClosed = NEXT_BOOLEAN(b);
+                jint transX       = NEXT_INT(b);
+                jint transY       = NEXT_INT(b);
+                jint *xPoints = (jint *)b;
+                jint *yPoints = ((jint *)b) + nPoints;
+                CONTINUE_IF_NULL(d3dc);
+                res = D3DRenderer_DrawPoly(d3dc, nPoints, isClosed,
+                                           transX, transY,
+                                     xPoints, yPoints);
+                SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
+            {
+                jint x = NEXT_INT(b);
+                jint y = NEXT_INT(b);
+
+                CONTINUE_IF_NULL(d3dc);
+                res = D3DRenderer_DrawLine(d3dc, x, y, x, y);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
+            {
+                jint count = NEXT_INT(b);
+                res = D3DRenderer_DrawScanlines(d3dc, count, (jint *)b);
+                SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
+            {
+                jfloat x11 = NEXT_FLOAT(b);
+                jfloat y11 = NEXT_FLOAT(b);
+                jfloat dx21 = NEXT_FLOAT(b);
+                jfloat dy21 = NEXT_FLOAT(b);
+                jfloat dx12 = NEXT_FLOAT(b);
+                jfloat dy12 = NEXT_FLOAT(b);
+                jfloat lwr21 = NEXT_FLOAT(b);
+                jfloat lwr12 = NEXT_FLOAT(b);
+
+                CONTINUE_IF_NULL(d3dc);
+                res = D3DRenderer_DrawParallelogram(d3dc,
+                                                    x11, y11,
+                                                    dx21, dy21,
+                                                    dx12, dy12,
+                                                    lwr21, lwr12);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
+            {
+                jfloat x11 = NEXT_FLOAT(b);
+                jfloat y11 = NEXT_FLOAT(b);
+                jfloat dx21 = NEXT_FLOAT(b);
+                jfloat dy21 = NEXT_FLOAT(b);
+                jfloat dx12 = NEXT_FLOAT(b);
+                jfloat dy12 = NEXT_FLOAT(b);
+                jfloat lwr21 = NEXT_FLOAT(b);
+                jfloat lwr12 = NEXT_FLOAT(b);
+
+                CONTINUE_IF_NULL(d3dc);
+                res = D3DRenderer_DrawAAParallelogram(d3dc,
+                                                      x11, y11,
+                                                      dx21, dy21,
+                                                      dx12, dy12,
+                                                      lwr21, lwr12);
+            }
+            break;
+
+        // fill ops
+        case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
+            {
+                jint x = NEXT_INT(b);
+                jint y = NEXT_INT(b);
+                jint w = NEXT_INT(b);
+                jint h = NEXT_INT(b);
+
+                CONTINUE_IF_NULL(d3dc);
+                res = D3DRenderer_FillRect(d3dc, x, y, w, h);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
+            {
+                jfloat x11 = NEXT_FLOAT(b);
+                jfloat y11 = NEXT_FLOAT(b);
+                jfloat dx21 = NEXT_FLOAT(b);
+                jfloat dy21 = NEXT_FLOAT(b);
+                jfloat dx12 = NEXT_FLOAT(b);
+                jfloat dy12 = NEXT_FLOAT(b);
+
+                CONTINUE_IF_NULL(d3dc);
+                res = D3DRenderer_FillParallelogram(d3dc,
+                                                    x11, y11,
+                                                    dx21, dy21,
+                                                    dx12, dy12);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
+            {
+                jfloat x11 = NEXT_FLOAT(b);
+                jfloat y11 = NEXT_FLOAT(b);
+                jfloat dx21 = NEXT_FLOAT(b);
+                jfloat dy21 = NEXT_FLOAT(b);
+                jfloat dx12 = NEXT_FLOAT(b);
+                jfloat dy12 = NEXT_FLOAT(b);
+
+                CONTINUE_IF_NULL(d3dc);
+                res = D3DRenderer_FillAAParallelogram(d3dc,
+                                                      x11, y11,
+                                                      dx21, dy21,
+                                                      dx12, dy12);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
+            {
+                jint count = NEXT_INT(b);
+                res = D3DRenderer_FillSpans(d3dc, count, (jint *)b);
+                SKIP_BYTES(b, count * BYTES_PER_SPAN);
+            }
+            break;
+
+        // text-related ops
+        case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
+            {
+                jint numGlyphs        = NEXT_INT(b);
+                jint packedParams     = NEXT_INT(b);
+                jfloat glyphListOrigX = NEXT_FLOAT(b);
+                jfloat glyphListOrigY = NEXT_FLOAT(b);
+                jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
+                                                        OFFSET_POSITIONS);
+                jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
+                                                        OFFSET_SUBPIXPOS);
+                jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
+                                                        OFFSET_RGBORDER);
+                jint lcdContrast      = EXTRACT_BYTE(packedParams,
+                                                     OFFSET_CONTRAST);
+                unsigned char *images = b;
+                unsigned char *positions;
+                jint bytesPerGlyph;
+                if (usePositions) {
+                    positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
+                    bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
+                } else {
+                    positions = NULL;
+                    bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
+                }
+                res = D3DTR_DrawGlyphList(d3dc, dstOps,
+                                          numGlyphs, usePositions,
+                                          subPixPos, rgbOrder, lcdContrast,
+                                          glyphListOrigX, glyphListOrigY,
+                                          images, positions);
+                SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
+            }
+            break;
+
+        // copy-related ops
+        case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
+            {
+                jint x  = NEXT_INT(b);
+                jint y  = NEXT_INT(b);
+                jint w  = NEXT_INT(b);
+                jint h  = NEXT_INT(b);
+                jint dx = NEXT_INT(b);
+                jint dy = NEXT_INT(b);
+                res = D3DBlitLoops_CopyArea(env, d3dc, dstOps,
+                                            x, y, w, h, dx, dy);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_BLIT:
+            {
+                jint packedParams = NEXT_INT(b);
+                jint sx1          = NEXT_INT(b);
+                jint sy1          = NEXT_INT(b);
+                jint sx2          = NEXT_INT(b);
+                jint sy2          = NEXT_INT(b);
+                jdouble dx1       = NEXT_DOUBLE(b);
+                jdouble dy1       = NEXT_DOUBLE(b);
+                jdouble dx2       = NEXT_DOUBLE(b);
+                jdouble dy2       = NEXT_DOUBLE(b);
+                jlong pSrc        = NEXT_LONG(b);
+                jlong pDst        = NEXT_LONG(b);
+                jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
+                jboolean texture  = EXTRACT_BOOLEAN(packedParams,
+                                                    OFFSET_TEXTURE);
+                jboolean rtt      = EXTRACT_BOOLEAN(packedParams,
+                                                    OFFSET_RTT);
+                jboolean xform    = EXTRACT_BOOLEAN(packedParams,
+                                                    OFFSET_XFORM);
+                jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
+                                                    OFFSET_ISOBLIT);
+                if (isoblit) {
+                    res = D3DBlitLoops_IsoBlit(env, d3dc, pSrc, pDst,
+                                               xform, hint, texture, rtt,
+                                               sx1, sy1, sx2, sy2,
+                                               dx1, dy1, dx2, dy2);
+                    D3DRQ_MarkLostIfNeeded(res, (D3DSDOps*)pSrc);
+                } else {
+                    jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
+                    res = D3DBlitLoops_Blit(env, d3dc, pSrc, pDst,
+                                            xform, hint, srctype, texture,
+                                            sx1, sy1, sx2, sy2,
+                                            dx1, dy1, dx2, dy2);
+                }
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
+            {
+                jint sx      = NEXT_INT(b);
+                jint sy      = NEXT_INT(b);
+                jint dx      = NEXT_INT(b);
+                jint dy      = NEXT_INT(b);
+                jint w       = NEXT_INT(b);
+                jint h       = NEXT_INT(b);
+                jint dsttype = NEXT_INT(b);
+                jlong pSrc   = NEXT_LONG(b);
+                jlong pDst   = NEXT_LONG(b);
+                res = D3DBlitLoops_SurfaceToSwBlit(env, d3dc,
+                                                   pSrc, pDst, dsttype,
+                                                   sx, sy, dx, dy, w, h);
+                D3DRQ_MarkLostIfNeeded(res, (D3DSDOps*)pSrc);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
+            {
+                jint x        = NEXT_INT(b);
+                jint y        = NEXT_INT(b);
+                jint w        = NEXT_INT(b);
+                jint h        = NEXT_INT(b);
+                jint maskoff  = NEXT_INT(b);
+                jint maskscan = NEXT_INT(b);
+                jint masklen  = NEXT_INT(b);
+                unsigned char *pMask = (masklen > 0) ? b : NULL;
+                res = D3DMaskFill_MaskFill(d3dc, x, y, w, h,
+                                           maskoff, maskscan, masklen, pMask);
+                SKIP_BYTES(b, masklen);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
+            {
+                jint dstx     = NEXT_INT(b);
+                jint dsty     = NEXT_INT(b);
+                jint width    = NEXT_INT(b);
+                jint height   = NEXT_INT(b);
+                jint masklen  = width * height * sizeof(jint);
+                res = D3DMaskBlit_MaskBlit(env, d3dc,
+                                           dstx, dsty, width, height, b);
+                SKIP_BYTES(b, masklen);
+            }
+            break;
+
+        // state-related ops
+        case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
+            {
+                jint x1 = NEXT_INT(b);
+                jint y1 = NEXT_INT(b);
+                jint x2 = NEXT_INT(b);
+                jint y2 = NEXT_INT(b);
+                CONTINUE_IF_NULL(d3dc);
+                res = d3dc->SetRectClip(x1, y1, x2, y2);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
+            {
+                CONTINUE_IF_NULL(d3dc);
+                res = d3dc->BeginShapeClip();
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
+            {
+                jint count = NEXT_INT(b);
+                res = D3DRenderer_FillSpans(d3dc, count, (jint *)b);
+                SKIP_BYTES(b, count * BYTES_PER_SPAN);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
+            {
+                CONTINUE_IF_NULL(d3dc);
+                res = d3dc->EndShapeClip();
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
+            {
+                CONTINUE_IF_NULL(d3dc);
+                res = d3dc->ResetClip();
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
+            {
+                jint rule         = NEXT_INT(b);
+                jfloat extraAlpha = NEXT_FLOAT(b);
+                jint flags        = NEXT_INT(b);
+                CONTINUE_IF_NULL(d3dc);
+                res = d3dc->SetAlphaComposite(rule, extraAlpha, flags);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
+            {
+                jint xorPixel = NEXT_INT(b);
+//                res = d3dc->SetXorComposite(d3dc, xorPixel);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
+            {
+                CONTINUE_IF_NULL(d3dc);
+                res = d3dc->ResetComposite();
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
+            {
+                jdouble m00 = NEXT_DOUBLE(b);
+                jdouble m10 = NEXT_DOUBLE(b);
+                jdouble m01 = NEXT_DOUBLE(b);
+                jdouble m11 = NEXT_DOUBLE(b);
+                jdouble m02 = NEXT_DOUBLE(b);
+                jdouble m12 = NEXT_DOUBLE(b);
+                res = d3dc->SetTransform(m00, m10, m01, m11, m02, m12);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
+            {
+                CONTINUE_IF_NULL(d3dc);
+                res = d3dc->ResetTransform();
+            }
+            break;
+
+        // context-related ops
+        case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
+            {
+                jlong pSrc = NEXT_LONG(b);
+                jlong pDst = NEXT_LONG(b);
+                D3DContext *oldd3dc = NULL;
+                if (d3dc != NULL) {
+                    oldd3dc = d3dc;
+                    d3dc = NULL;
+                    oldd3dc->UpdateState(STATE_CHANGE);
+                }
+                dstOps = (D3DSDOps *)jlong_to_ptr(pDst);
+                res = pMgr->GetD3DContext(dstOps->adapter, &d3dc);
+                if (FAILED(res)) {
+                    J2dRlsTraceLn(J2D_TRACE_ERROR,
+                        "D3DRQ_FlushBuffer: failed to get context");
+                    D3DRQ_ResetCurrentContextAndDestination();
+                    break;
+                }
+                // REMIND: we may also want to do EndScene on each
+                // render target change so that the GPU can go work on
+                // whatever is already in the queue
+                if (oldd3dc != d3dc && oldd3dc != NULL) {
+                    res = oldd3dc->EndScene();
+                }
+                CONTINUE_IF_NULL(dstOps->pResource);
+                res = d3dc->SetRenderTarget(dstOps->pResource->GetSurface());
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
+            {
+                jint screen = NEXT_INT(b);
+                jint adapter = pMgr->GetAdapterOrdinalForScreen(screen);
+                D3DContext *oldd3dc = NULL;
+
+                if (d3dc != NULL) {
+                    oldd3dc = d3dc;
+                    d3dc = NULL;
+                }
+                res = pMgr->GetD3DContext(adapter, &d3dc);
+                if (FAILED(res)) {
+                    J2dRlsTraceLn(J2D_TRACE_ERROR,
+                        "D3DRQ_FlushBuffer: failed to get context");
+                    D3DRQ_ResetCurrentContextAndDestination();
+                } else if (oldd3dc != d3dc && oldd3dc != NULL) {
+                    res = oldd3dc->EndScene();
+                }
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
+            {
+                jlong pData = NEXT_LONG(b);
+                D3DSDOps *d3dsdo = (D3DSDOps *)jlong_to_ptr(pData);
+                D3DSD_Flush(d3dsdo);
+                if (dstOps == d3dsdo) {
+                    dstOps = NULL;
+                }
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
+            {
+                jlong pData = NEXT_LONG(b);
+                D3DSDOps *d3dsdo = (D3DSDOps *)jlong_to_ptr(pData);
+                D3DSD_Flush(d3dsdo);
+                if (dstOps == d3dsdo) {
+                    dstOps = NULL;
+                }
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
+            {
+                jlong pConfigInfo = NEXT_LONG(b);
+                CONTINUE_IF_NULL(d3dc);
+                // REMIND: does this need to be implemented for D3D?
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
+            {
+                // flush just in case there are any pending operations in
+                // the hardware pipe
+                if (d3dc != NULL) {
+                    res = d3dc->EndScene();
+                }
+
+                // invalidate the references to the current context and
+                // destination surface that are maintained at the native level
+                D3DRQ_ResetCurrentContextAndDestination();
+            }
+            break;
+
+        case sun_java2d_pipe_BufferedOpCodes_SYNC:
+            {
+                bSync = TRUE;
+            }
+            break;
+
+        case sun_java2d_pipe_BufferedOpCodes_RESTORE_DEVICES:
+            {
+                J2dTraceLn(J2D_TRACE_INFO, "D3DRQ_FlushBuffer:  RESTORE_DEVICES");
+                if (SUCCEEDED(res = pMgr->HandleLostDevices())) {
+                    bLostDevices = FALSE;
+                } else {
+                    bLostDevices = TRUE;
+                }
+            }
+            break;
+
+        case sun_java2d_pipe_BufferedOpCodes_SAVE_STATE:
+            {
+                CONTINUE_IF_NULL(d3dc);
+
+                res = d3dc->SaveState();
+            }
+            break;
+
+        case sun_java2d_pipe_BufferedOpCodes_RESTORE_STATE:
+            {
+                CONTINUE_IF_NULL(d3dc);
+
+                res = d3dc->RestoreState();
+            }
+            break;
+
+        // multibuffering ops
+        case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
+            {
+                jlong sdo = NEXT_LONG(b);
+                jint x1 = NEXT_INT(b);
+                jint y1 = NEXT_INT(b);
+                jint x2 = NEXT_INT(b);
+                jint y2 = NEXT_INT(b);
+
+                res = D3DRQ_SwapBuffers(pMgr, (D3DSDOps *)jlong_to_ptr(sdo),
+                                        x1, y1, x2, y2);
+            }
+            break;
+
+        // special no-op (mainly used for achieving 8-byte alignment)
+        case sun_java2d_pipe_BufferedOpCodes_NOOP:
+            break;
+
+        // paint-related ops
+        case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
+            {
+                res = D3DPaints_ResetPaint(d3dc);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
+            {
+                jint pixel = NEXT_INT(b);
+                res = D3DPaints_SetColor(d3dc, pixel);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
+            {
+                jboolean useMask= NEXT_BOOLEAN(b);
+                jboolean cyclic = NEXT_BOOLEAN(b);
+                jdouble p0      = NEXT_DOUBLE(b);
+                jdouble p1      = NEXT_DOUBLE(b);
+                jdouble p3      = NEXT_DOUBLE(b);
+                jint pixel1     = NEXT_INT(b);
+                jint pixel2     = NEXT_INT(b);
+                res = D3DPaints_SetGradientPaint(d3dc, useMask, cyclic,
+                                                 p0, p1, p3,
+                                                 pixel1, pixel2);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
+            {
+                jboolean useMask = NEXT_BOOLEAN(b);
+                jboolean linear  = NEXT_BOOLEAN(b);
+                jint cycleMethod = NEXT_INT(b);
+                jint numStops    = NEXT_INT(b);
+                jfloat p0        = NEXT_FLOAT(b);
+                jfloat p1        = NEXT_FLOAT(b);
+                jfloat p3        = NEXT_FLOAT(b);
+                void *fractions, *pixels;
+                fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
+                pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
+                res = D3DPaints_SetLinearGradientPaint(d3dc, dstOps,
+                                                        useMask, linear,
+                                                        cycleMethod, numStops,
+                                                        p0, p1, p3,
+                                                        fractions, pixels);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
+            {
+                jboolean useMask = NEXT_BOOLEAN(b);
+                jboolean linear  = NEXT_BOOLEAN(b);
+                jint numStops    = NEXT_INT(b);
+                jint cycleMethod = NEXT_INT(b);
+                jfloat m00       = NEXT_FLOAT(b);
+                jfloat m01       = NEXT_FLOAT(b);
+                jfloat m02       = NEXT_FLOAT(b);
+                jfloat m10       = NEXT_FLOAT(b);
+                jfloat m11       = NEXT_FLOAT(b);
+                jfloat m12       = NEXT_FLOAT(b);
+                jfloat focusX    = NEXT_FLOAT(b);
+                void *fractions, *pixels;
+                fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
+                pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
+                res = D3DPaints_SetRadialGradientPaint(d3dc, dstOps,
+                                                       useMask, linear,
+                                                       cycleMethod, numStops,
+                                                       m00, m01, m02,
+                                                       m10, m11, m12,
+                                                       focusX,
+                                                       fractions, pixels);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
+            {
+                jboolean useMask= NEXT_BOOLEAN(b);
+                jboolean filter = NEXT_BOOLEAN(b);
+                jlong pSrc      = NEXT_LONG(b);
+                jdouble xp0     = NEXT_DOUBLE(b);
+                jdouble xp1     = NEXT_DOUBLE(b);
+                jdouble xp3     = NEXT_DOUBLE(b);
+                jdouble yp0     = NEXT_DOUBLE(b);
+                jdouble yp1     = NEXT_DOUBLE(b);
+                jdouble yp3     = NEXT_DOUBLE(b);
+                res = D3DPaints_SetTexturePaint(d3dc, useMask, pSrc, filter,
+                                                xp0, xp1, xp3,
+                                                yp0, yp1, yp3);
+            }
+            break;
+
+        // BufferedImageOp-related ops
+        case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
+            {
+                jlong pSrc        = NEXT_LONG(b);
+                jboolean edgeZero = NEXT_BOOLEAN(b);
+                jint kernelWidth  = NEXT_INT(b);
+                jint kernelHeight = NEXT_INT(b);
+                res = D3DBufImgOps_EnableConvolveOp(d3dc, pSrc, edgeZero,
+                                                    kernelWidth, kernelHeight, b);
+                SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
+            {
+                res = D3DBufImgOps_DisableConvolveOp(d3dc);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
+            {
+                jlong pSrc          = NEXT_LONG(b); // unused
+                jboolean nonPremult = NEXT_BOOLEAN(b);
+                jint numFactors     = 4;
+                unsigned char *scaleFactors = b;
+                unsigned char *offsets = (b + numFactors * sizeof(jfloat));
+                res = D3DBufImgOps_EnableRescaleOp(d3dc, nonPremult,
+                                                   scaleFactors, offsets);
+                SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
+            {
+                D3DBufImgOps_DisableRescaleOp(d3dc);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
+            {
+                jlong pSrc          = NEXT_LONG(b); // unused
+                jboolean nonPremult = NEXT_BOOLEAN(b);
+                jboolean shortData  = NEXT_BOOLEAN(b);
+                jint numBands       = NEXT_INT(b);
+                jint bandLength     = NEXT_INT(b);
+                jint offset         = NEXT_INT(b);
+                jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
+                void *tableValues = b;
+                res = D3DBufImgOps_EnableLookupOp(d3dc, nonPremult, shortData,
+                                                  numBands, bandLength, offset,
+                                                  tableValues);
+                SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
+            }
+            break;
+        case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
+            {
+                res = D3DBufImgOps_DisableLookupOp(d3dc);
+            }
+            break;
+
+        default:
+            J2dRlsTraceLn1(J2D_TRACE_ERROR,
+                "D3DRQ_flushBuffer: invalid opcode=%d", opcode);
+            return;
+        }
+        // we may mark the surface lost repeatedly but that won't do much harm
+        res = D3DRQ_MarkLostIfNeeded(res, dstOps);
+    }
+
+    if (d3dc != NULL) {
+        res = d3dc->EndScene();
+        // REMIND: EndScene is not really enough to flush the
+        // whole d3d pipeline
+
+        // REMIND: there may be an issue with BeginScene/EndScene
+        // for each flushQueue, because of the blits, which flush
+        // the queue
+        if (bSync) {
+            res = d3dc->Sync();
+        }
+    }
+
+    // REMIND: we need to also handle hard errors here as well, and disable
+    // particular context if needed
+    D3DRQ_MarkLostIfNeeded(res, dstOps);
+
+    if (!JNU_IsNull(env, pFlush->runnable)) {
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  executing runnable");
+        JNU_CallMethodByName(env, NULL, pFlush->runnable, "run", "()V");
+    }
+}
+
+/**
+ * Returns a pointer to the "current" context, as set by the last SET_SURFACES
+ * or SET_SCRATCH_SURFACE operation.
+ */
+D3DContext *
+D3DRQ_GetCurrentContext()
+{
+    return d3dc;
+}
+
+/**
+ * Returns a pointer to the "current" destination surface, as set by the last
+ * SET_SURFACES operation.
+ */
+D3DSDOps *
+D3DRQ_GetCurrentDestination()
+{
+    return dstOps;
+}
+
+/**
+ * Resets current context and destination surface.
+ */
+void
+D3DRQ_ResetCurrentContextAndDestination()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRQ_ResetCurrentContextAndDestination");
+
+    d3dc = NULL;
+    dstOps = NULL;
+}
+
+extern "C"
+{
+
+/*
+ * Class:     sun_java2d_d3d_D3DRenderQueue
+ * Method:    flushBuffer
+ * Signature: (JILjava/lang/Runnable;)V
+ */
+JNIEXPORT void JNICALL
+Java_sun_java2d_d3d_D3DRenderQueue_flushBuffer
+  (JNIEnv *env, jobject d3drq, jlong buf, jint limit, jobject runnable)
+{
+    FlushBufferStruct bufstr;
+    // just in case we forget to init any new fields
+    ZeroMemory(&bufstr, sizeof(FlushBufferStruct));
+
+    bufstr.buffer = (unsigned char *)jlong_to_ptr(buf);
+    if (bufstr.buffer == NULL) {
+        J2dRlsTraceLn(J2D_TRACE_ERROR,
+            "D3DRenderQueue_flushBuffer: cannot get direct buffer address");
+        return;
+    }
+    bufstr.limit = limit;
+
+    bufstr.runnable = JNU_IsNull(env, runnable) ?
+        NULL : env->NewGlobalRef(runnable);
+    AwtToolkit::GetInstance().InvokeFunction(D3DRQ_FlushBuffer, &bufstr);
+    if (!JNU_IsNull(env, bufstr.runnable)) {
+        env->DeleteGlobalRef(bufstr.runnable);
+    }
+}
+
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DRenderQueue.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DRenderQueue.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DRenderQueue.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DRenderQueue.h	2011-01-08 01:26:50.479202297 +0000
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef D3DRenderQueue_h_Included
+#define D3DRenderQueue_h_Included
+
+#include "D3DContext.h"
+#include "D3DSurfaceData.h"
+
+/*
+ * The following macros are used to pick values (of the specified type) off
+ * the queue.
+ */
+#define NEXT_VAL(buf, type) (((type *)((buf) += sizeof(type)))[-1])
+#define NEXT_BYTE(buf)      NEXT_VAL(buf, unsigned char)
+#define NEXT_INT(buf)       NEXT_VAL(buf, jint)
+#define NEXT_FLOAT(buf)     NEXT_VAL(buf, jfloat)
+#define NEXT_BOOLEAN(buf)   (jboolean)NEXT_INT(buf)
+#define NEXT_LONG(buf)      NEXT_VAL(buf, jlong)
+#define NEXT_DOUBLE(buf)    NEXT_VAL(buf, jdouble)
+
+/*
+ * Increments a pointer (buf) by the given number of bytes.
+ */
+#define SKIP_BYTES(buf, numbytes) buf += (numbytes)
+
+/*
+ * Extracts a value at the given offset from the provided packed value.
+ */
+#define EXTRACT_VAL(packedval, offset, mask) \
+    (((packedval) >> (offset)) & (mask))
+#define EXTRACT_BYTE(packedval, offset) \
+    (unsigned char)EXTRACT_VAL(packedval, offset, 0xff)
+#define EXTRACT_BOOLEAN(packedval, offset) \
+    (jboolean)EXTRACT_VAL(packedval, offset, 0x1)
+
+D3DContext *D3DRQ_GetCurrentContext();
+D3DSDOps *D3DRQ_GetCurrentDestination();
+void D3DRQ_ResetCurrentContextAndDestination();
+HRESULT D3DRQ_MarkLostIfNeeded(HRESULT res, D3DSDOps *d3dops);
+
+#endif /* D3DRenderQueue_h_Included */
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DResourceManager.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DResourceManager.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DResourceManager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DResourceManager.cpp	2011-01-08 01:26:50.479202297 +0000
@@ -0,0 +1,765 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "D3DResourceManager.h"
+#include "awt.h"
+#include "D3DPaints.h"
+#include "D3DTextRenderer.h"
+
+void
+D3DResource::Init(IDirect3DResource9 *pRes, IDirect3DSwapChain9 *pSC)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DResource::Init");
+
+    pResource  = NULL;
+    pSwapChain = pSC;
+    pSurface   = NULL;
+    pTexture   = NULL;
+    pOps       = NULL;
+    ZeroMemory(&desc, sizeof(desc));
+    desc.Format = D3DFMT_UNKNOWN;
+
+    if (pRes != NULL) {
+        pResource = pRes;
+
+        D3DRESOURCETYPE type = pResource->GetType();
+        switch (type) {
+        case D3DRTYPE_TEXTURE:
+            // addRef is needed because both pResource and pTexture will be
+            // Release()d, and they point to the same object
+            pResource->AddRef();
+            pTexture = (IDirect3DTexture9*)pResource;
+            pTexture->GetSurfaceLevel(0, &pSurface);
+            break;
+        case D3DRTYPE_SURFACE:
+            pResource->AddRef();
+            pSurface = (IDirect3DSurface9*)pResource;
+            break;
+        case D3DRTYPE_CUBETEXTURE:
+            ((IDirect3DCubeTexture9*)pResource)->GetLevelDesc(0, &desc);
+            break;
+        default:
+            J2dTraceLn1(J2D_TRACE_VERBOSE, "  resource type=%d", type);
+        }
+    } else if (pSwapChain != NULL) {
+        pSwapChain->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pSurface);
+    } else {
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  pResource == pSwapChain == NULL");
+    }
+
+    if (pSurface != NULL) {
+        pSurface->GetDesc(&desc);
+    }
+
+    SAFE_PRINTLN(pResource);
+    SAFE_PRINTLN(pSurface);
+    SAFE_PRINTLN(pTexture);
+    SAFE_PRINTLN(pSwapChain);
+}
+
+D3DResource::~D3DResource()
+{
+    Release();
+}
+
+void
+D3DResource::SetSDOps(D3DSDOps *pOps)
+{
+    if (pOps != NULL && this->pOps != NULL) {
+        // something's wrong, we're overwriting
+        // a non-null field (setting it to null is allowed)
+        J2dTraceLn2(J2D_TRACE_WARNING,
+                    "D3DResource::SetSDOps: overwriting "\
+                    "this->pOps=0x%x with pOps=0x%x", this->pOps, pOps);
+    }
+    this->pOps = pOps;
+}
+
+BOOL
+D3DResource::IsDefaultPool()
+{
+    if (desc.Format != D3DFMT_UNKNOWN) {
+        return (desc.Pool == D3DPOOL_DEFAULT);
+    }
+    return TRUE;
+}
+
+void
+D3DResource::Release()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DResource::Release");
+
+    SAFE_PRINTLN(pResource);
+    SAFE_PRINTLN(pSurface);
+    SAFE_PRINTLN(pTexture);
+    SAFE_PRINTLN(pSwapChain);
+
+    SAFE_RELEASE(pSurface);
+    SAFE_RELEASE(pTexture);
+    SAFE_RELEASE(pResource);
+    SAFE_RELEASE(pSwapChain);
+
+    if (pOps != NULL) {
+        // if sdOps is not NULL it means that the release was initiated
+        // from the native level, and is caused by a surface loss
+        D3DSD_MarkLost(pOps);
+        pOps->pResource = NULL;
+        pOps = NULL;
+    }
+}
+
+HRESULT
+D3DResourceManager::CreateInstance(D3DContext *pCtx,
+                                   D3DResourceManager** ppResourceMgr)
+{
+    HRESULT res;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::CreateInstance");
+
+    *ppResourceMgr = new D3DResourceManager();
+    if (FAILED(res = (*ppResourceMgr)->Init(pCtx))) {
+        delete *ppResourceMgr;
+        *ppResourceMgr = NULL;
+    }
+    return res;
+}
+
+D3DResourceManager::D3DResourceManager()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::D3DRM");
+
+    this->pCtx = NULL;
+    this->pHead = NULL;
+}
+
+HRESULT
+D3DResourceManager::Init(D3DContext *pCtx)
+{
+    J2dTraceLn1(J2D_TRACE_INFO, "D3DRM::Init pCtx=%x", pCtx);
+    if (this->pCtx != pCtx ||
+        (this->pCtx != NULL &&
+         this->pCtx->Get3DDevice() != pCtx->Get3DDevice()))
+    {
+        ReleaseAll();
+    }
+    this->pCtx = pCtx;
+    return S_OK;
+}
+
+D3DResourceManager::~D3DResourceManager()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::~D3DRM");
+    ReleaseAll();
+    pCtx = NULL;
+    pHead = NULL;
+}
+
+void
+D3DResourceManager::ReleaseAll()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::ReleaseAll");
+    IManagedResource* pCurrent;
+    while (pHead != NULL) {
+        pCurrent = pHead;
+        pHead = pHead->pNext;
+        delete pCurrent;
+    }
+    pCachedDestTexture    = NULL;
+    pBlitTexture          = NULL;
+    pBlitRTTexture        = NULL;
+    pBlitOSPSurface       = NULL;
+    pGradientTexture      = NULL;
+    pLookupOpLutTexture   = NULL;
+    pMaskTexture          = NULL;
+    pMultiGradientTexture = NULL;
+    pLockableRTSurface    = NULL;
+}
+
+void
+D3DResourceManager::ReleaseDefPoolResources()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::ReleaseDefPoolResources");
+    // REMIND: for now, release all resources
+    ReleaseAll();
+}
+
+HRESULT
+D3DResourceManager::ReleaseResource(IManagedResource* pResource)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::ReleaseResource");
+
+    if (pResource != NULL) {
+        J2dTraceLn1(J2D_TRACE_VERBOSE, "  releasing pResource=%x", pResource);
+        if (pResource->pPrev != NULL) {
+            pResource->pPrev->pNext = pResource->pNext;
+        } else {
+            // it's the head
+            pHead = pResource->pNext;
+            if (pHead != NULL) {
+                pHead->pPrev = NULL;
+            }
+        }
+        if (pResource->pNext != NULL) {
+            pResource->pNext->pPrev = pResource->pPrev;
+        }
+        delete pResource;
+    }
+    return S_OK;
+}
+
+HRESULT
+D3DResourceManager::AddResource(IManagedResource* pResource)
+{
+    HRESULT res = S_OK;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::AddResource");
+
+    if (pResource != NULL) {
+        J2dTraceLn1(J2D_TRACE_VERBOSE, "  pResource=%x", pResource);
+        pResource->pPrev = NULL;
+        pResource->pNext = pHead;
+        if (pHead != NULL) {
+            pHead->pPrev = pResource;
+        }
+        pHead = pResource;
+    }
+
+    return S_OK;
+}
+
+HRESULT
+D3DResourceManager::CreateTexture(UINT width, UINT height,
+                                  BOOL isRTT, BOOL isOpaque,
+                                  D3DFORMAT *pFormat, DWORD dwUsage,
+                                  D3DResource **ppTextureResource)
+{
+    D3DPOOL pool;
+    D3DFORMAT format;
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::CreateTexture");
+    J2dTraceLn4(J2D_TRACE_VERBOSE, "  w=%d h=%d isRTT=%d isOpaque=%d",
+                width, height, isRTT, isOpaque);
+
+    if (ppTextureResource == NULL || pCtx == NULL ||
+        (pd3dDevice = pCtx->Get3DDevice()) == NULL)
+    {
+        return E_FAIL;
+    }
+    if (FAILED(res = pd3dDevice->TestCooperativeLevel())) {
+        return res;
+    }
+
+    if (pFormat != NULL && *pFormat != D3DFMT_UNKNOWN) {
+        format = *pFormat;
+    } else {
+        if (isOpaque) {
+            format = D3DFMT_X8R8G8B8;
+        } else {
+            format = D3DFMT_A8R8G8B8;
+        }
+    }
+
+    if (isRTT) {
+        dwUsage = D3DUSAGE_RENDERTARGET;
+        pool = D3DPOOL_DEFAULT;
+    } else {
+        if (dwUsage == D3DUSAGE_DYNAMIC && !pCtx->IsDynamicTextureSupported()) {
+            dwUsage = 0;
+        }
+        if (dwUsage == D3DUSAGE_DYNAMIC) {
+            pool = D3DPOOL_DEFAULT;
+        } else {
+            pool = pCtx->IsHWRasterizer() ?
+                D3DPOOL_MANAGED : D3DPOOL_SYSTEMMEM;
+        }
+    }
+
+    if (pCtx->IsPow2TexturesOnly()) {
+          UINT w, h;
+          for (w = 1; width  > w; w <<= 1);
+          for (h = 1; height > h; h <<= 1);
+          width = w;
+          height = h;
+    }
+    if (pCtx->IsSquareTexturesOnly()) {
+        if (width > height) {
+            height = width;
+        } else {
+            width = height;
+        }
+    }
+
+    IDirect3DTexture9 *pTexture = NULL;
+    res = pd3dDevice->CreateTexture(width, height, 1/*levels*/, dwUsage,
+                                    format, pool, &pTexture, 0);
+    if (SUCCEEDED(res)) {
+        J2dTraceLn1(J2D_TRACE_VERBOSE, "  created texture: 0x%x", pTexture);
+        *ppTextureResource = new D3DResource((IDirect3DResource9*)pTexture);
+        res = AddResource(*ppTextureResource);
+    } else {
+        DebugPrintD3DError(res, "D3DRM::CreateTexture failed");
+        *ppTextureResource = NULL;
+        format = D3DFMT_UNKNOWN;
+    }
+
+    if (pFormat != NULL) {
+        *pFormat = format;
+    }
+
+    return res;
+}
+
+HRESULT D3DResourceManager::CreateRTSurface(UINT width, UINT height,
+                                         BOOL isOpaque, BOOL isLockable,
+                                         D3DFORMAT *pFormat/*out*/,
+                                         D3DResource** ppSurfaceResource/*out*/)
+{
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::CreateRTSurface");
+    J2dTraceLn3(J2D_TRACE_VERBOSE, "  w=%d h=%d isOpaque=%d",
+                width, height, isOpaque);
+
+    if (pCtx == NULL || ppSurfaceResource == NULL ||
+        (pd3dDevice = pCtx->Get3DDevice()) == NULL)
+    {
+        return E_FAIL;
+    }
+    if (FAILED(res = pd3dDevice->TestCooperativeLevel())) {
+        return res;
+    }
+
+    D3DPRESENT_PARAMETERS *curParams = pCtx->GetPresentationParams();
+    D3DFORMAT format = isOpaque ? curParams->BackBufferFormat : D3DFMT_A8R8G8B8;
+    IDirect3DSurface9 *pSurface = NULL;
+
+    res = pd3dDevice->CreateRenderTarget(width, height, format,
+                                         D3DMULTISAMPLE_NONE, 0,
+                                         isLockable,
+                                         &pSurface, NULL);
+    if (SUCCEEDED(res)) {
+        J2dTraceLn1(J2D_TRACE_VERBOSE, "  created RT Surface: 0x%x ", pSurface);
+        if (pFormat != NULL) {
+            *pFormat = format;
+        }
+        *ppSurfaceResource = new D3DResource((IDirect3DResource9*)pSurface);
+        res = AddResource(*ppSurfaceResource);
+    } else {
+        DebugPrintD3DError(res, "D3DRM::CreateRTSurface failed");
+        ppSurfaceResource = NULL;
+    }
+    return res;
+}
+
+// REMIND: this method is currently unused; consider removing it later...
+HRESULT D3DResourceManager::CreateOSPSurface(UINT width, UINT height,
+                                         D3DFORMAT fmt,
+                                         D3DResource** ppSurfaceResource/*out*/)
+{
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::CreateOSPSurface");
+    J2dTraceLn2(J2D_TRACE_VERBOSE, "  w=%d h=%d", width, height);
+
+    if (pCtx == NULL || ppSurfaceResource == NULL ||
+        (pd3dDevice = pCtx->Get3DDevice()) == NULL)
+    {
+        return E_FAIL;
+    }
+    if (FAILED(res = pd3dDevice->TestCooperativeLevel())) {
+        return res;
+    }
+
+    // since the off-screen plain surface is intended to be used with
+    // the UpdateSurface() method, it is essential that it be created
+    // in the same format as the destination and allocated in the
+    // SYSTEMMEM pool (otherwise UpdateSurface() will fail)
+    D3DFORMAT format;
+    if (fmt == D3DFMT_UNKNOWN) {
+        format = pCtx->GetPresentationParams()->BackBufferFormat;
+    } else {
+        format = fmt;
+    }
+    D3DPOOL pool = D3DPOOL_SYSTEMMEM;
+    IDirect3DSurface9 *pSurface = NULL;
+
+    res = pd3dDevice->CreateOffscreenPlainSurface(width, height,
+                                                  format, pool,
+                                                  &pSurface, NULL);
+    if (SUCCEEDED(res)) {
+        J2dTraceLn1(J2D_TRACE_VERBOSE, "  created OSP Surface: 0x%x ",pSurface);
+        *ppSurfaceResource = new D3DResource((IDirect3DResource9*)pSurface);
+        res = AddResource(*ppSurfaceResource);
+    } else {
+        DebugPrintD3DError(res, "D3DRM::CreateOSPSurface failed");
+        ppSurfaceResource = NULL;
+    }
+    return res;
+}
+
+HRESULT
+D3DResourceManager::CreateSwapChain(HWND hWnd, UINT numBuffers,
+                                    UINT width, UINT height,
+                                    D3DSWAPEFFECT swapEffect,
+                                    UINT presentationInterval,
+                                    D3DResource ** ppSwapChainResource)
+{
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice;
+    IDirect3DSwapChain9 *pSwapChain = NULL;
+    D3DPRESENT_PARAMETERS newParams, *curParams;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::CreateSwapChain");
+    J2dTraceLn4(J2D_TRACE_VERBOSE, "  w=%d h=%d hwnd=%x numBuffers=%d",
+                width, height, hWnd, numBuffers);
+
+    if (pCtx == NULL || ppSwapChainResource == NULL ||
+        (pd3dDevice = pCtx->Get3DDevice()) == NULL)
+    {
+        return E_FAIL;
+    }
+    RETURN_STATUS_IF_FAILED(res = pd3dDevice->TestCooperativeLevel());
+
+    curParams = pCtx->GetPresentationParams();
+
+    if (curParams->Windowed == FALSE) {
+        // there's a single swap chain in full-screen mode, use it if
+        // it fits our parameters, reset the device otherwise
+        if (curParams->BackBufferCount != numBuffers ||
+            curParams->SwapEffect != swapEffect ||
+            curParams->PresentationInterval != presentationInterval)
+        {
+            newParams = *curParams;
+            newParams.BackBufferCount = numBuffers;
+            newParams.SwapEffect = swapEffect;
+            newParams.PresentationInterval = presentationInterval;
+
+            res = pCtx->ConfigureContext(&newParams);
+            RETURN_STATUS_IF_FAILED(res);
+            // this reset will not have released the device, so our pd3dDevice
+            // is still valid, but to be on a safe side, reset it
+            pd3dDevice = pCtx->Get3DDevice();
+        }
+        res = pd3dDevice->GetSwapChain(0, &pSwapChain);
+    } else {
+        ZeroMemory(&newParams, sizeof(D3DPRESENT_PARAMETERS));
+        newParams.BackBufferWidth = width;
+        newParams.BackBufferHeight = height;
+        newParams.hDeviceWindow = hWnd;
+        newParams.Windowed = TRUE;
+        newParams.BackBufferCount = numBuffers;
+        newParams.SwapEffect = swapEffect;
+        newParams.PresentationInterval = presentationInterval;
+
+        res = pd3dDevice->CreateAdditionalSwapChain(&newParams, &pSwapChain);
+    }
+
+    if (SUCCEEDED(res)) {
+        J2dTraceLn1(J2D_TRACE_VERBOSE,"  created swap chain: 0x%x ",pSwapChain);
+        *ppSwapChainResource = new D3DResource(pSwapChain);
+        res = AddResource(*ppSwapChainResource);
+    } else {
+        DebugPrintD3DError(res, "D3DRM::CreateSwapChain failed");
+        *ppSwapChainResource = NULL;
+    }
+    return res;
+}
+
+HRESULT
+D3DResourceManager::GetMaskTexture(D3DResource **ppTextureResource)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::GetMaskTexture");
+
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+    RETURN_STATUS_IF_NULL(ppTextureResource, E_FAIL);
+
+    D3DFORMAT format = pCtx->IsTextureFormatSupported(D3DFMT_A8) ?
+        D3DFMT_A8 : D3DFMT_A8R8G8B8;
+
+    jboolean needsInit = (pMaskTexture == NULL);
+    HRESULT res;
+    if (FAILED(res =
+        GetStockTextureResource(D3D_MASK_CACHE_WIDTH_IN_TEXELS,
+                                D3D_MASK_CACHE_HEIGHT_IN_TEXELS,
+                                FALSE/*isRTT*/, FALSE/*isOpaque*/, &format, 0,
+                                &pMaskTexture)))
+    {
+        return res;
+    }
+
+    if (needsInit) {
+        // init special fully opaque tile in the upper-right corner of
+        // the mask cache texture
+        jubyte allOnes[D3D_MASK_CACHE_TILE_SIZE];
+        memset(allOnes, 0xff, D3D_MASK_CACHE_TILE_SIZE);
+        if (FAILED(res = pCtx->UploadTileToTexture(
+                                         pMaskTexture,
+                                         allOnes,
+                                         D3D_MASK_CACHE_SPECIAL_TILE_X,
+                                         D3D_MASK_CACHE_SPECIAL_TILE_Y,
+                                         0, 0,
+                                         D3D_MASK_CACHE_TILE_WIDTH,
+                                         D3D_MASK_CACHE_TILE_HEIGHT,
+                                         D3D_MASK_CACHE_TILE_WIDTH,
+                                         TILEFMT_1BYTE_ALPHA)))
+        {
+            return res;
+        }
+    }
+
+    *ppTextureResource = pMaskTexture;
+
+    return res;
+}
+
+HRESULT
+D3DResourceManager::GetBlitTexture(D3DResource **ppTextureResource)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::GetBlitTexture");
+
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+    RETURN_STATUS_IF_NULL(ppTextureResource, E_FAIL);
+
+    HRESULT res =
+        GetStockTextureResource(D3DC_BLIT_TILE_SIZE, D3DC_BLIT_TILE_SIZE,
+                                FALSE/*isRTT*/, FALSE/*isOpaque*/, NULL,
+                                D3DUSAGE_DYNAMIC,
+                                &pBlitTexture);
+    *ppTextureResource = pBlitTexture;
+
+    return res;
+}
+
+HRESULT
+D3DResourceManager::GetGradientTexture(D3DResource **ppTextureResource)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::GetGradientTexture");
+
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+    RETURN_STATUS_IF_NULL(ppTextureResource, E_FAIL);
+
+    HRESULT res =
+        GetStockTextureResource(2, 1,
+                                FALSE/*isRTT*/, FALSE/*isOpaque*/, NULL, 0,
+                                &pGradientTexture);
+    *ppTextureResource = pGradientTexture;
+
+    return res;
+}
+
+HRESULT
+D3DResourceManager::GetMultiGradientTexture(D3DResource **ppTextureResource)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::GetMultiGradientTexture");
+
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+    RETURN_STATUS_IF_NULL(ppTextureResource, E_FAIL);
+
+    HRESULT res =
+        GetStockTextureResource(MAX_MULTI_GRADIENT_COLORS, 1,
+                                FALSE/*isRTT*/, FALSE/*isOpaque*/, NULL, 0,
+                                &pMultiGradientTexture);
+    *ppTextureResource = pMultiGradientTexture;
+
+    return res;
+}
+
+HRESULT
+D3DResourceManager::GetLookupOpLutTexture(D3DResource **ppTextureResource)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::GetLookupOpTexture");
+
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+    RETURN_STATUS_IF_NULL(ppTextureResource, E_FAIL);
+
+    D3DFORMAT format = D3DFMT_L16;
+    HRESULT res =
+        GetStockTextureResource(256, 4,
+                                FALSE/*isRTT*/, FALSE/*isOpaque*/, &format, 0,
+                                &pLookupOpLutTexture);
+    *ppTextureResource = pLookupOpLutTexture;
+
+    return res;
+}
+
+HRESULT
+D3DResourceManager::GetBlitRTTexture(UINT width, UINT height, D3DFORMAT format,
+                                     D3DResource **ppTextureResource)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::GetBlitRTTexture");
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+    RETURN_STATUS_IF_NULL(ppTextureResource, E_FAIL);
+
+    HRESULT res = GetStockTextureResource(width, height,
+                                          TRUE/*isRTT*/, FALSE/*isOpaque*/,
+                                          &format, 0,
+                                          &pBlitRTTexture);
+    if (SUCCEEDED(res)) {
+        D3DSURFACE_DESC *pDesc = pBlitRTTexture->GetDesc();
+        D3DCAPS9 *pDevCaps = pCtx->GetDeviceCaps();
+        if ((width <= pDesc->Width && height <= pDesc->Height) &&
+            (format == pDesc->Format ||
+             SUCCEEDED(pCtx->Get3DObject()->CheckDeviceFormatConversion(
+                       pDevCaps->AdapterOrdinal,
+                       pDevCaps->DeviceType, format, pDesc->Format))))
+        {
+            *ppTextureResource = pBlitRTTexture;
+            return res;
+        }
+        // current texture doesn't fit, release and allocate a new one
+        ReleaseResource(pBlitRTTexture);
+        pBlitRTTexture = NULL;
+    }
+    if (width  < D3DC_BLIT_TILE_SIZE) width  = D3DC_BLIT_TILE_SIZE;
+    if (height < D3DC_BLIT_TILE_SIZE) height = D3DC_BLIT_TILE_SIZE;
+
+    res = CreateTexture(width, height, TRUE, FALSE, &format, 0,&pBlitRTTexture);
+    *ppTextureResource = pBlitRTTexture;
+
+    return res;
+}
+
+HRESULT
+D3DResourceManager::GetBlitOSPSurface(UINT width, UINT height, D3DFORMAT fmt,
+                                      D3DResource **ppSurfaceResource)
+{
+    HRESULT res = S_OK;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::GetBlitOSPSurface");
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+    RETURN_STATUS_IF_NULL(ppSurfaceResource, E_FAIL);
+
+    if (pBlitOSPSurface != NULL) {
+        D3DSURFACE_DESC *pDesc = pBlitOSPSurface->GetDesc();
+        if (width == pDesc->Width && height == pDesc->Height &&
+            (fmt == pDesc->Format || fmt == D3DFMT_UNKNOWN))
+        {
+            *ppSurfaceResource = pBlitOSPSurface;
+            return res;
+        }
+        // current surface doesn't fit, release and allocate a new one
+        ReleaseResource(pBlitOSPSurface);
+        pBlitOSPSurface = NULL;
+    }
+
+    res = CreateOSPSurface(width, height, fmt, &pBlitOSPSurface);
+    *ppSurfaceResource = pBlitOSPSurface;
+
+    return res;
+}
+
+HRESULT
+D3DResourceManager::GetLockableRTSurface(UINT width, UINT height,
+                                         D3DFORMAT format,
+                                         D3DResource **ppSurfaceResource)
+{
+    HRESULT res = S_OK;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::GetLockableRTSurface");
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+    RETURN_STATUS_IF_NULL(ppSurfaceResource, E_FAIL);
+
+    if (pLockableRTSurface != NULL) {
+        D3DSURFACE_DESC *pDesc = pLockableRTSurface->GetDesc();
+        if (width <= pDesc->Width && height <= pDesc->Height &&
+            format == pDesc->Format)
+        {
+            *ppSurfaceResource = pLockableRTSurface;
+            return res;
+        }
+        // current surface doesn't fit, release and allocate a new one
+        ReleaseResource(pLockableRTSurface);
+        pLockableRTSurface = NULL;
+    }
+    if (width  < D3DC_BLIT_TILE_SIZE) width  = D3DC_BLIT_TILE_SIZE;
+    if (height < D3DC_BLIT_TILE_SIZE) height = D3DC_BLIT_TILE_SIZE;
+
+    res = CreateRTSurface(width,height,
+                          (format != D3DFMT_A8R8G8B8), TRUE /*lockable*/,
+                          &format, &pLockableRTSurface);
+    *ppSurfaceResource = pLockableRTSurface;
+
+    return res;
+}
+
+HRESULT
+D3DResourceManager::GetCachedDestTexture(D3DFORMAT format,
+                                         D3DResource **ppTextureResource)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DRM::GetCachedDestTexture");
+
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+    RETURN_STATUS_IF_NULL(ppTextureResource, E_FAIL);
+
+    HRESULT res =
+        GetStockTextureResource(D3DTR_CACHED_DEST_WIDTH,
+                                D3DTR_CACHED_DEST_HEIGHT,
+                                TRUE/*isRTT*/, FALSE/*isOpaque*/,
+                                &format, 0, &pCachedDestTexture);
+    if (SUCCEEDED(res)) {
+        D3DSURFACE_DESC *pDesc = pCachedDestTexture->GetDesc();
+        D3DCAPS9 *pDevCaps = pCtx->GetDeviceCaps();
+        if ((format == pDesc->Format ||
+             SUCCEEDED(pCtx->Get3DObject()->CheckDeviceFormatConversion(
+                           pDevCaps->AdapterOrdinal,
+                           pDevCaps->DeviceType, format, pDesc->Format))))
+        {
+            *ppTextureResource = pCachedDestTexture;
+            return res;
+        }
+        // current texture doesn't fit, release and allocate a new one
+        ReleaseResource(pCachedDestTexture);
+        pCachedDestTexture = NULL;
+    }
+    res = CreateTexture(D3DTR_CACHED_DEST_WIDTH, D3DTR_CACHED_DEST_HEIGHT,
+                        TRUE, FALSE, &format, 0,
+                        &pCachedDestTexture);
+    *ppTextureResource = pCachedDestTexture;
+    return res;
+}
+
+HRESULT
+D3DResourceManager::GetStockTextureResource(UINT width, UINT height,
+                                            BOOL isRTT, BOOL isOpaque,
+                                            D3DFORMAT *pFormat/*in/out*/,
+                                            DWORD dwUsage,
+                                            D3DResource **ppTextureResource)
+{
+    D3DResource *pResource = *ppTextureResource;
+    if (pResource != NULL) {
+        if (pResource->GetTexture() != NULL) {
+            return S_OK;
+        }
+        ReleaseResource(pResource);
+        *ppTextureResource = NULL;
+    }
+
+    return CreateTexture(width, height, isRTT, isOpaque, pFormat, dwUsage,
+                         ppTextureResource);
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DResourceManager.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DResourceManager.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DResourceManager.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DResourceManager.h	2011-01-08 01:26:50.479202297 +0000
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+
+#ifndef _D3DRESOURCEMANAGER_H_
+#define _D3DRESOURCEMANAGER_H_
+
+#include "D3DContext.h"
+#include "D3DSurfaceData.h"
+
+class D3DResourceManager;
+class D3DContext;
+
+/**
+ * This interface represents a Direct3D resource which is managed by the
+ * D3DResourceManager.
+ *
+ * Subclasses will need to override Release() and the destructor to release
+ * the resources held by the object.
+ *
+ * The subclasses then can be used like this:
+ *   class D3DShaderResource : public IManagedResource {
+ *               D3DShaderResource(IDirect3DPixelShader9 *pShader) { // ... }
+ *      virtual ~D3DShaderResource() { Release(); }
+ *      virtual  Release() { SAFE_RELEASE(pShader); }
+ *      virtual  IsDefaultPool() { return FALSE; }
+ *   private:
+ *      IDirect3DPixelShader9 *pShader;
+ *   }
+ *
+ *   pD3DDevice->CreatePixelShader(..., &pShader);
+ *   IManagedResource *pShaderRes = new D3DShaderResource(pShader);
+ *   pCtx->GetResourceManager()->AddResource(pShaderRes);
+ *
+ * D3DResourceManager::ReleaseResource() must be used to dispose of the
+ * resource:
+ *   pCtx->GetResourceManager()->ReleaseResource(pShaderRes);
+ *   // pShaderRes is now invalid, it was deleted
+ *   shaderRes = NULL;
+ *
+ * In certain cases the D3DResourceManager may need to release all its
+ * resources (like when resetting the device), so the subclasses must be
+ * ready to be released at any time, and be able to notify their users.
+ * For an example of how this can be achieved see how D3DSDO's
+ * pResource field and D3DResource subclass. d3dsdo->pResource is reset when
+ * the D3DResource it was pointing to is disposed.
+ */
+class IManagedResource {
+friend class D3DResourceManager;
+public:
+    // determines whether the resource should be released by the manager
+    // when defaul pool resources are to be released
+    virtual BOOL IsDefaultPool() = 0;
+protected:
+                 IManagedResource() { pPrev = pNext = NULL; };
+    virtual     ~IManagedResource() { pPrev = pNext = NULL; };
+    virtual void Release() = 0;
+private:
+    // prevents accidental bad things like copying the object
+    IManagedResource& operator=(const IManagedResource&);
+
+    IManagedResource* pPrev;
+    IManagedResource* pNext;
+};
+
+/**
+ * This class handles either IDirect3DResource9 or IDirect3DSwapChain9
+ * type of resources and provides access to Texture, Surface or SwapChain,
+ * as well as the surface description.
+ */
+class D3DResource : public IManagedResource {
+public:
+                         D3DResource(IDirect3DResource9 *pRes)
+                             { Init(pRes, NULL); }
+                         D3DResource(IDirect3DSwapChain9 *pSC)
+                             { Init(NULL, pSC); }
+    IDirect3DResource9*  GetResource() { return pResource; }
+    IDirect3DTexture9*   GetTexture() { return pTexture; }
+    IDirect3DSurface9*   GetSurface() { return pSurface; }
+    IDirect3DSwapChain9* GetSwapChain() { return pSwapChain; }
+    D3DSDOps*            GetSDOps() { return pOps; }
+    void                 SetSDOps(D3DSDOps *pOps);
+    D3DSURFACE_DESC*     GetDesc() { return &desc; }
+    virtual BOOL         IsDefaultPool();
+
+protected:
+    // these are protected because we want D3DResource to be only released via
+    // ResourceManager
+virtual                 ~D3DResource();
+virtual void             Release();
+    void                 Init(IDirect3DResource9*, IDirect3DSwapChain9*);
+
+private:
+    // prevents accidental bad things like copying the object
+                         D3DResource() {}
+    D3DResource&         operator=(const D3DResource&);
+
+    IDirect3DResource9*  pResource;
+    IDirect3DSwapChain9* pSwapChain;
+    IDirect3DSurface9*   pSurface;
+    IDirect3DTexture9*   pTexture;
+    D3DSDOps*            pOps;
+    D3DSURFACE_DESC      desc;
+};
+
+/**
+ * This class maintains a list of d3d resources created by the pipeline or
+ * other clients. It is needed because in some cases all resources have to be
+ * released in order to reset the device so we must keep track of them.
+ *
+ * There is one instance of this class per D3DContext. Clients can either
+ * use factory methods for creating resources or create their own encapsulated
+ * in an IManagedResource interface subclass and add them to the list
+ * using the AddResource() method. Resources added to the list must be released
+ * via the ReleaseResource() method so that they can be stopped being managed.
+ */
+class D3DResourceManager {
+
+public:
+            ~D3DResourceManager();
+    HRESULT Init(D3DContext *pCtx);
+    // Releases and deletes all resources managed by this manager.
+    void    ReleaseAll();
+    // Releases (and deletes) all resources belonging to the default pool.
+    // Note: this method may release other resources as well.
+    void    ReleaseDefPoolResources();
+
+    // Adds the resource to the list managed by this class.
+    HRESULT AddResource(IManagedResource* pResource);
+    // Removes the resource from the list of managed resources, and deletes
+    // it. The argument pointer is invalid after this method returns.
+    HRESULT ReleaseResource(IManagedResource* pResource);
+
+    HRESULT CreateTexture(UINT width, UINT height,
+                          BOOL isRTT, BOOL isOpaque,
+                          D3DFORMAT *pFormat/*in/out*/,
+                          DWORD dwUsage,
+                          D3DResource **ppTextureResource/*out*/);
+
+    HRESULT CreateRTSurface(UINT width, UINT height,
+                            BOOL isOpaque, BOOL isLockable,
+                            D3DFORMAT *pFormat/*in/out*/,
+                            D3DResource ** ppSurfaceResource/*out*/);
+
+    HRESULT CreateSwapChain(HWND hWnd, UINT numBuffers, UINT width, UINT height,
+                            D3DSWAPEFFECT swapEffect, UINT presentationInterval,
+                            D3DResource ** ppSwapChainResource/*out*/);
+
+    HRESULT GetCachedDestTexture(D3DFORMAT format,
+                                 D3DResource **ppTextureResource);
+    HRESULT GetBlitTexture(D3DResource **ppTextureResource);
+    HRESULT GetBlitRTTexture(UINT width, UINT height, D3DFORMAT format,
+                             D3DResource **ppTextureResource);
+    HRESULT GetBlitOSPSurface(UINT width, UINT height, D3DFORMAT fmt,
+                              D3DResource **ppSurfaceResource);
+    HRESULT GetMaskTexture(D3DResource **ppTextureResource);
+    HRESULT GetGradientTexture(D3DResource **ppTextureResource);
+    HRESULT GetMultiGradientTexture(D3DResource **ppTextureResource);
+    HRESULT GetLookupOpLutTexture(D3DResource **ppTextureResource);
+    HRESULT GetLockableRTSurface(UINT width, UINT height, D3DFORMAT format,
+                                 D3DResource **ppSurfaceResource);
+
+static
+    HRESULT CreateInstance(D3DContext *pCtx, D3DResourceManager **ppResMgr);
+
+private:
+            D3DResourceManager();
+    HRESULT GetStockTextureResource(UINT width, UINT height,
+                                    BOOL isRTT, BOOL isOpaque,
+                                    D3DFORMAT *pFormat/*in/out*/,
+                                    DWORD dwUsage,
+                                    D3DResource **ppTextureResource/*out*/);
+
+    HRESULT CreateOSPSurface(UINT width, UINT height,
+                             D3DFORMAT fmt,
+                             D3DResource ** ppSurfaceResource/*out*/);
+
+    D3DResource*      pCachedDestTexture;
+    D3DResource*      pBlitTexture;
+    D3DResource*      pBlitRTTexture;
+    D3DResource*      pBlitOSPSurface;
+    D3DResource*      pGradientTexture;
+    D3DResource*      pLookupOpLutTexture;
+    D3DResource*      pMaskTexture;
+    D3DResource*      pMultiGradientTexture;
+    D3DResource*      pLockableRTSurface;
+
+    D3DContext*       pCtx;
+
+    IManagedResource* pHead;
+};
+#endif _D3DRESOURCEMANAGER_H_
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DShaderGen.c openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DShaderGen.c
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DShaderGen.c	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DShaderGen.c	2011-01-08 01:26:50.479202297 +0000
@@ -0,0 +1,985 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/**
+ * This file contains a standalone program that is used to generate the
+ * D3DShaders.h file.  The program invokes the fxc (D3D Shader Compiler)
+ * utility, which is part of the DirectX 9/10 SDK.  Since most JDK
+ * developers (other than some Java 2D engineers) do not have the full DXSDK
+ * installed, and since we do not want to make the JDK build process
+ * dependent on the full DXSDK installation, we have chosen not to make
+ * this shader compilation step part of the build process.  Instead, it is
+ * only necessary to compile and run this program when changes need to be
+ * made to the shader code contained within.  Typically, this only happens
+ * on an as-needed basis by someone familiar with the D3D pipeline.  Running
+ * this program is fairly straightforward:
+ *
+ *   % rm D3DShaders.h
+ *   % cl D3DShaderGen.c
+ *   % D3DShaderGen.exe
+ *
+ * (And don't forget to putback the updated D3DShaders.h file!)
+ */
+
+#include <stdio.h>
+#include <process.h>
+#include <Windows.h>
+
+static FILE *fpHeader = NULL;
+static char *strHeaderFile = "D3DShaders.h";
+
+/** Evaluates to true if the given bit is set on the local flags variable. */
+#define IS_SET(flagbit) \
+    (((flags) & (flagbit)) != 0)
+
+// REMIND
+//#define J2dTraceLn(a, b) fprintf(stderr, "%s\n", b);
+//#define J2dTraceLn1(a, b, c) fprintf(stderr, b, c);
+#define J2dTraceLn(a, b)
+#define J2dTraceLn1(a, b, c)
+
+/************************* General shader support ***************************/
+
+static void
+D3DShaderGen_WriteShader(char *source, char *target, char *name, int flags)
+{
+    FILE *fpTmp;
+    char varname[50];
+    char *args[8];
+    int val;
+
+    // write source to tmp.hlsl
+    fpTmp = fopen("tmp.hlsl", "w");
+    fprintf(fpTmp, "%s\n", source);
+    fclose(fpTmp);
+
+    {
+        PROCESS_INFORMATION pi;
+        STARTUPINFO si;
+        char pargs[300];
+        sprintf(pargs,
+                "c:\\progra~1\\mi5889~1\\utilit~1\\bin\\x86\\fxc.exe "
+                "/T %s /Vn %s%d /Fh tmp.h tmp.hlsl",
+                // uncomment the following line to generate debug
+                // info in the shader header file (may be useful
+                // for testing/debuggging purposes, but it nearly
+                // doubles the size of the header file and compiled
+                // shader programs - off for production builds)
+                //"/Zi /T %s /Vn %s%d /Fh tmp.h tmp.hlsl",
+                target, name, flags);
+        fprintf(stderr, "%s\n", pargs);
+        memset(&si, 0, sizeof(si));
+        si.cb = sizeof(si);
+        si.dwFlags = STARTF_USESTDHANDLES;
+        //si.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
+        //fprintf(stderr, "%s\n", pargs);
+        val = CreateProcess(0, pargs, 0, 0, TRUE,
+                            CREATE_NO_WINDOW, NULL, NULL, &si, &pi);
+
+        {
+            DWORD code;
+            do {
+                GetExitCodeProcess(pi.hProcess, &code);
+                //fprintf(stderr, "waiting...");
+                Sleep(100);
+            } while (code == STILL_ACTIVE);
+
+            if (code != 0) {
+                fprintf(stderr, "fxc failed for %s%d\n", name, flags);
+            }
+        }
+
+        CloseHandle(pi.hThread);
+        CloseHandle(pi.hProcess);
+    }
+
+    // append tmp.h to D3DShaders.h
+    {
+        int ch;
+        fpTmp = fopen("tmp.h", "r");
+        while ((ch = fgetc(fpTmp)) != EOF) {
+            fputc(ch, fpHeader);
+        }
+        fclose(fpTmp);
+    }
+}
+
+static void
+D3DShaderGen_WritePixelShader(char *source, char *name, int flags)
+{
+    D3DShaderGen_WriteShader(source, "ps_2_0", name, flags);
+}
+
+#define MULTI_GRAD_CYCLE_METHOD (3 << 0)
+/** Extracts the CycleMethod enum value from the given flags variable. */
+#define EXTRACT_CYCLE_METHOD(flags) \
+    ((flags) & MULTI_GRAD_CYCLE_METHOD)
+
+static void
+D3DShaderGen_WriteShaderArray(char *name, int num)
+{
+    char array[5000];
+    char elem[30];
+    int i;
+
+    sprintf(array, "const DWORD *%sShaders[] =\n{\n", name);
+    for (i = 0; i < num; i++) {
+        if (num == 32 && EXTRACT_CYCLE_METHOD(i) == 3) {
+            // REMIND: what a hack!
+            sprintf(elem, "    NULL,\n");
+        } else {
+            sprintf(elem, "    %s%d,\n", name, i);
+        }
+        strcat(array, elem);
+    }
+    strcat(array, "};\n");
+
+    // append to D3DShaders.h
+    fprintf(fpHeader, "%s\n", array);
+}
+
+/**************************** ConvolveOp support ****************************/
+
+static const char *convolveShaderSource =
+    // image to be convolved
+    "sampler2D baseImage   : register(s0);"
+    // image edge limits:
+    //   imgEdge.xy = imgMin.xy (anything < will be treated as edge case)
+    //   imgEdge.zw = imgMax.xy (anything > will be treated as edge case)
+    "float4 imgEdge        : register(c0);"
+    // value for each location in the convolution kernel:
+    //   kernelVals[i].x = offsetX[i]
+    //   kernelVals[i].y = offsetY[i]
+    //   kernelVals[i].z = kernel[i]
+    "float3 kernelVals[%d] : register(c1);"
+    ""
+    "void main(in float2 tc : TEXCOORD0,"
+    "          inout float4 color : COLOR0)"
+    "{"
+    "    float4 sum = imgEdge - tc.xyxy;"
+    ""
+    "    if (sum.x > 0 || sum.y > 0 || sum.z < 0 || sum.w < 0) {"
+             // (placeholder for edge condition code)
+    "        color = %s;"
+    "    } else {"
+    "        int i;"
+    "        sum = float4(0, 0, 0, 0);"
+    "        for (i = 0; i < %d; i++) {"
+    "            sum +="
+    "                kernelVals[i].z *"
+    "                tex2D(baseImage, tc + kernelVals[i].xy);"
+    "        }"
+             // modulate with current color in order to apply extra alpha
+    "        color *= sum;"
+    "    }"
+    ""
+    "}";
+
+/**
+ * Flags that can be bitwise-or'ed together to control how the shader
+ * source code is generated.
+ */
+#define CONVOLVE_EDGE_ZERO_FILL (1 << 0)
+#define CONVOLVE_5X5            (1 << 1)
+#define MAX_CONVOLVE            (1 << 2)
+
+static void
+D3DShaderGen_GenerateConvolveShader(int flags)
+{
+    int kernelMax = IS_SET(CONVOLVE_5X5) ? 25 : 9;
+    char *edge;
+    char finalSource[2000];
+
+    J2dTraceLn1(J2D_TRACE_INFO,
+                "D3DShaderGen_GenerateConvolveShader: flags=%d",
+                flags);
+
+    if (IS_SET(CONVOLVE_EDGE_ZERO_FILL)) {
+        // EDGE_ZERO_FILL: fill in zero at the edges
+        edge = "float4(0, 0, 0, 0)";
+    } else {
+        // EDGE_NO_OP: use the source pixel color at the edges
+        edge = "tex2D(baseImage, tc)";
+    }
+
+    // compose the final source code string from the various pieces
+    sprintf(finalSource, convolveShaderSource,
+            kernelMax, edge, kernelMax);
+
+    D3DShaderGen_WritePixelShader(finalSource, "convolve", flags);
+}
+
+/**************************** RescaleOp support *****************************/
+
+static const char *rescaleShaderSource =
+    // image to be rescaled
+    "sampler2D baseImage : register(s0);"
+    // vector containing scale factors
+    "float4 scaleFactors : register(c0);"
+    // vector containing offsets
+    "float4 offsets      : register(c1);"
+    ""
+    "void main(in float2 tc : TEXCOORD0,"
+    "          inout float4 color : COLOR0)"
+    "{"
+    "    float4 srcColor = tex2D(baseImage, tc);"
+    ""
+         // (placeholder for un-premult code)
+    "    %s"
+    ""
+         // rescale source value
+    "    float4 result = (srcColor * scaleFactors) + offsets;"
+    ""
+         // (placeholder for re-premult code)
+    "    %s"
+    ""
+         // modulate with current color in order to apply extra alpha
+    "    color *= result;"
+    "}";
+
+/**
+ * Flags that can be bitwise-or'ed together to control how the shader
+ * source code is generated.
+ */
+#define RESCALE_NON_PREMULT (1 << 0)
+#define MAX_RESCALE         (1 << 1)
+
+static void
+D3DShaderGen_GenerateRescaleShader(int flags)
+{
+    char *preRescale = "";
+    char *postRescale = "";
+    char finalSource[2000];
+
+    J2dTraceLn1(J2D_TRACE_INFO,
+                "D3DShaderGen_GenerateRescaleShader: flags=%d",
+                flags);
+
+    if (IS_SET(RESCALE_NON_PREMULT)) {
+        preRescale  = "srcColor.rgb /= srcColor.a;";
+        postRescale = "result.rgb *= result.a;";
+    }
+
+    // compose the final source code string from the various pieces
+    sprintf(finalSource, rescaleShaderSource,
+            preRescale, postRescale);
+
+    D3DShaderGen_WritePixelShader(finalSource, "rescale", flags);
+}
+
+/**************************** LookupOp support ******************************/
+
+static const char *lookupShaderSource =
+    // source image (bound to texture unit 0)
+    "sampler2D baseImage   : register(s0);"
+    // lookup table (bound to texture unit 1)
+    "sampler2D lookupTable : register(s1);"
+    // offset subtracted from source index prior to lookup step
+    "float4 offset         : register(c0);"
+    ""
+    "void main(in float2 tc : TEXCOORD0,"
+    "          inout float4 color : COLOR0)"
+    "{"
+    "    float4 srcColor = tex2D(baseImage, tc);"
+         // (placeholder for un-premult code)
+    "    %s"
+         // subtract offset from original index
+    "    float4 srcIndex = srcColor - offset;"
+         // use source value as input to lookup table (note that
+         // "v" texcoords are hardcoded to hit texel centers of
+         // each row/band in texture)
+    "    float4 result;"
+    "    result.r = tex2D(lookupTable, float2(srcIndex.r, 0.125)).r;"
+    "    result.g = tex2D(lookupTable, float2(srcIndex.g, 0.375)).r;"
+    "    result.b = tex2D(lookupTable, float2(srcIndex.b, 0.625)).r;"
+         // (placeholder for alpha store code)
+    "    %s"
+         // (placeholder for re-premult code)
+    "    %s"
+         // modulate with current color in order to apply extra alpha
+    "    color *= result;"
+    "}";
+
+/**
+ * Flags that can be bitwise-or'ed together to control how the shader
+ * source code is generated.
+ */
+#define LOOKUP_USE_SRC_ALPHA (1 << 0)
+#define LOOKUP_NON_PREMULT   (1 << 1)
+#define MAX_LOOKUP           (1 << 2)
+
+static void
+D3DShaderGen_GenerateLookupShader(int flags)
+{
+    char *alpha;
+    char *preLookup = "";
+    char *postLookup = "";
+    char finalSource[2000];
+
+    J2dTraceLn1(J2D_TRACE_INFO,
+                "D3DShaderGen_GenerateLookupShader: flags=%d",
+                flags);
+
+    if (IS_SET(LOOKUP_USE_SRC_ALPHA)) {
+        // when numComps is 1 or 3, the alpha is not looked up in the table;
+        // just keep the alpha from the source fragment
+        alpha = "result.a = srcColor.a;";
+    } else {
+        // when numComps is 4, the alpha is looked up in the table, just
+        // like the other color components from the source fragment
+        alpha = "result.a = tex2D(lookupTable, float2(srcIndex.a, 0.875)).r;";
+    }
+    if (IS_SET(LOOKUP_NON_PREMULT)) {
+        preLookup  = "srcColor.rgb /= srcColor.a;";
+        postLookup = "result.rgb *= result.a;";
+    }
+
+    // compose the final source code string from the various pieces
+    sprintf(finalSource, lookupShaderSource,
+            preLookup, alpha, postLookup);
+
+    D3DShaderGen_WritePixelShader(finalSource, "lookup", flags);
+}
+
+/************************* GradientPaint support ****************************/
+
+/*
+ * To simplify the code and to make it easier to upload a number of
+ * uniform values at once, we pack a bunch of scalar (float) values
+ * into a single float3 below.  Here's how the values are related:
+ *
+ *   params.x = p0
+ *   params.y = p1
+ *   params.z = p3
+ */
+static const char *basicGradientShaderSource =
+    "float3 params : register (c0);"
+    "float4 color1 : register (c1);"
+    "float4 color2 : register (c2);"
+    // (placeholder for mask variable)
+    "%s"
+    ""
+    // (placeholder for mask texcoord input)
+    "void main(%s"
+    "          in float4 winCoord : TEXCOORD%d,"
+    "          inout float4 color : COLOR0)"
+    "{"
+    "    float3 fragCoord = float3(winCoord.x, winCoord.y, 1.0);"
+    "    float dist = dot(params.xyz, fragCoord);"
+    ""
+         // the setup code for p0/p1/p3 translates/scales to hit texel
+         // centers (at 0.25 and 0.75) because it is needed for the
+         // original/fast texture-based implementation, but it is not
+         // desirable for this shader-based implementation, so we
+         // re-transform the value here...
+    "    dist = (dist - 0.25) * 2.0;"
+    ""
+    "    float fraction;"
+         // (placeholder for cycle code)
+    "    %s"
+    ""
+    "    float4 result = lerp(color1, color2, fraction);"
+    ""
+         // (placeholder for mask modulation code)
+    "    %s"
+    ""
+         // modulate with current color in order to apply extra alpha
+    "    color *= result;"
+    "}";
+
+/**
+ * Flags that can be bitwise-or'ed together to control how the shader
+ * source code is generated.
+ */
+#define BASIC_GRAD_IS_CYCLIC (1 << 0)
+#define BASIC_GRAD_USE_MASK  (1 << 1)
+#define MAX_BASIC_GRAD       (1 << 2)
+
+static void
+D3DShaderGen_GenerateBasicGradShader(int flags)
+{
+    int colorSampler = IS_SET(BASIC_GRAD_USE_MASK) ? 1 : 0;
+    char *cycleCode;
+    char *maskVars = "";
+    char *maskInput = "";
+    char *maskCode = "";
+    char finalSource[3000];
+
+    J2dTraceLn1(J2D_TRACE_INFO,
+                "D3DShaderGen_GenerateBasicGradShader",
+                flags);
+
+    if (IS_SET(BASIC_GRAD_IS_CYCLIC)) {
+        cycleCode =
+            "fraction = 1.0 - (abs(frac(dist * 0.5) - 0.5) * 2.0);";
+    } else {
+        cycleCode =
+            "fraction = clamp(dist, 0.0, 1.0);";
+    }
+
+    if (IS_SET(BASIC_GRAD_USE_MASK)) {
+        /*
+         * This code modulates the calculated result color with the
+         * corresponding alpha value from the alpha mask texture active
+         * on texture unit 0.  Only needed when useMask is true (i.e., only
+         * for MaskFill operations).
+         */
+        maskVars = "sampler2D mask : register(s0);";
+        maskInput = "in float4 maskCoord : TEXCOORD0,";
+        maskCode = "result *= tex2D(mask, maskCoord.xy).a;";
+    }
+
+    // compose the final source code string from the various pieces
+    sprintf(finalSource, basicGradientShaderSource,
+            maskVars, maskInput, colorSampler, cycleCode, maskCode);
+
+    D3DShaderGen_WritePixelShader(finalSource, "grad", flags);
+}
+
+/****************** Shared MultipleGradientPaint support ********************/
+
+/**
+ * These constants are identical to those defined in the
+ * MultipleGradientPaint.CycleMethod enum; they are copied here for
+ * convenience (ideally we would pull them directly from the Java level,
+ * but that entails more hassle than it is worth).
+ */
+#define CYCLE_NONE    0
+#define CYCLE_REFLECT 1
+#define CYCLE_REPEAT  2
+
+/**
+ * The following constants are flags that can be bitwise-or'ed together
+ * to control how the MultipleGradientPaint shader source code is generated:
+ *
+ *   MULTI_GRAD_CYCLE_METHOD
+ *     Placeholder for the CycleMethod enum constant.
+ *
+ *   MULTI_GRAD_LARGE
+ *     If set, use the (slower) shader that supports a larger number of
+ *     gradient colors; otherwise, use the optimized codepath.  See
+ *     the MAX_FRACTIONS_SMALL/LARGE constants below for more details.
+ *
+ *   MULTI_GRAD_USE_MASK
+ *     If set, apply the alpha mask value from texture unit 1 to the
+ *     final color result (only used in the MaskFill case).
+ *
+ *   MULTI_GRAD_LINEAR_RGB
+ *     If set, convert the linear RGB result back into the sRGB color space.
+ */
+//#define MULTI_GRAD_CYCLE_METHOD (3 << 0)
+#define MULTI_GRAD_LARGE        (1 << 2)
+#define MULTI_GRAD_USE_MASK     (1 << 3)
+#define MULTI_GRAD_LINEAR_RGB   (1 << 4)
+
+// REMIND
+#define MAX_MULTI_GRAD     (1 << 5)
+
+/** Extracts the CycleMethod enum value from the given flags variable. */
+//#define EXTRACT_CYCLE_METHOD(flags) \
+//    ((flags) & MULTI_GRAD_CYCLE_METHOD)
+
+/**
+ * The maximum number of gradient "stops" supported by the fragment shader
+ * and related code.  When the MULTI_GRAD_LARGE flag is set, we will use
+ * MAX_FRACTIONS_LARGE; otherwise, we use MAX_FRACTIONS_SMALL.  By having
+ * two separate values, we can have one highly optimized shader (SMALL) that
+ * supports only a few fractions/colors, and then another, less optimal
+ * shader that supports more stops.
+ */
+#define MAX_FRACTIONS 8
+#define MAX_FRACTIONS_LARGE MAX_FRACTIONS
+#define MAX_FRACTIONS_SMALL 4
+
+/**
+ * The maximum number of gradient colors supported by all of the gradient
+ * fragment shaders.  Note that this value must be a power of two, as it
+ * determines the size of the 1D texture created below.  It also must be
+ * greater than or equal to MAX_FRACTIONS (there is no strict requirement
+ * that the two values be equal).
+ */
+#define MAX_COLORS 16
+
+static const char *multiGradientShaderSource =
+    // gradient texture size (in texels)
+    "#define TEXTURE_SIZE  %d\n"
+    // maximum number of fractions/colors supported by this shader
+    "#define MAX_FRACTIONS %d\n"
+    // size of a single texel
+    "#define FULL_TEXEL    (1.0 / float(TEXTURE_SIZE))\n"
+    // size of half of a single texel
+    "#define HALF_TEXEL    (FULL_TEXEL / 2.0)\n"
+    // texture containing the gradient colors
+    "sampler2D colors                : register (s%d);"
+    // array of gradient stops/fractions and corresponding scale factors
+    //   fractions[i].x = gradientStop[i]
+    //   fractions[i].y = scaleFactor[i]
+    "float2 fractions[MAX_FRACTIONS] : register (c0);"
+    // (placeholder for mask variable)
+    "%s"
+    // (placeholder for Linear/RadialGP-specific variables)
+    "%s"
+    ""
+    // (placeholder for mask texcoord input)
+    "void main(%s"
+    "          in float4 winCoord : TEXCOORD%d,"
+    "          inout float4 color : COLOR0)"
+    "{"
+    "    float dist;"
+         // (placeholder for Linear/RadialGradientPaint-specific code)
+    "    %s"
+    ""
+    "    float4 result;"
+         // (placeholder for CycleMethod-specific code)
+    "    %s"
+    ""
+         // (placeholder for ColorSpace conversion code)
+    "    %s"
+    ""
+         // (placeholder for mask modulation code)
+    "    %s"
+    ""
+         // modulate with current color in order to apply extra alpha
+    "    color *= result;"
+    "}";
+
+/*
+ * Note: An earlier version of this code would simply calculate a single
+ * texcoord:
+ *     "tc = HALF_TEXEL + (FULL_TEXEL * relFraction);"
+ * and then use that value to do a single texture lookup, taking advantage
+ * of the LINEAR texture filtering mode which in theory will do the
+ * appropriate linear interpolation between adjacent texels, like this:
+ *     "float4 result = tex2D(colors, float2(tc, 0.5));"
+ *
+ * The problem with that approach is that on certain hardware (from ATI,
+ * notably) the LINEAR texture fetch unit has low precision, and would
+ * for instance only produce 64 distinct grayscales between white and black,
+ * instead of the expected 256.  The visual banding caused by this issue
+ * is severe enough to likely cause complaints from developers, so we have
+ * devised a new approach below that instead manually fetches the two
+ * relevant neighboring texels and then performs the linear interpolation
+ * using the lerp() instruction (which does not suffer from the precision
+ * issues of the fixed-function texture filtering unit).  This new approach
+ * requires a few more instructions and is therefore slightly slower than
+ * the old approach (not more than 10% or so).
+ */
+static const char *texCoordCalcCode =
+    "int i;"
+    "float relFraction = 0.0;"
+    "for (i = 0; i < MAX_FRACTIONS-1; i++) {"
+    "    relFraction +="
+    "        clamp((dist - fractions[i].x) * fractions[i].y, 0.0, 1.0);"
+    "}"
+    // we offset by half a texel so that we find the linearly interpolated
+    // color between the two texel centers of interest
+    "float intPart = floor(relFraction);"
+    "float tc1 = HALF_TEXEL + (FULL_TEXEL * intPart);"
+    "float tc2 = HALF_TEXEL + (FULL_TEXEL * (intPart + 1.0));"
+    "float4 clr1 = tex2D(colors, float2(tc1, 0.5));"
+    "float4 clr2 = tex2D(colors, float2(tc2, 0.5));"
+    "result = lerp(clr1, clr2, frac(relFraction));";
+
+/** Code for NO_CYCLE that gets plugged into the CycleMethod placeholder. */
+static const char *noCycleCode =
+    "if (dist <= 0.0) {"
+    "    result = tex2D(colors, float2(0.0, 0.5));"
+    "} else if (dist >= 1.0) {"
+    "    result = tex2D(colors, float2(1.0, 0.5));"
+    "} else {"
+         // (placeholder for texcoord calculation)
+    "    %s"
+    "}";
+
+/** Code for REFLECT that gets plugged into the CycleMethod placeholder. */
+static const char *reflectCode =
+    "dist = 1.0 - (abs(frac(dist * 0.5) - 0.5) * 2.0);"
+    // (placeholder for texcoord calculation)
+    "%s";
+
+/** Code for REPEAT that gets plugged into the CycleMethod placeholder. */
+static const char *repeatCode =
+    "dist = frac(dist);"
+    // (placeholder for texcoord calculation)
+    "%s";
+
+static void
+D3DShaderGen_GenerateMultiGradShader(int flags, char *name,
+                                     char *paintVars, char *distCode)
+{
+    char *maskVars = "";
+    char *maskInput = "";
+    char *maskCode = "";
+    char *colorSpaceCode = "";
+    char cycleCode[1500];
+    char finalSource[3000];
+    int colorSampler = IS_SET(MULTI_GRAD_USE_MASK) ? 1 : 0;
+    int cycleMethod = EXTRACT_CYCLE_METHOD(flags);
+    int maxFractions = IS_SET(MULTI_GRAD_LARGE) ?
+        MAX_FRACTIONS_LARGE : MAX_FRACTIONS_SMALL;
+
+    J2dTraceLn(J2D_TRACE_INFO, "OGLPaints_CreateMultiGradProgram");
+
+    if (IS_SET(MULTI_GRAD_USE_MASK)) {
+        /*
+         * This code modulates the calculated result color with the
+         * corresponding alpha value from the alpha mask texture active
+         * on texture unit 0.  Only needed when useMask is true (i.e., only
+         * for MaskFill operations).
+         */
+        maskVars = "sampler2D mask : register(s0);";
+        maskInput = "in float4 maskCoord : TEXCOORD0,";
+        maskCode = "result *= tex2D(mask, maskCoord.xy).a;";
+    }
+
+    if (IS_SET(MULTI_GRAD_LINEAR_RGB)) {
+        /*
+         * This code converts a single pixel in linear RGB space back
+         * into sRGB (note: this code was adapted from the
+         * MultipleGradientPaintContext.convertLinearRGBtoSRGB() method).
+         */
+        colorSpaceCode =
+            "result.rgb = 1.055 * pow(result.rgb, 0.416667) - 0.055;";
+    }
+
+    if (cycleMethod == CYCLE_NONE) {
+        sprintf(cycleCode, noCycleCode, texCoordCalcCode);
+    } else if (cycleMethod == CYCLE_REFLECT) {
+        sprintf(cycleCode, reflectCode, texCoordCalcCode);
+    } else { // (cycleMethod == CYCLE_REPEAT)
+        sprintf(cycleCode, repeatCode, texCoordCalcCode);
+    }
+
+    // compose the final source code string from the various pieces
+    sprintf(finalSource, multiGradientShaderSource,
+            MAX_COLORS, maxFractions, colorSampler,
+            maskVars, paintVars, maskInput, colorSampler,
+            distCode, cycleCode, colorSpaceCode, maskCode);
+
+    D3DShaderGen_WritePixelShader(finalSource, name, flags);
+}
+
+/********************** LinearGradientPaint support *************************/
+
+static void
+D3DShaderGen_GenerateLinearGradShader(int flags)
+{
+    char *paintVars;
+    char *distCode;
+
+    J2dTraceLn1(J2D_TRACE_INFO,
+                "D3DShaderGen_GenerateLinearGradShader",
+                flags);
+
+    /*
+     * To simplify the code and to make it easier to upload a number of
+     * uniform values at once, we pack a bunch of scalar (float) values
+     * into a single float3 below.  Here's how the values are related:
+     *
+     *   params.x = p0
+     *   params.y = p1
+     *   params.z = p3
+     */
+    paintVars =
+        "float3 params : register(c16);";
+    distCode =
+        "float3 fragCoord = float3(winCoord.x, winCoord.y, 1.0);"
+        "dist = dot(params.xyz, fragCoord);";
+
+    D3DShaderGen_GenerateMultiGradShader(flags, "linear",
+                                         paintVars, distCode);
+}
+
+/********************** RadialGradientPaint support *************************/
+
+static void
+D3DShaderGen_GenerateRadialGradShader(int flags)
+{
+    char *paintVars;
+    char *distCode;
+
+    J2dTraceLn1(J2D_TRACE_INFO,
+                "D3DShaderGen_GenerateRadialGradShader",
+                flags);
+
+    /*
+     * To simplify the code and to make it easier to upload a number of
+     * uniform values at once, we pack a bunch of scalar (float) values
+     * into float3 values below.  Here's how the values are related:
+     *
+     *   m0.x = m00
+     *   m0.y = m01
+     *   m0.z = m02
+     *
+     *   m1.x = m10
+     *   m1.y = m11
+     *   m1.z = m12
+     *
+     *   precalc.x = focusX
+     *   precalc.y = 1.0 - (focusX * focusX)
+     *   precalc.z = 1.0 / precalc.z
+     */
+    paintVars =
+        "float3 m0      : register(c16);"
+        "float3 m1      : register(c17);"
+        "float3 precalc : register(c18);";
+
+    /*
+     * The following code is derived from Daniel Rice's whitepaper on
+     * radial gradient performance (attached to the bug report for 6521533).
+     * Refer to that document as well as the setup code in the Java-level
+     * BufferedPaints.setRadialGradientPaint() method for more details.
+     */
+    distCode =
+        "float3 fragCoord = float3(winCoord.x, winCoord.y, 1.0);"
+        "float x = dot(fragCoord, m0);"
+        "float y = dot(fragCoord, m1);"
+        "float xfx = x - precalc.x;"
+        "dist = (precalc.x*xfx + sqrt(xfx*xfx + y*y*precalc.y))*precalc.z;";
+
+    D3DShaderGen_GenerateMultiGradShader(flags, "radial",
+                                         paintVars, distCode);
+}
+
+/*************************** LCD text support *******************************/
+
+// REMIND: Shader uses texture addressing operations in a dependency chain
+//         that is too complex for the target shader model (ps_2_0) to handle
+//         (ugh, I guess we can either require ps_3_0 or just use
+//         the slower pow intrinsic)
+#define POW_LUT 0
+
+static const char *lcdTextShaderSource =
+    "float3 srcAdj         : register(c0);"
+    "sampler2D glyphTex    : register(s0);"
+    "sampler2D dstTex      : register(s1);"
+#if POW_LUT
+    "sampler3D invgammaTex : register(s2);"
+    "sampler3D gammaTex    : register(s3);"
+#else
+    "float3 invgamma       : register(c1);"
+    "float3 gamma          : register(c2);"
+#endif
+    ""
+    "void main(in float2 tc0 : TEXCOORD0,"
+    "          in float2 tc1 : TEXCOORD1,"
+    "          inout float4 color : COLOR0)"
+    "{"
+         // load the RGB value from the glyph image at the current texcoord
+    "    float3 glyphClr = tex2D(glyphTex, tc0).rgb;"
+    "    if (!any(glyphClr)) {"
+             // zero coverage, so skip this fragment
+    "        discard;"
+    "    }"
+         // load the RGB value from the corresponding destination pixel
+    "    float3 dstClr = tex2D(dstTex, tc1).rgb;"
+         // gamma adjust the dest color using the invgamma LUT
+#if POW_LUT
+    "    float3 dstAdj = tex3D(invgammaTex, dstClr).rgb;"
+#else
+    "    float3 dstAdj = pow(dstClr, invgamma);"
+#endif
+         // linearly interpolate the three color values
+    "    float3 result = lerp(dstAdj, srcAdj, glyphClr);"
+         // gamma re-adjust the resulting color (alpha is always set to 1.0)
+#if POW_LUT
+    "    color = float4(tex3D(gammaTex, result).rgb, 1.0);"
+#else
+    "    color = float4(pow(result, gamma), 1.0);"
+#endif
+    "}";
+
+static void
+D3DShaderGen_GenerateLCDTextShader()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DShaderGen_GenerateLCDTextShader");
+
+    D3DShaderGen_WritePixelShader((char *)lcdTextShaderSource, "lcdtext", 0);
+}
+
+/*************************** AA support *******************************/
+
+/*
+ * This shader fills the space between an outer and inner parallelogram.
+ * It can be used to draw an outline by specifying both inner and outer
+ * values.  It fills pixels by estimating what portion falls inside the
+ * outer shape, and subtracting an estimate of what portion falls inside
+ * the inner shape.  Specifying both inner and outer values produces a
+ * standard "wide outline".  Specifying an inner shape that falls far
+ * outside the outer shape allows the same shader to fill the outer
+ * shape entirely since pixels that fall within the outer shape are never
+ * inside the inner shape and so they are filled based solely on their
+ * coverage of the outer shape.
+ *
+ * The setup code renders this shader over the bounds of the outer
+ * shape (or the only shape in the case of a fill operation) and
+ * sets the texture 0 coordinates so that 0,0=>0,1=>1,1=>1,0 in those
+ * texture coordinates map to the four corners of the parallelogram.
+ * Similarly the texture 1 coordinates map the inner shape to the
+ * unit square as well, but in a different coordinate system.
+ *
+ * When viewed in the texture coordinate systems the parallelograms
+ * we are filling are unit squares, but the pixels have then become
+ * tiny parallelograms themselves.  Both of the texture coordinate
+ * systems are affine transforms so the rate of change in X and Y
+ * of the texture coordinates are essentially constants and happen
+ * to correspond to the size and direction of the slanted sides of
+ * the distorted pixels relative to the "square mapped" boundary
+ * of the parallelograms.
+ *
+ * The shader uses the ddx() and ddy() functions to measure the "rate
+ * of change" of these texture coordinates and thus gets an accurate
+ * measure of the size and shape of a pixel relative to the two
+ * parallelograms.  It then uses the bounds of the size and shape
+ * of a pixel to intersect with the unit square to estimate the
+ * coverage of the pixel.  Unfortunately, without a lot more work
+ * to calculate the exact area of intersection between a unit
+ * square (the original parallelogram) and a parallelogram (the
+ * distorted pixel), this shader only approximates the pixel
+ * coverage, but emperically the estimate is very useful and
+ * produces visually pleasing results, if not theoretically accurate.
+ */
+static const char *aaShaderSource =
+    "void main(in float2 tco : TEXCOORD0,"
+    "          in float2 tci : TEXCOORD1,"
+    "          inout float4 color : COLOR0)"
+    "{"
+    // Calculate the vectors for the "legs" of the pixel parallelogram
+    // for the outer parallelogram.
+    "    float2 oleg1 = ddx(tco);"
+    "    float2 oleg2 = ddy(tco);"
+    // Calculate the bounds of the distorted pixel parallelogram.
+    "    float2 omin = min(tco, tco+oleg1);"
+    "    omin = min(omin, tco+oleg2);"
+    "    omin = min(omin, tco+oleg1+oleg2);"
+    "    float2 omax = max(tco, tco+oleg1);"
+    "    omax = max(omax, tco+oleg2);"
+    "    omax = max(omax, tco+oleg1+oleg2);"
+    // Calculate the vectors for the "legs" of the pixel parallelogram
+    // for the inner parallelogram.
+    "    float2 ileg1 = ddx(tci);"
+    "    float2 ileg2 = ddy(tci);"
+    // Calculate the bounds of the distorted pixel parallelogram.
+    "    float2 imin = min(tci, tci+ileg1);"
+    "    imin = min(imin, tci+ileg2);"
+    "    imin = min(imin, tci+ileg1+ileg2);"
+    "    float2 imax = max(tci, tci+ileg1);"
+    "    imax = max(imax, tci+ileg2);"
+    "    imax = max(imax, tci+ileg1+ileg2);"
+    // Clamp the bounds of the parallelograms to the unit square to
+    // estimate the intersection of the pixel parallelogram with
+    // the unit square.  The ratio of the 2 rectangle areas is a
+    // reasonable estimate of the proportion of coverage.
+    "    float2 o1 = clamp(omin, 0.0, 1.0);"
+    "    float2 o2 = clamp(omax, 0.0, 1.0);"
+    "    float oint = (o2.y-o1.y)*(o2.x-o1.x);"
+    "    float oarea = (omax.y-omin.y)*(omax.x-omin.x);"
+    "    float2 i1 = clamp(imin, 0.0, 1.0);"
+    "    float2 i2 = clamp(imax, 0.0, 1.0);"
+    "    float iint = (i2.y-i1.y)*(i2.x-i1.x);"
+    "    float iarea = (imax.y-imin.y)*(imax.x-imin.x);"
+    // Proportion of pixel in outer shape minus the proportion
+    // of pixel in the inner shape == the coverage of the pixel
+    // in the area between the two.
+    "    float coverage = oint/oarea - iint / iarea;"
+    "    color *= coverage;"
+    "}";
+
+static void
+D3DShaderGen_GenerateAAParallelogramShader()
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DShaderGen_GenerateAAParallelogramShader");
+
+    D3DShaderGen_WriteShader((char *)aaShaderSource, "ps_2_a", "aapgram", 0);
+}
+
+/**************************** Main entrypoint *******************************/
+
+static void
+D3DShaderGen_GenerateAllShaders()
+{
+    int i;
+
+#if 1
+    // Generate BufferedImageOp shaders
+    for (i = 0; i < MAX_RESCALE; i++) {
+        D3DShaderGen_GenerateRescaleShader(i);
+    }
+    D3DShaderGen_WriteShaderArray("rescale", MAX_RESCALE);
+    for (i = 0; i < MAX_CONVOLVE; i++) {
+        D3DShaderGen_GenerateConvolveShader(i);
+    }
+    D3DShaderGen_WriteShaderArray("convolve", MAX_CONVOLVE);
+    for (i = 0; i < MAX_LOOKUP; i++) {
+        D3DShaderGen_GenerateLookupShader(i);
+    }
+    D3DShaderGen_WriteShaderArray("lookup", MAX_LOOKUP);
+
+    // Generate Paint shaders
+    for (i = 0; i < MAX_BASIC_GRAD; i++) {
+        D3DShaderGen_GenerateBasicGradShader(i);
+    }
+    D3DShaderGen_WriteShaderArray("grad", MAX_BASIC_GRAD);
+    for (i = 0; i < MAX_MULTI_GRAD; i++) {
+        if (EXTRACT_CYCLE_METHOD(i) == 3) continue; // REMIND
+        D3DShaderGen_GenerateLinearGradShader(i);
+    }
+    D3DShaderGen_WriteShaderArray("linear", MAX_MULTI_GRAD);
+    for (i = 0; i < MAX_MULTI_GRAD; i++) {
+        if (EXTRACT_CYCLE_METHOD(i) == 3) continue; // REMIND
+        D3DShaderGen_GenerateRadialGradShader(i);
+    }
+    D3DShaderGen_WriteShaderArray("radial", MAX_MULTI_GRAD);
+
+    // Generate LCD text shader
+    D3DShaderGen_GenerateLCDTextShader();
+
+    // Genereate Shader to fill Antialiased parallelograms
+    D3DShaderGen_GenerateAAParallelogramShader();
+#else
+    /*
+    for (i = 0; i < MAX_RESCALE; i++) {
+        D3DShaderGen_GenerateRescaleShader(i);
+    }
+    D3DShaderGen_WriteShaderArray("rescale", MAX_RESCALE);
+    */
+    //D3DShaderGen_GenerateConvolveShader(2);
+    //D3DShaderGen_GenerateLCDTextShader();
+    //D3DShaderGen_GenerateLinearGradShader(16);
+    D3DShaderGen_GenerateBasicGradShader(0);
+#endif
+}
+
+int
+main(int argc, char **argv)
+{
+    fpHeader = fopen(strHeaderFile, "a");
+
+    D3DShaderGen_GenerateAllShaders();
+
+    fclose(fpHeader);
+
+    return 0;
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DShaders.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DShaders.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DShaders.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DShaders.h	2011-01-08 01:26:50.483202340 +0000
@@ -0,0 +1,7734 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn rescale0 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D baseImage;
+//   float4 offsets;
+//   float4 scaleFactors;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   scaleFactors c0       1
+//   offsets      c1       1
+//   baseImage    s0       1
+//
+
+    ps_2_0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    texld r0, t0, s0
+    mov r1, c0
+    mad r0, r0, r1, c1
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 5 instruction slots used (1 texture, 4 arithmetic)
+#endif
+
+const DWORD rescale0[] =
+{
+    0xffff0200, 0x0036fffe, 0x42415443, 0x0000001c, 0x000000a0, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x00000099, 0x00000058, 0x00000003,
+    0x00020001, 0x00000064, 0x00000000, 0x00000074, 0x00010002, 0x00060001,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00000002, 0x00020001, 0x0000007c,
+    0x00000000, 0x65736162, 0x67616d49, 0xabab0065, 0x000c0004, 0x00010001,
+    0x00000001, 0x00000000, 0x7366666f, 0x00737465, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x6c616373, 0x63614665, 0x73726f74, 0x5f737000,
+    0x00305f32, 0x7263694d, 0x666f736f, 0x52282074, 0x4c482029, 0x53204c53,
+    0x65646168, 0x6f432072, 0x6c69706d, 0x39207265, 0x2e39312e, 0x2e393439,
+    0x31313132, 0xababab00, 0x0200001f, 0x80000000, 0xb0030000, 0x0200001f,
+    0x80000000, 0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x03000042,
+    0x800f0000, 0xb0e40000, 0xa0e40800, 0x02000001, 0x800f0001, 0xa0e40000,
+    0x04000004, 0x800f0000, 0x80e40000, 0x80e40001, 0xa0e40001, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn rescale1 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D baseImage;
+//   float4 offsets;
+//   float4 scaleFactors;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   scaleFactors c0       1
+//   offsets      c1       1
+//   baseImage    s0       1
+//
+
+    ps_2_0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    texld r0, t0, s0
+    rcp r1.w, r0.w
+    mul r0.xyz, r0, r1.w
+    mov r1, c0
+    mad r0, r0, r1, c1
+    mul r0.xyz, r0.w, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 8 instruction slots used (1 texture, 7 arithmetic)
+#endif
+
+const DWORD rescale1[] =
+{
+    0xffff0200, 0x0036fffe, 0x42415443, 0x0000001c, 0x000000a0, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x00000099, 0x00000058, 0x00000003,
+    0x00020001, 0x00000064, 0x00000000, 0x00000074, 0x00010002, 0x00060001,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00000002, 0x00020001, 0x0000007c,
+    0x00000000, 0x65736162, 0x67616d49, 0xabab0065, 0x000c0004, 0x00010001,
+    0x00000001, 0x00000000, 0x7366666f, 0x00737465, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x6c616373, 0x63614665, 0x73726f74, 0x5f737000,
+    0x00305f32, 0x7263694d, 0x666f736f, 0x52282074, 0x4c482029, 0x53204c53,
+    0x65646168, 0x6f432072, 0x6c69706d, 0x39207265, 0x2e39312e, 0x2e393439,
+    0x31313132, 0xababab00, 0x0200001f, 0x80000000, 0xb0030000, 0x0200001f,
+    0x80000000, 0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x03000042,
+    0x800f0000, 0xb0e40000, 0xa0e40800, 0x02000006, 0x80080001, 0x80ff0000,
+    0x03000005, 0x80070000, 0x80e40000, 0x80ff0001, 0x02000001, 0x800f0001,
+    0xa0e40000, 0x04000004, 0x800f0000, 0x80e40000, 0x80e40001, 0xa0e40001,
+    0x03000005, 0x80070000, 0x80ff0000, 0x80e40000, 0x03000005, 0x800f0000,
+    0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+const DWORD *rescaleShaders[] =
+{
+    rescale0,
+    rescale1,
+};
+
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn convolve0 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D baseImage;
+//   float4 imgEdge;
+//   float3 kernelVals[9];
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   imgEdge      c0       1
+//   kernelVals   c1       9
+//   baseImage    s0       1
+//
+
+    ps_2_0
+    def c10, 0, 1, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    add r0.xy, t0, c2
+    add r1.xy, t0, c1
+    add r2.xy, t0, c3
+    add r3.xy, t0, c4
+    add r4.xy, t0, c5
+    add r5.xy, t0, c6
+    add r6.xy, t0, c7
+    add r7.xy, t0, c8
+    add r8.xy, t0, c9
+    texld r0, r0, s0
+    texld r1, r1, s0
+    texld r2, r2, s0
+    texld r9, t0, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    texld r5, r5, s0
+    texld r6, r6, s0
+    texld r7, r7, s0
+    texld r8, r8, s0
+    mul r0, r0, c2.z
+    mad r0, c1.z, r1, r0
+    mad r0, c3.z, r2, r0
+    mad r0, c4.z, r3, r0
+    mad r0, c5.z, r4, r0
+    mad r0, c6.z, r5, r0
+    mad r0, c7.z, r6, r0
+    mad r0, c8.z, r7, r0
+    mad r0, c9.z, r8, r0
+    mul r0, r0, v0
+    add r1.yw, -t0.y, c0
+    add r1.xz, -t0.x, c0
+    cmp r1.x, -r1.x, c10.x, c10.y
+    cmp r1.y, -r1.y, c10.x, c10.y
+    add r1.x, r1.x, r1.y
+    cmp r1.x, -r1.x, c10.x, c10.y
+    cmp r1.y, r1.z, c10.x, c10.y
+    cmp r1.z, r1.w, c10.x, c10.y
+    add r1.x, r1.x, r1.y
+    cmp r1.x, -r1.x, c10.x, c10.y
+    add r1.x, r1.z, r1.x
+    cmp r0, -r1.x, r0, r9
+    mov oC0, r0
+
+// approximately 42 instruction slots used (10 texture, 32 arithmetic)
+#endif
+
+const DWORD convolve0[] =
+{
+    0xffff0200, 0x0039fffe, 0x42415443, 0x0000001c, 0x000000af, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a8, 0x00000058, 0x00000003,
+    0x00020001, 0x00000064, 0x00000000, 0x00000074, 0x00000002, 0x00020001,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00010002, 0x00060009, 0x00000098,
+    0x00000000, 0x65736162, 0x67616d49, 0xabab0065, 0x000c0004, 0x00010001,
+    0x00000001, 0x00000000, 0x45676d69, 0x00656764, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x6e72656b, 0x61566c65, 0xab00736c, 0x00030001,
+    0x00030001, 0x00000009, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369,
+    0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320,
+    0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051,
+    0xa00f000a, 0x00000000, 0x3f800000, 0x00000000, 0x00000000, 0x0200001f,
+    0x80000000, 0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f,
+    0x90000000, 0xa00f0800, 0x03000002, 0x80030000, 0xb0e40000, 0xa0e40002,
+    0x03000002, 0x80030001, 0xb0e40000, 0xa0e40001, 0x03000002, 0x80030002,
+    0xb0e40000, 0xa0e40003, 0x03000002, 0x80030003, 0xb0e40000, 0xa0e40004,
+    0x03000002, 0x80030004, 0xb0e40000, 0xa0e40005, 0x03000002, 0x80030005,
+    0xb0e40000, 0xa0e40006, 0x03000002, 0x80030006, 0xb0e40000, 0xa0e40007,
+    0x03000002, 0x80030007, 0xb0e40000, 0xa0e40008, 0x03000002, 0x80030008,
+    0xb0e40000, 0xa0e40009, 0x03000042, 0x800f0000, 0x80e40000, 0xa0e40800,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0002,
+    0x80e40002, 0xa0e40800, 0x03000042, 0x800f0009, 0xb0e40000, 0xa0e40800,
+    0x03000042, 0x800f0003, 0x80e40003, 0xa0e40800, 0x03000042, 0x800f0004,
+    0x80e40004, 0xa0e40800, 0x03000042, 0x800f0005, 0x80e40005, 0xa0e40800,
+    0x03000042, 0x800f0006, 0x80e40006, 0xa0e40800, 0x03000042, 0x800f0007,
+    0x80e40007, 0xa0e40800, 0x03000042, 0x800f0008, 0x80e40008, 0xa0e40800,
+    0x03000005, 0x800f0000, 0x80e40000, 0xa0aa0002, 0x04000004, 0x800f0000,
+    0xa0aa0001, 0x80e40001, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0003,
+    0x80e40002, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0004, 0x80e40003,
+    0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0005, 0x80e40004, 0x80e40000,
+    0x04000004, 0x800f0000, 0xa0aa0006, 0x80e40005, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa0007, 0x80e40006, 0x80e40000, 0x04000004, 0x800f0000,
+    0xa0aa0008, 0x80e40007, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0009,
+    0x80e40008, 0x80e40000, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000,
+    0x03000002, 0x800a0001, 0xb1550000, 0xa0e40000, 0x03000002, 0x80050001,
+    0xb1000000, 0xa0e40000, 0x04000058, 0x80010001, 0x81000001, 0xa000000a,
+    0xa055000a, 0x04000058, 0x80020001, 0x81550001, 0xa000000a, 0xa055000a,
+    0x03000002, 0x80010001, 0x80000001, 0x80550001, 0x04000058, 0x80010001,
+    0x81000001, 0xa000000a, 0xa055000a, 0x04000058, 0x80020001, 0x80aa0001,
+    0xa000000a, 0xa055000a, 0x04000058, 0x80040001, 0x80ff0001, 0xa000000a,
+    0xa055000a, 0x03000002, 0x80010001, 0x80000001, 0x80550001, 0x04000058,
+    0x80010001, 0x81000001, 0xa000000a, 0xa055000a, 0x03000002, 0x80010001,
+    0x80aa0001, 0x80000001, 0x04000058, 0x800f0000, 0x81000001, 0x80e40000,
+    0x80e40009, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn convolve1 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D baseImage;
+//   float4 imgEdge;
+//   float3 kernelVals[9];
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   imgEdge      c0       1
+//   kernelVals   c1       9
+//   baseImage    s0       1
+//
+
+    ps_2_0
+    def c10, 0, 1, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    add r0.xy, t0, c2
+    add r1.xy, t0, c1
+    add r2.xy, t0, c3
+    add r3.xy, t0, c4
+    add r4.xy, t0, c5
+    add r5.xy, t0, c6
+    add r6.xy, t0, c7
+    add r7.xy, t0, c8
+    add r8.xy, t0, c9
+    texld r0, r0, s0
+    texld r1, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    texld r5, r5, s0
+    texld r6, r6, s0
+    texld r7, r7, s0
+    texld r8, r8, s0
+    mul r0, r0, c2.z
+    mad r0, c1.z, r1, r0
+    mad r0, c3.z, r2, r0
+    mad r0, c4.z, r3, r0
+    mad r0, c5.z, r4, r0
+    mad r0, c6.z, r5, r0
+    mad r0, c7.z, r6, r0
+    mad r0, c8.z, r7, r0
+    mad r0, c9.z, r8, r0
+    mul r0, r0, v0
+    add r1.yw, -t0.y, c0
+    add r1.xz, -t0.x, c0
+    cmp r1.x, -r1.x, c10.x, c10.y
+    cmp r1.y, -r1.y, c10.x, c10.y
+    add r1.x, r1.x, r1.y
+    cmp r1.x, -r1.x, c10.x, c10.y
+    cmp r1.y, r1.z, c10.x, c10.y
+    cmp r1.z, r1.w, c10.x, c10.y
+    add r1.x, r1.x, r1.y
+    cmp r1.x, -r1.x, c10.x, c10.y
+    add r1.x, r1.z, r1.x
+    cmp r0, -r1.x, r0, c10.x
+    mov oC0, r0
+
+// approximately 41 instruction slots used (9 texture, 32 arithmetic)
+#endif
+
+const DWORD convolve1[] =
+{
+    0xffff0200, 0x0039fffe, 0x42415443, 0x0000001c, 0x000000af, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a8, 0x00000058, 0x00000003,
+    0x00020001, 0x00000064, 0x00000000, 0x00000074, 0x00000002, 0x00020001,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00010002, 0x00060009, 0x00000098,
+    0x00000000, 0x65736162, 0x67616d49, 0xabab0065, 0x000c0004, 0x00010001,
+    0x00000001, 0x00000000, 0x45676d69, 0x00656764, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x6e72656b, 0x61566c65, 0xab00736c, 0x00030001,
+    0x00030001, 0x00000009, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369,
+    0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320,
+    0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051,
+    0xa00f000a, 0x00000000, 0x3f800000, 0x00000000, 0x00000000, 0x0200001f,
+    0x80000000, 0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f,
+    0x90000000, 0xa00f0800, 0x03000002, 0x80030000, 0xb0e40000, 0xa0e40002,
+    0x03000002, 0x80030001, 0xb0e40000, 0xa0e40001, 0x03000002, 0x80030002,
+    0xb0e40000, 0xa0e40003, 0x03000002, 0x80030003, 0xb0e40000, 0xa0e40004,
+    0x03000002, 0x80030004, 0xb0e40000, 0xa0e40005, 0x03000002, 0x80030005,
+    0xb0e40000, 0xa0e40006, 0x03000002, 0x80030006, 0xb0e40000, 0xa0e40007,
+    0x03000002, 0x80030007, 0xb0e40000, 0xa0e40008, 0x03000002, 0x80030008,
+    0xb0e40000, 0xa0e40009, 0x03000042, 0x800f0000, 0x80e40000, 0xa0e40800,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0002,
+    0x80e40002, 0xa0e40800, 0x03000042, 0x800f0003, 0x80e40003, 0xa0e40800,
+    0x03000042, 0x800f0004, 0x80e40004, 0xa0e40800, 0x03000042, 0x800f0005,
+    0x80e40005, 0xa0e40800, 0x03000042, 0x800f0006, 0x80e40006, 0xa0e40800,
+    0x03000042, 0x800f0007, 0x80e40007, 0xa0e40800, 0x03000042, 0x800f0008,
+    0x80e40008, 0xa0e40800, 0x03000005, 0x800f0000, 0x80e40000, 0xa0aa0002,
+    0x04000004, 0x800f0000, 0xa0aa0001, 0x80e40001, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa0003, 0x80e40002, 0x80e40000, 0x04000004, 0x800f0000,
+    0xa0aa0004, 0x80e40003, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0005,
+    0x80e40004, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0006, 0x80e40005,
+    0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0007, 0x80e40006, 0x80e40000,
+    0x04000004, 0x800f0000, 0xa0aa0008, 0x80e40007, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa0009, 0x80e40008, 0x80e40000, 0x03000005, 0x800f0000,
+    0x80e40000, 0x90e40000, 0x03000002, 0x800a0001, 0xb1550000, 0xa0e40000,
+    0x03000002, 0x80050001, 0xb1000000, 0xa0e40000, 0x04000058, 0x80010001,
+    0x81000001, 0xa000000a, 0xa055000a, 0x04000058, 0x80020001, 0x81550001,
+    0xa000000a, 0xa055000a, 0x03000002, 0x80010001, 0x80000001, 0x80550001,
+    0x04000058, 0x80010001, 0x81000001, 0xa000000a, 0xa055000a, 0x04000058,
+    0x80020001, 0x80aa0001, 0xa000000a, 0xa055000a, 0x04000058, 0x80040001,
+    0x80ff0001, 0xa000000a, 0xa055000a, 0x03000002, 0x80010001, 0x80000001,
+    0x80550001, 0x04000058, 0x80010001, 0x81000001, 0xa000000a, 0xa055000a,
+    0x03000002, 0x80010001, 0x80aa0001, 0x80000001, 0x04000058, 0x800f0000,
+    0x81000001, 0x80e40000, 0xa000000a, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn convolve2 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D baseImage;
+//   float4 imgEdge;
+//   float3 kernelVals[25];
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   imgEdge      c0       1
+//   kernelVals   c1      25
+//   baseImage    s0       1
+//
+
+    ps_2_0
+    def c26, 0, 1, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    add r0.xy, t0, c2
+    add r1.xy, t0, c1
+    add r2.xy, t0, c3
+    add r3.xy, t0, c4
+    add r4.xy, t0, c5
+    add r5.xy, t0, c6
+    add r6.xy, t0, c7
+    add r7.xy, t0, c8
+    add r8.xy, t0, c9
+    texld r0, r0, s0
+    texld r1, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    texld r5, r5, s0
+    texld r6, r6, s0
+    texld r7, r7, s0
+    texld r8, r8, s0
+    mul r0, r0, c2.z
+    mad r0, c1.z, r1, r0
+    mad r0, c3.z, r2, r0
+    mad r0, c4.z, r3, r0
+    mad r0, c5.z, r4, r0
+    mad r0, c6.z, r5, r0
+    mad r0, c7.z, r6, r0
+    mad r0, c8.z, r7, r0
+    mad r0, c9.z, r8, r0
+    add r1.xy, t0, c10
+    add r2.xy, t0, c11
+    add r3.xy, t0, c12
+    add r4.xy, t0, c13
+    add r5.xy, t0, c14
+    add r6.xy, t0, c15
+    add r7.xy, t0, c16
+    add r8.xy, t0, c17
+    add r9.xy, t0, c18
+    texld r1, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    texld r5, r5, s0
+    texld r6, r6, s0
+    texld r7, r7, s0
+    texld r8, r8, s0
+    texld r9, r9, s0
+    mad r0, c10.z, r1, r0
+    mad r0, c11.z, r2, r0
+    mad r0, c12.z, r3, r0
+    mad r0, c13.z, r4, r0
+    mad r0, c14.z, r5, r0
+    mad r0, c15.z, r6, r0
+    mad r0, c16.z, r7, r0
+    mad r0, c17.z, r8, r0
+    mad r0, c18.z, r9, r0
+    add r1.xy, t0, c19
+    add r2.xy, t0, c20
+    add r3.xy, t0, c21
+    add r4.xy, t0, c22
+    add r5.xy, t0, c23
+    add r6.xy, t0, c24
+    add r7.xy, t0, c25
+    texld r1, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    texld r5, r5, s0
+    texld r6, r6, s0
+    texld r7, r7, s0
+    texld r8, t0, s0
+    mad r0, c19.z, r1, r0
+    mad r0, c20.z, r2, r0
+    mad r0, c21.z, r3, r0
+    mad r0, c22.z, r4, r0
+    mad r0, c23.z, r5, r0
+    mad r0, c24.z, r6, r0
+    mad r0, c25.z, r7, r0
+    mul r0, r0, v0
+    add r1.yw, -t0.y, c0
+    add r1.xz, -t0.x, c0
+    cmp r1.x, -r1.x, c26.x, c26.y
+    cmp r1.y, -r1.y, c26.x, c26.y
+    add r1.x, r1.x, r1.y
+    cmp r1.x, -r1.x, c26.x, c26.y
+    cmp r1.y, r1.z, c26.x, c26.y
+    cmp r1.z, r1.w, c26.x, c26.y
+    add r1.x, r1.x, r1.y
+    cmp r1.x, -r1.x, c26.x, c26.y
+    add r1.x, r1.z, r1.x
+    cmp r0, -r1.x, r0, r8
+    mov oC0, r0
+
+// approximately 90 instruction slots used (26 texture, 64 arithmetic)
+#endif
+
+const DWORD convolve2[] =
+{
+    0xffff0200, 0x0039fffe, 0x42415443, 0x0000001c, 0x000000af, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a8, 0x00000058, 0x00000003,
+    0x00020001, 0x00000064, 0x00000000, 0x00000074, 0x00000002, 0x00020001,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00010002, 0x00060019, 0x00000098,
+    0x00000000, 0x65736162, 0x67616d49, 0xabab0065, 0x000c0004, 0x00010001,
+    0x00000001, 0x00000000, 0x45676d69, 0x00656764, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x6e72656b, 0x61566c65, 0xab00736c, 0x00030001,
+    0x00030001, 0x00000019, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369,
+    0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320,
+    0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051,
+    0xa00f001a, 0x00000000, 0x3f800000, 0x00000000, 0x00000000, 0x0200001f,
+    0x80000000, 0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f,
+    0x90000000, 0xa00f0800, 0x03000002, 0x80030000, 0xb0e40000, 0xa0e40002,
+    0x03000002, 0x80030001, 0xb0e40000, 0xa0e40001, 0x03000002, 0x80030002,
+    0xb0e40000, 0xa0e40003, 0x03000002, 0x80030003, 0xb0e40000, 0xa0e40004,
+    0x03000002, 0x80030004, 0xb0e40000, 0xa0e40005, 0x03000002, 0x80030005,
+    0xb0e40000, 0xa0e40006, 0x03000002, 0x80030006, 0xb0e40000, 0xa0e40007,
+    0x03000002, 0x80030007, 0xb0e40000, 0xa0e40008, 0x03000002, 0x80030008,
+    0xb0e40000, 0xa0e40009, 0x03000042, 0x800f0000, 0x80e40000, 0xa0e40800,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0002,
+    0x80e40002, 0xa0e40800, 0x03000042, 0x800f0003, 0x80e40003, 0xa0e40800,
+    0x03000042, 0x800f0004, 0x80e40004, 0xa0e40800, 0x03000042, 0x800f0005,
+    0x80e40005, 0xa0e40800, 0x03000042, 0x800f0006, 0x80e40006, 0xa0e40800,
+    0x03000042, 0x800f0007, 0x80e40007, 0xa0e40800, 0x03000042, 0x800f0008,
+    0x80e40008, 0xa0e40800, 0x03000005, 0x800f0000, 0x80e40000, 0xa0aa0002,
+    0x04000004, 0x800f0000, 0xa0aa0001, 0x80e40001, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa0003, 0x80e40002, 0x80e40000, 0x04000004, 0x800f0000,
+    0xa0aa0004, 0x80e40003, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0005,
+    0x80e40004, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0006, 0x80e40005,
+    0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0007, 0x80e40006, 0x80e40000,
+    0x04000004, 0x800f0000, 0xa0aa0008, 0x80e40007, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa0009, 0x80e40008, 0x80e40000, 0x03000002, 0x80030001,
+    0xb0e40000, 0xa0e4000a, 0x03000002, 0x80030002, 0xb0e40000, 0xa0e4000b,
+    0x03000002, 0x80030003, 0xb0e40000, 0xa0e4000c, 0x03000002, 0x80030004,
+    0xb0e40000, 0xa0e4000d, 0x03000002, 0x80030005, 0xb0e40000, 0xa0e4000e,
+    0x03000002, 0x80030006, 0xb0e40000, 0xa0e4000f, 0x03000002, 0x80030007,
+    0xb0e40000, 0xa0e40010, 0x03000002, 0x80030008, 0xb0e40000, 0xa0e40011,
+    0x03000002, 0x80030009, 0xb0e40000, 0xa0e40012, 0x03000042, 0x800f0001,
+    0x80e40001, 0xa0e40800, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800,
+    0x03000042, 0x800f0003, 0x80e40003, 0xa0e40800, 0x03000042, 0x800f0004,
+    0x80e40004, 0xa0e40800, 0x03000042, 0x800f0005, 0x80e40005, 0xa0e40800,
+    0x03000042, 0x800f0006, 0x80e40006, 0xa0e40800, 0x03000042, 0x800f0007,
+    0x80e40007, 0xa0e40800, 0x03000042, 0x800f0008, 0x80e40008, 0xa0e40800,
+    0x03000042, 0x800f0009, 0x80e40009, 0xa0e40800, 0x04000004, 0x800f0000,
+    0xa0aa000a, 0x80e40001, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa000b,
+    0x80e40002, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa000c, 0x80e40003,
+    0x80e40000, 0x04000004, 0x800f0000, 0xa0aa000d, 0x80e40004, 0x80e40000,
+    0x04000004, 0x800f0000, 0xa0aa000e, 0x80e40005, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa000f, 0x80e40006, 0x80e40000, 0x04000004, 0x800f0000,
+    0xa0aa0010, 0x80e40007, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0011,
+    0x80e40008, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0012, 0x80e40009,
+    0x80e40000, 0x03000002, 0x80030001, 0xb0e40000, 0xa0e40013, 0x03000002,
+    0x80030002, 0xb0e40000, 0xa0e40014, 0x03000002, 0x80030003, 0xb0e40000,
+    0xa0e40015, 0x03000002, 0x80030004, 0xb0e40000, 0xa0e40016, 0x03000002,
+    0x80030005, 0xb0e40000, 0xa0e40017, 0x03000002, 0x80030006, 0xb0e40000,
+    0xa0e40018, 0x03000002, 0x80030007, 0xb0e40000, 0xa0e40019, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0002, 0x80e40002,
+    0xa0e40800, 0x03000042, 0x800f0003, 0x80e40003, 0xa0e40800, 0x03000042,
+    0x800f0004, 0x80e40004, 0xa0e40800, 0x03000042, 0x800f0005, 0x80e40005,
+    0xa0e40800, 0x03000042, 0x800f0006, 0x80e40006, 0xa0e40800, 0x03000042,
+    0x800f0007, 0x80e40007, 0xa0e40800, 0x03000042, 0x800f0008, 0xb0e40000,
+    0xa0e40800, 0x04000004, 0x800f0000, 0xa0aa0013, 0x80e40001, 0x80e40000,
+    0x04000004, 0x800f0000, 0xa0aa0014, 0x80e40002, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa0015, 0x80e40003, 0x80e40000, 0x04000004, 0x800f0000,
+    0xa0aa0016, 0x80e40004, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0017,
+    0x80e40005, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0018, 0x80e40006,
+    0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0019, 0x80e40007, 0x80e40000,
+    0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x03000002, 0x800a0001,
+    0xb1550000, 0xa0e40000, 0x03000002, 0x80050001, 0xb1000000, 0xa0e40000,
+    0x04000058, 0x80010001, 0x81000001, 0xa000001a, 0xa055001a, 0x04000058,
+    0x80020001, 0x81550001, 0xa000001a, 0xa055001a, 0x03000002, 0x80010001,
+    0x80000001, 0x80550001, 0x04000058, 0x80010001, 0x81000001, 0xa000001a,
+    0xa055001a, 0x04000058, 0x80020001, 0x80aa0001, 0xa000001a, 0xa055001a,
+    0x04000058, 0x80040001, 0x80ff0001, 0xa000001a, 0xa055001a, 0x03000002,
+    0x80010001, 0x80000001, 0x80550001, 0x04000058, 0x80010001, 0x81000001,
+    0xa000001a, 0xa055001a, 0x03000002, 0x80010001, 0x80aa0001, 0x80000001,
+    0x04000058, 0x800f0000, 0x81000001, 0x80e40000, 0x80e40008, 0x02000001,
+    0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn convolve3 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D baseImage;
+//   float4 imgEdge;
+//   float3 kernelVals[25];
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   imgEdge      c0       1
+//   kernelVals   c1      25
+//   baseImage    s0       1
+//
+
+    ps_2_0
+    def c26, 0, 1, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    add r0.xy, t0, c2
+    add r1.xy, t0, c1
+    add r2.xy, t0, c3
+    add r3.xy, t0, c4
+    add r4.xy, t0, c5
+    add r5.xy, t0, c6
+    add r6.xy, t0, c7
+    add r7.xy, t0, c8
+    add r8.xy, t0, c9
+    texld r0, r0, s0
+    texld r1, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    texld r5, r5, s0
+    texld r6, r6, s0
+    texld r7, r7, s0
+    texld r8, r8, s0
+    mul r0, r0, c2.z
+    mad r0, c1.z, r1, r0
+    mad r0, c3.z, r2, r0
+    mad r0, c4.z, r3, r0
+    mad r0, c5.z, r4, r0
+    mad r0, c6.z, r5, r0
+    mad r0, c7.z, r6, r0
+    mad r0, c8.z, r7, r0
+    mad r0, c9.z, r8, r0
+    add r1.xy, t0, c10
+    add r2.xy, t0, c11
+    add r3.xy, t0, c12
+    add r4.xy, t0, c13
+    add r5.xy, t0, c14
+    add r6.xy, t0, c15
+    add r7.xy, t0, c16
+    add r8.xy, t0, c17
+    add r9.xy, t0, c18
+    texld r1, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    texld r5, r5, s0
+    texld r6, r6, s0
+    texld r7, r7, s0
+    texld r8, r8, s0
+    texld r9, r9, s0
+    mad r0, c10.z, r1, r0
+    mad r0, c11.z, r2, r0
+    mad r0, c12.z, r3, r0
+    mad r0, c13.z, r4, r0
+    mad r0, c14.z, r5, r0
+    mad r0, c15.z, r6, r0
+    mad r0, c16.z, r7, r0
+    mad r0, c17.z, r8, r0
+    mad r0, c18.z, r9, r0
+    add r1.xy, t0, c19
+    add r2.xy, t0, c20
+    add r3.xy, t0, c21
+    add r4.xy, t0, c22
+    add r5.xy, t0, c23
+    add r6.xy, t0, c24
+    add r7.xy, t0, c25
+    texld r1, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    texld r5, r5, s0
+    texld r6, r6, s0
+    texld r7, r7, s0
+    mad r0, c19.z, r1, r0
+    mad r0, c20.z, r2, r0
+    mad r0, c21.z, r3, r0
+    mad r0, c22.z, r4, r0
+    mad r0, c23.z, r5, r0
+    mad r0, c24.z, r6, r0
+    mad r0, c25.z, r7, r0
+    mul r0, r0, v0
+    add r1.yw, -t0.y, c0
+    add r1.xz, -t0.x, c0
+    cmp r1.x, -r1.x, c26.x, c26.y
+    cmp r1.y, -r1.y, c26.x, c26.y
+    add r1.x, r1.x, r1.y
+    cmp r1.x, -r1.x, c26.x, c26.y
+    cmp r1.y, r1.z, c26.x, c26.y
+    cmp r1.z, r1.w, c26.x, c26.y
+    add r1.x, r1.x, r1.y
+    cmp r1.x, -r1.x, c26.x, c26.y
+    add r1.x, r1.z, r1.x
+    cmp r0, -r1.x, r0, c26.x
+    mov oC0, r0
+
+// approximately 89 instruction slots used (25 texture, 64 arithmetic)
+#endif
+
+const DWORD convolve3[] =
+{
+    0xffff0200, 0x0039fffe, 0x42415443, 0x0000001c, 0x000000af, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a8, 0x00000058, 0x00000003,
+    0x00020001, 0x00000064, 0x00000000, 0x00000074, 0x00000002, 0x00020001,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00010002, 0x00060019, 0x00000098,
+    0x00000000, 0x65736162, 0x67616d49, 0xabab0065, 0x000c0004, 0x00010001,
+    0x00000001, 0x00000000, 0x45676d69, 0x00656764, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x6e72656b, 0x61566c65, 0xab00736c, 0x00030001,
+    0x00030001, 0x00000019, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369,
+    0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320,
+    0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051,
+    0xa00f001a, 0x00000000, 0x3f800000, 0x00000000, 0x00000000, 0x0200001f,
+    0x80000000, 0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f,
+    0x90000000, 0xa00f0800, 0x03000002, 0x80030000, 0xb0e40000, 0xa0e40002,
+    0x03000002, 0x80030001, 0xb0e40000, 0xa0e40001, 0x03000002, 0x80030002,
+    0xb0e40000, 0xa0e40003, 0x03000002, 0x80030003, 0xb0e40000, 0xa0e40004,
+    0x03000002, 0x80030004, 0xb0e40000, 0xa0e40005, 0x03000002, 0x80030005,
+    0xb0e40000, 0xa0e40006, 0x03000002, 0x80030006, 0xb0e40000, 0xa0e40007,
+    0x03000002, 0x80030007, 0xb0e40000, 0xa0e40008, 0x03000002, 0x80030008,
+    0xb0e40000, 0xa0e40009, 0x03000042, 0x800f0000, 0x80e40000, 0xa0e40800,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0002,
+    0x80e40002, 0xa0e40800, 0x03000042, 0x800f0003, 0x80e40003, 0xa0e40800,
+    0x03000042, 0x800f0004, 0x80e40004, 0xa0e40800, 0x03000042, 0x800f0005,
+    0x80e40005, 0xa0e40800, 0x03000042, 0x800f0006, 0x80e40006, 0xa0e40800,
+    0x03000042, 0x800f0007, 0x80e40007, 0xa0e40800, 0x03000042, 0x800f0008,
+    0x80e40008, 0xa0e40800, 0x03000005, 0x800f0000, 0x80e40000, 0xa0aa0002,
+    0x04000004, 0x800f0000, 0xa0aa0001, 0x80e40001, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa0003, 0x80e40002, 0x80e40000, 0x04000004, 0x800f0000,
+    0xa0aa0004, 0x80e40003, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0005,
+    0x80e40004, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0006, 0x80e40005,
+    0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0007, 0x80e40006, 0x80e40000,
+    0x04000004, 0x800f0000, 0xa0aa0008, 0x80e40007, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa0009, 0x80e40008, 0x80e40000, 0x03000002, 0x80030001,
+    0xb0e40000, 0xa0e4000a, 0x03000002, 0x80030002, 0xb0e40000, 0xa0e4000b,
+    0x03000002, 0x80030003, 0xb0e40000, 0xa0e4000c, 0x03000002, 0x80030004,
+    0xb0e40000, 0xa0e4000d, 0x03000002, 0x80030005, 0xb0e40000, 0xa0e4000e,
+    0x03000002, 0x80030006, 0xb0e40000, 0xa0e4000f, 0x03000002, 0x80030007,
+    0xb0e40000, 0xa0e40010, 0x03000002, 0x80030008, 0xb0e40000, 0xa0e40011,
+    0x03000002, 0x80030009, 0xb0e40000, 0xa0e40012, 0x03000042, 0x800f0001,
+    0x80e40001, 0xa0e40800, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800,
+    0x03000042, 0x800f0003, 0x80e40003, 0xa0e40800, 0x03000042, 0x800f0004,
+    0x80e40004, 0xa0e40800, 0x03000042, 0x800f0005, 0x80e40005, 0xa0e40800,
+    0x03000042, 0x800f0006, 0x80e40006, 0xa0e40800, 0x03000042, 0x800f0007,
+    0x80e40007, 0xa0e40800, 0x03000042, 0x800f0008, 0x80e40008, 0xa0e40800,
+    0x03000042, 0x800f0009, 0x80e40009, 0xa0e40800, 0x04000004, 0x800f0000,
+    0xa0aa000a, 0x80e40001, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa000b,
+    0x80e40002, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa000c, 0x80e40003,
+    0x80e40000, 0x04000004, 0x800f0000, 0xa0aa000d, 0x80e40004, 0x80e40000,
+    0x04000004, 0x800f0000, 0xa0aa000e, 0x80e40005, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa000f, 0x80e40006, 0x80e40000, 0x04000004, 0x800f0000,
+    0xa0aa0010, 0x80e40007, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0011,
+    0x80e40008, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0012, 0x80e40009,
+    0x80e40000, 0x03000002, 0x80030001, 0xb0e40000, 0xa0e40013, 0x03000002,
+    0x80030002, 0xb0e40000, 0xa0e40014, 0x03000002, 0x80030003, 0xb0e40000,
+    0xa0e40015, 0x03000002, 0x80030004, 0xb0e40000, 0xa0e40016, 0x03000002,
+    0x80030005, 0xb0e40000, 0xa0e40017, 0x03000002, 0x80030006, 0xb0e40000,
+    0xa0e40018, 0x03000002, 0x80030007, 0xb0e40000, 0xa0e40019, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0002, 0x80e40002,
+    0xa0e40800, 0x03000042, 0x800f0003, 0x80e40003, 0xa0e40800, 0x03000042,
+    0x800f0004, 0x80e40004, 0xa0e40800, 0x03000042, 0x800f0005, 0x80e40005,
+    0xa0e40800, 0x03000042, 0x800f0006, 0x80e40006, 0xa0e40800, 0x03000042,
+    0x800f0007, 0x80e40007, 0xa0e40800, 0x04000004, 0x800f0000, 0xa0aa0013,
+    0x80e40001, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0014, 0x80e40002,
+    0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0015, 0x80e40003, 0x80e40000,
+    0x04000004, 0x800f0000, 0xa0aa0016, 0x80e40004, 0x80e40000, 0x04000004,
+    0x800f0000, 0xa0aa0017, 0x80e40005, 0x80e40000, 0x04000004, 0x800f0000,
+    0xa0aa0018, 0x80e40006, 0x80e40000, 0x04000004, 0x800f0000, 0xa0aa0019,
+    0x80e40007, 0x80e40000, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000,
+    0x03000002, 0x800a0001, 0xb1550000, 0xa0e40000, 0x03000002, 0x80050001,
+    0xb1000000, 0xa0e40000, 0x04000058, 0x80010001, 0x81000001, 0xa000001a,
+    0xa055001a, 0x04000058, 0x80020001, 0x81550001, 0xa000001a, 0xa055001a,
+    0x03000002, 0x80010001, 0x80000001, 0x80550001, 0x04000058, 0x80010001,
+    0x81000001, 0xa000001a, 0xa055001a, 0x04000058, 0x80020001, 0x80aa0001,
+    0xa000001a, 0xa055001a, 0x04000058, 0x80040001, 0x80ff0001, 0xa000001a,
+    0xa055001a, 0x03000002, 0x80010001, 0x80000001, 0x80550001, 0x04000058,
+    0x80010001, 0x81000001, 0xa000001a, 0xa055001a, 0x03000002, 0x80010001,
+    0x80aa0001, 0x80000001, 0x04000058, 0x800f0000, 0x81000001, 0x80e40000,
+    0xa000001a, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+const DWORD *convolveShaders[] =
+{
+    convolve0,
+    convolve1,
+    convolve2,
+    convolve3,
+};
+
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn lookup0 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D baseImage;
+//   sampler2D lookupTable;
+//   float4 offset;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   offset       c0       1
+//   baseImage    s0       1
+//   lookupTable  s1       1
+//
+
+    ps_2_0
+    def c1, 0.125, 0.375, 0.625, 0.875
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    texld r0, t0, s0
+    mov r1.y, c1.x
+    add r0, r0, -c0
+    mov r1.x, r0.x
+    mov r0.x, r0.y
+    mov r0.y, c1.y
+    mov r2.x, r0.z
+    mov r3.x, r0.w
+    mov r2.y, c1.z
+    mov r3.y, c1.w
+    texld r1, r1, s1
+    texld r0, r0, s1
+    texld r2, r2, s1
+    texld r3, r3, s1
+    mov r1.y, r0.x
+    mov r1.z, r2.x
+    mov r1.w, r3.x
+    mul r0, r1, v0
+    mov oC0, r0
+
+// approximately 19 instruction slots used (5 texture, 14 arithmetic)
+#endif
+
+const DWORD lookup0[] =
+{
+    0xffff0200, 0x0035fffe, 0x42415443, 0x0000001c, 0x0000009f, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x00000098, 0x00000058, 0x00000003,
+    0x00020001, 0x00000064, 0x00000000, 0x00000074, 0x00010003, 0x00060001,
+    0x00000064, 0x00000000, 0x00000080, 0x00000002, 0x00020001, 0x00000088,
+    0x00000000, 0x65736162, 0x67616d49, 0xabab0065, 0x000c0004, 0x00010001,
+    0x00000001, 0x00000000, 0x6b6f6f6c, 0x61547075, 0x00656c62, 0x7366666f,
+    0xab007465, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x325f7370,
+    0x4d00305f, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c,
+    0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934,
+    0x00313131, 0x05000051, 0xa00f0001, 0x3e000000, 0x3ec00000, 0x3f200000,
+    0x3f600000, 0x0200001f, 0x80000000, 0xb0030000, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x03000042, 0x800f0000, 0xb0e40000, 0xa0e40800, 0x02000001,
+    0x80020001, 0xa0000001, 0x03000002, 0x800f0000, 0x80e40000, 0xa1e40000,
+    0x02000001, 0x80010001, 0x80000000, 0x02000001, 0x80010000, 0x80550000,
+    0x02000001, 0x80020000, 0xa0550001, 0x02000001, 0x80010002, 0x80aa0000,
+    0x02000001, 0x80010003, 0x80ff0000, 0x02000001, 0x80020002, 0xa0aa0001,
+    0x02000001, 0x80020003, 0xa0ff0001, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40801, 0x03000042, 0x800f0000, 0x80e40000, 0xa0e40801, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0003, 0x80e40003,
+    0xa0e40801, 0x02000001, 0x80020001, 0x80000000, 0x02000001, 0x80040001,
+    0x80000002, 0x02000001, 0x80080001, 0x80000003, 0x03000005, 0x800f0000,
+    0x80e40001, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn lookup1 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D baseImage;
+//   sampler2D lookupTable;
+//   float4 offset;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   offset       c0       1
+//   baseImage    s0       1
+//   lookupTable  s1       1
+//
+
+    ps_2_0
+    def c1, 0.125, 0.375, 0.625, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    texld r0, t0, s0
+    mov r1.y, c1.x
+    add r2.xyz, r0, -c0
+    mov r1.x, r2.x
+    mov r2.x, r2.y
+    mov r3.x, r2.z
+    mov r2.y, c1.y
+    mov r3.y, c1.z
+    texld r1, r1, s1
+    texld r2, r2, s1
+    texld r3, r3, s1
+    mov r0.x, r1.x
+    mov r0.y, r2.x
+    mov r0.z, r3.x
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 16 instruction slots used (4 texture, 12 arithmetic)
+#endif
+
+const DWORD lookup1[] =
+{
+    0xffff0200, 0x0035fffe, 0x42415443, 0x0000001c, 0x0000009f, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x00000098, 0x00000058, 0x00000003,
+    0x00020001, 0x00000064, 0x00000000, 0x00000074, 0x00010003, 0x00060001,
+    0x00000064, 0x00000000, 0x00000080, 0x00000002, 0x00020001, 0x00000088,
+    0x00000000, 0x65736162, 0x67616d49, 0xabab0065, 0x000c0004, 0x00010001,
+    0x00000001, 0x00000000, 0x6b6f6f6c, 0x61547075, 0x00656c62, 0x7366666f,
+    0xab007465, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x325f7370,
+    0x4d00305f, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c,
+    0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934,
+    0x00313131, 0x05000051, 0xa00f0001, 0x3e000000, 0x3ec00000, 0x3f200000,
+    0x00000000, 0x0200001f, 0x80000000, 0xb0030000, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x03000042, 0x800f0000, 0xb0e40000, 0xa0e40800, 0x02000001,
+    0x80020001, 0xa0000001, 0x03000002, 0x80070002, 0x80e40000, 0xa1e40000,
+    0x02000001, 0x80010001, 0x80000002, 0x02000001, 0x80010002, 0x80550002,
+    0x02000001, 0x80010003, 0x80aa0002, 0x02000001, 0x80020002, 0xa0550001,
+    0x02000001, 0x80020003, 0xa0aa0001, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40801, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042,
+    0x800f0003, 0x80e40003, 0xa0e40801, 0x02000001, 0x80010000, 0x80000001,
+    0x02000001, 0x80020000, 0x80000002, 0x02000001, 0x80040000, 0x80000003,
+    0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800,
+    0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn lookup2 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D baseImage;
+//   sampler2D lookupTable;
+//   float4 offset;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   offset       c0       1
+//   baseImage    s0       1
+//   lookupTable  s1       1
+//
+
+    ps_2_0
+    def c1, 0.125, 0.375, 0.625, 0.875
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    texld r0, t0, s0
+    mov r1.y, c1.x
+    rcp r1.z, r0.w
+    mul r0.xyz, r0, r1.z
+    add r0, r0, -c0
+    mov r1.x, r0.x
+    mov r0.x, r0.y
+    mov r0.y, c1.y
+    mov r2.x, r0.z
+    mov r3.x, r0.w
+    mov r2.y, c1.z
+    mov r3.y, c1.w
+    texld r1, r1, s1
+    texld r0, r0, s1
+    texld r2, r2, s1
+    texld r3, r3, s1
+    mov r1.y, r0.x
+    mov r1.z, r2.x
+    mul r0.xyz, r3.x, r1
+    mov r0.w, r3.x
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 22 instruction slots used (5 texture, 17 arithmetic)
+#endif
+
+const DWORD lookup2[] =
+{
+    0xffff0200, 0x0035fffe, 0x42415443, 0x0000001c, 0x0000009f, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x00000098, 0x00000058, 0x00000003,
+    0x00020001, 0x00000064, 0x00000000, 0x00000074, 0x00010003, 0x00060001,
+    0x00000064, 0x00000000, 0x00000080, 0x00000002, 0x00020001, 0x00000088,
+    0x00000000, 0x65736162, 0x67616d49, 0xabab0065, 0x000c0004, 0x00010001,
+    0x00000001, 0x00000000, 0x6b6f6f6c, 0x61547075, 0x00656c62, 0x7366666f,
+    0xab007465, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x325f7370,
+    0x4d00305f, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c,
+    0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934,
+    0x00313131, 0x05000051, 0xa00f0001, 0x3e000000, 0x3ec00000, 0x3f200000,
+    0x3f600000, 0x0200001f, 0x80000000, 0xb0030000, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x03000042, 0x800f0000, 0xb0e40000, 0xa0e40800, 0x02000001,
+    0x80020001, 0xa0000001, 0x02000006, 0x80040001, 0x80ff0000, 0x03000005,
+    0x80070000, 0x80e40000, 0x80aa0001, 0x03000002, 0x800f0000, 0x80e40000,
+    0xa1e40000, 0x02000001, 0x80010001, 0x80000000, 0x02000001, 0x80010000,
+    0x80550000, 0x02000001, 0x80020000, 0xa0550001, 0x02000001, 0x80010002,
+    0x80aa0000, 0x02000001, 0x80010003, 0x80ff0000, 0x02000001, 0x80020002,
+    0xa0aa0001, 0x02000001, 0x80020003, 0xa0ff0001, 0x03000042, 0x800f0001,
+    0x80e40001, 0xa0e40801, 0x03000042, 0x800f0000, 0x80e40000, 0xa0e40801,
+    0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0003,
+    0x80e40003, 0xa0e40801, 0x02000001, 0x80020001, 0x80000000, 0x02000001,
+    0x80040001, 0x80000002, 0x03000005, 0x80070000, 0x80000003, 0x80e40001,
+    0x02000001, 0x80080000, 0x80000003, 0x03000005, 0x800f0000, 0x80e40000,
+    0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn lookup3 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D baseImage;
+//   sampler2D lookupTable;
+//   float4 offset;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   offset       c0       1
+//   baseImage    s0       1
+//   lookupTable  s1       1
+//
+
+    ps_2_0
+    def c1, 0.125, 0.375, 0.625, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    texld r0, t0, s0
+    mov r1.y, c1.x
+    rcp r1.z, r0.w
+    mad r2.xyz, r0, r1.z, -c0
+    mov r1.x, r2.x
+    mov r3.y, c1.y
+    mov r3.x, r2.y
+    mov r2.x, r2.z
+    mov r2.y, c1.z
+    texld r1, r1, s1
+    texld r3, r3, s1
+    texld r2, r2, s1
+    mov r1.y, r3.x
+    mov r1.z, r2.x
+    mul r0.xyz, r0.w, r1
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 17 instruction slots used (4 texture, 13 arithmetic)
+#endif
+
+const DWORD lookup3[] =
+{
+    0xffff0200, 0x0035fffe, 0x42415443, 0x0000001c, 0x0000009f, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x00000098, 0x00000058, 0x00000003,
+    0x00020001, 0x00000064, 0x00000000, 0x00000074, 0x00010003, 0x00060001,
+    0x00000064, 0x00000000, 0x00000080, 0x00000002, 0x00020001, 0x00000088,
+    0x00000000, 0x65736162, 0x67616d49, 0xabab0065, 0x000c0004, 0x00010001,
+    0x00000001, 0x00000000, 0x6b6f6f6c, 0x61547075, 0x00656c62, 0x7366666f,
+    0xab007465, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x325f7370,
+    0x4d00305f, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c,
+    0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934,
+    0x00313131, 0x05000051, 0xa00f0001, 0x3e000000, 0x3ec00000, 0x3f200000,
+    0x00000000, 0x0200001f, 0x80000000, 0xb0030000, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x03000042, 0x800f0000, 0xb0e40000, 0xa0e40800, 0x02000001,
+    0x80020001, 0xa0000001, 0x02000006, 0x80040001, 0x80ff0000, 0x04000004,
+    0x80070002, 0x80e40000, 0x80aa0001, 0xa1e40000, 0x02000001, 0x80010001,
+    0x80000002, 0x02000001, 0x80020003, 0xa0550001, 0x02000001, 0x80010003,
+    0x80550002, 0x02000001, 0x80010002, 0x80aa0002, 0x02000001, 0x80020002,
+    0xa0aa0001, 0x03000042, 0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042,
+    0x800f0003, 0x80e40003, 0xa0e40801, 0x03000042, 0x800f0002, 0x80e40002,
+    0xa0e40801, 0x02000001, 0x80020001, 0x80000003, 0x02000001, 0x80040001,
+    0x80000002, 0x03000005, 0x80070000, 0x80ff0000, 0x80e40001, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+const DWORD *lookupShaders[] =
+{
+    lookup0,
+    lookup1,
+    lookup2,
+    lookup3,
+};
+
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn grad0 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   float4 color1;
+//   float4 color2;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   params       c0       1
+//   color1       c1       1
+//   color2       c2       1
+//
+
+    ps_2_0
+    def c3, 1, -0.25, 0, 0
+    dcl t0.xy
+    dcl v0
+    mov r0.xy, t0
+    mov r0.z, c3.x
+    dp3 r0.x, c0, r0
+    add r0.x, r0.x, c3.y
+    add_sat r0.x, r0.x, r0.x
+    mov r1, c1
+    add r1, -r1, c2
+    mad r0, r0.x, r1, c1
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 10 instruction slots used
+#endif
+
+const DWORD grad0[] =
+{
+    0xffff0200, 0x0033fffe, 0x42415443, 0x0000001c, 0x00000097, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x00000090, 0x00000058, 0x00010002,
+    0x00060001, 0x00000060, 0x00000000, 0x00000070, 0x00020002, 0x000a0001,
+    0x00000060, 0x00000000, 0x00000077, 0x00000002, 0x00020001, 0x00000080,
+    0x00000000, 0x6f6c6f63, 0xab003172, 0x00030001, 0x00040001, 0x00000001,
+    0x00000000, 0x6f6c6f63, 0x70003272, 0x6d617261, 0xabab0073, 0x00030001,
+    0x00030001, 0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369,
+    0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320,
+    0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051,
+    0xa00f0003, 0x3f800000, 0xbe800000, 0x00000000, 0x00000000, 0x0200001f,
+    0x80000000, 0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x02000001,
+    0x80030000, 0xb0e40000, 0x02000001, 0x80040000, 0xa0000003, 0x03000008,
+    0x80010000, 0xa0e40000, 0x80e40000, 0x03000002, 0x80010000, 0x80000000,
+    0xa0550003, 0x03000002, 0x80110000, 0x80000000, 0x80000000, 0x02000001,
+    0x800f0001, 0xa0e40001, 0x03000002, 0x800f0001, 0x81e40001, 0xa0e40002,
+    0x04000004, 0x800f0000, 0x80000000, 0x80e40001, 0xa0e40001, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn grad1 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   float4 color1;
+//   float4 color2;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   params       c0       1
+//   color1       c1       1
+//   color2       c2       1
+//
+
+    ps_2_0
+    def c3, 1, -0.25, -0.5, 2
+    dcl t0.xy
+    dcl v0
+    mov r0.xy, t0
+    mov r0.z, c3.x
+    dp3 r0.x, c0, r0
+    add r0.x, r0.x, c3.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c3.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c3.w, c3.x
+    mov r1, c1
+    add r1, -r1, c2
+    mad r0, r0.x, r1, c1
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 13 instruction slots used
+#endif
+
+const DWORD grad1[] =
+{
+    0xffff0200, 0x0033fffe, 0x42415443, 0x0000001c, 0x00000097, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x00000090, 0x00000058, 0x00010002,
+    0x00060001, 0x00000060, 0x00000000, 0x00000070, 0x00020002, 0x000a0001,
+    0x00000060, 0x00000000, 0x00000077, 0x00000002, 0x00020001, 0x00000080,
+    0x00000000, 0x6f6c6f63, 0xab003172, 0x00030001, 0x00040001, 0x00000001,
+    0x00000000, 0x6f6c6f63, 0x70003272, 0x6d617261, 0xabab0073, 0x00030001,
+    0x00030001, 0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369,
+    0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320,
+    0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051,
+    0xa00f0003, 0x3f800000, 0xbe800000, 0xbf000000, 0x40000000, 0x0200001f,
+    0x80000000, 0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x02000001,
+    0x80030000, 0xb0e40000, 0x02000001, 0x80040000, 0xa0000003, 0x03000008,
+    0x80010000, 0xa0e40000, 0x80e40000, 0x03000002, 0x80010000, 0x80000000,
+    0xa0550003, 0x02000013, 0x80010000, 0x80000000, 0x03000002, 0x80010000,
+    0x80000000, 0xa0aa0003, 0x02000023, 0x80010000, 0x80000000, 0x04000004,
+    0x80010000, 0x80000000, 0xa1ff0003, 0xa0000003, 0x02000001, 0x800f0001,
+    0xa0e40001, 0x03000002, 0x800f0001, 0x81e40001, 0xa0e40002, 0x04000004,
+    0x800f0000, 0x80000000, 0x80e40001, 0xa0e40001, 0x03000005, 0x800f0000,
+    0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn grad2 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   float4 color1;
+//   float4 color2;
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   params       c0       1
+//   color1       c1       1
+//   color2       c2       1
+//   mask         s0       1
+//
+
+    ps_2_0
+    def c3, 1, -0.25, 0, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    texld r0, t0, s0
+    mov r0.xy, t1
+    mov r0.z, c3.x
+    dp3 r0.x, c0, r0
+    add r0.x, r0.x, c3.y
+    add_sat r0.x, r0.x, r0.x
+    mov r1, c1
+    add r1, -r1, c2
+    mad r1, r0.x, r1, c1
+    mul r0, r0.w, r1
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 12 instruction slots used (1 texture, 11 arithmetic)
+#endif
+
+const DWORD grad2[] =
+{
+    0xffff0200, 0x003dfffe, 0x42415443, 0x0000001c, 0x000000bf, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000b8, 0x0000006c, 0x00010002,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00020002, 0x000a0001,
+    0x00000074, 0x00000000, 0x0000008b, 0x00000003, 0x00020001, 0x00000090,
+    0x00000000, 0x000000a0, 0x00000002, 0x00020001, 0x000000a8, 0x00000000,
+    0x6f6c6f63, 0xab003172, 0x00030001, 0x00040001, 0x00000001, 0x00000000,
+    0x6f6c6f63, 0x6d003272, 0x006b7361, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001, 0x00000001,
+    0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73, 0x29522820,
+    0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072,
+    0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003, 0x3f800000,
+    0xbe800000, 0x00000000, 0x00000000, 0x0200001f, 0x80000000, 0xb0030000,
+    0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000, 0x900f0000,
+    0x0200001f, 0x90000000, 0xa00f0800, 0x03000042, 0x800f0000, 0xb0e40000,
+    0xa0e40800, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80010000, 0xa0e40000, 0x80e40000, 0x03000002,
+    0x80010000, 0x80000000, 0xa0550003, 0x03000002, 0x80110000, 0x80000000,
+    0x80000000, 0x02000001, 0x800f0001, 0xa0e40001, 0x03000002, 0x800f0001,
+    0x81e40001, 0xa0e40002, 0x04000004, 0x800f0001, 0x80000000, 0x80e40001,
+    0xa0e40001, 0x03000005, 0x800f0000, 0x80ff0000, 0x80e40001, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn grad3 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   float4 color1;
+//   float4 color2;
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   params       c0       1
+//   color1       c1       1
+//   color2       c2       1
+//   mask         s0       1
+//
+
+    ps_2_0
+    def c3, 1, -0.25, -0.5, 2
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    texld r0, t0, s0
+    mov r0.xy, t1
+    mov r0.z, c3.x
+    dp3 r0.x, c0, r0
+    add r0.x, r0.x, c3.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c3.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c3.w, c3.x
+    mov r1, c1
+    add r1, -r1, c2
+    mad r1, r0.x, r1, c1
+    mul r0, r0.w, r1
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 15 instruction slots used (1 texture, 14 arithmetic)
+#endif
+
+const DWORD grad3[] =
+{
+    0xffff0200, 0x003dfffe, 0x42415443, 0x0000001c, 0x000000bf, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000b8, 0x0000006c, 0x00010002,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00020002, 0x000a0001,
+    0x00000074, 0x00000000, 0x0000008b, 0x00000003, 0x00020001, 0x00000090,
+    0x00000000, 0x000000a0, 0x00000002, 0x00020001, 0x000000a8, 0x00000000,
+    0x6f6c6f63, 0xab003172, 0x00030001, 0x00040001, 0x00000001, 0x00000000,
+    0x6f6c6f63, 0x6d003272, 0x006b7361, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001, 0x00000001,
+    0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73, 0x29522820,
+    0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072,
+    0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003, 0x3f800000,
+    0xbe800000, 0xbf000000, 0x40000000, 0x0200001f, 0x80000000, 0xb0030000,
+    0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000, 0x900f0000,
+    0x0200001f, 0x90000000, 0xa00f0800, 0x03000042, 0x800f0000, 0xb0e40000,
+    0xa0e40800, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80010000, 0xa0e40000, 0x80e40000, 0x03000002,
+    0x80010000, 0x80000000, 0xa0550003, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0003, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0003, 0xa0000003,
+    0x02000001, 0x800f0001, 0xa0e40001, 0x03000002, 0x800f0001, 0x81e40001,
+    0xa0e40002, 0x04000004, 0x800f0001, 0x80000000, 0x80e40001, 0xa0e40001,
+    0x03000005, 0x800f0000, 0x80ff0000, 0x80e40001, 0x03000005, 0x800f0000,
+    0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+const DWORD *gradShaders[] =
+{
+    grad0,
+    grad1,
+    grad2,
+    grad3,
+};
+
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear0 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0, 0.5, -1
+    def c4, 1, 0.5, 0.0625, 0.03125
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.z, c3.x
+    mov r0.xy, t0
+    dp3 r0.x, c16, r0
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    frc r0.z, r0.y
+    add r0.y, r0.y, -r0.z
+    add r0.w, r0.y, c3.x
+    mad r1.x, r0.w, c4.z, c4.w
+    add r0.w, r0.x, c3.w
+    mad r2.x, r0.y, c4.z, c4.w
+    mov r2.y, c3.z
+    mov r1.y, c3.z
+    mov r3.xy, c4
+    mov r4.xy, c3.yzxw
+    texld r2, r2, s0
+    texld r1, r1, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    lrp r5, r0.z, r1, r2
+    cmp r1, r0.w, r3, r5
+    cmp r0, -r0.x, r4, r1
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 30 instruction slots used (4 texture, 26 arithmetic)
+#endif
+
+const DWORD linear0[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020003,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000004, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0004,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80040000, 0xa0000003, 0x02000001, 0x80030000,
+    0xb0e40000, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000002,
+    0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x02000013, 0x80040000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81aa0000, 0x03000002, 0x80080000, 0x80550000, 0xa0000003,
+    0x04000004, 0x80010001, 0x80ff0000, 0xa0aa0004, 0xa0ff0004, 0x03000002,
+    0x80080000, 0x80000000, 0xa0ff0003, 0x04000004, 0x80010002, 0x80550000,
+    0xa0aa0004, 0xa0ff0004, 0x02000001, 0x80020002, 0xa0aa0003, 0x02000001,
+    0x80020001, 0xa0aa0003, 0x02000001, 0x80030003, 0xa0e40004, 0x02000001,
+    0x80030004, 0xa0c90003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0003,
+    0x80e40003, 0xa0e40800, 0x03000042, 0x800f0004, 0x80e40004, 0xa0e40800,
+    0x04000012, 0x800f0005, 0x80aa0000, 0x80e40001, 0x80e40002, 0x04000058,
+    0x800f0001, 0x80ff0000, 0x80e40003, 0x80e40005, 0x04000058, 0x800f0000,
+    0x81000000, 0x80e40004, 0x80e40001, 0x03000005, 0x800f0000, 0x80e40000,
+    0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear1 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0.5, -0.5, 2
+    def c4, 0.0625, 0.03125, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c3.x
+    dp3 r0.x, c16, r0
+    mul r0.x, r0.x, c3.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c3.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c3.w, c3.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c4.x, c4.y
+    mad r2.x, r0.z, c4.x, c4.y
+    mov r2.y, c3.y
+    mov r1.y, c3.y
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 28 instruction slots used (2 texture, 26 arithmetic)
+#endif
+
+const DWORD linear1[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020003,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000004, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0004,
+    0x3d800000, 0x3d000000, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550003, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0003, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0003, 0xa0000003,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000002, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550002, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000003, 0x04000004, 0x80010001, 0x80000000, 0xa0000004, 0xa0550004,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000004, 0xa0550004, 0x02000001,
+    0x80020002, 0xa0550003, 0x02000001, 0x80020001, 0xa0550003, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40800, 0x04000012, 0x800f0003, 0x80550000, 0x80e40002, 0x80e40001,
+    0x03000005, 0x800f0000, 0x80e40003, 0x90e40000, 0x02000001, 0x800f0800,
+    0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear2 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0.0625, 0.03125, 0.5
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c3.x
+    dp3 r0.x, c16, r0
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c3.y, c3.z
+    mad r2.x, r0.z, c3.y, c3.z
+    mov r2.y, c3.w
+    mov r1.y, c3.w
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 24 instruction slots used (2 texture, 22 arithmetic)
+#endif
+
+const DWORD linear2[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020003,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000004, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000002, 0x80010000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550002,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000003, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550003, 0xa0aa0003, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550003,
+    0xa0aa0003, 0x02000001, 0x80020002, 0xa0ff0003, 0x02000001, 0x80020001,
+    0xa0ff0003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40800, 0x04000012, 0x800f0003, 0x80550000,
+    0x80e40002, 0x80e40001, 0x03000005, 0x800f0000, 0x80e40003, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear4 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0, 0.5, -1
+    def c8, 1, 0.5, 0.0625, 0.03125
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.z, c7.x
+    mov r0.xy, t0
+    dp3 r0.x, c16, r0
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c6.y
+    add r0.y, r0.y, r0.z
+    frc r0.z, r0.y
+    add r0.y, r0.y, -r0.z
+    add r0.w, r0.y, c7.x
+    mad r1.x, r0.w, c8.z, c8.w
+    add r0.w, r0.x, c7.w
+    mad r2.x, r0.y, c8.z, c8.w
+    mov r2.y, c7.z
+    mov r1.y, c7.z
+    mov r3.xy, c8
+    mov r4.xy, c7.yzxw
+    texld r2, r2, s0
+    texld r1, r1, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    lrp r5, r0.z, r1, r2
+    cmp r1, r0.w, r3, r5
+    cmp r0, -r0.x, r4, r1
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 42 instruction slots used (4 texture, 38 arithmetic)
+#endif
+
+const DWORD linear4[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020007,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000008, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0008,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80040000, 0xa0000007, 0x02000001, 0x80030000,
+    0xb0e40000, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000002,
+    0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000006, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550006, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x02000013, 0x80040000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81aa0000, 0x03000002, 0x80080000, 0x80550000, 0xa0000007,
+    0x04000004, 0x80010001, 0x80ff0000, 0xa0aa0008, 0xa0ff0008, 0x03000002,
+    0x80080000, 0x80000000, 0xa0ff0007, 0x04000004, 0x80010002, 0x80550000,
+    0xa0aa0008, 0xa0ff0008, 0x02000001, 0x80020002, 0xa0aa0007, 0x02000001,
+    0x80020001, 0xa0aa0007, 0x02000001, 0x80030003, 0xa0e40008, 0x02000001,
+    0x80030004, 0xa0c90007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0003,
+    0x80e40003, 0xa0e40800, 0x03000042, 0x800f0004, 0x80e40004, 0xa0e40800,
+    0x04000012, 0x800f0005, 0x80aa0000, 0x80e40001, 0x80e40002, 0x04000058,
+    0x800f0001, 0x80ff0000, 0x80e40003, 0x80e40005, 0x04000058, 0x800f0000,
+    0x81000000, 0x80e40004, 0x80e40001, 0x03000005, 0x800f0000, 0x80e40000,
+    0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear5 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0.5, -0.5, 2
+    def c8, 0.0625, 0.03125, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c7.x
+    dp3 r0.x, c16, r0
+    mul r0.x, r0.x, c7.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c7.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c7.w, c7.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c8.x, c8.y
+    mad r2.x, r0.z, c8.x, c8.y
+    mov r2.y, c7.y
+    mov r1.y, c7.y
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 40 instruction slots used (2 texture, 38 arithmetic)
+#endif
+
+const DWORD linear5[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020007,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000008, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0008,
+    0x3d800000, 0x3d000000, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550007, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0007, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0007, 0xa0000007,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000006, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550006, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000007, 0x04000004, 0x80010001, 0x80000000, 0xa0000008, 0xa0550008,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000008, 0xa0550008, 0x02000001,
+    0x80020002, 0xa0550007, 0x02000001, 0x80020001, 0xa0550007, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40800, 0x04000012, 0x800f0003, 0x80550000, 0x80e40002, 0x80e40001,
+    0x03000005, 0x800f0000, 0x80e40003, 0x90e40000, 0x02000001, 0x800f0800,
+    0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear6 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0.0625, 0.03125, 0.5
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c7.x
+    dp3 r0.x, c16, r0
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c7.y, c7.z
+    mad r2.x, r0.z, c7.y, c7.z
+    mov r2.y, c7.w
+    mov r1.y, c7.w
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 36 instruction slots used (2 texture, 34 arithmetic)
+#endif
+
+const DWORD linear6[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020007,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000008, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550001,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000002, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550002,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000003, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000004, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550004,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000005, 0x03000002, 0x80010000, 0x80000000, 0xa1000006,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550006,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000007, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550007, 0xa0aa0007, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550007,
+    0xa0aa0007, 0x02000001, 0x80020002, 0xa0ff0007, 0x02000001, 0x80020001,
+    0xa0ff0007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40800, 0x04000012, 0x800f0003, 0x80550000,
+    0x80e40002, 0x80e40001, 0x03000005, 0x800f0000, 0x80e40003, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear8 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0, 0.5, -1
+    def c4, 1, 0.5, 0.0625, 0.03125
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.z, c3.x
+    mov r0.xy, t1
+    dp3 r0.x, c16, r0
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    frc r0.z, r0.y
+    add r0.y, r0.y, -r0.z
+    add r0.w, r0.y, c3.x
+    mad r1.x, r0.w, c4.z, c4.w
+    add r0.w, r0.x, c3.w
+    mad r2.x, r0.y, c4.z, c4.w
+    mov r2.y, c3.z
+    mov r1.y, c3.z
+    mov r3.xy, c4
+    mov r4.xy, c3.yzxw
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, r3, s1
+    texld r4, r4, s1
+    texld r5, t0, s0
+    lrp r6, r0.z, r1, r2
+    cmp r1, r0.w, r3, r6
+    cmp r0, -r0.x, r4, r1
+    mul r0, r5.w, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 32 instruction slots used (5 texture, 27 arithmetic)
+#endif
+
+const DWORD linear8[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020003,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0004,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80040000, 0xa0000003, 0x02000001, 0x80030000,
+    0xb0e40001, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000002,
+    0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x02000013, 0x80040000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81aa0000, 0x03000002, 0x80080000, 0x80550000, 0xa0000003,
+    0x04000004, 0x80010001, 0x80ff0000, 0xa0aa0004, 0xa0ff0004, 0x03000002,
+    0x80080000, 0x80000000, 0xa0ff0003, 0x04000004, 0x80010002, 0x80550000,
+    0xa0aa0004, 0xa0ff0004, 0x02000001, 0x80020002, 0xa0aa0003, 0x02000001,
+    0x80020001, 0xa0aa0003, 0x02000001, 0x80030003, 0xa0e40004, 0x02000001,
+    0x80030004, 0xa0c90003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003,
+    0x80e40003, 0xa0e40801, 0x03000042, 0x800f0004, 0x80e40004, 0xa0e40801,
+    0x03000042, 0x800f0005, 0xb0e40000, 0xa0e40800, 0x04000012, 0x800f0006,
+    0x80aa0000, 0x80e40001, 0x80e40002, 0x04000058, 0x800f0001, 0x80ff0000,
+    0x80e40003, 0x80e40006, 0x04000058, 0x800f0000, 0x81000000, 0x80e40004,
+    0x80e40001, 0x03000005, 0x800f0000, 0x80ff0005, 0x80e40000, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear9 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0.5, -0.5, 2
+    def c4, 0.0625, 0.03125, 0, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c3.x
+    dp3 r0.x, c16, r0
+    mul r0.x, r0.x, c3.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c3.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c3.w, c3.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c4.x, c4.y
+    mad r2.x, r0.z, c4.x, c4.y
+    mov r2.y, c3.y
+    mov r1.y, c3.y
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 30 instruction slots used (3 texture, 27 arithmetic)
+#endif
+
+const DWORD linear9[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020003,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0004,
+    0x3d800000, 0x3d000000, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550003, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0003, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0003, 0xa0000003,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000002, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550002, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000003, 0x04000004, 0x80010001, 0x80000000, 0xa0000004, 0xa0550004,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000004, 0xa0550004, 0x02000001,
+    0x80020002, 0xa0550003, 0x02000001, 0x80020001, 0xa0550003, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000, 0xa0e40800, 0x04000012,
+    0x800f0004, 0x80550000, 0x80e40002, 0x80e40001, 0x03000005, 0x800f0000,
+    0x80ff0003, 0x80e40004, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear10 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0.0625, 0.03125, 0.5
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c3.x
+    dp3 r0.x, c16, r0
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c3.y, c3.z
+    mad r2.x, r0.z, c3.y, c3.z
+    mov r2.y, c3.w
+    mov r1.y, c3.w
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 26 instruction slots used (3 texture, 23 arithmetic)
+#endif
+
+const DWORD linear10[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020003,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000002, 0x80010000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550002,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000003, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550003, 0xa0aa0003, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550003,
+    0xa0aa0003, 0x02000001, 0x80020002, 0xa0ff0003, 0x02000001, 0x80020001,
+    0xa0ff0003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000,
+    0xa0e40800, 0x04000012, 0x800f0004, 0x80550000, 0x80e40002, 0x80e40001,
+    0x03000005, 0x800f0000, 0x80ff0003, 0x80e40004, 0x03000005, 0x800f0000,
+    0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear12 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0, 0.5, -1
+    def c8, 1, 0.5, 0.0625, 0.03125
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.z, c7.x
+    mov r0.xy, t1
+    dp3 r0.x, c16, r0
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c6.y
+    add r0.y, r0.y, r0.z
+    frc r0.z, r0.y
+    add r0.y, r0.y, -r0.z
+    add r0.w, r0.y, c7.x
+    mad r1.x, r0.w, c8.z, c8.w
+    add r0.w, r0.x, c7.w
+    mad r2.x, r0.y, c8.z, c8.w
+    mov r2.y, c7.z
+    mov r1.y, c7.z
+    mov r3.xy, c8
+    mov r4.xy, c7.yzxw
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, r3, s1
+    texld r4, r4, s1
+    texld r5, t0, s0
+    lrp r6, r0.z, r1, r2
+    cmp r1, r0.w, r3, r6
+    cmp r0, -r0.x, r4, r1
+    mul r0, r5.w, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 44 instruction slots used (5 texture, 39 arithmetic)
+#endif
+
+const DWORD linear12[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020007,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0008,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80040000, 0xa0000007, 0x02000001, 0x80030000,
+    0xb0e40001, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000002,
+    0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000006, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550006, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x02000013, 0x80040000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81aa0000, 0x03000002, 0x80080000, 0x80550000, 0xa0000007,
+    0x04000004, 0x80010001, 0x80ff0000, 0xa0aa0008, 0xa0ff0008, 0x03000002,
+    0x80080000, 0x80000000, 0xa0ff0007, 0x04000004, 0x80010002, 0x80550000,
+    0xa0aa0008, 0xa0ff0008, 0x02000001, 0x80020002, 0xa0aa0007, 0x02000001,
+    0x80020001, 0xa0aa0007, 0x02000001, 0x80030003, 0xa0e40008, 0x02000001,
+    0x80030004, 0xa0c90007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003,
+    0x80e40003, 0xa0e40801, 0x03000042, 0x800f0004, 0x80e40004, 0xa0e40801,
+    0x03000042, 0x800f0005, 0xb0e40000, 0xa0e40800, 0x04000012, 0x800f0006,
+    0x80aa0000, 0x80e40001, 0x80e40002, 0x04000058, 0x800f0001, 0x80ff0000,
+    0x80e40003, 0x80e40006, 0x04000058, 0x800f0000, 0x81000000, 0x80e40004,
+    0x80e40001, 0x03000005, 0x800f0000, 0x80ff0005, 0x80e40000, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear13 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0.5, -0.5, 2
+    def c8, 0.0625, 0.03125, 0, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c7.x
+    dp3 r0.x, c16, r0
+    mul r0.x, r0.x, c7.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c7.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c7.w, c7.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c8.x, c8.y
+    mad r2.x, r0.z, c8.x, c8.y
+    mov r2.y, c7.y
+    mov r1.y, c7.y
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 42 instruction slots used (3 texture, 39 arithmetic)
+#endif
+
+const DWORD linear13[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020007,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0008,
+    0x3d800000, 0x3d000000, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550007, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0007, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0007, 0xa0000007,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000006, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550006, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000007, 0x04000004, 0x80010001, 0x80000000, 0xa0000008, 0xa0550008,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000008, 0xa0550008, 0x02000001,
+    0x80020002, 0xa0550007, 0x02000001, 0x80020001, 0xa0550007, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000, 0xa0e40800, 0x04000012,
+    0x800f0004, 0x80550000, 0x80e40002, 0x80e40001, 0x03000005, 0x800f0000,
+    0x80ff0003, 0x80e40004, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear14 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0.0625, 0.03125, 0.5
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c7.x
+    dp3 r0.x, c16, r0
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c7.y, c7.z
+    mad r2.x, r0.z, c7.y, c7.z
+    mov r2.y, c7.w
+    mov r1.y, c7.w
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 38 instruction slots used (3 texture, 35 arithmetic)
+#endif
+
+const DWORD linear14[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020007,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550001,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000002, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550002,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000003, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000004, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550004,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000005, 0x03000002, 0x80010000, 0x80000000, 0xa1000006,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550006,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000007, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550007, 0xa0aa0007, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550007,
+    0xa0aa0007, 0x02000001, 0x80020002, 0xa0ff0007, 0x02000001, 0x80020001,
+    0xa0ff0007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000,
+    0xa0e40800, 0x04000012, 0x800f0004, 0x80550000, 0x80e40002, 0x80e40001,
+    0x03000005, 0x800f0000, 0x80ff0003, 0x80e40004, 0x03000005, 0x800f0000,
+    0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear16 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0, 0.5, -1
+    def c4, 1, 0.5, 0.0625, 0.03125
+    def c5, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.z, c3.x
+    mov r0.xy, t0
+    dp3 r0.x, c16, r0
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    frc r0.z, r0.y
+    add r0.y, r0.y, -r0.z
+    add r0.w, r0.y, c3.x
+    mad r1.x, r0.w, c4.z, c4.w
+    add r0.w, r0.x, c3.w
+    mad r2.x, r0.y, c4.z, c4.w
+    mov r2.y, c3.z
+    mov r1.y, c3.z
+    mov r3.xy, c4
+    mov r4.xy, c3.yzxw
+    texld r2, r2, s0
+    texld r1, r1, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    lrp r5, r0.z, r1, r2
+    cmp r1, r0.w, r3, r5
+    cmp r0, -r0.x, r4, r1
+    log r1.x, r0.x
+    log r1.y, r0.y
+    log r1.z, r0.z
+    mul r1.xyz, r1, c5.x
+    exp r2.x, r1.x
+    exp r2.y, r1.y
+    exp r2.z, r1.z
+    mad r0.xyz, r2, c5.y, c5.z
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 38 instruction slots used (4 texture, 34 arithmetic)
+#endif
+
+const DWORD linear16[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020003,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000004, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0004,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x05000051, 0xa00f0005,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80040000, 0xa0000003, 0x02000001, 0x80030000,
+    0xb0e40000, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000002,
+    0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x02000013, 0x80040000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81aa0000, 0x03000002, 0x80080000, 0x80550000, 0xa0000003,
+    0x04000004, 0x80010001, 0x80ff0000, 0xa0aa0004, 0xa0ff0004, 0x03000002,
+    0x80080000, 0x80000000, 0xa0ff0003, 0x04000004, 0x80010002, 0x80550000,
+    0xa0aa0004, 0xa0ff0004, 0x02000001, 0x80020002, 0xa0aa0003, 0x02000001,
+    0x80020001, 0xa0aa0003, 0x02000001, 0x80030003, 0xa0e40004, 0x02000001,
+    0x80030004, 0xa0c90003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0003,
+    0x80e40003, 0xa0e40800, 0x03000042, 0x800f0004, 0x80e40004, 0xa0e40800,
+    0x04000012, 0x800f0005, 0x80aa0000, 0x80e40001, 0x80e40002, 0x04000058,
+    0x800f0001, 0x80ff0000, 0x80e40003, 0x80e40005, 0x04000058, 0x800f0000,
+    0x81000000, 0x80e40004, 0x80e40001, 0x0200000f, 0x80010001, 0x80000000,
+    0x0200000f, 0x80020001, 0x80550000, 0x0200000f, 0x80040001, 0x80aa0000,
+    0x03000005, 0x80070001, 0x80e40001, 0xa0000005, 0x0200000e, 0x80010002,
+    0x80000001, 0x0200000e, 0x80020002, 0x80550001, 0x0200000e, 0x80040002,
+    0x80aa0001, 0x04000004, 0x80070000, 0x80e40002, 0xa0550005, 0xa0aa0005,
+    0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800,
+    0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear17 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0.5, -0.5, 2
+    def c4, 0.0625, 0.03125, 0.416667014, 0
+    def c5, 1.05499995, -0.0549999997, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c3.x
+    dp3 r0.x, c16, r0
+    mul r0.x, r0.x, c3.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c3.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c3.w, c3.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c4.x, c4.y
+    mad r2.x, r0.z, c4.x, c4.y
+    mov r2.y, c3.y
+    mov r1.y, c3.y
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    log r0.x, r3.x
+    log r0.y, r3.y
+    log r0.z, r3.z
+    mul r0.xyz, r0, c4.z
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r3.xyz, r1, c5.x, c5.y
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 36 instruction slots used (2 texture, 34 arithmetic)
+#endif
+
+const DWORD linear17[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020003,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000004, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0004,
+    0x3d800000, 0x3d000000, 0x3ed55561, 0x00000000, 0x05000051, 0xa00f0005,
+    0x3f870a3d, 0xbd6147ae, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550003, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0003, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0003, 0xa0000003,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000002, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550002, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000003, 0x04000004, 0x80010001, 0x80000000, 0xa0000004, 0xa0550004,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000004, 0xa0550004, 0x02000001,
+    0x80020002, 0xa0550003, 0x02000001, 0x80020001, 0xa0550003, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40800, 0x04000012, 0x800f0003, 0x80550000, 0x80e40002, 0x80e40001,
+    0x0200000f, 0x80010000, 0x80000003, 0x0200000f, 0x80020000, 0x80550003,
+    0x0200000f, 0x80040000, 0x80aa0003, 0x03000005, 0x80070000, 0x80e40000,
+    0xa0aa0004, 0x0200000e, 0x80010001, 0x80000000, 0x0200000e, 0x80020001,
+    0x80550000, 0x0200000e, 0x80040001, 0x80aa0000, 0x04000004, 0x80070003,
+    0x80e40001, 0xa0000005, 0xa0550005, 0x03000005, 0x800f0000, 0x80e40003,
+    0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear18 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0.0625, 0.03125, 0.5
+    def c4, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c3.x
+    dp3 r0.x, c16, r0
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c3.y, c3.z
+    mad r2.x, r0.z, c3.y, c3.z
+    mov r2.y, c3.w
+    mov r1.y, c3.w
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    log r0.x, r3.x
+    log r0.y, r3.y
+    log r0.z, r3.z
+    mul r0.xyz, r0, c4.x
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r3.xyz, r1, c4.y, c4.z
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 32 instruction slots used (2 texture, 30 arithmetic)
+#endif
+
+const DWORD linear18[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020003,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000004, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x05000051, 0xa00f0004,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000002, 0x80010000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550002,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000003, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550003, 0xa0aa0003, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550003,
+    0xa0aa0003, 0x02000001, 0x80020002, 0xa0ff0003, 0x02000001, 0x80020001,
+    0xa0ff0003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40800, 0x04000012, 0x800f0003, 0x80550000,
+    0x80e40002, 0x80e40001, 0x0200000f, 0x80010000, 0x80000003, 0x0200000f,
+    0x80020000, 0x80550003, 0x0200000f, 0x80040000, 0x80aa0003, 0x03000005,
+    0x80070000, 0x80e40000, 0xa0000004, 0x0200000e, 0x80010001, 0x80000000,
+    0x0200000e, 0x80020001, 0x80550000, 0x0200000e, 0x80040001, 0x80aa0000,
+    0x04000004, 0x80070003, 0x80e40001, 0xa0550004, 0xa0aa0004, 0x03000005,
+    0x800f0000, 0x80e40003, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear20 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0, 0.5, -1
+    def c8, 1, 0.5, 0.0625, 0.03125
+    def c9, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.z, c7.x
+    mov r0.xy, t0
+    dp3 r0.x, c16, r0
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c6.y
+    add r0.y, r0.y, r0.z
+    frc r0.z, r0.y
+    add r0.y, r0.y, -r0.z
+    add r0.w, r0.y, c7.x
+    mad r1.x, r0.w, c8.z, c8.w
+    add r0.w, r0.x, c7.w
+    mad r2.x, r0.y, c8.z, c8.w
+    mov r2.y, c7.z
+    mov r1.y, c7.z
+    mov r3.xy, c8
+    mov r4.xy, c7.yzxw
+    texld r2, r2, s0
+    texld r1, r1, s0
+    texld r3, r3, s0
+    texld r4, r4, s0
+    lrp r5, r0.z, r1, r2
+    cmp r1, r0.w, r3, r5
+    cmp r0, -r0.x, r4, r1
+    log r1.x, r0.x
+    log r1.y, r0.y
+    log r1.z, r0.z
+    mul r1.xyz, r1, c9.x
+    exp r2.x, r1.x
+    exp r2.y, r1.y
+    exp r2.z, r1.z
+    mad r0.xyz, r2, c9.y, c9.z
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 50 instruction slots used (4 texture, 46 arithmetic)
+#endif
+
+const DWORD linear20[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020007,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000008, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0008,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x05000051, 0xa00f0009,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80040000, 0xa0000007, 0x02000001, 0x80030000,
+    0xb0e40000, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000002,
+    0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000006, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550006, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x02000013, 0x80040000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81aa0000, 0x03000002, 0x80080000, 0x80550000, 0xa0000007,
+    0x04000004, 0x80010001, 0x80ff0000, 0xa0aa0008, 0xa0ff0008, 0x03000002,
+    0x80080000, 0x80000000, 0xa0ff0007, 0x04000004, 0x80010002, 0x80550000,
+    0xa0aa0008, 0xa0ff0008, 0x02000001, 0x80020002, 0xa0aa0007, 0x02000001,
+    0x80020001, 0xa0aa0007, 0x02000001, 0x80030003, 0xa0e40008, 0x02000001,
+    0x80030004, 0xa0c90007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0003,
+    0x80e40003, 0xa0e40800, 0x03000042, 0x800f0004, 0x80e40004, 0xa0e40800,
+    0x04000012, 0x800f0005, 0x80aa0000, 0x80e40001, 0x80e40002, 0x04000058,
+    0x800f0001, 0x80ff0000, 0x80e40003, 0x80e40005, 0x04000058, 0x800f0000,
+    0x81000000, 0x80e40004, 0x80e40001, 0x0200000f, 0x80010001, 0x80000000,
+    0x0200000f, 0x80020001, 0x80550000, 0x0200000f, 0x80040001, 0x80aa0000,
+    0x03000005, 0x80070001, 0x80e40001, 0xa0000009, 0x0200000e, 0x80010002,
+    0x80000001, 0x0200000e, 0x80020002, 0x80550001, 0x0200000e, 0x80040002,
+    0x80aa0001, 0x04000004, 0x80070000, 0x80e40002, 0xa0550009, 0xa0aa0009,
+    0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800,
+    0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear21 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0.5, -0.5, 2
+    def c8, 0.0625, 0.03125, 0.416667014, 0
+    def c9, 1.05499995, -0.0549999997, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c7.x
+    dp3 r0.x, c16, r0
+    mul r0.x, r0.x, c7.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c7.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c7.w, c7.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c8.x, c8.y
+    mad r2.x, r0.z, c8.x, c8.y
+    mov r2.y, c7.y
+    mov r1.y, c7.y
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    log r0.x, r3.x
+    log r0.y, r3.y
+    log r0.z, r3.z
+    mul r0.xyz, r0, c8.z
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r3.xyz, r1, c9.x, c9.y
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 48 instruction slots used (2 texture, 46 arithmetic)
+#endif
+
+const DWORD linear21[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020007,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000008, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0008,
+    0x3d800000, 0x3d000000, 0x3ed55561, 0x00000000, 0x05000051, 0xa00f0009,
+    0x3f870a3d, 0xbd6147ae, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550007, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0007, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0007, 0xa0000007,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000006, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550006, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000007, 0x04000004, 0x80010001, 0x80000000, 0xa0000008, 0xa0550008,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000008, 0xa0550008, 0x02000001,
+    0x80020002, 0xa0550007, 0x02000001, 0x80020001, 0xa0550007, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40800, 0x04000012, 0x800f0003, 0x80550000, 0x80e40002, 0x80e40001,
+    0x0200000f, 0x80010000, 0x80000003, 0x0200000f, 0x80020000, 0x80550003,
+    0x0200000f, 0x80040000, 0x80aa0003, 0x03000005, 0x80070000, 0x80e40000,
+    0xa0aa0008, 0x0200000e, 0x80010001, 0x80000000, 0x0200000e, 0x80020001,
+    0x80550000, 0x0200000e, 0x80040001, 0x80aa0000, 0x04000004, 0x80070003,
+    0x80e40001, 0xa0000009, 0xa0550009, 0x03000005, 0x800f0000, 0x80e40003,
+    0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear22 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0.0625, 0.03125, 0.5
+    def c8, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c7.x
+    dp3 r0.x, c16, r0
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c7.y, c7.z
+    mad r2.x, r0.z, c7.y, c7.z
+    mov r2.y, c7.w
+    mov r1.y, c7.w
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    log r0.x, r3.x
+    log r0.y, r3.y
+    log r0.z, r3.z
+    mul r0.xyz, r0, c8.x
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r3.xyz, r1, c8.y, c8.z
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 44 instruction slots used (2 texture, 42 arithmetic)
+#endif
+
+const DWORD linear22[] =
+{
+    0xffff0200, 0x0038fffe, 0x42415443, 0x0000001c, 0x000000ab, 0xffff0200,
+    0x00000003, 0x0000001c, 0x20000100, 0x000000a4, 0x00000058, 0x00000003,
+    0x00020001, 0x00000060, 0x00000000, 0x00000070, 0x00000002, 0x00020007,
+    0x0000007c, 0x00000000, 0x0000008c, 0x00100002, 0x00420001, 0x00000094,
+    0x00000000, 0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001,
+    0x00000000, 0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001,
+    0x00000008, 0x00000000, 0x61726170, 0xab00736d, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x05000051, 0xa00f0008,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550001,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000002, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550002,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000003, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000004, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550004,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000005, 0x03000002, 0x80010000, 0x80000000, 0xa1000006,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550006,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000007, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550007, 0xa0aa0007, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550007,
+    0xa0aa0007, 0x02000001, 0x80020002, 0xa0ff0007, 0x02000001, 0x80020001,
+    0xa0ff0007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40800, 0x04000012, 0x800f0003, 0x80550000,
+    0x80e40002, 0x80e40001, 0x0200000f, 0x80010000, 0x80000003, 0x0200000f,
+    0x80020000, 0x80550003, 0x0200000f, 0x80040000, 0x80aa0003, 0x03000005,
+    0x80070000, 0x80e40000, 0xa0000008, 0x0200000e, 0x80010001, 0x80000000,
+    0x0200000e, 0x80020001, 0x80550000, 0x0200000e, 0x80040001, 0x80aa0000,
+    0x04000004, 0x80070003, 0x80e40001, 0xa0550008, 0xa0aa0008, 0x03000005,
+    0x800f0000, 0x80e40003, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear24 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0, 0.5, -1
+    def c4, 1, 0.5, 0.0625, 0.03125
+    def c5, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.z, c3.x
+    mov r0.xy, t1
+    dp3 r0.x, c16, r0
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    frc r0.z, r0.y
+    add r0.y, r0.y, -r0.z
+    add r0.w, r0.y, c3.x
+    mad r1.x, r0.w, c4.z, c4.w
+    add r0.w, r0.x, c3.w
+    mad r2.x, r0.y, c4.z, c4.w
+    mov r2.y, c3.z
+    mov r1.y, c3.z
+    mov r3.xy, c4
+    mov r4.xy, c3.yzxw
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, r3, s1
+    texld r4, r4, s1
+    texld r5, t0, s0
+    lrp r6, r0.z, r1, r2
+    cmp r1, r0.w, r3, r6
+    cmp r0, -r0.x, r4, r1
+    log r1.x, r0.x
+    log r1.y, r0.y
+    log r1.z, r0.z
+    mul r1.xyz, r1, c5.x
+    exp r2.x, r1.x
+    exp r2.y, r1.y
+    exp r2.z, r1.z
+    mad r0.xyz, r2, c5.y, c5.z
+    mul r0, r5.w, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 40 instruction slots used (5 texture, 35 arithmetic)
+#endif
+
+const DWORD linear24[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020003,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0004,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x05000051, 0xa00f0005,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80040000, 0xa0000003, 0x02000001, 0x80030000,
+    0xb0e40001, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000002,
+    0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x02000013, 0x80040000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81aa0000, 0x03000002, 0x80080000, 0x80550000, 0xa0000003,
+    0x04000004, 0x80010001, 0x80ff0000, 0xa0aa0004, 0xa0ff0004, 0x03000002,
+    0x80080000, 0x80000000, 0xa0ff0003, 0x04000004, 0x80010002, 0x80550000,
+    0xa0aa0004, 0xa0ff0004, 0x02000001, 0x80020002, 0xa0aa0003, 0x02000001,
+    0x80020001, 0xa0aa0003, 0x02000001, 0x80030003, 0xa0e40004, 0x02000001,
+    0x80030004, 0xa0c90003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003,
+    0x80e40003, 0xa0e40801, 0x03000042, 0x800f0004, 0x80e40004, 0xa0e40801,
+    0x03000042, 0x800f0005, 0xb0e40000, 0xa0e40800, 0x04000012, 0x800f0006,
+    0x80aa0000, 0x80e40001, 0x80e40002, 0x04000058, 0x800f0001, 0x80ff0000,
+    0x80e40003, 0x80e40006, 0x04000058, 0x800f0000, 0x81000000, 0x80e40004,
+    0x80e40001, 0x0200000f, 0x80010001, 0x80000000, 0x0200000f, 0x80020001,
+    0x80550000, 0x0200000f, 0x80040001, 0x80aa0000, 0x03000005, 0x80070001,
+    0x80e40001, 0xa0000005, 0x0200000e, 0x80010002, 0x80000001, 0x0200000e,
+    0x80020002, 0x80550001, 0x0200000e, 0x80040002, 0x80aa0001, 0x04000004,
+    0x80070000, 0x80e40002, 0xa0550005, 0xa0aa0005, 0x03000005, 0x800f0000,
+    0x80ff0005, 0x80e40000, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear25 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0.5, -0.5, 2
+    def c4, 0.0625, 0.03125, 0.416667014, 0
+    def c5, 1.05499995, -0.0549999997, 0, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c3.x
+    dp3 r0.x, c16, r0
+    mul r0.x, r0.x, c3.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c3.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c3.w, c3.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c4.x, c4.y
+    mad r2.x, r0.z, c4.x, c4.y
+    mov r2.y, c3.y
+    mov r1.y, c3.y
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    log r0.x, r4.x
+    log r0.y, r4.y
+    log r0.z, r4.z
+    mul r0.xyz, r0, c4.z
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r4.xyz, r1, c5.x, c5.y
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 38 instruction slots used (3 texture, 35 arithmetic)
+#endif
+
+const DWORD linear25[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020003,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0004,
+    0x3d800000, 0x3d000000, 0x3ed55561, 0x00000000, 0x05000051, 0xa00f0005,
+    0x3f870a3d, 0xbd6147ae, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550003, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0003, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0003, 0xa0000003,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000002, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550002, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000003, 0x04000004, 0x80010001, 0x80000000, 0xa0000004, 0xa0550004,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000004, 0xa0550004, 0x02000001,
+    0x80020002, 0xa0550003, 0x02000001, 0x80020001, 0xa0550003, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000, 0xa0e40800, 0x04000012,
+    0x800f0004, 0x80550000, 0x80e40002, 0x80e40001, 0x0200000f, 0x80010000,
+    0x80000004, 0x0200000f, 0x80020000, 0x80550004, 0x0200000f, 0x80040000,
+    0x80aa0004, 0x03000005, 0x80070000, 0x80e40000, 0xa0aa0004, 0x0200000e,
+    0x80010001, 0x80000000, 0x0200000e, 0x80020001, 0x80550000, 0x0200000e,
+    0x80040001, 0x80aa0000, 0x04000004, 0x80070004, 0x80e40001, 0xa0000005,
+    0xa0550005, 0x03000005, 0x800f0000, 0x80ff0003, 0x80e40004, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear26 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0.0625, 0.03125, 0.5
+    def c4, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c3.x
+    dp3 r0.x, c16, r0
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c3.y, c3.z
+    mad r2.x, r0.z, c3.y, c3.z
+    mov r2.y, c3.w
+    mov r1.y, c3.w
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    log r0.x, r4.x
+    log r0.y, r4.y
+    log r0.z, r4.z
+    mul r0.xyz, r0, c4.x
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r4.xyz, r1, c4.y, c4.z
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 34 instruction slots used (3 texture, 31 arithmetic)
+#endif
+
+const DWORD linear26[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020003,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x05000051, 0xa00f0004,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000002, 0x80010000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550002,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000003, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550003, 0xa0aa0003, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550003,
+    0xa0aa0003, 0x02000001, 0x80020002, 0xa0ff0003, 0x02000001, 0x80020001,
+    0xa0ff0003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000,
+    0xa0e40800, 0x04000012, 0x800f0004, 0x80550000, 0x80e40002, 0x80e40001,
+    0x0200000f, 0x80010000, 0x80000004, 0x0200000f, 0x80020000, 0x80550004,
+    0x0200000f, 0x80040000, 0x80aa0004, 0x03000005, 0x80070000, 0x80e40000,
+    0xa0000004, 0x0200000e, 0x80010001, 0x80000000, 0x0200000e, 0x80020001,
+    0x80550000, 0x0200000e, 0x80040001, 0x80aa0000, 0x04000004, 0x80070004,
+    0x80e40001, 0xa0550004, 0xa0aa0004, 0x03000005, 0x800f0000, 0x80ff0003,
+    0x80e40004, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x02000001,
+    0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear28 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0, 0.5, -1
+    def c8, 1, 0.5, 0.0625, 0.03125
+    def c9, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.z, c7.x
+    mov r0.xy, t1
+    dp3 r0.x, c16, r0
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c6.y
+    add r0.y, r0.y, r0.z
+    frc r0.z, r0.y
+    add r0.y, r0.y, -r0.z
+    add r0.w, r0.y, c7.x
+    mad r1.x, r0.w, c8.z, c8.w
+    add r0.w, r0.x, c7.w
+    mad r2.x, r0.y, c8.z, c8.w
+    mov r2.y, c7.z
+    mov r1.y, c7.z
+    mov r3.xy, c8
+    mov r4.xy, c7.yzxw
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, r3, s1
+    texld r4, r4, s1
+    texld r5, t0, s0
+    lrp r6, r0.z, r1, r2
+    cmp r1, r0.w, r3, r6
+    cmp r0, -r0.x, r4, r1
+    log r1.x, r0.x
+    log r1.y, r0.y
+    log r1.z, r0.z
+    mul r1.xyz, r1, c9.x
+    exp r2.x, r1.x
+    exp r2.y, r1.y
+    exp r2.z, r1.z
+    mad r0.xyz, r2, c9.y, c9.z
+    mul r0, r5.w, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 52 instruction slots used (5 texture, 47 arithmetic)
+#endif
+
+const DWORD linear28[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020007,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0008,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x05000051, 0xa00f0009,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80040000, 0xa0000007, 0x02000001, 0x80030000,
+    0xb0e40001, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000002,
+    0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000006, 0x03000005,
+    0x80140000, 0x80aa0000, 0xa0550006, 0x03000002, 0x80020000, 0x80550000,
+    0x80aa0000, 0x02000013, 0x80040000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81aa0000, 0x03000002, 0x80080000, 0x80550000, 0xa0000007,
+    0x04000004, 0x80010001, 0x80ff0000, 0xa0aa0008, 0xa0ff0008, 0x03000002,
+    0x80080000, 0x80000000, 0xa0ff0007, 0x04000004, 0x80010002, 0x80550000,
+    0xa0aa0008, 0xa0ff0008, 0x02000001, 0x80020002, 0xa0aa0007, 0x02000001,
+    0x80020001, 0xa0aa0007, 0x02000001, 0x80030003, 0xa0e40008, 0x02000001,
+    0x80030004, 0xa0c90007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801,
+    0x03000042, 0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003,
+    0x80e40003, 0xa0e40801, 0x03000042, 0x800f0004, 0x80e40004, 0xa0e40801,
+    0x03000042, 0x800f0005, 0xb0e40000, 0xa0e40800, 0x04000012, 0x800f0006,
+    0x80aa0000, 0x80e40001, 0x80e40002, 0x04000058, 0x800f0001, 0x80ff0000,
+    0x80e40003, 0x80e40006, 0x04000058, 0x800f0000, 0x81000000, 0x80e40004,
+    0x80e40001, 0x0200000f, 0x80010001, 0x80000000, 0x0200000f, 0x80020001,
+    0x80550000, 0x0200000f, 0x80040001, 0x80aa0000, 0x03000005, 0x80070001,
+    0x80e40001, 0xa0000009, 0x0200000e, 0x80010002, 0x80000001, 0x0200000e,
+    0x80020002, 0x80550001, 0x0200000e, 0x80040002, 0x80aa0001, 0x04000004,
+    0x80070000, 0x80e40002, 0xa0550009, 0xa0aa0009, 0x03000005, 0x800f0000,
+    0x80ff0005, 0x80e40000, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear29 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0.5, -0.5, 2
+    def c8, 0.0625, 0.03125, 0.416667014, 0
+    def c9, 1.05499995, -0.0549999997, 0, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c7.x
+    dp3 r0.x, c16, r0
+    mul r0.x, r0.x, c7.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c7.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c7.w, c7.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c8.x, c8.y
+    mad r2.x, r0.z, c8.x, c8.y
+    mov r2.y, c7.y
+    mov r1.y, c7.y
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    log r0.x, r4.x
+    log r0.y, r4.y
+    log r0.z, r4.z
+    mul r0.xyz, r0, c8.z
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r4.xyz, r1, c9.x, c9.y
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 50 instruction slots used (3 texture, 47 arithmetic)
+#endif
+
+const DWORD linear29[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020007,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0008,
+    0x3d800000, 0x3d000000, 0x3ed55561, 0x00000000, 0x05000051, 0xa00f0009,
+    0x3f870a3d, 0xbd6147ae, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550007, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0007, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0007, 0xa0000007,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000006, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550006, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000007, 0x04000004, 0x80010001, 0x80000000, 0xa0000008, 0xa0550008,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000008, 0xa0550008, 0x02000001,
+    0x80020002, 0xa0550007, 0x02000001, 0x80020001, 0xa0550007, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000, 0xa0e40800, 0x04000012,
+    0x800f0004, 0x80550000, 0x80e40002, 0x80e40001, 0x0200000f, 0x80010000,
+    0x80000004, 0x0200000f, 0x80020000, 0x80550004, 0x0200000f, 0x80040000,
+    0x80aa0004, 0x03000005, 0x80070000, 0x80e40000, 0xa0aa0008, 0x0200000e,
+    0x80010001, 0x80000000, 0x0200000e, 0x80020001, 0x80550000, 0x0200000e,
+    0x80040001, 0x80aa0000, 0x04000004, 0x80070004, 0x80e40001, 0xa0000009,
+    0xa0550009, 0x03000005, 0x800f0000, 0x80ff0003, 0x80e40004, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn linear30 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   sampler2D mask;
+//   float3 params;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   params       c16      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0.0625, 0.03125, 0.5
+    def c8, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c7.x
+    dp3 r0.x, c16, r0
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c7.y, c7.z
+    mad r2.x, r0.z, c7.y, c7.z
+    mov r2.y, c7.w
+    mov r1.y, c7.w
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    log r0.x, r4.x
+    log r0.y, r4.y
+    log r0.z, r4.z
+    mul r0.xyz, r0, c8.x
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r4.xyz, r1, c8.y, c8.z
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 46 instruction slots used (3 texture, 43 arithmetic)
+#endif
+
+const DWORD linear30[] =
+{
+    0xffff0200, 0x003efffe, 0x42415443, 0x0000001c, 0x000000c3, 0xffff0200,
+    0x00000004, 0x0000001c, 0x20000100, 0x000000bc, 0x0000006c, 0x00010003,
+    0x00060001, 0x00000074, 0x00000000, 0x00000084, 0x00000002, 0x00020007,
+    0x00000090, 0x00000000, 0x000000a0, 0x00000003, 0x00020001, 0x00000074,
+    0x00000000, 0x000000a5, 0x00100002, 0x00420001, 0x000000ac, 0x00000000,
+    0x6f6c6f63, 0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000,
+    0x63617266, 0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008,
+    0x00000000, 0x6b73616d, 0x72617000, 0x00736d61, 0x00030001, 0x00030001,
+    0x00000001, 0x00000000, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x05000051, 0xa00f0008,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80010000, 0xa0e40010, 0x80e40000, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550001,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000002, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550002,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000003, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000004, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550004,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000005, 0x03000002, 0x80010000, 0x80000000, 0xa1000006,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550006,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000007, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550007, 0xa0aa0007, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550007,
+    0xa0aa0007, 0x02000001, 0x80020002, 0xa0ff0007, 0x02000001, 0x80020001,
+    0xa0ff0007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000,
+    0xa0e40800, 0x04000012, 0x800f0004, 0x80550000, 0x80e40002, 0x80e40001,
+    0x0200000f, 0x80010000, 0x80000004, 0x0200000f, 0x80020000, 0x80550004,
+    0x0200000f, 0x80040000, 0x80aa0004, 0x03000005, 0x80070000, 0x80e40000,
+    0xa0000008, 0x0200000e, 0x80010001, 0x80000000, 0x0200000e, 0x80020001,
+    0x80550000, 0x0200000e, 0x80040001, 0x80aa0000, 0x04000004, 0x80070004,
+    0x80e40001, 0xa0550008, 0xa0aa0008, 0x03000005, 0x800f0000, 0x80ff0003,
+    0x80e40004, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x02000001,
+    0x800f0800, 0x80e40000, 0x0000ffff
+};
+const DWORD *linearShaders[] =
+{
+    linear0,
+    linear1,
+    linear2,
+    NULL,
+    linear4,
+    linear5,
+    linear6,
+    NULL,
+    linear8,
+    linear9,
+    linear10,
+    NULL,
+    linear12,
+    linear13,
+    linear14,
+    NULL,
+    linear16,
+    linear17,
+    linear18,
+    NULL,
+    linear20,
+    linear21,
+    linear22,
+    NULL,
+    linear24,
+    linear25,
+    linear26,
+    NULL,
+    linear28,
+    linear29,
+    linear30,
+    NULL,
+};
+
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial0 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0, 0.5, -1
+    def c4, 1, 0.5, 0.0625, 0.03125
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.z, c3.x
+    mov r0.xy, t0
+    dp3 r0.w, r0, c17
+    mul r0.w, r0.w, r0.w
+    mul r0.w, r0.w, c18.y
+    dp3 r0.x, r0, c16
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.w
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mov r0.z, c18.z
+    mad r0.y, r0.x, r0.z, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    mad r0.w, r0.x, r0.z, -c1.x
+    mul_sat r0.w, r0.w, c1.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c2.x
+    mul_sat r0.w, r0.w, c2.y
+    add r0.y, r0.y, r0.w
+    frc r0.w, r0.y
+    add r0.y, r0.y, -r0.w
+    add r1.w, r0.y, c3.x
+    mad r1.x, r1.w, c4.z, c4.w
+    mul r1.z, r0.x, c18.z
+    mad r1.w, r0.x, r0.z, c3.w
+    mad r0.x, r0.y, c4.z, c4.w
+    mov r0.y, c3.z
+    mov r1.y, c3.z
+    mov r2.xy, c4
+    mov r3.xy, c3.yzxw
+    texld r4, r0, s0
+    texld r5, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    lrp r6, r0.w, r5, r4
+    cmp r0, r1.w, r2, r6
+    cmp r0, -r1.z, r3, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 40 instruction slots used (4 texture, 36 arithmetic)
+#endif
+
+const DWORD radial0[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020003,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0004,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80040000, 0xa0000003, 0x02000001, 0x80030000,
+    0xb0e40000, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000005,
+    0x80080000, 0x80ff0000, 0x80ff0000, 0x03000005, 0x80080000, 0x80ff0000,
+    0xa0550012, 0x03000008, 0x80010000, 0x80e40000, 0xa0e40010, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80ff0000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x02000001, 0x80040000, 0xa0aa0012, 0x04000004, 0x80020000,
+    0x80000000, 0x80aa0000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000001,
+    0x03000005, 0x80180000, 0x80ff0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000,
+    0xa1000002, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550002, 0x03000002,
+    0x80020000, 0x80550000, 0x80ff0000, 0x02000013, 0x80080000, 0x80550000,
+    0x03000002, 0x80020000, 0x80550000, 0x81ff0000, 0x03000002, 0x80080001,
+    0x80550000, 0xa0000003, 0x04000004, 0x80010001, 0x80ff0001, 0xa0aa0004,
+    0xa0ff0004, 0x03000005, 0x80040001, 0x80000000, 0xa0aa0012, 0x04000004,
+    0x80080001, 0x80000000, 0x80aa0000, 0xa0ff0003, 0x04000004, 0x80010000,
+    0x80550000, 0xa0aa0004, 0xa0ff0004, 0x02000001, 0x80020000, 0xa0aa0003,
+    0x02000001, 0x80020001, 0xa0aa0003, 0x02000001, 0x80030002, 0xa0e40004,
+    0x02000001, 0x80030003, 0xa0c90003, 0x03000042, 0x800f0004, 0x80e40000,
+    0xa0e40800, 0x03000042, 0x800f0005, 0x80e40001, 0xa0e40800, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042, 0x800f0003, 0x80e40003,
+    0xa0e40800, 0x04000012, 0x800f0006, 0x80ff0000, 0x80e40005, 0x80e40004,
+    0x04000058, 0x800f0000, 0x80ff0001, 0x80e40002, 0x80e40006, 0x04000058,
+    0x800f0000, 0x81aa0001, 0x80e40003, 0x80e40000, 0x03000005, 0x800f0000,
+    0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial1 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0.5, -0.5, 2
+    def c4, 0.0625, 0.03125, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c3.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    mul r0.x, r0.x, c3.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c3.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c3.w, c3.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c4.x, c4.y
+    mad r2.x, r0.z, c4.x, c4.y
+    mov r2.y, c3.y
+    mov r1.y, c3.y
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 37 instruction slots used (2 texture, 35 arithmetic)
+#endif
+
+const DWORD radial1[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020003,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0004,
+    0x3d800000, 0x3d000000, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550003, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0003, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0003, 0xa0000003,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000002, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550002, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000003, 0x04000004, 0x80010001, 0x80000000, 0xa0000004, 0xa0550004,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000004, 0xa0550004, 0x02000001,
+    0x80020002, 0xa0550003, 0x02000001, 0x80020001, 0xa0550003, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40800, 0x04000012, 0x800f0003, 0x80550000, 0x80e40002, 0x80e40001,
+    0x03000005, 0x800f0000, 0x80e40003, 0x90e40000, 0x02000001, 0x800f0800,
+    0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial2 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0.0625, 0.03125, 0.5
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c3.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c3.y, c3.z
+    mad r2.x, r0.z, c3.y, c3.z
+    mov r2.y, c3.w
+    mov r1.y, c3.w
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 33 instruction slots used (2 texture, 31 arithmetic)
+#endif
+
+const DWORD radial2[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020003,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000002, 0x80010000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550002,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000003, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550003, 0xa0aa0003, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550003,
+    0xa0aa0003, 0x02000001, 0x80020002, 0xa0ff0003, 0x02000001, 0x80020001,
+    0xa0ff0003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40800, 0x04000012, 0x800f0003, 0x80550000,
+    0x80e40002, 0x80e40001, 0x03000005, 0x800f0000, 0x80e40003, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial4 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0, 0.5, -1
+    def c8, 1, 0.5, 0.0625, 0.03125
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.z, c7.x
+    mov r0.xy, t0
+    dp3 r0.w, r0, c17
+    mul r0.w, r0.w, r0.w
+    mul r0.w, r0.w, c18.y
+    dp3 r0.x, r0, c16
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.w
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mov r0.z, c18.z
+    mad r0.y, r0.x, r0.z, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    mad r0.w, r0.x, r0.z, -c1.x
+    mul_sat r0.w, r0.w, c1.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c2.x
+    mul_sat r0.w, r0.w, c2.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c3.x
+    mul_sat r0.w, r0.w, c3.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c4.x
+    mul_sat r0.w, r0.w, c4.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c5.x
+    mul_sat r0.w, r0.w, c5.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c6.x
+    mul_sat r0.w, r0.w, c6.y
+    add r0.y, r0.y, r0.w
+    frc r0.w, r0.y
+    add r0.y, r0.y, -r0.w
+    add r1.w, r0.y, c7.x
+    mad r1.x, r1.w, c8.z, c8.w
+    mul r1.z, r0.x, c18.z
+    mad r1.w, r0.x, r0.z, c7.w
+    mad r0.x, r0.y, c8.z, c8.w
+    mov r0.y, c7.z
+    mov r1.y, c7.z
+    mov r2.xy, c8
+    mov r3.xy, c7.yzxw
+    texld r4, r0, s0
+    texld r5, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    lrp r6, r0.w, r5, r4
+    cmp r0, r1.w, r2, r6
+    cmp r0, -r1.z, r3, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 52 instruction slots used (4 texture, 48 arithmetic)
+#endif
+
+const DWORD radial4[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020007,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0008,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80040000, 0xa0000007, 0x02000001, 0x80030000,
+    0xb0e40000, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000005,
+    0x80080000, 0x80ff0000, 0x80ff0000, 0x03000005, 0x80080000, 0x80ff0000,
+    0xa0550012, 0x03000008, 0x80010000, 0x80e40000, 0xa0e40010, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80ff0000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x02000001, 0x80040000, 0xa0aa0012, 0x04000004, 0x80020000,
+    0x80000000, 0x80aa0000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000001,
+    0x03000005, 0x80180000, 0x80ff0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000,
+    0xa1000002, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550002, 0x03000002,
+    0x80020000, 0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000,
+    0x80aa0000, 0xa1000003, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80ff0000, 0x04000004, 0x80080000,
+    0x80000000, 0x80aa0000, 0xa1000004, 0x03000005, 0x80180000, 0x80ff0000,
+    0xa0550004, 0x03000002, 0x80020000, 0x80550000, 0x80ff0000, 0x04000004,
+    0x80080000, 0x80000000, 0x80aa0000, 0xa1000005, 0x03000005, 0x80180000,
+    0x80ff0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80ff0000,
+    0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000006, 0x03000005,
+    0x80180000, 0x80ff0000, 0xa0550006, 0x03000002, 0x80020000, 0x80550000,
+    0x80ff0000, 0x02000013, 0x80080000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81ff0000, 0x03000002, 0x80080001, 0x80550000, 0xa0000007,
+    0x04000004, 0x80010001, 0x80ff0001, 0xa0aa0008, 0xa0ff0008, 0x03000005,
+    0x80040001, 0x80000000, 0xa0aa0012, 0x04000004, 0x80080001, 0x80000000,
+    0x80aa0000, 0xa0ff0007, 0x04000004, 0x80010000, 0x80550000, 0xa0aa0008,
+    0xa0ff0008, 0x02000001, 0x80020000, 0xa0aa0007, 0x02000001, 0x80020001,
+    0xa0aa0007, 0x02000001, 0x80030002, 0xa0e40008, 0x02000001, 0x80030003,
+    0xa0c90007, 0x03000042, 0x800f0004, 0x80e40000, 0xa0e40800, 0x03000042,
+    0x800f0005, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0002, 0x80e40002,
+    0xa0e40800, 0x03000042, 0x800f0003, 0x80e40003, 0xa0e40800, 0x04000012,
+    0x800f0006, 0x80ff0000, 0x80e40005, 0x80e40004, 0x04000058, 0x800f0000,
+    0x80ff0001, 0x80e40002, 0x80e40006, 0x04000058, 0x800f0000, 0x81aa0001,
+    0x80e40003, 0x80e40000, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial5 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0.5, -0.5, 2
+    def c8, 0.0625, 0.03125, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c7.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    mul r0.x, r0.x, c7.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c7.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c7.w, c7.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c8.x, c8.y
+    mad r2.x, r0.z, c8.x, c8.y
+    mov r2.y, c7.y
+    mov r1.y, c7.y
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 49 instruction slots used (2 texture, 47 arithmetic)
+#endif
+
+const DWORD radial5[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020007,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0008,
+    0x3d800000, 0x3d000000, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550007, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0007, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0007, 0xa0000007,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000006, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550006, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000007, 0x04000004, 0x80010001, 0x80000000, 0xa0000008, 0xa0550008,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000008, 0xa0550008, 0x02000001,
+    0x80020002, 0xa0550007, 0x02000001, 0x80020001, 0xa0550007, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40800, 0x04000012, 0x800f0003, 0x80550000, 0x80e40002, 0x80e40001,
+    0x03000005, 0x800f0000, 0x80e40003, 0x90e40000, 0x02000001, 0x800f0800,
+    0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial6 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0.0625, 0.03125, 0.5
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c7.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c7.y, c7.z
+    mad r2.x, r0.z, c7.y, c7.z
+    mov r2.y, c7.w
+    mov r1.y, c7.w
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 45 instruction slots used (2 texture, 43 arithmetic)
+#endif
+
+const DWORD radial6[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020007,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550001,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000002, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550002,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000003, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000004, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550004,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000005, 0x03000002, 0x80010000, 0x80000000, 0xa1000006,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550006,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000007, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550007, 0xa0aa0007, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550007,
+    0xa0aa0007, 0x02000001, 0x80020002, 0xa0ff0007, 0x02000001, 0x80020001,
+    0xa0ff0007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40800, 0x04000012, 0x800f0003, 0x80550000,
+    0x80e40002, 0x80e40001, 0x03000005, 0x800f0000, 0x80e40003, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial8 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0, 0.5, -1
+    def c4, 1, 0.5, 0.0625, 0.03125
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.z, c3.x
+    mov r0.xy, t1
+    dp3 r0.w, r0, c17
+    mul r0.w, r0.w, r0.w
+    mul r0.w, r0.w, c18.y
+    dp3 r0.x, r0, c16
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.w
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mov r0.z, c18.z
+    mad r0.y, r0.x, r0.z, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    mad r0.w, r0.x, r0.z, -c1.x
+    mul_sat r0.w, r0.w, c1.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c2.x
+    mul_sat r0.w, r0.w, c2.y
+    add r0.y, r0.y, r0.w
+    frc r0.w, r0.y
+    add r0.y, r0.y, -r0.w
+    add r1.w, r0.y, c3.x
+    mad r1.x, r1.w, c4.z, c4.w
+    mul r1.z, r0.x, c18.z
+    mad r1.w, r0.x, r0.z, c3.w
+    mad r0.x, r0.y, c4.z, c4.w
+    mov r0.y, c3.z
+    mov r1.y, c3.z
+    mov r2.xy, c4
+    mov r3.xy, c3.yzxw
+    texld r4, r0, s1
+    texld r5, r1, s1
+    texld r2, r2, s1
+    texld r3, r3, s1
+    texld r6, t0, s0
+    lrp r7, r0.w, r5, r4
+    cmp r0, r1.w, r2, r7
+    cmp r0, -r1.z, r3, r0
+    mul r0, r6.w, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 42 instruction slots used (5 texture, 37 arithmetic)
+#endif
+
+const DWORD radial8[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020003,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0004,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80040000, 0xa0000003, 0x02000001, 0x80030000,
+    0xb0e40001, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000005,
+    0x80080000, 0x80ff0000, 0x80ff0000, 0x03000005, 0x80080000, 0x80ff0000,
+    0xa0550012, 0x03000008, 0x80010000, 0x80e40000, 0xa0e40010, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80ff0000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x02000001, 0x80040000, 0xa0aa0012, 0x04000004, 0x80020000,
+    0x80000000, 0x80aa0000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000001,
+    0x03000005, 0x80180000, 0x80ff0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000,
+    0xa1000002, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550002, 0x03000002,
+    0x80020000, 0x80550000, 0x80ff0000, 0x02000013, 0x80080000, 0x80550000,
+    0x03000002, 0x80020000, 0x80550000, 0x81ff0000, 0x03000002, 0x80080001,
+    0x80550000, 0xa0000003, 0x04000004, 0x80010001, 0x80ff0001, 0xa0aa0004,
+    0xa0ff0004, 0x03000005, 0x80040001, 0x80000000, 0xa0aa0012, 0x04000004,
+    0x80080001, 0x80000000, 0x80aa0000, 0xa0ff0003, 0x04000004, 0x80010000,
+    0x80550000, 0xa0aa0004, 0xa0ff0004, 0x02000001, 0x80020000, 0xa0aa0003,
+    0x02000001, 0x80020001, 0xa0aa0003, 0x02000001, 0x80030002, 0xa0e40004,
+    0x02000001, 0x80030003, 0xa0c90003, 0x03000042, 0x800f0004, 0x80e40000,
+    0xa0e40801, 0x03000042, 0x800f0005, 0x80e40001, 0xa0e40801, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0003, 0x80e40003,
+    0xa0e40801, 0x03000042, 0x800f0006, 0xb0e40000, 0xa0e40800, 0x04000012,
+    0x800f0007, 0x80ff0000, 0x80e40005, 0x80e40004, 0x04000058, 0x800f0000,
+    0x80ff0001, 0x80e40002, 0x80e40007, 0x04000058, 0x800f0000, 0x81aa0001,
+    0x80e40003, 0x80e40000, 0x03000005, 0x800f0000, 0x80ff0006, 0x80e40000,
+    0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800,
+    0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial9 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0.5, -0.5, 2
+    def c4, 0.0625, 0.03125, 0, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c3.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    mul r0.x, r0.x, c3.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c3.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c3.w, c3.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c4.x, c4.y
+    mad r2.x, r0.z, c4.x, c4.y
+    mov r2.y, c3.y
+    mov r1.y, c3.y
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 39 instruction slots used (3 texture, 36 arithmetic)
+#endif
+
+const DWORD radial9[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020003,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0004,
+    0x3d800000, 0x3d000000, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550003, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0003, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0003, 0xa0000003,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000002, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550002, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000003, 0x04000004, 0x80010001, 0x80000000, 0xa0000004, 0xa0550004,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000004, 0xa0550004, 0x02000001,
+    0x80020002, 0xa0550003, 0x02000001, 0x80020001, 0xa0550003, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000, 0xa0e40800, 0x04000012,
+    0x800f0004, 0x80550000, 0x80e40002, 0x80e40001, 0x03000005, 0x800f0000,
+    0x80ff0003, 0x80e40004, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial10 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0.0625, 0.03125, 0.5
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c3.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c3.y, c3.z
+    mad r2.x, r0.z, c3.y, c3.z
+    mov r2.y, c3.w
+    mov r1.y, c3.w
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 35 instruction slots used (3 texture, 32 arithmetic)
+#endif
+
+const DWORD radial10[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020003,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000002, 0x80010000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550002,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000003, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550003, 0xa0aa0003, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550003,
+    0xa0aa0003, 0x02000001, 0x80020002, 0xa0ff0003, 0x02000001, 0x80020001,
+    0xa0ff0003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000,
+    0xa0e40800, 0x04000012, 0x800f0004, 0x80550000, 0x80e40002, 0x80e40001,
+    0x03000005, 0x800f0000, 0x80ff0003, 0x80e40004, 0x03000005, 0x800f0000,
+    0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial12 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0, 0.5, -1
+    def c8, 1, 0.5, 0.0625, 0.03125
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.z, c7.x
+    mov r0.xy, t1
+    dp3 r0.w, r0, c17
+    mul r0.w, r0.w, r0.w
+    mul r0.w, r0.w, c18.y
+    dp3 r0.x, r0, c16
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.w
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mov r0.z, c18.z
+    mad r0.y, r0.x, r0.z, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    mad r0.w, r0.x, r0.z, -c1.x
+    mul_sat r0.w, r0.w, c1.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c2.x
+    mul_sat r0.w, r0.w, c2.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c3.x
+    mul_sat r0.w, r0.w, c3.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c4.x
+    mul_sat r0.w, r0.w, c4.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c5.x
+    mul_sat r0.w, r0.w, c5.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c6.x
+    mul_sat r0.w, r0.w, c6.y
+    add r0.y, r0.y, r0.w
+    frc r0.w, r0.y
+    add r0.y, r0.y, -r0.w
+    add r1.w, r0.y, c7.x
+    mad r1.x, r1.w, c8.z, c8.w
+    mul r1.z, r0.x, c18.z
+    mad r1.w, r0.x, r0.z, c7.w
+    mad r0.x, r0.y, c8.z, c8.w
+    mov r0.y, c7.z
+    mov r1.y, c7.z
+    mov r2.xy, c8
+    mov r3.xy, c7.yzxw
+    texld r4, r0, s1
+    texld r5, r1, s1
+    texld r2, r2, s1
+    texld r3, r3, s1
+    texld r6, t0, s0
+    lrp r7, r0.w, r5, r4
+    cmp r0, r1.w, r2, r7
+    cmp r0, -r1.z, r3, r0
+    mul r0, r6.w, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 54 instruction slots used (5 texture, 49 arithmetic)
+#endif
+
+const DWORD radial12[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020007,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0008,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80040000, 0xa0000007, 0x02000001, 0x80030000,
+    0xb0e40001, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000005,
+    0x80080000, 0x80ff0000, 0x80ff0000, 0x03000005, 0x80080000, 0x80ff0000,
+    0xa0550012, 0x03000008, 0x80010000, 0x80e40000, 0xa0e40010, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80ff0000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x02000001, 0x80040000, 0xa0aa0012, 0x04000004, 0x80020000,
+    0x80000000, 0x80aa0000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000001,
+    0x03000005, 0x80180000, 0x80ff0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000,
+    0xa1000002, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550002, 0x03000002,
+    0x80020000, 0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000,
+    0x80aa0000, 0xa1000003, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80ff0000, 0x04000004, 0x80080000,
+    0x80000000, 0x80aa0000, 0xa1000004, 0x03000005, 0x80180000, 0x80ff0000,
+    0xa0550004, 0x03000002, 0x80020000, 0x80550000, 0x80ff0000, 0x04000004,
+    0x80080000, 0x80000000, 0x80aa0000, 0xa1000005, 0x03000005, 0x80180000,
+    0x80ff0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80ff0000,
+    0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000006, 0x03000005,
+    0x80180000, 0x80ff0000, 0xa0550006, 0x03000002, 0x80020000, 0x80550000,
+    0x80ff0000, 0x02000013, 0x80080000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81ff0000, 0x03000002, 0x80080001, 0x80550000, 0xa0000007,
+    0x04000004, 0x80010001, 0x80ff0001, 0xa0aa0008, 0xa0ff0008, 0x03000005,
+    0x80040001, 0x80000000, 0xa0aa0012, 0x04000004, 0x80080001, 0x80000000,
+    0x80aa0000, 0xa0ff0007, 0x04000004, 0x80010000, 0x80550000, 0xa0aa0008,
+    0xa0ff0008, 0x02000001, 0x80020000, 0xa0aa0007, 0x02000001, 0x80020001,
+    0xa0aa0007, 0x02000001, 0x80030002, 0xa0e40008, 0x02000001, 0x80030003,
+    0xa0c90007, 0x03000042, 0x800f0004, 0x80e40000, 0xa0e40801, 0x03000042,
+    0x800f0005, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0002, 0x80e40002,
+    0xa0e40801, 0x03000042, 0x800f0003, 0x80e40003, 0xa0e40801, 0x03000042,
+    0x800f0006, 0xb0e40000, 0xa0e40800, 0x04000012, 0x800f0007, 0x80ff0000,
+    0x80e40005, 0x80e40004, 0x04000058, 0x800f0000, 0x80ff0001, 0x80e40002,
+    0x80e40007, 0x04000058, 0x800f0000, 0x81aa0001, 0x80e40003, 0x80e40000,
+    0x03000005, 0x800f0000, 0x80ff0006, 0x80e40000, 0x03000005, 0x800f0000,
+    0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial13 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0.5, -0.5, 2
+    def c8, 0.0625, 0.03125, 0, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c7.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    mul r0.x, r0.x, c7.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c7.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c7.w, c7.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c8.x, c8.y
+    mad r2.x, r0.z, c8.x, c8.y
+    mov r2.y, c7.y
+    mov r1.y, c7.y
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 51 instruction slots used (3 texture, 48 arithmetic)
+#endif
+
+const DWORD radial13[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020007,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0008,
+    0x3d800000, 0x3d000000, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550007, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0007, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0007, 0xa0000007,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000006, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550006, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000007, 0x04000004, 0x80010001, 0x80000000, 0xa0000008, 0xa0550008,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000008, 0xa0550008, 0x02000001,
+    0x80020002, 0xa0550007, 0x02000001, 0x80020001, 0xa0550007, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000, 0xa0e40800, 0x04000012,
+    0x800f0004, 0x80550000, 0x80e40002, 0x80e40001, 0x03000005, 0x800f0000,
+    0x80ff0003, 0x80e40004, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000,
+    0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial14 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0.0625, 0.03125, 0.5
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c7.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c7.y, c7.z
+    mad r2.x, r0.z, c7.y, c7.z
+    mov r2.y, c7.w
+    mov r1.y, c7.w
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 47 instruction slots used (3 texture, 44 arithmetic)
+#endif
+
+const DWORD radial14[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020007,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550001,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000002, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550002,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000003, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000004, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550004,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000005, 0x03000002, 0x80010000, 0x80000000, 0xa1000006,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550006,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000007, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550007, 0xa0aa0007, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550007,
+    0xa0aa0007, 0x02000001, 0x80020002, 0xa0ff0007, 0x02000001, 0x80020001,
+    0xa0ff0007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000,
+    0xa0e40800, 0x04000012, 0x800f0004, 0x80550000, 0x80e40002, 0x80e40001,
+    0x03000005, 0x800f0000, 0x80ff0003, 0x80e40004, 0x03000005, 0x800f0000,
+    0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial16 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0, 0.5, -1
+    def c4, 1, 0.5, 0.0625, 0.03125
+    def c5, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.z, c3.x
+    mov r0.xy, t0
+    dp3 r0.w, r0, c17
+    mul r0.w, r0.w, r0.w
+    mul r0.w, r0.w, c18.y
+    dp3 r0.x, r0, c16
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.w
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mov r0.z, c18.z
+    mad r0.y, r0.x, r0.z, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    mad r0.w, r0.x, r0.z, -c1.x
+    mul_sat r0.w, r0.w, c1.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c2.x
+    mul_sat r0.w, r0.w, c2.y
+    add r0.y, r0.y, r0.w
+    frc r0.w, r0.y
+    add r0.y, r0.y, -r0.w
+    add r1.w, r0.y, c3.x
+    mad r1.x, r1.w, c4.z, c4.w
+    mul r1.z, r0.x, c18.z
+    mad r1.w, r0.x, r0.z, c3.w
+    mad r0.x, r0.y, c4.z, c4.w
+    mov r0.y, c3.z
+    mov r1.y, c3.z
+    mov r2.xy, c4
+    mov r3.xy, c3.yzxw
+    texld r4, r0, s0
+    texld r5, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    lrp r6, r0.w, r5, r4
+    cmp r0, r1.w, r2, r6
+    cmp r0, -r1.z, r3, r0
+    log r1.x, r0.x
+    log r1.y, r0.y
+    log r1.z, r0.z
+    mul r1.xyz, r1, c5.x
+    exp r2.x, r1.x
+    exp r2.y, r1.y
+    exp r2.z, r1.z
+    mad r0.xyz, r2, c5.y, c5.z
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 48 instruction slots used (4 texture, 44 arithmetic)
+#endif
+
+const DWORD radial16[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020003,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0004,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x05000051, 0xa00f0005,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80040000, 0xa0000003, 0x02000001, 0x80030000,
+    0xb0e40000, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000005,
+    0x80080000, 0x80ff0000, 0x80ff0000, 0x03000005, 0x80080000, 0x80ff0000,
+    0xa0550012, 0x03000008, 0x80010000, 0x80e40000, 0xa0e40010, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80ff0000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x02000001, 0x80040000, 0xa0aa0012, 0x04000004, 0x80020000,
+    0x80000000, 0x80aa0000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000001,
+    0x03000005, 0x80180000, 0x80ff0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000,
+    0xa1000002, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550002, 0x03000002,
+    0x80020000, 0x80550000, 0x80ff0000, 0x02000013, 0x80080000, 0x80550000,
+    0x03000002, 0x80020000, 0x80550000, 0x81ff0000, 0x03000002, 0x80080001,
+    0x80550000, 0xa0000003, 0x04000004, 0x80010001, 0x80ff0001, 0xa0aa0004,
+    0xa0ff0004, 0x03000005, 0x80040001, 0x80000000, 0xa0aa0012, 0x04000004,
+    0x80080001, 0x80000000, 0x80aa0000, 0xa0ff0003, 0x04000004, 0x80010000,
+    0x80550000, 0xa0aa0004, 0xa0ff0004, 0x02000001, 0x80020000, 0xa0aa0003,
+    0x02000001, 0x80020001, 0xa0aa0003, 0x02000001, 0x80030002, 0xa0e40004,
+    0x02000001, 0x80030003, 0xa0c90003, 0x03000042, 0x800f0004, 0x80e40000,
+    0xa0e40800, 0x03000042, 0x800f0005, 0x80e40001, 0xa0e40800, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042, 0x800f0003, 0x80e40003,
+    0xa0e40800, 0x04000012, 0x800f0006, 0x80ff0000, 0x80e40005, 0x80e40004,
+    0x04000058, 0x800f0000, 0x80ff0001, 0x80e40002, 0x80e40006, 0x04000058,
+    0x800f0000, 0x81aa0001, 0x80e40003, 0x80e40000, 0x0200000f, 0x80010001,
+    0x80000000, 0x0200000f, 0x80020001, 0x80550000, 0x0200000f, 0x80040001,
+    0x80aa0000, 0x03000005, 0x80070001, 0x80e40001, 0xa0000005, 0x0200000e,
+    0x80010002, 0x80000001, 0x0200000e, 0x80020002, 0x80550001, 0x0200000e,
+    0x80040002, 0x80aa0001, 0x04000004, 0x80070000, 0x80e40002, 0xa0550005,
+    0xa0aa0005, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x02000001,
+    0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial17 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0.5, -0.5, 2
+    def c4, 0.0625, 0.03125, 0.416667014, 0
+    def c5, 1.05499995, -0.0549999997, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c3.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    mul r0.x, r0.x, c3.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c3.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c3.w, c3.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c4.x, c4.y
+    mad r2.x, r0.z, c4.x, c4.y
+    mov r2.y, c3.y
+    mov r1.y, c3.y
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    log r0.x, r3.x
+    log r0.y, r3.y
+    log r0.z, r3.z
+    mul r0.xyz, r0, c4.z
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r3.xyz, r1, c5.x, c5.y
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 45 instruction slots used (2 texture, 43 arithmetic)
+#endif
+
+const DWORD radial17[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020003,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0004,
+    0x3d800000, 0x3d000000, 0x3ed55561, 0x00000000, 0x05000051, 0xa00f0005,
+    0x3f870a3d, 0xbd6147ae, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550003, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0003, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0003, 0xa0000003,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000002, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550002, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000003, 0x04000004, 0x80010001, 0x80000000, 0xa0000004, 0xa0550004,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000004, 0xa0550004, 0x02000001,
+    0x80020002, 0xa0550003, 0x02000001, 0x80020001, 0xa0550003, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40800, 0x04000012, 0x800f0003, 0x80550000, 0x80e40002, 0x80e40001,
+    0x0200000f, 0x80010000, 0x80000003, 0x0200000f, 0x80020000, 0x80550003,
+    0x0200000f, 0x80040000, 0x80aa0003, 0x03000005, 0x80070000, 0x80e40000,
+    0xa0aa0004, 0x0200000e, 0x80010001, 0x80000000, 0x0200000e, 0x80020001,
+    0x80550000, 0x0200000e, 0x80040001, 0x80aa0000, 0x04000004, 0x80070003,
+    0x80e40001, 0xa0000005, 0xa0550005, 0x03000005, 0x800f0000, 0x80e40003,
+    0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial18 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c3, 1, 0.0625, 0.03125, 0.5
+    def c4, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c3.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c3.y, c3.z
+    mad r2.x, r0.z, c3.y, c3.z
+    mov r2.y, c3.w
+    mov r1.y, c3.w
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    log r0.x, r3.x
+    log r0.y, r3.y
+    log r0.z, r3.z
+    mul r0.xyz, r0, c4.x
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r3.xyz, r1, c4.y, c4.z
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 41 instruction slots used (2 texture, 39 arithmetic)
+#endif
+
+const DWORD radial18[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020003,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x05000051, 0xa00f0004,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000002, 0x80010000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550002,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000003, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550003, 0xa0aa0003, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550003,
+    0xa0aa0003, 0x02000001, 0x80020002, 0xa0ff0003, 0x02000001, 0x80020001,
+    0xa0ff0003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40800, 0x04000012, 0x800f0003, 0x80550000,
+    0x80e40002, 0x80e40001, 0x0200000f, 0x80010000, 0x80000003, 0x0200000f,
+    0x80020000, 0x80550003, 0x0200000f, 0x80040000, 0x80aa0003, 0x03000005,
+    0x80070000, 0x80e40000, 0xa0000004, 0x0200000e, 0x80010001, 0x80000000,
+    0x0200000e, 0x80020001, 0x80550000, 0x0200000e, 0x80040001, 0x80aa0000,
+    0x04000004, 0x80070003, 0x80e40001, 0xa0550004, 0xa0aa0004, 0x03000005,
+    0x800f0000, 0x80e40003, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial20 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0, 0.5, -1
+    def c8, 1, 0.5, 0.0625, 0.03125
+    def c9, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.z, c7.x
+    mov r0.xy, t0
+    dp3 r0.w, r0, c17
+    mul r0.w, r0.w, r0.w
+    mul r0.w, r0.w, c18.y
+    dp3 r0.x, r0, c16
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.w
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mov r0.z, c18.z
+    mad r0.y, r0.x, r0.z, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    mad r0.w, r0.x, r0.z, -c1.x
+    mul_sat r0.w, r0.w, c1.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c2.x
+    mul_sat r0.w, r0.w, c2.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c3.x
+    mul_sat r0.w, r0.w, c3.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c4.x
+    mul_sat r0.w, r0.w, c4.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c5.x
+    mul_sat r0.w, r0.w, c5.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c6.x
+    mul_sat r0.w, r0.w, c6.y
+    add r0.y, r0.y, r0.w
+    frc r0.w, r0.y
+    add r0.y, r0.y, -r0.w
+    add r1.w, r0.y, c7.x
+    mad r1.x, r1.w, c8.z, c8.w
+    mul r1.z, r0.x, c18.z
+    mad r1.w, r0.x, r0.z, c7.w
+    mad r0.x, r0.y, c8.z, c8.w
+    mov r0.y, c7.z
+    mov r1.y, c7.z
+    mov r2.xy, c8
+    mov r3.xy, c7.yzxw
+    texld r4, r0, s0
+    texld r5, r1, s0
+    texld r2, r2, s0
+    texld r3, r3, s0
+    lrp r6, r0.w, r5, r4
+    cmp r0, r1.w, r2, r6
+    cmp r0, -r1.z, r3, r0
+    log r1.x, r0.x
+    log r1.y, r0.y
+    log r1.z, r0.z
+    mul r1.xyz, r1, c9.x
+    exp r2.x, r1.x
+    exp r2.y, r1.y
+    exp r2.z, r1.z
+    mad r0.xyz, r2, c9.y, c9.z
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 60 instruction slots used (4 texture, 56 arithmetic)
+#endif
+
+const DWORD radial20[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020007,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0008,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x05000051, 0xa00f0009,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80040000, 0xa0000007, 0x02000001, 0x80030000,
+    0xb0e40000, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000005,
+    0x80080000, 0x80ff0000, 0x80ff0000, 0x03000005, 0x80080000, 0x80ff0000,
+    0xa0550012, 0x03000008, 0x80010000, 0x80e40000, 0xa0e40010, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80ff0000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x02000001, 0x80040000, 0xa0aa0012, 0x04000004, 0x80020000,
+    0x80000000, 0x80aa0000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000001,
+    0x03000005, 0x80180000, 0x80ff0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000,
+    0xa1000002, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550002, 0x03000002,
+    0x80020000, 0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000,
+    0x80aa0000, 0xa1000003, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80ff0000, 0x04000004, 0x80080000,
+    0x80000000, 0x80aa0000, 0xa1000004, 0x03000005, 0x80180000, 0x80ff0000,
+    0xa0550004, 0x03000002, 0x80020000, 0x80550000, 0x80ff0000, 0x04000004,
+    0x80080000, 0x80000000, 0x80aa0000, 0xa1000005, 0x03000005, 0x80180000,
+    0x80ff0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80ff0000,
+    0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000006, 0x03000005,
+    0x80180000, 0x80ff0000, 0xa0550006, 0x03000002, 0x80020000, 0x80550000,
+    0x80ff0000, 0x02000013, 0x80080000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81ff0000, 0x03000002, 0x80080001, 0x80550000, 0xa0000007,
+    0x04000004, 0x80010001, 0x80ff0001, 0xa0aa0008, 0xa0ff0008, 0x03000005,
+    0x80040001, 0x80000000, 0xa0aa0012, 0x04000004, 0x80080001, 0x80000000,
+    0x80aa0000, 0xa0ff0007, 0x04000004, 0x80010000, 0x80550000, 0xa0aa0008,
+    0xa0ff0008, 0x02000001, 0x80020000, 0xa0aa0007, 0x02000001, 0x80020001,
+    0xa0aa0007, 0x02000001, 0x80030002, 0xa0e40008, 0x02000001, 0x80030003,
+    0xa0c90007, 0x03000042, 0x800f0004, 0x80e40000, 0xa0e40800, 0x03000042,
+    0x800f0005, 0x80e40001, 0xa0e40800, 0x03000042, 0x800f0002, 0x80e40002,
+    0xa0e40800, 0x03000042, 0x800f0003, 0x80e40003, 0xa0e40800, 0x04000012,
+    0x800f0006, 0x80ff0000, 0x80e40005, 0x80e40004, 0x04000058, 0x800f0000,
+    0x80ff0001, 0x80e40002, 0x80e40006, 0x04000058, 0x800f0000, 0x81aa0001,
+    0x80e40003, 0x80e40000, 0x0200000f, 0x80010001, 0x80000000, 0x0200000f,
+    0x80020001, 0x80550000, 0x0200000f, 0x80040001, 0x80aa0000, 0x03000005,
+    0x80070001, 0x80e40001, 0xa0000009, 0x0200000e, 0x80010002, 0x80000001,
+    0x0200000e, 0x80020002, 0x80550001, 0x0200000e, 0x80040002, 0x80aa0001,
+    0x04000004, 0x80070000, 0x80e40002, 0xa0550009, 0xa0aa0009, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial21 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0.5, -0.5, 2
+    def c8, 0.0625, 0.03125, 0.416667014, 0
+    def c9, 1.05499995, -0.0549999997, 0, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c7.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    mul r0.x, r0.x, c7.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c7.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c7.w, c7.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c8.x, c8.y
+    mad r2.x, r0.z, c8.x, c8.y
+    mov r2.y, c7.y
+    mov r1.y, c7.y
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    log r0.x, r3.x
+    log r0.y, r3.y
+    log r0.z, r3.z
+    mul r0.xyz, r0, c8.z
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r3.xyz, r1, c9.x, c9.y
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 57 instruction slots used (2 texture, 55 arithmetic)
+#endif
+
+const DWORD radial21[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020007,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0008,
+    0x3d800000, 0x3d000000, 0x3ed55561, 0x00000000, 0x05000051, 0xa00f0009,
+    0x3f870a3d, 0xbd6147ae, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550007, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0007, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0007, 0xa0000007,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000006, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550006, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000007, 0x04000004, 0x80010001, 0x80000000, 0xa0000008, 0xa0550008,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000008, 0xa0550008, 0x02000001,
+    0x80020002, 0xa0550007, 0x02000001, 0x80020001, 0xa0550007, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40800, 0x04000012, 0x800f0003, 0x80550000, 0x80e40002, 0x80e40001,
+    0x0200000f, 0x80010000, 0x80000003, 0x0200000f, 0x80020000, 0x80550003,
+    0x0200000f, 0x80040000, 0x80aa0003, 0x03000005, 0x80070000, 0x80e40000,
+    0xa0aa0008, 0x0200000e, 0x80010001, 0x80000000, 0x0200000e, 0x80020001,
+    0x80550000, 0x0200000e, 0x80040001, 0x80aa0000, 0x04000004, 0x80070003,
+    0x80e40001, 0xa0000009, 0xa0550009, 0x03000005, 0x800f0000, 0x80e40003,
+    0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial22 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   colors       s0       1
+//
+
+    ps_2_0
+    def c7, 1, 0.0625, 0.03125, 0.5
+    def c8, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl v0
+    dcl_2d s0
+    mov r0.xy, t0
+    mov r0.z, c7.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c7.y, c7.z
+    mad r2.x, r0.z, c7.y, c7.z
+    mov r2.y, c7.w
+    mov r1.y, c7.w
+    texld r2, r2, s0
+    texld r1, r1, s0
+    lrp r3, r0.y, r2, r1
+    log r0.x, r3.x
+    log r0.y, r3.y
+    log r0.z, r3.z
+    mul r0.xyz, r0, c8.x
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r3.xyz, r1, c8.y, c8.z
+    mul r0, r3, v0
+    mov oC0, r0
+
+// approximately 53 instruction slots used (2 texture, 51 arithmetic)
+#endif
+
+const DWORD radial22[] =
+{
+    0xffff0200, 0x0044fffe, 0x42415443, 0x0000001c, 0x000000da, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000d3, 0x00000080, 0x00000003,
+    0x00020001, 0x00000088, 0x00000000, 0x00000098, 0x00000002, 0x00020007,
+    0x000000a4, 0x00000000, 0x000000b4, 0x00100002, 0x00420001, 0x000000b8,
+    0x00000000, 0x000000c8, 0x00110002, 0x00460001, 0x000000b8, 0x00000000,
+    0x000000cb, 0x00120002, 0x004a0001, 0x000000b8, 0x00000000, 0x6f6c6f63,
+    0xab007372, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266,
+    0x6e6f6974, 0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000,
+    0xab00306d, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x7000316d,
+    0x61636572, 0x7000636c, 0x5f325f73, 0x694d0030, 0x736f7263, 0x2074666f,
+    0x20295228, 0x4c534c48, 0x61685320, 0x20726564, 0x706d6f43, 0x72656c69,
+    0x312e3920, 0x34392e39, 0x31322e39, 0xab003131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x05000051, 0xa00f0008,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f, 0x90000000,
+    0xa00f0800, 0x02000001, 0x80030000, 0xb0e40000, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550001,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000002, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550002,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000003, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000004, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550004,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000005, 0x03000002, 0x80010000, 0x80000000, 0xa1000006,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550006,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000007, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550007, 0xa0aa0007, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550007,
+    0xa0aa0007, 0x02000001, 0x80020002, 0xa0ff0007, 0x02000001, 0x80020001,
+    0xa0ff0007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40800, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40800, 0x04000012, 0x800f0003, 0x80550000,
+    0x80e40002, 0x80e40001, 0x0200000f, 0x80010000, 0x80000003, 0x0200000f,
+    0x80020000, 0x80550003, 0x0200000f, 0x80040000, 0x80aa0003, 0x03000005,
+    0x80070000, 0x80e40000, 0xa0000008, 0x0200000e, 0x80010001, 0x80000000,
+    0x0200000e, 0x80020001, 0x80550000, 0x0200000e, 0x80040001, 0x80aa0000,
+    0x04000004, 0x80070003, 0x80e40001, 0xa0550008, 0xa0aa0008, 0x03000005,
+    0x800f0000, 0x80e40003, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial24 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0, 0.5, -1
+    def c4, 1, 0.5, 0.0625, 0.03125
+    def c5, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.z, c3.x
+    mov r0.xy, t1
+    dp3 r0.w, r0, c17
+    mul r0.w, r0.w, r0.w
+    mul r0.w, r0.w, c18.y
+    dp3 r0.x, r0, c16
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.w
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mov r0.z, c18.z
+    mad r0.y, r0.x, r0.z, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    mad r0.w, r0.x, r0.z, -c1.x
+    mul_sat r0.w, r0.w, c1.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c2.x
+    mul_sat r0.w, r0.w, c2.y
+    add r0.y, r0.y, r0.w
+    frc r0.w, r0.y
+    add r0.y, r0.y, -r0.w
+    add r1.w, r0.y, c3.x
+    mad r1.x, r1.w, c4.z, c4.w
+    mul r1.z, r0.x, c18.z
+    mad r1.w, r0.x, r0.z, c3.w
+    mad r0.x, r0.y, c4.z, c4.w
+    mov r0.y, c3.z
+    mov r1.y, c3.z
+    mov r2.xy, c4
+    mov r3.xy, c3.yzxw
+    texld r4, r0, s1
+    texld r5, r1, s1
+    texld r2, r2, s1
+    texld r3, r3, s1
+    texld r6, t0, s0
+    lrp r7, r0.w, r5, r4
+    cmp r0, r1.w, r2, r7
+    cmp r0, -r1.z, r3, r0
+    log r1.x, r0.x
+    log r1.y, r0.y
+    log r1.z, r0.z
+    mul r1.xyz, r1, c5.x
+    exp r2.x, r1.x
+    exp r2.y, r1.y
+    exp r2.z, r1.z
+    mad r0.xyz, r2, c5.y, c5.z
+    mul r0, r6.w, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 50 instruction slots used (5 texture, 45 arithmetic)
+#endif
+
+const DWORD radial24[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020003,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0004,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x05000051, 0xa00f0005,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80040000, 0xa0000003, 0x02000001, 0x80030000,
+    0xb0e40001, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000005,
+    0x80080000, 0x80ff0000, 0x80ff0000, 0x03000005, 0x80080000, 0x80ff0000,
+    0xa0550012, 0x03000008, 0x80010000, 0x80e40000, 0xa0e40010, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80ff0000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x02000001, 0x80040000, 0xa0aa0012, 0x04000004, 0x80020000,
+    0x80000000, 0x80aa0000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000001,
+    0x03000005, 0x80180000, 0x80ff0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000,
+    0xa1000002, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550002, 0x03000002,
+    0x80020000, 0x80550000, 0x80ff0000, 0x02000013, 0x80080000, 0x80550000,
+    0x03000002, 0x80020000, 0x80550000, 0x81ff0000, 0x03000002, 0x80080001,
+    0x80550000, 0xa0000003, 0x04000004, 0x80010001, 0x80ff0001, 0xa0aa0004,
+    0xa0ff0004, 0x03000005, 0x80040001, 0x80000000, 0xa0aa0012, 0x04000004,
+    0x80080001, 0x80000000, 0x80aa0000, 0xa0ff0003, 0x04000004, 0x80010000,
+    0x80550000, 0xa0aa0004, 0xa0ff0004, 0x02000001, 0x80020000, 0xa0aa0003,
+    0x02000001, 0x80020001, 0xa0aa0003, 0x02000001, 0x80030002, 0xa0e40004,
+    0x02000001, 0x80030003, 0xa0c90003, 0x03000042, 0x800f0004, 0x80e40000,
+    0xa0e40801, 0x03000042, 0x800f0005, 0x80e40001, 0xa0e40801, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0003, 0x80e40003,
+    0xa0e40801, 0x03000042, 0x800f0006, 0xb0e40000, 0xa0e40800, 0x04000012,
+    0x800f0007, 0x80ff0000, 0x80e40005, 0x80e40004, 0x04000058, 0x800f0000,
+    0x80ff0001, 0x80e40002, 0x80e40007, 0x04000058, 0x800f0000, 0x81aa0001,
+    0x80e40003, 0x80e40000, 0x0200000f, 0x80010001, 0x80000000, 0x0200000f,
+    0x80020001, 0x80550000, 0x0200000f, 0x80040001, 0x80aa0000, 0x03000005,
+    0x80070001, 0x80e40001, 0xa0000005, 0x0200000e, 0x80010002, 0x80000001,
+    0x0200000e, 0x80020002, 0x80550001, 0x0200000e, 0x80040002, 0x80aa0001,
+    0x04000004, 0x80070000, 0x80e40002, 0xa0550005, 0xa0aa0005, 0x03000005,
+    0x800f0000, 0x80ff0006, 0x80e40000, 0x03000005, 0x800f0000, 0x80e40000,
+    0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial25 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0.5, -0.5, 2
+    def c4, 0.0625, 0.03125, 0.416667014, 0
+    def c5, 1.05499995, -0.0549999997, 0, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c3.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    mul r0.x, r0.x, c3.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c3.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c3.w, c3.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c4.x, c4.y
+    mad r2.x, r0.z, c4.x, c4.y
+    mov r2.y, c3.y
+    mov r1.y, c3.y
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    log r0.x, r4.x
+    log r0.y, r4.y
+    log r0.z, r4.z
+    mul r0.xyz, r0, c4.z
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r4.xyz, r1, c5.x, c5.y
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 47 instruction slots used (3 texture, 44 arithmetic)
+#endif
+
+const DWORD radial25[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020003,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0004,
+    0x3d800000, 0x3d000000, 0x3ed55561, 0x00000000, 0x05000051, 0xa00f0005,
+    0x3f870a3d, 0xbd6147ae, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550003, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0003, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0003, 0xa0000003,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000002, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550001, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550002, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000003, 0x04000004, 0x80010001, 0x80000000, 0xa0000004, 0xa0550004,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000004, 0xa0550004, 0x02000001,
+    0x80020002, 0xa0550003, 0x02000001, 0x80020001, 0xa0550003, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000, 0xa0e40800, 0x04000012,
+    0x800f0004, 0x80550000, 0x80e40002, 0x80e40001, 0x0200000f, 0x80010000,
+    0x80000004, 0x0200000f, 0x80020000, 0x80550004, 0x0200000f, 0x80040000,
+    0x80aa0004, 0x03000005, 0x80070000, 0x80e40000, 0xa0aa0004, 0x0200000e,
+    0x80010001, 0x80000000, 0x0200000e, 0x80020001, 0x80550000, 0x0200000e,
+    0x80040001, 0x80aa0000, 0x04000004, 0x80070004, 0x80e40001, 0xa0000005,
+    0xa0550005, 0x03000005, 0x800f0000, 0x80ff0003, 0x80e40004, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial26 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[4];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       3
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c3, 1, 0.0625, 0.03125, 0.5
+    def c4, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c3.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    add r0.x, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c2.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c3.x
+    mad r1.x, r0.x, c3.y, c3.z
+    mad r2.x, r0.z, c3.y, c3.z
+    mov r2.y, c3.w
+    mov r1.y, c3.w
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    log r0.x, r4.x
+    log r0.y, r4.y
+    log r0.z, r4.z
+    mul r0.xyz, r0, c4.x
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r4.xyz, r1, c4.y, c4.z
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 43 instruction slots used (3 texture, 40 arithmetic)
+#endif
+
+const DWORD radial26[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020003,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000004, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0003,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x05000051, 0xa00f0004,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000003, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000002, 0x80010000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550002,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000003, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550003, 0xa0aa0003, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550003,
+    0xa0aa0003, 0x02000001, 0x80020002, 0xa0ff0003, 0x02000001, 0x80020001,
+    0xa0ff0003, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000,
+    0xa0e40800, 0x04000012, 0x800f0004, 0x80550000, 0x80e40002, 0x80e40001,
+    0x0200000f, 0x80010000, 0x80000004, 0x0200000f, 0x80020000, 0x80550004,
+    0x0200000f, 0x80040000, 0x80aa0004, 0x03000005, 0x80070000, 0x80e40000,
+    0xa0000004, 0x0200000e, 0x80010001, 0x80000000, 0x0200000e, 0x80020001,
+    0x80550000, 0x0200000e, 0x80040001, 0x80aa0000, 0x04000004, 0x80070004,
+    0x80e40001, 0xa0550004, 0xa0aa0004, 0x03000005, 0x800f0000, 0x80ff0003,
+    0x80e40004, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x02000001,
+    0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial28 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0, 0.5, -1
+    def c8, 1, 0.5, 0.0625, 0.03125
+    def c9, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.z, c7.x
+    mov r0.xy, t1
+    dp3 r0.w, r0, c17
+    mul r0.w, r0.w, r0.w
+    mul r0.w, r0.w, c18.y
+    dp3 r0.x, r0, c16
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.w
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mov r0.z, c18.z
+    mad r0.y, r0.x, r0.z, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    mad r0.w, r0.x, r0.z, -c1.x
+    mul_sat r0.w, r0.w, c1.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c2.x
+    mul_sat r0.w, r0.w, c2.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c3.x
+    mul_sat r0.w, r0.w, c3.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c4.x
+    mul_sat r0.w, r0.w, c4.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c5.x
+    mul_sat r0.w, r0.w, c5.y
+    add r0.y, r0.y, r0.w
+    mad r0.w, r0.x, r0.z, -c6.x
+    mul_sat r0.w, r0.w, c6.y
+    add r0.y, r0.y, r0.w
+    frc r0.w, r0.y
+    add r0.y, r0.y, -r0.w
+    add r1.w, r0.y, c7.x
+    mad r1.x, r1.w, c8.z, c8.w
+    mul r1.z, r0.x, c18.z
+    mad r1.w, r0.x, r0.z, c7.w
+    mad r0.x, r0.y, c8.z, c8.w
+    mov r0.y, c7.z
+    mov r1.y, c7.z
+    mov r2.xy, c8
+    mov r3.xy, c7.yzxw
+    texld r4, r0, s1
+    texld r5, r1, s1
+    texld r2, r2, s1
+    texld r3, r3, s1
+    texld r6, t0, s0
+    lrp r7, r0.w, r5, r4
+    cmp r0, r1.w, r2, r7
+    cmp r0, -r1.z, r3, r0
+    log r1.x, r0.x
+    log r1.y, r0.y
+    log r1.z, r0.z
+    mul r1.xyz, r1, c9.x
+    exp r2.x, r1.x
+    exp r2.y, r1.y
+    exp r2.z, r1.z
+    mad r0.xyz, r2, c9.y, c9.z
+    mul r0, r6.w, r0
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 62 instruction slots used (5 texture, 57 arithmetic)
+#endif
+
+const DWORD radial28[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020007,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x00000000, 0x3f000000, 0xbf800000, 0x05000051, 0xa00f0008,
+    0x3f800000, 0x3f000000, 0x3d800000, 0x3d000000, 0x05000051, 0xa00f0009,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80040000, 0xa0000007, 0x02000001, 0x80030000,
+    0xb0e40001, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000005,
+    0x80080000, 0x80ff0000, 0x80ff0000, 0x03000005, 0x80080000, 0x80ff0000,
+    0xa0550012, 0x03000008, 0x80010000, 0x80e40000, 0xa0e40010, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80ff0000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x02000001, 0x80040000, 0xa0aa0012, 0x04000004, 0x80020000,
+    0x80000000, 0x80aa0000, 0xa1000000, 0x03000005, 0x80120000, 0x80550000,
+    0xa0550000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000001,
+    0x03000005, 0x80180000, 0x80ff0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000, 0x80aa0000,
+    0xa1000002, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550002, 0x03000002,
+    0x80020000, 0x80550000, 0x80ff0000, 0x04000004, 0x80080000, 0x80000000,
+    0x80aa0000, 0xa1000003, 0x03000005, 0x80180000, 0x80ff0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80ff0000, 0x04000004, 0x80080000,
+    0x80000000, 0x80aa0000, 0xa1000004, 0x03000005, 0x80180000, 0x80ff0000,
+    0xa0550004, 0x03000002, 0x80020000, 0x80550000, 0x80ff0000, 0x04000004,
+    0x80080000, 0x80000000, 0x80aa0000, 0xa1000005, 0x03000005, 0x80180000,
+    0x80ff0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80ff0000,
+    0x04000004, 0x80080000, 0x80000000, 0x80aa0000, 0xa1000006, 0x03000005,
+    0x80180000, 0x80ff0000, 0xa0550006, 0x03000002, 0x80020000, 0x80550000,
+    0x80ff0000, 0x02000013, 0x80080000, 0x80550000, 0x03000002, 0x80020000,
+    0x80550000, 0x81ff0000, 0x03000002, 0x80080001, 0x80550000, 0xa0000007,
+    0x04000004, 0x80010001, 0x80ff0001, 0xa0aa0008, 0xa0ff0008, 0x03000005,
+    0x80040001, 0x80000000, 0xa0aa0012, 0x04000004, 0x80080001, 0x80000000,
+    0x80aa0000, 0xa0ff0007, 0x04000004, 0x80010000, 0x80550000, 0xa0aa0008,
+    0xa0ff0008, 0x02000001, 0x80020000, 0xa0aa0007, 0x02000001, 0x80020001,
+    0xa0aa0007, 0x02000001, 0x80030002, 0xa0e40008, 0x02000001, 0x80030003,
+    0xa0c90007, 0x03000042, 0x800f0004, 0x80e40000, 0xa0e40801, 0x03000042,
+    0x800f0005, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0002, 0x80e40002,
+    0xa0e40801, 0x03000042, 0x800f0003, 0x80e40003, 0xa0e40801, 0x03000042,
+    0x800f0006, 0xb0e40000, 0xa0e40800, 0x04000012, 0x800f0007, 0x80ff0000,
+    0x80e40005, 0x80e40004, 0x04000058, 0x800f0000, 0x80ff0001, 0x80e40002,
+    0x80e40007, 0x04000058, 0x800f0000, 0x81aa0001, 0x80e40003, 0x80e40000,
+    0x0200000f, 0x80010001, 0x80000000, 0x0200000f, 0x80020001, 0x80550000,
+    0x0200000f, 0x80040001, 0x80aa0000, 0x03000005, 0x80070001, 0x80e40001,
+    0xa0000009, 0x0200000e, 0x80010002, 0x80000001, 0x0200000e, 0x80020002,
+    0x80550001, 0x0200000e, 0x80040002, 0x80aa0001, 0x04000004, 0x80070000,
+    0x80e40002, 0xa0550009, 0xa0aa0009, 0x03000005, 0x800f0000, 0x80ff0006,
+    0x80e40000, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x02000001,
+    0x800f0800, 0x80e40000, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial29 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0.5, -0.5, 2
+    def c8, 0.0625, 0.03125, 0.416667014, 0
+    def c9, 1.05499995, -0.0549999997, 0, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c7.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    mul r0.x, r0.x, c7.y
+    frc r0.x, r0.x
+    add r0.x, r0.x, c7.z
+    abs r0.x, r0.x
+    mad r0.x, r0.x, -c7.w, c7.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c8.x, c8.y
+    mad r2.x, r0.z, c8.x, c8.y
+    mov r2.y, c7.y
+    mov r1.y, c7.y
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    log r0.x, r4.x
+    log r0.y, r4.y
+    log r0.z, r4.z
+    mul r0.xyz, r0, c8.z
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r4.xyz, r1, c9.x, c9.y
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 59 instruction slots used (3 texture, 56 arithmetic)
+#endif
+
+const DWORD radial29[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020007,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3f000000, 0xbf000000, 0x40000000, 0x05000051, 0xa00f0008,
+    0x3d800000, 0x3d000000, 0x3ed55561, 0x00000000, 0x05000051, 0xa00f0009,
+    0x3f870a3d, 0xbd6147ae, 0x00000000, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x03000005,
+    0x80010000, 0x80000000, 0xa0550007, 0x02000013, 0x80010000, 0x80000000,
+    0x03000002, 0x80010000, 0x80000000, 0xa0aa0007, 0x02000023, 0x80010000,
+    0x80000000, 0x04000004, 0x80010000, 0x80000000, 0xa1ff0007, 0xa0000007,
+    0x03000002, 0x80020000, 0x80000000, 0xa1000000, 0x03000005, 0x80120000,
+    0x80550000, 0xa0550000, 0x03000002, 0x80040000, 0x80000000, 0xa1000001,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550001, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000002,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550002, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000003,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550003, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000004,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550004, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000002, 0x80040000, 0x80000000, 0xa1000005,
+    0x03000002, 0x80010000, 0x80000000, 0xa1000006, 0x03000005, 0x80140000,
+    0x80aa0000, 0xa0550005, 0x03000002, 0x80020000, 0x80550000, 0x80aa0000,
+    0x03000005, 0x80110000, 0x80000000, 0xa0550006, 0x03000002, 0x80010000,
+    0x80550000, 0x80000000, 0x02000013, 0x80020000, 0x80000000, 0x03000002,
+    0x80010000, 0x80000000, 0x81550000, 0x03000002, 0x80040000, 0x80000000,
+    0xa0000007, 0x04000004, 0x80010001, 0x80000000, 0xa0000008, 0xa0550008,
+    0x04000004, 0x80010002, 0x80aa0000, 0xa0000008, 0xa0550008, 0x02000001,
+    0x80020002, 0xa0550007, 0x02000001, 0x80020001, 0xa0550007, 0x03000042,
+    0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042, 0x800f0001, 0x80e40001,
+    0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000, 0xa0e40800, 0x04000012,
+    0x800f0004, 0x80550000, 0x80e40002, 0x80e40001, 0x0200000f, 0x80010000,
+    0x80000004, 0x0200000f, 0x80020000, 0x80550004, 0x0200000f, 0x80040000,
+    0x80aa0004, 0x03000005, 0x80070000, 0x80e40000, 0xa0aa0008, 0x0200000e,
+    0x80010001, 0x80000000, 0x0200000e, 0x80020001, 0x80550000, 0x0200000e,
+    0x80040001, 0x80aa0000, 0x04000004, 0x80070004, 0x80e40001, 0xa0000009,
+    0xa0550009, 0x03000005, 0x800f0000, 0x80ff0003, 0x80e40004, 0x03000005,
+    0x800f0000, 0x80e40000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000,
+    0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn radial30 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D colors;
+//   float2 fractions[8];
+//   float3 m0;
+//   float3 m1;
+//   sampler2D mask;
+//   float3 precalc;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   fractions    c0       7
+//   m0           c16      1
+//   m1           c17      1
+//   precalc      c18      1
+//   mask         s0       1
+//   colors       s1       1
+//
+
+    ps_2_0
+    def c7, 1, 0.0625, 0.03125, 0.5
+    def c8, 0.416667014, 1.05499995, -0.0549999997, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dcl_2d s0
+    dcl_2d s1
+    mov r0.xy, t1
+    mov r0.z, c7.x
+    dp3 r0.w, r0, c17
+    dp3 r0.x, r0, c16
+    mul r0.y, r0.w, r0.w
+    mul r0.y, r0.y, c18.y
+    add r0.x, r0.x, -c18.x
+    mad r0.y, r0.x, r0.x, r0.y
+    rsq r0.y, r0.y
+    rcp r0.y, r0.y
+    mad r0.x, c18.x, r0.x, r0.y
+    mul r0.x, r0.x, c18.z
+    frc r0.x, r0.x
+    add r0.y, r0.x, -c0.x
+    mul_sat r0.y, r0.y, c0.y
+    add r0.z, r0.x, -c1.x
+    mul_sat r0.z, r0.z, c1.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c2.x
+    mul_sat r0.z, r0.z, c2.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c3.x
+    mul_sat r0.z, r0.z, c3.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c4.x
+    mul_sat r0.z, r0.z, c4.y
+    add r0.y, r0.y, r0.z
+    add r0.z, r0.x, -c5.x
+    add r0.x, r0.x, -c6.x
+    mul_sat r0.z, r0.z, c5.y
+    add r0.y, r0.y, r0.z
+    mul_sat r0.x, r0.x, c6.y
+    add r0.x, r0.y, r0.x
+    frc r0.y, r0.x
+    add r0.x, r0.x, -r0.y
+    add r0.z, r0.x, c7.x
+    mad r1.x, r0.x, c7.y, c7.z
+    mad r2.x, r0.z, c7.y, c7.z
+    mov r2.y, c7.w
+    mov r1.y, c7.w
+    texld r2, r2, s1
+    texld r1, r1, s1
+    texld r3, t0, s0
+    lrp r4, r0.y, r2, r1
+    log r0.x, r4.x
+    log r0.y, r4.y
+    log r0.z, r4.z
+    mul r0.xyz, r0, c8.x
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mad r4.xyz, r1, c8.y, c8.z
+    mul r0, r3.w, r4
+    mul r0, r0, v0
+    mov oC0, r0
+
+// approximately 55 instruction slots used (3 texture, 52 arithmetic)
+#endif
+
+const DWORD radial30[] =
+{
+    0xffff0200, 0x004afffe, 0x42415443, 0x0000001c, 0x000000f3, 0xffff0200,
+    0x00000006, 0x0000001c, 0x20000100, 0x000000ec, 0x00000094, 0x00010003,
+    0x00060001, 0x0000009c, 0x00000000, 0x000000ac, 0x00000002, 0x00020007,
+    0x000000b8, 0x00000000, 0x000000c8, 0x00100002, 0x00420001, 0x000000cc,
+    0x00000000, 0x000000dc, 0x00110002, 0x00460001, 0x000000cc, 0x00000000,
+    0x000000df, 0x00000003, 0x00020001, 0x0000009c, 0x00000000, 0x000000e4,
+    0x00120002, 0x004a0001, 0x000000cc, 0x00000000, 0x6f6c6f63, 0xab007372,
+    0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x63617266, 0x6e6f6974,
+    0xabab0073, 0x00030001, 0x00020001, 0x00000008, 0x00000000, 0xab00306d,
+    0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x6d00316d, 0x006b7361,
+    0x63657270, 0x00636c61, 0x325f7370, 0x4d00305f, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3931, 0x322e3934, 0x00313131, 0x05000051, 0xa00f0007,
+    0x3f800000, 0x3d800000, 0x3d000000, 0x3f000000, 0x05000051, 0xa00f0008,
+    0x3ed55561, 0x3f870a3d, 0xbd6147ae, 0x00000000, 0x0200001f, 0x80000000,
+    0xb0030000, 0x0200001f, 0x80000000, 0xb0030001, 0x0200001f, 0x80000000,
+    0x900f0000, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f, 0x90000000,
+    0xa00f0801, 0x02000001, 0x80030000, 0xb0e40001, 0x02000001, 0x80040000,
+    0xa0000007, 0x03000008, 0x80080000, 0x80e40000, 0xa0e40011, 0x03000008,
+    0x80010000, 0x80e40000, 0xa0e40010, 0x03000005, 0x80020000, 0x80ff0000,
+    0x80ff0000, 0x03000005, 0x80020000, 0x80550000, 0xa0550012, 0x03000002,
+    0x80010000, 0x80000000, 0xa1000012, 0x04000004, 0x80020000, 0x80000000,
+    0x80000000, 0x80550000, 0x02000007, 0x80020000, 0x80550000, 0x02000006,
+    0x80020000, 0x80550000, 0x04000004, 0x80010000, 0xa0000012, 0x80000000,
+    0x80550000, 0x03000005, 0x80010000, 0x80000000, 0xa0aa0012, 0x02000013,
+    0x80010000, 0x80000000, 0x03000002, 0x80020000, 0x80000000, 0xa1000000,
+    0x03000005, 0x80120000, 0x80550000, 0xa0550000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000001, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550001,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000002, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550002,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000003, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550003,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000004, 0x03000005, 0x80140000, 0x80aa0000, 0xa0550004,
+    0x03000002, 0x80020000, 0x80550000, 0x80aa0000, 0x03000002, 0x80040000,
+    0x80000000, 0xa1000005, 0x03000002, 0x80010000, 0x80000000, 0xa1000006,
+    0x03000005, 0x80140000, 0x80aa0000, 0xa0550005, 0x03000002, 0x80020000,
+    0x80550000, 0x80aa0000, 0x03000005, 0x80110000, 0x80000000, 0xa0550006,
+    0x03000002, 0x80010000, 0x80550000, 0x80000000, 0x02000013, 0x80020000,
+    0x80000000, 0x03000002, 0x80010000, 0x80000000, 0x81550000, 0x03000002,
+    0x80040000, 0x80000000, 0xa0000007, 0x04000004, 0x80010001, 0x80000000,
+    0xa0550007, 0xa0aa0007, 0x04000004, 0x80010002, 0x80aa0000, 0xa0550007,
+    0xa0aa0007, 0x02000001, 0x80020002, 0xa0ff0007, 0x02000001, 0x80020001,
+    0xa0ff0007, 0x03000042, 0x800f0002, 0x80e40002, 0xa0e40801, 0x03000042,
+    0x800f0001, 0x80e40001, 0xa0e40801, 0x03000042, 0x800f0003, 0xb0e40000,
+    0xa0e40800, 0x04000012, 0x800f0004, 0x80550000, 0x80e40002, 0x80e40001,
+    0x0200000f, 0x80010000, 0x80000004, 0x0200000f, 0x80020000, 0x80550004,
+    0x0200000f, 0x80040000, 0x80aa0004, 0x03000005, 0x80070000, 0x80e40000,
+    0xa0000008, 0x0200000e, 0x80010001, 0x80000000, 0x0200000e, 0x80020001,
+    0x80550000, 0x0200000e, 0x80040001, 0x80aa0000, 0x04000004, 0x80070004,
+    0x80e40001, 0xa0550008, 0xa0aa0008, 0x03000005, 0x800f0000, 0x80ff0003,
+    0x80e40004, 0x03000005, 0x800f0000, 0x80e40000, 0x90e40000, 0x02000001,
+    0x800f0800, 0x80e40000, 0x0000ffff
+};
+const DWORD *radialShaders[] =
+{
+    radial0,
+    radial1,
+    radial2,
+    NULL,
+    radial4,
+    radial5,
+    radial6,
+    NULL,
+    radial8,
+    radial9,
+    radial10,
+    NULL,
+    radial12,
+    radial13,
+    radial14,
+    NULL,
+    radial16,
+    radial17,
+    radial18,
+    NULL,
+    radial20,
+    radial21,
+    radial22,
+    NULL,
+    radial24,
+    radial25,
+    radial26,
+    NULL,
+    radial28,
+    radial29,
+    radial30,
+    NULL,
+};
+
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_0 /Vn lcdtext0 /Fh tmp.h tmp.hlsl
+//
+//
+// Parameters:
+//
+//   sampler2D dstTex;
+//   float3 gamma;
+//   sampler2D glyphTex;
+//   float3 invgamma;
+//   float3 srcAdj;
+//
+//
+// Registers:
+//
+//   Name         Reg   Size
+//   ------------ ----- ----
+//   srcAdj       c0       1
+//   invgamma     c1       1
+//   gamma        c2       1
+//   glyphTex     s0       1
+//   dstTex       s1       1
+//
+
+    ps_2_0
+    def c3, -1, 0, 1, 0
+    dcl t0.xy
+    dcl t1.xy
+    dcl_2d s0
+    dcl_2d s1
+    texld r0, t0, s0
+    dp3 r0.w, r0, r0
+    cmp r1, -r0.w, c3.x, c3.y
+    texkill r1
+    texld r1, t1, s1
+    log r2.x, r1.x
+    log r2.y, r1.y
+    log r2.z, r1.z
+    mul r1.xyz, r2, c1
+    exp r2.x, r1.x
+    exp r2.y, r1.y
+    exp r2.z, r1.z
+    lrp r1.xyz, r0, c0, r2
+    log r0.x, r1.x
+    log r0.y, r1.y
+    log r0.z, r1.z
+    mul r0.xyz, r0, c2
+    exp r1.x, r0.x
+    exp r1.y, r0.y
+    exp r1.z, r0.z
+    mov r1.w, c3.z
+    mov oC0, r1
+
+// approximately 22 instruction slots used (2 texture, 20 arithmetic)
+#endif
+
+const DWORD lcdtext0[] =
+{
+    0xffff0200, 0x0042fffe, 0x42415443, 0x0000001c, 0x000000d0, 0xffff0200,
+    0x00000005, 0x0000001c, 0x20000100, 0x000000c9, 0x00000080, 0x00010003,
+    0x00060001, 0x00000088, 0x00000000, 0x00000098, 0x00020002, 0x000a0001,
+    0x000000a0, 0x00000000, 0x000000b0, 0x00000003, 0x00020001, 0x00000088,
+    0x00000000, 0x000000b9, 0x00010002, 0x00060001, 0x000000a0, 0x00000000,
+    0x000000c2, 0x00000002, 0x00020001, 0x000000a0, 0x00000000, 0x54747364,
+    0xab007865, 0x000c0004, 0x00010001, 0x00000001, 0x00000000, 0x6d6d6167,
+    0xabab0061, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0x70796c67,
+    0x78655468, 0x766e6900, 0x6d6d6167, 0x72730061, 0x6a644163, 0x5f737000,
+    0x00305f32, 0x7263694d, 0x666f736f, 0x52282074, 0x4c482029, 0x53204c53,
+    0x65646168, 0x6f432072, 0x6c69706d, 0x39207265, 0x2e39312e, 0x2e393439,
+    0x31313132, 0xababab00, 0x05000051, 0xa00f0003, 0xbf800000, 0x80000000,
+    0x3f800000, 0x00000000, 0x0200001f, 0x80000000, 0xb0030000, 0x0200001f,
+    0x80000000, 0xb0030001, 0x0200001f, 0x90000000, 0xa00f0800, 0x0200001f,
+    0x90000000, 0xa00f0801, 0x03000042, 0x800f0000, 0xb0e40000, 0xa0e40800,
+    0x03000008, 0x80080000, 0x80e40000, 0x80e40000, 0x04000058, 0x800f0001,
+    0x81ff0000, 0xa0000003, 0xa0550003, 0x01000041, 0x800f0001, 0x03000042,
+    0x800f0001, 0xb0e40001, 0xa0e40801, 0x0200000f, 0x80010002, 0x80000001,
+    0x0200000f, 0x80020002, 0x80550001, 0x0200000f, 0x80040002, 0x80aa0001,
+    0x03000005, 0x80070001, 0x80e40002, 0xa0e40001, 0x0200000e, 0x80010002,
+    0x80000001, 0x0200000e, 0x80020002, 0x80550001, 0x0200000e, 0x80040002,
+    0x80aa0001, 0x04000012, 0x80070001, 0x80e40000, 0xa0e40000, 0x80e40002,
+    0x0200000f, 0x80010000, 0x80000001, 0x0200000f, 0x80020000, 0x80550001,
+    0x0200000f, 0x80040000, 0x80aa0001, 0x03000005, 0x80070000, 0x80e40000,
+    0xa0e40002, 0x0200000e, 0x80010001, 0x80000000, 0x0200000e, 0x80020001,
+    0x80550000, 0x0200000e, 0x80040001, 0x80aa0000, 0x02000001, 0x80080001,
+    0xa0aa0003, 0x02000001, 0x800f0800, 0x80e40001, 0x0000ffff
+};
+#if 0
+//
+// Generated by Microsoft (R) HLSL Shader Compiler 9.19.949.2111
+//
+//   fxc /T ps_2_a /Vn aapgram0 /Fh tmp.h tmp.hlsl
+//
+    ps_2_x
+    dcl t0.xy
+    dcl t1.xy
+    dcl v0
+    dsx r0.xy, t1.yxzw
+    add r0.xy, r0, t1.yxzw
+    min r1.xy, r0, t1.yxzw
+    dsy r0.zw, t1.xyyx
+    add r1.zw, r0, t1.xyyx
+    add r0.zw, r0.xyxy, r0
+    max r2.xy, t1.yxzw, r0
+    min r0.xy, r1.zwzw, r1
+    max r3.xy, r2, r1.zwzw
+    min r1.xy, r0.zwzw, r0
+    max r1.zw, r3.xyxy, r0
+    mov_sat r0.xy, r1
+    add r0.zw, -r1.xyxy, r1
+    mov_sat r1.zw, r1
+    add r0.xy, -r0, r1.zwzw
+    mul r0.xy, r0.ywzw, r0.xzzw
+    rcp r0.y, r0.y
+    mul r0.x, r0.x, r0.y
+    dsx r0.yz, t0.xyxw
+    add r0.yz, r0, t0.xyxw
+    min r1.xy, r0.yzzw, t0.yxzw
+    dsy r1.zw, t0.xyyx
+    add r2.xy, r1.zwzw, t0.yxzw
+    add r1.zw, r0.xyyz, r1
+    max r2.zw, t0.xyyx, r0.xyyz
+    min r0.yz, r2.xxyw, r1.xxyw
+    max r1.xy, r2.zwzw, r2
+    min r2.xy, r1.zwzw, r0.yzzw
+    max r0.yz, r1.xxyw, r1.xzww
+    mov_sat r1.xy, r2
+    add r1.zw, -r2.xyxy, r0.xyyz
+    mov_sat r0.yz, r0
+    add r0.yz, -r1.xxyw, r0
+    mul r0.y, r0.z, r0.y
+    mul r0.z, r1.w, r1.z
+    rcp r0.z, r0.z
+    mad r0.x, r0.y, r0.z, -r0.x
+    mul r0, r0.x, v0
+    mov oC0, r0
+
+// approximately 43 instruction slots used
+#endif
+
+const DWORD aapgram0[] =
+{
+    0xffff0201, 0x0016fffe, 0x42415443, 0x0000001c, 0x00000023, 0xffff0201,
+    0x00000000, 0x00000000, 0x20000100, 0x0000001c, 0x325f7370, 0x4d00615f,
+    0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461,
+    0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3931, 0x322e3934, 0x00313131,
+    0x0200001f, 0x80000000, 0xb0030000, 0x0200001f, 0x80000000, 0xb0030001,
+    0x0200001f, 0x80000000, 0x900f0000, 0x0200005b, 0x80030000, 0xb0e10001,
+    0x03000002, 0x80030000, 0x80e40000, 0xb0e10001, 0x0300000a, 0x80030001,
+    0x80e40000, 0xb0e10001, 0x0200005c, 0x800c0000, 0xb0140001, 0x03000002,
+    0x800c0001, 0x80e40000, 0xb0140001, 0x03000002, 0x800c0000, 0x80440000,
+    0x80e40000, 0x0300000b, 0x80030002, 0xb0e10001, 0x80e40000, 0x0300000a,
+    0x80030000, 0x80ee0001, 0x80e40001, 0x0300000b, 0x80030003, 0x80e40002,
+    0x80ee0001, 0x0300000a, 0x80030001, 0x80ee0000, 0x80e40000, 0x0300000b,
+    0x800c0001, 0x80440003, 0x80e40000, 0x02000001, 0x80130000, 0x80e40001,
+    0x03000002, 0x800c0000, 0x81440001, 0x80e40001, 0x02000001, 0x801c0001,
+    0x80e40001, 0x03000002, 0x80030000, 0x81e40000, 0x80ee0001, 0x03000005,
+    0x80030000, 0x80ed0000, 0x80e80000, 0x02000006, 0x80020000, 0x80550000,
+    0x03000005, 0x80010000, 0x80000000, 0x80550000, 0x0200005b, 0x80060000,
+    0xb0c40000, 0x03000002, 0x80060000, 0x80e40000, 0xb0c40000, 0x0300000a,
+    0x80030001, 0x80e90000, 0xb0e10000, 0x0200005c, 0x800c0001, 0xb0140000,
+    0x03000002, 0x80030002, 0x80ee0001, 0xb0e10000, 0x03000002, 0x800c0001,
+    0x80940000, 0x80e40001, 0x0300000b, 0x800c0002, 0xb0140000, 0x80940000,
+    0x0300000a, 0x80060000, 0x80d00002, 0x80d00001, 0x0300000b, 0x80030001,
+    0x80ee0002, 0x80e40002, 0x0300000a, 0x80030002, 0x80ee0001, 0x80e90000,
+    0x0300000b, 0x80060000, 0x80d00001, 0x80f80001, 0x02000001, 0x80130001,
+    0x80e40002, 0x03000002, 0x800c0001, 0x81440002, 0x80940000, 0x02000001,
+    0x80160000, 0x80e40000, 0x03000002, 0x80060000, 0x81d00001, 0x80e40000,
+    0x03000005, 0x80020000, 0x80aa0000, 0x80550000, 0x03000005, 0x80040000,
+    0x80ff0001, 0x80aa0001, 0x02000006, 0x80040000, 0x80aa0000, 0x04000004,
+    0x80010000, 0x80550000, 0x80aa0000, 0x81000000, 0x03000005, 0x800f0000,
+    0x80000000, 0x90e40000, 0x02000001, 0x800f0800, 0x80e40000, 0x0000ffff
+};
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DSurfaceData.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DSurfaceData.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DSurfaceData.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DSurfaceData.cpp	2011-01-08 01:26:50.483202340 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,291 +23,611 @@
  * questions.
  */
 
+#include <jni.h>
+#include <jni_util.h>
+#include <jlong.h>
 #include "D3DSurfaceData.h"
-#include "D3DContext.h"
-#include "jlong.h"
-#include "jni_util.h"
+#include "D3DPipelineManager.h"
 #include "Trace.h"
-#include "ddrawUtils.h"
-#include "Devices.h"
+#include "awt_Toolkit.h"
+#include "awt_Window.h"
+#include "awt_BitmapUtil.h"
+#include "D3DRenderQueue.h"
+
+// REMIND: move to awt_Component.h
+extern "C" HWND AwtComponent_GetHWnd(JNIEnv *env, jlong pData);
+
+/**
+ * Initializes nativeWidth/Height fields of the SurfaceData object with
+ * dimensions on the native surface.
+ */
+void D3DSD_SetNativeDimensions(JNIEnv *env, D3DSDOps *d3dsdo) {
+    jobject sdObject;
+    jint width, height;
+
+    RETURN_IF_NULL(sdObject = env->NewLocalRef(d3dsdo->sdOps.sdObject));
+
+    if (d3dsdo->pResource != NULL) {
+        width = d3dsdo->pResource->GetDesc()->Width;
+        height = d3dsdo->pResource->GetDesc()->Height;
+    } else {
+        width = d3dsdo->width;
+        height = d3dsdo->height;
+    }
 
-#include "Win32SurfaceData.h"
-#include "sun_java2d_d3d_D3DBackBufferSurfaceData.h"
+    JNU_SetFieldByName(env, NULL, sdObject, "nativeWidth", "I", width);
+    JNU_SetFieldByName(env, NULL, sdObject, "nativeHeight", "I", height);
 
-extern LockFunc Win32OSSD_Lock;
-extern GetRasInfoFunc Win32OSSD_GetRasInfo;
-extern UnlockFunc Win32OSSD_Unlock;
-extern DisposeFunc Win32OSSD_Dispose;
-extern GetDCFunc Win32OSSD_GetDC;
-extern ReleaseDCFunc Win32OSSD_ReleaseDC;
-extern InvalidateSDFunc Win32OSSD_InvalidateSD;
-extern RestoreSurfaceFunc Win32OSSD_RestoreSurface;
-extern DisposeFunc Win32BBSD_Dispose;
+    env->DeleteLocalRef(sdObject);
+}
 
-extern "C" {
+void D3DSD_Flush(void *pData)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DSD_Flush");
+    RETURN_IF_NULL(pData);
 
-RestoreSurfaceFunc D3DSD_RestoreSurface;
+    D3DSDOps *d3dsdo = (D3DSDOps*)pData;
+    if (d3dsdo->pResource != NULL) {
+        D3DContext *pCtx;
+        D3DPipelineManager *pMgr;
 
-/*
- * D3D-surface specific restore function.
- * We need to make sure the D3DContext is notified if the
- * surface is lost (only if this surface is the current target,
- * otherwise it's possible that it'll get restored (along with its
- * depth buffer), and the context will still think that the clipping
- * that's set for this surface is valid.
- * Consider this scenario:
- * do {
- *     vi.validate(gc); // validated, vi's surface is restored, clipping is lost
- *     // render stuff using d3d, clipping is reset
- *     // -> surface loss event happens
- *     // do a DD blit of the VI to the screen
- *     // at this point the VI surface will be marked lost
- *     // and will be restored in validate() next time around,
- *     // losing the clipping w/o notifying the D3D context
- * } while (vi.surfaceLost());
- */
-void D3DSD_RestoreSurface(JNIEnv *env, Win32SDOps *wsdo) {
-    J2dTraceLn(J2D_TRACE_INFO, "D3DSD_RestoreSurface");
-    D3DSDOps *d3dsdo = (D3DSDOps *)wsdo;
-    // This is needed only for non-textures, since textures can't
-    // lose their surfaces, as they're managed.
-    if (!(d3dsdo->d3dType & D3D_TEXTURE_SURFACE) && wsdo->lpSurface != NULL)
-    {
-        if (wsdo->ddInstance != NULL && wsdo->ddInstance->ddObject != NULL) {
-            D3DContext *d3dContext =
-                wsdo->ddInstance->ddObject->GetD3dContext();
-            if (d3dContext != NULL) {
-                d3dContext->InvalidateIfTarget(env, wsdo->lpSurface);
+        d3dsdo->pResource->SetSDOps(NULL);
+
+        if ((pMgr = D3DPipelineManager::GetInstance()) != NULL &&
+            SUCCEEDED(pMgr->GetD3DContext(d3dsdo->adapter, &pCtx)))
+        {
+            if (pCtx->GetResourceManager()) {
+                pCtx->GetResourceManager()->ReleaseResource(d3dsdo->pResource);
             }
         }
+        d3dsdo->pResource = NULL;
     }
-    Win32OSSD_RestoreSurface(env, wsdo);
 }
 
+void
+D3DSD_MarkLost(void *pData)
+{
+    D3DSDOps *d3dsdo;
+    jobject sdObject;
+    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DSD_MarkLost");
+
+    RETURN_IF_NULL(pData);
+
+    d3dsdo = (D3DSDOps*)pData;
+    RETURN_IF_NULL(sdObject = env->NewLocalRef(d3dsdo->sdOps.sdObject));
+
+    JNU_CallMethodByName(env, NULL, sdObject,
+                         "setSurfaceLost", "(Z)V", JNI_TRUE);
+
+    env->DeleteLocalRef(sdObject);
+}
+
+// ------------ generic SurfaceData.h functions ----------------
+
+void
+D3DSD_Dispose(JNIEnv *env, SurfaceDataOps *ops)
+{
+    D3DSDOps *d3dsdo = (D3DSDOps *)ops;
+    RETURN_IF_NULL(d3dsdo);
+
+    JNU_CallStaticMethodByName(env, NULL, "sun/java2d/d3d/D3DSurfaceData",
+                               "dispose", "(J)V",
+                               ptr_to_jlong(ops));
+}
+
+/**
+ * This is the implementation of the general surface LockFunc defined in
+ * SurfaceData.h.
+ */
+jint
+D3DSD_Lock(JNIEnv *env,
+           SurfaceDataOps *ops,
+           SurfaceDataRasInfo *pRasInfo,
+           jint lockflags)
+{
+    JNU_ThrowInternalError(env, "D3DSD_Lock not implemented!");
+    return SD_FAILURE;
+}
+
+/**
+ * This is the implementation of the general GetRasInfoFunc defined in
+ * SurfaceData.h.
+ */
+void
+D3DSD_GetRasInfo(JNIEnv *env,
+                 SurfaceDataOps *ops,
+                 SurfaceDataRasInfo *pRasInfo)
+{
+    JNU_ThrowInternalError(env, "D3DSD_GetRasInfo not implemented!");
+}
+
+/**
+ * This is the implementation of the general surface UnlockFunc defined in
+ * SurfaceData.h.
+ */
+void
+D3DSD_Unlock(JNIEnv *env,
+             SurfaceDataOps *ops,
+             SurfaceDataRasInfo *pRasInfo)
+{
+    JNU_ThrowInternalError(env, "D3DSD_Unlock not implemented!");
+}
+
+// ------------ D3DSurfaceData's JNI methods ----------------
+
+
+extern "C" {
+
 /*
  * Class:     sun_java2d_d3d_D3DSurfaceData
  * Method:    initOps
- * Signature: (Ljava/lang/Object;)V
+ * Signature: (III)V
  */
-JNIEXPORT void JNICALL
-Java_sun_java2d_d3d_D3DSurfaceData_initOps(JNIEnv *env,
-                                           jobject wsd,
-                                           jint depth,
-                                           jint transparency)
+JNIEXPORT void
+JNICALL Java_sun_java2d_d3d_D3DSurfaceData_initOps
+  (JNIEnv *env, jobject d3dsd, jint gdiScreen, jint width, jint height)
 {
+    D3DPipelineManager *pMgr;
+    D3DSDOps *d3dsdo = (D3DSDOps *)SurfaceData_InitOps(env, d3dsd,
+                                                       sizeof(D3DSDOps));
+
     J2dTraceLn(J2D_TRACE_INFO, "D3DSurfaceData_initOps");
-    Win32SDOps *wsdo = (Win32SDOps *)SurfaceData_InitOps(env, wsd,
-                                                         sizeof(D3DSDOps));
-    wsdo->sdOps.Lock = Win32OSSD_Lock;
-    wsdo->sdOps.GetRasInfo = Win32OSSD_GetRasInfo;
-    wsdo->sdOps.Unlock = Win32OSSD_Unlock;
-    wsdo->sdOps.Dispose = Win32OSSD_Dispose;
-    wsdo->RestoreSurface = D3DSD_RestoreSurface;
-    wsdo->GetDC = Win32OSSD_GetDC;
-    wsdo->ReleaseDC = Win32OSSD_ReleaseDC;
-    wsdo->InvalidateSD = Win32OSSD_InvalidateSD;
-    wsdo->invalid = JNI_FALSE;
-    wsdo->lockType = WIN32SD_LOCK_UNLOCKED;
-    wsdo->window = NULL;
-    wsdo->backBufferCount = 0;
-    wsdo->depth = depth;
-    switch (depth) {
-        case 8:
-            wsdo->pixelStride = 1;
-            break;
-        case 15: //555
-            wsdo->pixelStride = 2;
-            wsdo->pixelMasks[0] = 0x1f << 10;
-            wsdo->pixelMasks[1] = 0x1f << 5;
-            wsdo->pixelMasks[2] = 0x1f;
-            break;
-        case 16: //565
-            wsdo->pixelStride = 2;
-            wsdo->pixelMasks[0] = 0x1f << 11;
-            wsdo->pixelMasks[1] = 0x3f << 5;
-            wsdo->pixelMasks[2] = 0x1f;
-            break;
-        case 24:
-            wsdo->pixelStride = 3;
-            break;
-        case 32: //x888
-            wsdo->pixelStride = 4;
-            wsdo->pixelMasks[0] = 0xff0000;
-            wsdo->pixelMasks[1] = 0x00ff00;
-            wsdo->pixelMasks[2] = 0x0000ff;
-            break;
-    }
-    wsdo->surfaceLock = new CriticalSection();
-    wsdo->surfaceLost = FALSE;
-    wsdo->transparency = transparency;
-    wsdo->surfacePuntData.usingDDSystem = FALSE;
-    wsdo->surfacePuntData.lpSurfaceSystem = NULL;
-    wsdo->surfacePuntData.lpSurfaceVram = NULL;
-    wsdo->surfacePuntData.numBltsSinceRead = 0;
-    wsdo->surfacePuntData.pixelsReadSinceBlt = 0;
-    wsdo->surfacePuntData.numBltsThreshold = 2;
-    wsdo->gdiOpPending = FALSE;
-}
-
-jboolean init_D3DSDO(JNIEnv* env, Win32SDOps* wsdo, jint width, jint height,
-                     jint d3dSurfaceType, jint screen)
-{
-    // default in case of an error
-    wsdo->lpSurface = NULL;
-    wsdo->ddInstance = NULL;
-
-    {
-        Devices::InstanceAccess devices;
-        wsdo->device = devices->GetDeviceReference(screen, FALSE);
-    }
-    if (wsdo->device == NULL) {
-        J2dTraceLn1(J2D_TRACE_WARNING,
-                    "init_D3DSDO: Incorrect "\
-                    "screen number (screen=%d)", screen);
-        wsdo->invalid = TRUE;
+
+    if (d3dsdo == NULL) {
+        JNU_ThrowOutOfMemoryError(env, "creating native d3d ops");
+        return;
+    }
+
+    d3dsdo->sdOps.Lock       = D3DSD_Lock;
+    d3dsdo->sdOps.GetRasInfo = D3DSD_GetRasInfo;
+    d3dsdo->sdOps.Unlock     = D3DSD_Unlock;
+    d3dsdo->sdOps.Dispose    = D3DSD_Dispose;
+
+    d3dsdo->xoff = 0;
+    d3dsdo->yoff = 0;
+    d3dsdo->width = width;
+    d3dsdo->height = height;
+
+    d3dsdo->pResource = NULL;
+
+    d3dsdo->adapter =
+        (pMgr = D3DPipelineManager::GetInstance()) == NULL ?
+            D3DADAPTER_DEFAULT :
+            pMgr->GetAdapterOrdinalForScreen(gdiScreen);
+}
+
+
+/*
+ * Class:     sun_java2d_d3d_D3DSurfaceData
+ * Method:    initTexture
+ * Signature: (JZZ)Z
+ */
+JNIEXPORT jboolean
+JNICALL Java_sun_java2d_d3d_D3DSurfaceData_initTexture
+  (JNIEnv *env, jobject d3dsd,
+  jlong pData, jboolean isRTT, jboolean isOpaque)
+{
+    HRESULT res;
+    D3DSDOps *d3dsdo;
+    D3DContext *pCtx;
+    D3DPipelineManager *pMgr;
+    D3DFORMAT format;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DSurfaceData_initTexture");
+
+    RETURN_STATUS_IF_NULL(d3dsdo = (D3DSDOps *)jlong_to_ptr(pData), JNI_FALSE);
+    RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), JNI_FALSE);
+
+    if (FAILED(res = pMgr->GetD3DContext(d3dsdo->adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
         return JNI_FALSE;
     }
-    wsdo->w = width;
-    wsdo->h = height;
-    wsdo->surfacePuntData.disablePunts = TRUE;
-    return JNI_TRUE;
+    RETURN_STATUS_IF_NULL(pCtx->GetResourceManager(), JNI_FALSE);
+
+    pCtx->GetResourceManager()->ReleaseResource(d3dsdo->pResource);
+    d3dsdo->pResource = NULL;
+
+    if (isRTT && isOpaque) {
+        format = pCtx->GetPresentationParams()->BackBufferFormat;
+    } else {
+        format = D3DFMT_UNKNOWN;
+    }
+
+    res = pCtx->GetResourceManager()->
+        CreateTexture(d3dsdo->width, d3dsdo->height,
+                      isRTT, isOpaque,
+                      &format, 0/*usage*/, &d3dsdo->pResource);
+    if (SUCCEEDED(res)) {
+        J2dTraceLn1(J2D_TRACE_VERBOSE,
+                    "  created texture pResource=%x", d3dsdo->pResource);
+        d3dsdo->pResource->SetSDOps(d3dsdo);
+    } else {
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+    }
+    D3DSD_SetNativeDimensions(env, d3dsdo);
+
+    return SUCCEEDED(res);
 }
 
 /*
  * Class:     sun_java2d_d3d_D3DSurfaceData
- * Method:    initOffScreenSurface
- * Signature: (JJJIIII)I
+ * Method:    initPlain
+ * Signature: (JZ)Z
  */
-JNIEXPORT jint JNICALL
-Java_sun_java2d_d3d_D3DSurfaceData_initOffScreenSurface
-    (JNIEnv *env, jobject sData,
-     jlong pCtx,
-     jlong pData, jlong parentPdata,
-     jint width, jint height,
-     jint d3dSurfaceType, jint screen)
-{
-    Win32SDOps *wsdo = (Win32SDOps *)jlong_to_ptr(pData);
-    D3DContext *pd3dc = (D3DContext *)jlong_to_ptr(pCtx);
-
-    J2dTraceLn(J2D_TRACE_INFO, "D3DSurfaceData_initOffScreenSurface");
-    J2dTraceLn4(J2D_TRACE_VERBOSE,
-                "  width=%-4d height=%-4d type=%-3d scr=%-3d",
-                width, height, d3dSurfaceType, screen);
-
-    // REMIND: ideally this should be done in initOps
-    if (d3dSurfaceType == D3D_ATTACHED_SURFACE) {
-        wsdo->sdOps.Dispose = Win32BBSD_Dispose;
-    }
-
-    if (init_D3DSDO(env, wsdo, width, height,
-                    d3dSurfaceType, screen) == JNI_FALSE)
-    {
-        SurfaceData_ThrowInvalidPipeException(env,
-            "Can't create offscreen surface");
-        return PF_INVALID;
-    }
-
-    HMONITOR hMon = (HMONITOR)wsdo->device->GetMonitor();
-    DDrawObjectStruct *ddInstance = GetDDInstanceForDevice(hMon);
-    if (!ddInstance || !ddInstance->valid || !pd3dc) {
-        return PF_INVALID;
-    }
-
-    if (d3dSurfaceType == D3D_ATTACHED_SURFACE) {
-        // REMIND: still using the old path. ideally the creation of attached
-        // surface shoudld be done in the same way as other types of surfaces,
-        // that is, in D3DContext::CreateSurface, but we really don't use
-        // anything from D3DContext to get an attached surface, so this
-        // was left here.
-
-        Win32SDOps *wsdo_parent = (Win32SDOps *)jlong_to_ptr(parentPdata);
-        // we're being explicit here: requesting backbuffer, and render target
-        DDrawSurface* pNew = wsdo_parent->lpSurface == NULL ?
-            NULL :
-            wsdo_parent->lpSurface->
-                GetDDAttachedSurface(DDSCAPS_BACKBUFFER|DDSCAPS_3DDEVICE);
-        if (pNew == NULL ||
-            FAILED(pd3dc->AttachDepthBuffer(pNew->GetDXSurface())))
-        {
-            J2dRlsTraceLn1(J2D_TRACE_ERROR,
-                           "D3DSD_initSurface: GetAttachedSurface for parent"\
-                           " wsdo_parent->lpSurface=0x%x failed",
-                           wsdo_parent->lpSurface);
-            if (pNew != NULL) {
-                delete pNew;
-            }
-            SurfaceData_ThrowInvalidPipeException(env,
-                "Can't create attached offscreen surface");
-            return PF_INVALID;
-        }
+JNIEXPORT jboolean JNICALL
+Java_sun_java2d_d3d_D3DSurfaceData_initRTSurface
+  (JNIEnv *env, jobject d3dsd, jlong pData, jboolean isOpaque)
+{
+    HRESULT res;
+    D3DSDOps *d3dsdo;
+    D3DContext *pCtx;
+    D3DPipelineManager *pMgr;
+    D3DFORMAT format = D3DFMT_UNKNOWN;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DSurfaceData_initRTSurface");
+
+    RETURN_STATUS_IF_NULL(d3dsdo = (D3DSDOps *)jlong_to_ptr(pData), JNI_FALSE);
+    RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), JNI_FALSE);
+
+    if (FAILED(res = pMgr->GetD3DContext(d3dsdo->adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+        return JNI_FALSE;
+    }
+    RETURN_STATUS_IF_NULL(pCtx->GetResourceManager(), JNI_FALSE);
+
+    pCtx->GetResourceManager()->ReleaseResource(d3dsdo->pResource);
+    d3dsdo->pResource = NULL;
 
-        wsdo->lpSurface = pNew;
-        wsdo->ddInstance = ddInstance;
-        J2dTraceLn2(J2D_TRACE_VERBOSE,
-                    "D3DSD_initSurface: created attached surface: "\
-                    "wsdo->lpSurface=0x%x for parent "\
-                    "wsdo_parent->lpSurface=0x%x",
-                    wsdo->lpSurface, wsdo_parent->lpSurface);
-        // we don't care about pixel format for non-texture surfaces
-        return PF_INVALID;
+    res = pCtx->GetResourceManager()->
+            CreateRTSurface(d3dsdo->width, d3dsdo->height,
+                            isOpaque, FALSE /*lockable*/,
+                            &format, &d3dsdo->pResource);
+    if (SUCCEEDED(res)) {
+        J2dTraceLn1(J2D_TRACE_VERBOSE, "  created RT surface pResource=0x%x",
+                    d3dsdo->pResource);
+        d3dsdo->pResource->SetSDOps(d3dsdo);
+    } else {
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
     }
+    D3DSD_SetNativeDimensions(env, d3dsdo);
+
+    return SUCCEEDED(res);
+}
 
-    DXSurface *dxSurface = NULL;
-    jint pf = PF_INVALID;
+/*
+ * Class:     sun_java2d_d3d_D3DSurfaceData
+ * Method:    initFlipBackbuffer
+ * Signature: (JJIZ)Z
+ */
+JNIEXPORT jboolean
+JNICALL Java_sun_java2d_d3d_D3DSurfaceData_initFlipBackbuffer
+  (JNIEnv *env, jobject d3dsd, jlong pData, jlong pPeerData,
+  jint numBuffers, jint swapEffect,
+  jint vSyncType)
+{
     HRESULT res;
-    if (SUCCEEDED(res = pd3dc->CreateSurface(env, wsdo->w, wsdo->h,
-                                             wsdo->depth, wsdo->transparency,
-                                             d3dSurfaceType,
-                                             &dxSurface, &pf)))
-    {
-        // REMIND: put all the error-handling stuff here from
-        // DDCreateOffScreenSurface
-        wsdo->lpSurface = new DDrawSurface(ddInstance->ddObject, dxSurface);
-        wsdo->surfacePuntData.lpSurfaceVram = wsdo->lpSurface;
-        wsdo->ddInstance = ddInstance;
-        // the dimensions of the surface may be adjusted in case of
-        // textures
-        wsdo->w = dxSurface->GetWidth();
-        wsdo->h = dxSurface->GetHeight();
-        J2dTraceLn1(J2D_TRACE_VERBOSE,
-                    "D3DSurfaceData_initSurface: created surface: "\
-                    "wsdo->lpSurface=0x%x", wsdo->lpSurface);
+    D3DSDOps *d3dsdo;
+    D3DContext *pCtx;
+    D3DPipelineManager *pMgr;
+    HWND hWnd;
+    UINT presentationInterval;
+    AwtComponent *pPeer;
+    RECT r = { 0, 0, 0, 0 };
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DSurfaceData_initFlipBackbuffer");
+
+    RETURN_STATUS_IF_NULL(d3dsdo = (D3DSDOps *)jlong_to_ptr(pData), JNI_FALSE);
+    RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), JNI_FALSE);
+    RETURN_STATUS_IF_NULL(pPeer = (AwtComponent *)jlong_to_ptr(pPeerData),
+                          JNI_FALSE);
+
+    hWnd = pPeer->GetHWnd();
+    if (!IsWindow(hWnd)) {
+        J2dTraceLn(J2D_TRACE_WARNING,
+                   "D3DSurfaceData_initFlipBackbuffer: disposed component");
+        return JNI_FALSE;
+    }
+
+    pPeer->GetInsets(&r);
+    d3dsdo->xoff = -r.left;
+    d3dsdo->yoff = -r.top;
+
+    if (FAILED(res = pMgr->GetD3DContext(d3dsdo->adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+        return JNI_FALSE;
+    }
+    RETURN_STATUS_IF_NULL(pCtx->GetResourceManager(), JNI_FALSE);
+
+    pCtx->GetResourceManager()->ReleaseResource(d3dsdo->pResource);
+    d3dsdo->pResource = NULL;
+
+    d3dsdo->swapEffect = (D3DSWAPEFFECT)swapEffect;
+
+    // in full-screen mode we should v-sync
+    if (pCtx->GetPresentationParams()->Windowed) {
+        if (vSyncType == VSYNC_ON) {
+            presentationInterval = D3DPRESENT_INTERVAL_ONE;
+            J2dTraceLn(J2D_TRACE_VERBOSE,
+                       "  windowed, forced interval: ONE");
+        } else {
+            presentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
+            J2dTraceLn(J2D_TRACE_VERBOSE,
+                       "  windowed, default interval: IMMEDIATE");
+        }
+
+        // REMIND: this is a workaround for the current issue
+        // we have with non-copy flip chains: since we can not specify
+        // the dest rectangle for Present for these modes, the result of
+        // Present(NULL, NULL) is scaled to the client area.
+        if (d3dsdo->xoff != 0 || d3dsdo->yoff != 0) {
+            d3dsdo->swapEffect = D3DSWAPEFFECT_COPY;
+        }
+    } else {
+        if (vSyncType == VSYNC_OFF) {
+            presentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
+            J2dTraceLn(J2D_TRACE_VERBOSE,
+                       "  full-screen, forced interval: IMMEDIATE");
+        } else {
+            presentationInterval = D3DPRESENT_INTERVAL_ONE;
+            J2dTraceLn(J2D_TRACE_VERBOSE,
+                       "  full-screen, default interval: ONE");
+        }
+    }
+
+    res = pCtx->GetResourceManager()->
+        CreateSwapChain(hWnd, numBuffers,
+                        d3dsdo->width, d3dsdo->height,
+                        d3dsdo->swapEffect, presentationInterval,
+                        &d3dsdo->pResource);
+    if (SUCCEEDED(res)) {
+        J2dTraceLn1(J2D_TRACE_VERBOSE, "  created swap chain pResource=0x%x",
+                    d3dsdo->pResource);
+        d3dsdo->pResource->SetSDOps(d3dsdo);
     } else {
-        DebugPrintDirectDrawError(res,
-                                  "D3DSurfaceData_initSurface: "\
-                                  "CreateSurface failed");
-        // REMIND: should use some other way to signal that
-        // surface creation was unsuccessful
-        SurfaceData_ThrowInvalidPipeException(env,
-                                              "Can't create offscreen surf");
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
     }
-    return pf;
+    D3DSD_SetNativeDimensions(env, d3dsdo);
+
+    return SUCCEEDED(res);
 }
 
 /*
- * Class:     sun_java2d_d3d_D3DBackBufferSurfaceData
- * Method:    restoreDepthBuffer
- * Signature: ()V
- */
-JNIEXPORT void JNICALL
-Java_sun_java2d_d3d_D3DBackBufferSurfaceData_restoreDepthBuffer(JNIEnv *env,
-                                                                jobject sData)
-{
-    Win32SDOps *wsdo = Win32SurfaceData_GetOpsNoSetup(env, sData);
-    J2dTraceLn1(J2D_TRACE_INFO,
-                "D3DBBSD_restoreDepthBuffer: wsdo=0x%x", wsdo);
-
-    if (wsdo != NULL) {
-        if (!DDRestoreSurface(wsdo)) {
-            // Failure - throw exception
-            J2dRlsTraceLn(J2D_TRACE_ERROR,
-                          "D3DBBSD_restoreDepthBuffer: failed to "\
-                          "restore depth buffer");
+ * Class:     sun_java2d_d3d_D3DSurfaceData
+ * Method:    dbGetPixelNative
+ * Signature: (JII)I
+ */
+JNIEXPORT jint JNICALL Java_sun_java2d_d3d_D3DSurfaceData_dbGetPixelNative
+  (JNIEnv *env, jclass clazz, jlong pData, jint x, jint y)
+{
+    HRESULT res;
+    D3DSDOps *d3dsdo;
+    D3DContext *pCtx;
+    D3DPipelineManager *pMgr;
+    D3DResource *pLockableRes;
+    jint pixel = 0;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DSurfaceData_dbGetPixelNative");
+
+    RETURN_STATUS_IF_NULL(d3dsdo = (D3DSDOps *)jlong_to_ptr(pData), pixel);
+    RETURN_STATUS_IF_NULL(d3dsdo->pResource, pixel);
+    RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), pixel);
+
+    if (FAILED(res = pMgr->GetD3DContext(d3dsdo->adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+        return pixel;
+    }
+    RETURN_STATUS_IF_NULL(pCtx->GetResourceManager(), 0);
+
+    IDirect3DDevice9 *pd3dDevice = pCtx->Get3DDevice();
+    IDirect3DSurface9 *pSrc = d3dsdo->pResource->GetSurface();
+    D3DFORMAT srcFmt = d3dsdo->pResource->GetDesc()->Format;
+
+    pCtx->UpdateState(STATE_OTHEROP);
+
+    res = pCtx->GetResourceManager()->
+            GetLockableRTSurface(1, 1, srcFmt, &pLockableRes);
+    if (SUCCEEDED(res)) {
+        IDirect3DSurface9 *pTmpSurface;
+        RECT srcRect = { x, y, x+1, y+1};
+        RECT dstRect = { 0l, 0l, 1, 1 };
+
+        pTmpSurface = pLockableRes->GetSurface();
+        res = pd3dDevice->StretchRect(pSrc, &srcRect, pTmpSurface, &dstRect,
+                                      D3DTEXF_NONE);
+        if (SUCCEEDED(res)) {
+            D3DLOCKED_RECT lRect;
+
+            res = pTmpSurface->LockRect(&lRect, &dstRect, D3DLOCK_NOSYSLOCK);
+            if (SUCCEEDED(res)) {
+                if (srcFmt == D3DFMT_X8R8G8B8) {
+                    pixel = *(jint*)lRect.pBits;
+                } else {
+                    pixel = *(unsigned short*)lRect.pBits;
+                }
+                pTmpSurface->UnlockRect();
+            }
+        }
+    }
+    D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+
+    return pixel;
+}
+
+/*
+ * Class:     sun_java2d_d3d_D3DSurfaceData
+ * Method:    dbSetPixelNative
+ * Signature: (JIII)V
+ */
+JNIEXPORT void JNICALL Java_sun_java2d_d3d_D3DSurfaceData_dbSetPixelNative
+  (JNIEnv *env, jclass clazz, jlong pData, jint x, jint y, jint pixel)
+{
+    HRESULT res;
+    D3DSDOps *d3dsdo;
+    D3DResource *pLockableRes;
+    D3DContext *pCtx;
+    D3DPipelineManager *pMgr;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DSurfaceData_dbSetPixelNative");
+
+    RETURN_IF_NULL(d3dsdo = (D3DSDOps *)jlong_to_ptr(pData));
+    RETURN_IF_NULL(d3dsdo->pResource);
+    RETURN_IF_NULL(pMgr = D3DPipelineManager::GetInstance());
+
+    if (FAILED(res = pMgr->GetD3DContext(d3dsdo->adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+        return;
+    }
+    RETURN_IF_NULL(pCtx->GetResourceManager());
+
+    IDirect3DDevice9 *pd3dDevice = pCtx->Get3DDevice();
+    IDirect3DSurface9 *pSrc = d3dsdo->pResource->GetSurface();
+    D3DFORMAT srcFmt = d3dsdo->pResource->GetDesc()->Format;
+
+    pCtx->UpdateState(STATE_OTHEROP);
+
+    res = pCtx->GetResourceManager()->
+            GetLockableRTSurface(1, 1, srcFmt, &pLockableRes);
+    if (SUCCEEDED(res)) {
+        IDirect3DSurface9 *pTmpSurface;
+        D3DLOCKED_RECT lRect;
+        RECT srcRect = { 0l, 0l, 1, 1 };
+        RECT dstRect = { x, y, x+1, y+1};
+
+        pTmpSurface = pLockableRes->GetSurface();
+        res = pTmpSurface->LockRect(&lRect, &srcRect, D3DLOCK_NOSYSLOCK);
+        if (SUCCEEDED(res)) {
+            if (srcFmt == D3DFMT_X8R8G8B8) {
+                *(jint*)lRect.pBits = pixel;
+            } else {
+                *(unsigned short*)lRect.pBits = (unsigned short)pixel;
+            }
+            pTmpSurface->UnlockRect();
 
-            SurfaceData_ThrowInvalidPipeException(env,
-                                                  "RestoreDepthBuffer failure");
+            res = pd3dDevice->StretchRect(pTmpSurface, &srcRect, pSrc, &dstRect,
+                                          D3DTEXF_NONE);
         }
     }
+    D3DRQ_MarkLostIfNeeded(res, d3dsdo);
 }
 
+/*
+ * Class:     sun_java2d_d3d_D3DSurfaceData
+ * Method:    getNativeResourceNative
+ * Signature: (JI)J
+ */
+JNIEXPORT jlong JNICALL
+    Java_sun_java2d_d3d_D3DSurfaceData_getNativeResourceNative
+        (JNIEnv *env, jclass d3sdc, jlong pData, jint resType)
+{
+    D3DSDOps *d3dsdo;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DSurfaceData_getNativeResourceNative")
+
+    RETURN_STATUS_IF_NULL(d3dsdo = (D3DSDOps *)jlong_to_ptr(pData), 0L);
+
+    if (resType == D3D_DEVICE_RESOURCE) {
+        HRESULT res;
+        D3DPipelineManager *pMgr;
+        D3DContext *pCtx;
+
+        RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), 0L);
+        if (FAILED(res = pMgr->GetD3DContext(d3dsdo->adapter, &pCtx))) {
+            D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+            return 0L;
+        }
+        return ptr_to_jlong(pCtx->Get3DDevice());
+    }
+
+    RETURN_STATUS_IF_NULL(d3dsdo->pResource, 0L);
+
+    if (resType == RT_PLAIN || resType == RT_TEXTURE) {
+        return ptr_to_jlong(d3dsdo->pResource->GetSurface());
+    }
+    if (resType == TEXTURE) {
+        return ptr_to_jlong(d3dsdo->pResource->GetTexture());
+    }
+    if (resType == FLIP_BACKBUFFER) {
+        return ptr_to_jlong(d3dsdo->pResource->GetSwapChain());
+    }
+
+    return 0L;
+}
+
+/*
+ * Class:     sun_java2d_d3d_D3DSurfaceData
+ * Method:    updateWindowAccelImpl
+ * Signature: (JJII)Z
+ */
+JNIEXPORT jboolean
+JNICALL Java_sun_java2d_d3d_D3DSurfaceData_updateWindowAccelImpl
+  (JNIEnv *env, jclass clazz, jlong pd3dsd, jlong pData, jint w, jint h)
+{
+    HRESULT res;
+    AwtWindow *window;
+    HBITMAP hBitmap = NULL;
+    D3DSDOps *d3dsdo;
+    D3DResource *pSrcRes;
+    D3DContext *pCtx;
+    D3DPipelineManager *pMgr;
+    D3DResource *pLockableRes = NULL;
+    IDirect3DSurface9 *pTmpSurface = NULL;
+    IDirect3DDevice9 *pd3dDevice = NULL;
+    D3DLOCKED_RECT lockedRect;
+
+    J2dTraceLn(J2D_TRACE_ERROR, "D3DSurfaceData_updateWindowAccelImpl");
+
+    if (w <= 0 || h <= 0) {
+        return JNI_TRUE;
+    }
+
+    RETURN_STATUS_IF_NULL(window = (AwtWindow *)jlong_to_ptr(pData), JNI_FALSE);
+    RETURN_STATUS_IF_NULL(d3dsdo = (D3DSDOps *)jlong_to_ptr(pd3dsd), JNI_FALSE);
+    RETURN_STATUS_IF_NULL(pMgr = D3DPipelineManager::GetInstance(), JNI_FALSE);
+    RETURN_STATUS_IF_NULL(pSrcRes = d3dsdo->pResource, JNI_FALSE);
+
+    if (FAILED(res = pMgr->GetD3DContext(d3dsdo->adapter, &pCtx))) {
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+        return JNI_FALSE;
+    }
+
+    RETURN_STATUS_IF_NULL(pd3dDevice = pCtx->Get3DDevice(), JNI_FALSE);
+    pCtx->UpdateState(STATE_OTHEROP);
+
+    res = pCtx->GetResourceManager()->
+            GetBlitOSPSurface(pSrcRes->GetDesc()->Width,
+                              pSrcRes->GetDesc()->Height,
+                              pSrcRes->GetDesc()->Format,
+                              &pLockableRes);
+    if (FAILED(res)) {
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+        return JNI_FALSE;
+    }
+    pTmpSurface = pLockableRes->GetSurface();
+
+    res = pd3dDevice->GetRenderTargetData(pSrcRes->GetSurface(), pTmpSurface);
+    if (FAILED(res)) {
+        D3DRQ_MarkLostIfNeeded(res, d3dsdo);
+        return JNI_FALSE;
+    }
+
+    res = pTmpSurface->LockRect(&lockedRect, NULL, D3DLOCK_NOSYSLOCK);
+    if (SUCCEEDED(res)) {
+        // REMIND: commented until translucent window support is integrated
+//        hBitmap =
+//            BitmapUtil::CreateBitmapFromARGBPre(w, h,
+//                                                lockedRect.Pitch,
+//                                                (int*)lockedRect.pBits);
+        pTmpSurface->UnlockRect();
+    }
+    RETURN_STATUS_IF_NULL(hBitmap, JNI_FALSE);
+
+    // REMIND: commented until translucent window support is integrated
+//    window->UpdateWindow(env, NULL, w, h, hBitmap);
+
+    // hBitmap is released in UpdateWindow
+
+    return JNI_TRUE;
+}
 }
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DSurfaceData.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DSurfaceData.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DSurfaceData.h	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DSurfaceData.h	2011-01-08 01:26:50.483202340 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,45 +23,71 @@
  * questions.
  */
 
-#ifndef D3DSurfaceData_h_Included
-#define D3DSurfaceData_h_Included
+#ifndef _D3DSURFACEDATA_H_
+#define _D3DSURFACEDATA_H_
 
 #include "java_awt_image_AffineTransformOp.h"
 #include "sun_java2d_d3d_D3DSurfaceData.h"
-#include "Win32SurfaceData.h"
-
-// Shortcut macros
-
-#define D3D_PLAIN_SURFACE      sun_java2d_d3d_D3DSurfaceData_D3D_PLAIN_SURFACE
-#define D3D_TEXTURE_SURFACE    sun_java2d_d3d_D3DSurfaceData_D3D_TEXTURE_SURFACE
-#define D3D_BACKBUFFER_SURFACE sun_java2d_d3d_D3DSurfaceData_D3D_BACKBUFFER_SURFACE
-#define D3D_RTT_SURFACE        sun_java2d_d3d_D3DSurfaceData_D3D_RTT_SURFACE
-
-#define D3D_RENDER_TARGET      sun_java2d_d3d_D3DSurfaceData_D3D_RENDER_TARGET
-#define D3D_ATTACHED_SURFACE   sun_java2d_d3d_D3DSurfaceData_D3D_ATTACHED_SURFACE
-
-#define PF_INVALID          sun_java2d_d3d_D3DSurfaceData_PF_INVALID
-#define PF_INT_ARGB         sun_java2d_d3d_D3DSurfaceData_PF_INT_ARGB
-#define PF_INT_RGB          sun_java2d_d3d_D3DSurfaceData_PF_INT_RGB
-#define PF_INT_RGBX         sun_java2d_d3d_D3DSurfaceData_PF_INT_RGBX
-#define PF_INT_BGR          sun_java2d_d3d_D3DSurfaceData_PF_INT_BGR
-#define PF_USHORT_565_RGB   sun_java2d_d3d_D3DSurfaceData_PF_USHORT_565_RGB
-#define PF_USHORT_555_RGB   sun_java2d_d3d_D3DSurfaceData_PF_USHORT_555_RGB
-#define PF_USHORT_555_RGBX  sun_java2d_d3d_D3DSurfaceData_PF_USHORT_555_RGBX
-#define PF_INT_ARGB_PRE     sun_java2d_d3d_D3DSurfaceData_PF_INT_ARGB_PRE
-#define PF_USHORT_4444_ARGB sun_java2d_d3d_D3DSurfaceData_PF_USHORT_4444_ARGB
+#include "sun_java2d_pipe_hw_AccelSurface.h"
+#include "SurfaceData.h"
+#include <d3d9.h>
 
 typedef struct _D3DSDOps D3DSDOps;
 
+class D3DResource;
+
 struct _D3DSDOps {
-    Win32SDOps dxOps;
-    jint d3dType; // surface type (plain/texture/bb/rtt) - see D3DSurfaceData.java
+    SurfaceDataOps sdOps;
+
+    // the ordinal of the d3d adapter this surface belongs to
+    // (may be different from GDI display number)
+    jint adapter;
+    jint width, height;
+
+    // backbuffer-related data
+    jint xoff, yoff;
+    D3DSWAPEFFECT swapEffect;
+
+    D3DResource  *pResource;
 };
 
+#define UNDEFINED       sun_java2d_pipe_hw_AccelSurface_UNDEFINED
+#define RT_PLAIN        sun_java2d_pipe_hw_AccelSurface_RT_PLAIN
+#define TEXTURE         sun_java2d_pipe_hw_AccelSurface_TEXTURE
+#define RT_TEXTURE      sun_java2d_pipe_hw_AccelSurface_RT_TEXTURE
+#define FLIP_BACKBUFFER sun_java2d_pipe_hw_AccelSurface_FLIP_BACKBUFFER
+#define D3D_DEVICE_RESOURCE \
+                        sun_java2d_d3d_D3DSurfaceData_D3D_DEVICE_RESOURCE
+
+#define ST_INT_ARGB        sun_java2d_d3d_D3DSurfaceData_ST_INT_ARGB
+#define ST_INT_ARGB_PRE    sun_java2d_d3d_D3DSurfaceData_ST_INT_ARGB_PRE
+#define ST_INT_ARGB_BM     sun_java2d_d3d_D3DSurfaceData_ST_INT_ARGB_BM
+#define ST_INT_RGB         sun_java2d_d3d_D3DSurfaceData_ST_INT_RGB
+#define ST_INT_BGR         sun_java2d_d3d_D3DSurfaceData_ST_INT_BGR
+#define ST_USHORT_565_RGB  sun_java2d_d3d_D3DSurfaceData_ST_USHORT_565_RGB
+#define ST_USHORT_555_RGB  sun_java2d_d3d_D3DSurfaceData_ST_USHORT_555_RGB
+#define ST_BYTE_INDEXED    sun_java2d_d3d_D3DSurfaceData_ST_BYTE_INDEXED
+#define ST_BYTE_INDEXED_BM sun_java2d_d3d_D3DSurfaceData_ST_BYTE_INDEXED_BM
+
+/**
+ * These are defined to be the same as ExtendedBufferCapabilities.VSyncType
+ * enum.
+ */
+#define VSYNC_DEFAULT 0
+#define VSYNC_ON      1
+#define VSYNC_OFF     2
+
+/**
+ * These are shorthand names for the filtering method constants used by
+ * image transform methods.
+ */
+#define D3DSD_XFORM_DEFAULT 0
 #define D3DSD_XFORM_NEAREST_NEIGHBOR \
     java_awt_image_AffineTransformOp_TYPE_NEAREST_NEIGHBOR
 #define D3DSD_XFORM_BILINEAR \
     java_awt_image_AffineTransformOp_TYPE_BILINEAR
 
+void D3DSD_Flush(void *pData);
+void D3DSD_MarkLost(void *pData);
 
-#endif /* D3DSurfaceData_h_Included */
+#endif /* _D3DSURFACEDATA_H_ */
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DTextRenderer.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DTextRenderer.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DTextRenderer.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DTextRenderer.cpp	2011-01-08 01:26:50.487202383 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,109 +24,888 @@
  */
 
 #include <malloc.h>
+#include <math.h>
+#include <jlong.h>
+
 #include "sun_java2d_d3d_D3DTextRenderer.h"
+#include "sun_java2d_pipe_BufferedTextPipe.h"
+
 #include "SurfaceData.h"
-#include "Region.h"
-#include "glyphblitting.h"
+#include "D3DContext.h"
+#include "D3DSurfaceData.h"
+#include "D3DRenderQueue.h"
+#include "D3DTextRenderer.h"
+#include "D3DGlyphCache.h"
+#include "AccelGlyphCache.h"
+#include "fontscalerdefs.h"
+
+/**
+ * The current "glyph mode" state.  This variable is used to track the
+ * codepath used to render a particular glyph.  This variable is reset to
+ * MODE_NOT_INITED at the beginning of every call to D3DTR_DrawGlyphList().
+ * As each glyph is rendered, the glyphMode variable is updated to reflect
+ * the current mode, so if the current mode is the same as the mode used
+ * to render the previous glyph, we can avoid doing costly setup operations
+ * each time.
+ */
+typedef enum {
+    MODE_NOT_INITED,
+    MODE_USE_CACHE_GRAY,
+    MODE_USE_CACHE_LCD,
+    MODE_NO_CACHE_GRAY,
+    MODE_NO_CACHE_LCD
+} GlyphMode;
+static GlyphMode glyphMode = MODE_NOT_INITED;
+
+/**
+ * The current bounds of the "cached destination" texture, in destination
+ * coordinate space.  The width/height of these bounds will not exceed the
+ * D3DTR_CACHED_DEST_WIDTH/HEIGHT values defined above.  These bounds are
+ * only considered valid when the isCachedDestValid flag is JNI_TRUE.
+ */
+static SurfaceDataBounds cachedDestBounds;
+
+/**
+ * This flag indicates whether the "cached destination" texture contains
+ * valid data.  This flag is reset to JNI_FALSE at the beginning of every
+ * call to D3DTR_DrawGlyphList().  Once we copy valid destination data
+ * into the cached texture, this flag is set to JNI_TRUE.  This way, we
+ * can limit the number of times we need to copy destination data, which
+ * is a very costly operation.
+ */
+static jboolean isCachedDestValid = JNI_FALSE;
+
+/**
+ * The bounds of the previously rendered LCD glyph, in destination
+ * coordinate space.  We use these bounds to determine whether the glyph
+ * currently being rendered overlaps the previously rendered glyph (i.e.
+ * its bounding box intersects that of the previously rendered glyph).
+ * If so, we need to re-read the destination area associated with that
+ * previous glyph so that we can correctly blend with the actual
+ * destination data.
+ */
+static SurfaceDataBounds previousGlyphBounds;
+
+/**
+ * Updates the gamma and inverse gamma values for the LCD text shader.
+ */
+static HRESULT
+D3DTR_UpdateLCDTextContrast(D3DContext *d3dc, jint contrast)
+{
+    HRESULT res;
+    IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+
+    jfloat fcon = ((jfloat)contrast) / 100.0f;
+    jfloat invgamma = fcon;
+    jfloat gamma = 1.0f / invgamma;
+    jfloat vals[4];
+
+    // update the "invgamma" parameter of the shader program
+    vals[0] = invgamma;
+    vals[1] = invgamma;
+    vals[2] = invgamma;
+    vals[3] = 0.0f; // unused
+    pd3dDevice->SetPixelShaderConstantF(1, vals, 1);
+
+    // update the "gamma" parameter of the shader program
+    vals[0] = gamma;
+    vals[1] = gamma;
+    vals[2] = gamma;
+    vals[3] = 0.0f; // unused
+    res = pd3dDevice->SetPixelShaderConstantF(2, vals, 1);
+
+    return res;
+}
+
+/**
+ * Updates the current gamma-adjusted source color ("src_adj") of the LCD
+ * text shader program.  Note that we could calculate this value in the
+ * shader (e.g. just as we do for "dst_adj"), but would be unnecessary work
+ * (and a measurable performance hit, maybe around 5%) since this value is
+ * constant over the entire glyph list.  So instead we just calculate the
+ * gamma-adjusted value once and update the uniform parameter of the LCD
+ * shader as needed.
+ */
+static HRESULT
+D3DTR_UpdateLCDTextColor(D3DContext *d3dc, jint contrast)
+{
+    IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+    jfloat gamma = ((jfloat)contrast) / 100.0f;
+    jfloat clr[4];
+
+    J2dTraceLn1(J2D_TRACE_INFO,
+                "D3DTR_UpdateLCDTextColor: contrast=%d", contrast);
+
+    /*
+     * Note: Ideally we would update the "srcAdj" uniform parameter only
+     * when there is a change in the source color.  Fortunately, the cost
+     * of querying the current D3D color state and updating the uniform
+     * value is quite small, and in the common case we only need to do this
+     * once per GlyphList, so we gain little from trying to optimize too
+     * eagerly here.
+     */
+
+    // get the current D3D primary color state
+    jint color = d3dc->pVCacher->GetColor();
+    clr[0] = (jfloat)((color >> 16) & 0xff) / 255.0f;
+    clr[1] = (jfloat)((color >>  8) & 0xff) / 255.0f;
+    clr[2] = (jfloat)((color >>  0) & 0xff) / 255.0f;
+    clr[3] = 0.0f; // unused
+
+    // gamma adjust the primary color
+    clr[0] = (jfloat)pow(clr[0], gamma);
+    clr[1] = (jfloat)pow(clr[1], gamma);
+    clr[2] = (jfloat)pow(clr[2], gamma);
+
+    // update the "srcAdj" parameter of the shader program with this value
+    return pd3dDevice->SetPixelShaderConstantF(0, clr, 1);
+}
+
+/**
+ * Enables the LCD text shader and updates any related state, such as the
+ * gamma values.
+ */
+static HRESULT
+D3DTR_EnableLCDGlyphModeState(D3DContext *d3dc, D3DSDOps *dstOps,
+                              jboolean useCache, jint contrast)
+{
+    D3DResource *pGlyphTexRes, *pCachedDestTexRes;
+    IDirect3DTexture9 *pGlyphTex, *pCachedDestTex;
+
+    RETURN_STATUS_IF_NULL(dstOps->pResource, E_FAIL);
+
+    HRESULT res = S_OK;
+    if (useCache) {
+        // glyph cache had been already initialized
+        pGlyphTexRes = d3dc->GetLCDGlyphCache()->GetGlyphCacheTexture();
+    } else {
+        res = d3dc->GetResourceManager()->GetBlitTexture(&pGlyphTexRes);
+    }
+    RETURN_STATUS_IF_FAILED(res);
 
-extern "C" {
+    pGlyphTex = pGlyphTexRes->GetTexture();
 
-#ifndef D3D_GCACHE_WIDTH
-  #define D3D_GCACHE_WIDTH 512
-  #define D3D_GCACHE_HEIGHT 512
-  #define D3D_GCACHE_CELL_WIDTH 16
-  #define D3D_GCACHE_CELL_HEIGHT 16
-#endif
-
-/**
- * This method is almost exactly the same as the RefineBounds() method
- * defined in DrawGlyphList.c.  The goal is to determine whether the given
- * GlyphBlitVector intersects with the given bounding box.  If any part of
- * the GBV intersects with the bounding box, this method returns true;
- * otherwise false is returned.  The only step that differs in this method
- * from RefineBounds() is that we check to see whether all the glyphs in
- * the GBV will fit in the glyph cache.  If any glyph is too big for a
- * glyph cache cell, we return FALSE in the useCache out parameter; otherwise
- * useCache is TRUE, indicating that the caller can be assured that all
- * the glyphs can be stored in the accelerated glyph cache.
- */
-jboolean
-D3DRefineBounds(GlyphBlitVector *gbv, SurfaceDataBounds *bounds,
-                jboolean *useCache)
+    res = d3dc->GetResourceManager()->
+        GetCachedDestTexture(dstOps->pResource->GetDesc()->Format,
+                             &pCachedDestTexRes);
+    RETURN_STATUS_IF_FAILED(res);
+    pCachedDestTex = pCachedDestTexRes->GetTexture();
+
+    IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+    D3DTEXTUREFILTERTYPE fhint =
+        d3dc->IsTextureFilteringSupported(D3DTEXF_NONE) ?
+        D3DTEXF_NONE : D3DTEXF_POINT;
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, fhint);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, fhint);
+    pd3dDevice->SetSamplerState(1, D3DSAMP_MAGFILTER, fhint);
+    pd3dDevice->SetSamplerState(1, D3DSAMP_MINFILTER, fhint);
+    d3dc->UpdateTextureColorState(D3DTA_TEXTURE, 1);
+
+    // bind the texture containing glyph data to texture unit 0
+    d3dc->SetTexture(pGlyphTex, 0);
+
+    // bind the texture tile containing destination data to texture unit 1
+    d3dc->SetTexture(pCachedDestTex, 1);
+
+    // create/enable the LCD text shader
+    res = d3dc->EnableLCDTextProgram();
+    RETURN_STATUS_IF_FAILED(res);
+
+    // update the current contrast settings (note: these change very rarely,
+    // but it seems that D3D pixel shader registers aren't maintained as
+    // part of the pixel shader instance, so we need to update these
+    // everytime around in case another shader blew away the contents
+    // of those registers)
+    D3DTR_UpdateLCDTextContrast(d3dc, contrast);
+
+    // update the current color settings
+    return D3DTR_UpdateLCDTextColor(d3dc, contrast);
+}
+
+HRESULT
+D3DTR_EnableGlyphVertexCache(D3DContext *d3dc)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DTR_EnableGlyphVertexCache");
+
+    IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+    D3DTEXTUREFILTERTYPE fhint =
+        d3dc->IsTextureFilteringSupported(D3DTEXF_NONE) ?
+        D3DTEXF_NONE : D3DTEXF_POINT;
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, fhint);
+    pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, fhint);
+
+    // glyph cache had been successfully initialized if we got here
+    D3DResource *pGlyphCacheTexRes =
+        d3dc->GetGrayscaleGlyphCache()->GetGlyphCacheTexture();
+    return d3dc->SetTexture(pGlyphCacheTexRes->GetTexture(), 0);
+}
+
+HRESULT
+D3DTR_DisableGlyphVertexCache(D3DContext *d3dc)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "D3DTR_DisableGlyphVertexCache");
+
+    return d3dc->SetTexture(NULL, 0);
+}
+
+/**
+ * Disables any pending state associated with the current "glyph mode".
+ */
+static HRESULT
+D3DTR_DisableGlyphModeState(D3DContext *d3dc)
+{
+    HRESULT res = S_OK;
+    IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+
+    switch (glyphMode) {
+    case MODE_NO_CACHE_LCD:
+    case MODE_USE_CACHE_LCD:
+        d3dc->FlushVertexQueue();
+        pd3dDevice->SetPixelShader(NULL);
+        res = d3dc->SetTexture(NULL, 1);
+        break;
+
+    case MODE_NO_CACHE_GRAY:
+    case MODE_USE_CACHE_GRAY:
+    case MODE_NOT_INITED:
+    default:
+        break;
+    }
+    return res;
+}
+
+static HRESULT
+D3DTR_DrawGrayscaleGlyphViaCache(D3DContext *d3dc,
+                                 GlyphInfo *ginfo, jint x, jint y)
+{
+    HRESULT res = S_OK;
+    D3DGlyphCache *pGrayscaleGCache;
+    CacheCellInfo *cell;
+    GlyphCacheInfo *gcache;
+    jfloat x1, y1, x2, y2;
+
+    J2dTraceLn(J2D_TRACE_VERBOSE, "D3DTR_DrawGrayscaleGlyphViaCache");
+
+    if (glyphMode != MODE_USE_CACHE_GRAY) {
+        D3DTR_DisableGlyphModeState(d3dc);
+
+        res = d3dc->BeginScene(STATE_GLYPHOP);
+        RETURN_STATUS_IF_FAILED(res);
+
+        glyphMode = MODE_USE_CACHE_GRAY;
+    }
+
+    pGrayscaleGCache = d3dc->GetGrayscaleGlyphCache();
+    gcache = pGrayscaleGCache->GetGlyphCache();
+    cell = AccelGlyphCache_GetCellInfoForCache(ginfo, gcache);
+    if (cell == NULL) {
+        // attempt to add glyph to accelerated glyph cache
+        res = pGrayscaleGCache->AddGlyph(ginfo);
+        RETURN_STATUS_IF_FAILED(res);
+
+        cell = AccelGlyphCache_GetCellInfoForCache(ginfo, gcache);
+        RETURN_STATUS_IF_NULL(cell, E_FAIL);
+    }
+
+    cell->timesRendered++;
+
+    x1 = (jfloat)x;
+    y1 = (jfloat)y;
+    x2 = x1 + ginfo->width;
+    y2 = y1 + ginfo->height;
+
+    return d3dc->pVCacher->DrawTexture(x1, y1, x2, y2,
+                                       cell->tx1, cell->ty1,
+                                       cell->tx2, cell->ty2);
+}
+
+/**
+ * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 is
+ * inside outerBounds.
+ */
+#define INSIDE(gx1, gy1, gx2, gy2, outerBounds) \
+    (((gx1) >= outerBounds.x1) && ((gy1) >= outerBounds.y1) && \
+     ((gx2) <= outerBounds.x2) && ((gy2) <= outerBounds.y2))
+
+/**
+ * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 intersects
+ * the rectangle defined by bounds.
+ */
+#define INTERSECTS(gx1, gy1, gx2, gy2, bounds) \
+    ((bounds.x2   > (gx1)) && (bounds.y2 > (gy1)) && \
+     (bounds.x1   < (gx2)) && (bounds.y1 < (gy2)))
+
+/**
+ * This method checks to see if the given LCD glyph bounds fall within the
+ * cached destination texture bounds.  If so, this method can return
+ * immediately.  If not, this method will copy a chunk of framebuffer data
+ * into the cached destination texture and then update the current cached
+ * destination bounds before returning.
+ *
+ * The agx1, agx2 are "adjusted" glyph bounds, which are only used when checking
+ * against the previous glyph bounds.
+ */
+static HRESULT
+D3DTR_UpdateCachedDestination(D3DContext *d3dc, D3DSDOps *dstOps,
+                              GlyphInfo *ginfo,
+                              jint gx1, jint gy1, jint gx2, jint gy2,
+                              jint agx1, jint agx2,
+                              jint glyphIndex, jint totalGlyphs)
 {
-    int index;
     jint dx1, dy1, dx2, dy2;
-    ImageRef glyphImage;
-    int num = gbv->numGlyphs;
-    SurfaceDataBounds glyphs;
-    jboolean tryCache = JNI_TRUE;
-
-    glyphs.x1 = glyphs.y1 = 0x7fffffff;
-    glyphs.x2 = glyphs.y2 = 0x80000000;
-    for (index = 0; index < num; index++) {
-        glyphImage = gbv->glyphs[index];
-        dx1 = (jint) glyphImage.x;
-        dy1 = (jint) glyphImage.y;
-        dx2 = dx1 + glyphImage.width;
-        dy2 = dy1 + glyphImage.height;
-        if (glyphs.x1 > dx1) glyphs.x1 = dx1;
-        if (glyphs.y1 > dy1) glyphs.y1 = dy1;
-        if (glyphs.x2 < dx2) glyphs.x2 = dx2;
-        if (glyphs.y2 < dy2) glyphs.y2 = dy2;
-
-        if (tryCache &&
-            ((glyphImage.width > D3D_GCACHE_CELL_WIDTH) ||
-             (glyphImage.height > D3D_GCACHE_CELL_HEIGHT)))
-        {
-            tryCache = JNI_FALSE;
+    D3DResource *pCachedDestTexRes;
+    IDirect3DSurface9 *pCachedDestSurface, *pDst;
+    HRESULT res;
+
+    if (isCachedDestValid && INSIDE(gx1, gy1, gx2, gy2, cachedDestBounds)) {
+        // glyph is already within the cached destination bounds; no need
+        // to read back the entire destination region again, but we do
+        // need to see if the current glyph overlaps the previous glyph...
+
+        // only use the "adjusted" glyph bounds when checking against
+        // previous glyph's bounds
+        gx1 = agx1;
+        gx2 = agx2;
+
+        if (INTERSECTS(gx1, gy1, gx2, gy2, previousGlyphBounds)) {
+            // the current glyph overlaps the destination region touched
+            // by the previous glyph, so now we need to read back the part
+            // of the destination corresponding to the previous glyph
+            dx1 = previousGlyphBounds.x1;
+            dy1 = previousGlyphBounds.y1;
+            dx2 = previousGlyphBounds.x2;
+            dy2 = previousGlyphBounds.y2;
+
+            // REMIND: make sure we flush any pending primitives that are
+            // dependent on the current contents of the cached dest
+            d3dc->FlushVertexQueue();
+
+            RETURN_STATUS_IF_NULL(dstOps->pResource, E_FAIL);
+            RETURN_STATUS_IF_NULL(pDst = dstOps->pResource->GetSurface(),
+                                  E_FAIL);
+            res = d3dc->GetResourceManager()->
+                GetCachedDestTexture(dstOps->pResource->GetDesc()->Format,
+                                     &pCachedDestTexRes);
+            RETURN_STATUS_IF_FAILED(res);
+            pCachedDestSurface = pCachedDestTexRes->GetSurface();
+
+            // now dxy12 represent the "desired" destination bounds, but the
+            // StretchRect() call may fail if these fall outside the actual
+            // surface bounds; therefore, we use cxy12 to represent the
+            // clamped bounds, and dxy12 are saved for later
+            jint cx1 = (dx1 < 0) ? 0 : dx1;
+            jint cy1 = (dy1 < 0) ? 0 : dy1;
+            jint cx2 = (dx2 > dstOps->width)  ? dstOps->width  : dx2;
+            jint cy2 = (dy2 > dstOps->height) ? dstOps->height : dy2;
+
+            if (cx2 > cx1 && cy2 > cy1) {
+                // copy destination into subregion of cached texture tile
+                //   cx1-cachedDestBounds.x1 == +xoffset from left of texture
+                //   cy1-cachedDestBounds.y1 == +yoffset from top of texture
+                //   cx2-cachedDestBounds.x1 == +xoffset from left of texture
+                //   cy2-cachedDestBounds.y1 == +yoffset from top of texture
+                jint cdx1 = cx1-cachedDestBounds.x1;
+                jint cdy1 = cy1-cachedDestBounds.y1;
+                jint cdx2 = cx2-cachedDestBounds.x1;
+                jint cdy2 = cy2-cachedDestBounds.y1;
+                RECT srcRect = {  cx1,  cy1,  cx2,  cy2 };
+                RECT dstRect = { cdx1, cdy1, cdx2, cdy2 };
+
+                IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+                res = pd3dDevice->StretchRect(pDst, &srcRect,
+                                              pCachedDestSurface, &dstRect,
+                                              D3DTEXF_NONE);
+            }
+        }
+    } else {
+        // destination region is not valid, so we need to read back a
+        // chunk of the destination into our cached texture
+
+        // position the upper-left corner of the destination region on the
+        // "top" line of glyph list
+        // REMIND: this isn't ideal; it would be better if we had some idea
+        //         of the bounding box of the whole glyph list (this is
+        //         do-able, but would require iterating through the whole
+        //         list up front, which may present its own problems)
+        dx1 = gx1;
+        dy1 = gy1;
+
+        jint remainingWidth;
+        if (ginfo->advanceX > 0) {
+            // estimate the width based on our current position in the glyph
+            // list and using the x advance of the current glyph (this is just
+            // a quick and dirty heuristic; if this is a "thin" glyph image,
+            // then we're likely to underestimate, and if it's "thick" then we
+            // may end up reading back more than we need to)
+            remainingWidth =
+                (jint)(ginfo->advanceX * (totalGlyphs - glyphIndex));
+            if (remainingWidth > D3DTR_CACHED_DEST_WIDTH) {
+                remainingWidth = D3DTR_CACHED_DEST_WIDTH;
+            } else if (remainingWidth < ginfo->width) {
+                // in some cases, the x-advance may be slightly smaller
+                // than the actual width of the glyph; if so, adjust our
+                // estimate so that we can accomodate the entire glyph
+                remainingWidth = ginfo->width;
+            }
+        } else {
+            // a negative advance is possible when rendering rotated text,
+            // in which case it is difficult to estimate an appropriate
+            // region for readback, so we will pick a region that
+            // encompasses just the current glyph
+            remainingWidth = ginfo->width;
+        }
+        dx2 = dx1 + remainingWidth;
+
+        // estimate the height (this is another sloppy heuristic; we'll
+        // make the cached destination region tall enough to encompass most
+        // glyphs that are small enough to fit in the glyph cache, and then
+        // we add a little something extra to account for descenders
+        dy2 = dy1 + D3DTR_CACHE_CELL_HEIGHT + 2;
+
+        // REMIND: make sure we flush any pending primitives that are
+        // dependent on the current contents of the cached dest
+        d3dc->FlushVertexQueue();
+
+        RETURN_STATUS_IF_NULL(dstOps->pResource, E_FAIL);
+        RETURN_STATUS_IF_NULL(pDst = dstOps->pResource->GetSurface(), E_FAIL);
+        res = d3dc->GetResourceManager()->
+            GetCachedDestTexture(dstOps->pResource->GetDesc()->Format,
+                                 &pCachedDestTexRes);
+        RETURN_STATUS_IF_FAILED(res);
+        pCachedDestSurface = pCachedDestTexRes->GetSurface();
+
+        // now dxy12 represent the "desired" destination bounds, but the
+        // StretchRect() call may fail if these fall outside the actual
+        // surface bounds; therefore, we use cxy12 to represent the
+        // clamped bounds, and dxy12 are saved for later
+        jint cx1 = (dx1 < 0) ? 0 : dx1;
+        jint cy1 = (dy1 < 0) ? 0 : dy1;
+        jint cx2 = (dx2 > dstOps->width)  ? dstOps->width  : dx2;
+        jint cy2 = (dy2 > dstOps->height) ? dstOps->height : dy2;
+
+        if (cx2 > cx1 && cy2 > cy1) {
+            // copy destination into cached texture tile (the upper-left
+            // corner of the destination region will be positioned at the
+            // upper-left corner (0,0) of the texture)
+            RECT srcRect = { cx1, cy1, cx2, cy2 };
+            RECT dstRect = { cx1-dx1, cy1-dy1, cx2-dx1, cy2-dy1 };
+
+            IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+            res = pd3dDevice->StretchRect(pDst, &srcRect,
+                                          pCachedDestSurface, &dstRect,
+                                          D3DTEXF_NONE);
         }
+
+        // update the cached bounds and mark it valid
+        cachedDestBounds.x1 = dx1;
+        cachedDestBounds.y1 = dy1;
+        cachedDestBounds.x2 = dx2;
+        cachedDestBounds.y2 = dy2;
+        isCachedDestValid = JNI_TRUE;
     }
 
-    *useCache = tryCache;
-
-    SurfaceData_IntersectBounds(bounds, &glyphs);
-    return (bounds->x1 < bounds->x2 && bounds->y1 < bounds->y2);
-}
-
-extern JNIEXPORT void JNICALL
-    D3DDrawGlyphList(JNIEnv *env, jobject d3dtr,
-                     jlong pData, jlong pCtx,
-                     ImageRef *glyphs, jint totalGlyphs,
-                     jboolean useCache);
+    // always update the previous glyph bounds
+    previousGlyphBounds.x1 = gx1;
+    previousGlyphBounds.y1 = gy1;
+    previousGlyphBounds.x2 = gx2;
+    previousGlyphBounds.y2 = gy2;
 
-/*
- * Class:     sun_java2d_d3d_D3DTextRenderer
- * Method:    doDrawGlyphList
- * Signature: (JLsun/java2d/pipe/Region;Lsun/font/GlyphList;)V
- */
-JNIEXPORT void JNICALL Java_sun_java2d_d3d_D3DTextRenderer_doDrawGlyphList
-    (JNIEnv *env, jobject d3dtr,
-     jlong pData,
-     jlong pCtx, jobject clip, jobject glyphlist)
+    return res;
+}
+
+static HRESULT
+D3DTR_DrawLCDGlyphViaCache(D3DContext *d3dc, D3DSDOps *dstOps,
+                           GlyphInfo *ginfo, jint x, jint y,
+                           jint glyphIndex, jint totalGlyphs,
+                           jboolean rgbOrder, jint contrast)
 {
-    GlyphBlitVector* gbv;
-    SurfaceDataBounds bounds;
-    jboolean useCache;
+    HRESULT res;
+    D3DGlyphCache *pLCDGCache;
+    CacheCellInfo *cell;
+    GlyphCacheInfo *gcache;
+    jint dx1, dy1, dx2, dy2;
+    jfloat dtx1, dty1, dtx2, dty2;
+
+    J2dTraceLn(J2D_TRACE_VERBOSE, "D3DTR_DrawLCDGlyphViaCache");
+
+    // the glyph cache is initialized before this method is called
+    pLCDGCache = d3dc->GetLCDGlyphCache();
 
-    if ((pData == 0) || (pCtx == 0)) {
-        return;
+    if (glyphMode != MODE_USE_CACHE_LCD) {
+        D3DTR_DisableGlyphModeState(d3dc);
+
+        res = d3dc->BeginScene(STATE_TEXTUREOP);
+        RETURN_STATUS_IF_FAILED(res);
+
+        pLCDGCache->CheckGlyphCacheByteOrder(rgbOrder);
+
+        res = D3DTR_EnableLCDGlyphModeState(d3dc, dstOps, JNI_TRUE, contrast);
+        RETURN_STATUS_IF_FAILED(res);
+
+        glyphMode = MODE_USE_CACHE_LCD;
     }
 
-    Region_GetBounds(env, clip, &bounds);
+    gcache = pLCDGCache->GetGlyphCache();
+    cell = AccelGlyphCache_GetCellInfoForCache(ginfo, gcache);
+    if (cell == NULL) {
+        // attempt to add glyph to accelerated glyph cache
+        res = pLCDGCache->AddGlyph(ginfo);
+        RETURN_STATUS_IF_FAILED(res);
+
+        // we'll just no-op in the rare case that the cell is NULL
+        cell = AccelGlyphCache_GetCellInfoForCache(ginfo, gcache);
+        RETURN_STATUS_IF_NULL(cell, E_FAIL);
+    }
 
-    if ((gbv = setupBlitVector(env, glyphlist)) == NULL) {
-        return;
+    cell->timesRendered++;
+
+    // location of the glyph in the destination's coordinate space
+    dx1 = x;
+    dy1 = y;
+    dx2 = dx1 + ginfo->width;
+    dy2 = dy1 + ginfo->height;
+
+    // copy destination into second cached texture, if necessary
+    D3DTR_UpdateCachedDestination(d3dc,
+                                  dstOps, ginfo,
+                                  dx1, dy1,
+                                  dx2, dy2,
+                                  dx1 + cell->leftOff,  // adjusted dx1
+                                  dx2 + cell->rightOff, // adjusted dx2
+                                  glyphIndex, totalGlyphs);
+
+    // texture coordinates of the destination tile
+    dtx1 = ((jfloat)(dx1 - cachedDestBounds.x1)) / D3DTR_CACHED_DEST_WIDTH;
+    dty1 = ((jfloat)(dy1 - cachedDestBounds.y1)) / D3DTR_CACHED_DEST_HEIGHT;
+    dtx2 = ((jfloat)(dx2 - cachedDestBounds.x1)) / D3DTR_CACHED_DEST_WIDTH;
+    dty2 = ((jfloat)(dy2 - cachedDestBounds.y1)) / D3DTR_CACHED_DEST_HEIGHT;
+
+    // render composed texture to the destination surface
+    return d3dc->pVCacher->DrawTexture((jfloat)dx1, (jfloat)dy1,
+                                       (jfloat)dx2, (jfloat)dy2,
+                                        cell->tx1, cell->ty1,
+                                        cell->tx2, cell->ty2,
+                                        dtx1, dty1, dtx2, dty2);
+}
+
+static HRESULT
+D3DTR_DrawGrayscaleGlyphNoCache(D3DContext *d3dc,
+                                GlyphInfo *ginfo, jint x, jint y)
+{
+    jint tw, th;
+    jint sx, sy, sw, sh;
+    jint x0;
+    jint w = ginfo->width;
+    jint h = ginfo->height;
+    HRESULT res = S_OK;
+
+    J2dTraceLn(J2D_TRACE_VERBOSE, "D3DTR_DrawGrayscaleGlyphNoCache");
+
+    if (glyphMode != MODE_NO_CACHE_GRAY) {
+        D3DTR_DisableGlyphModeState(d3dc);
+
+        res = d3dc->BeginScene(STATE_MASKOP);
+        RETURN_STATUS_IF_FAILED(res);
+
+        glyphMode = MODE_NO_CACHE_GRAY;
     }
 
-    if (!D3DRefineBounds(gbv, &bounds, &useCache)) {
-        free(gbv);
-        return;
+    x0 = x;
+    tw = D3D_MASK_CACHE_TILE_WIDTH;
+    th = D3D_MASK_CACHE_TILE_HEIGHT;
+
+    for (sy = 0; sy < h; sy += th, y += th) {
+        x = x0;
+        sh = ((sy + th) > h) ? (h - sy) : th;
+
+        for (sx = 0; sx < w; sx += tw, x += tw) {
+            sw = ((sx + tw) > w) ? (w - sx) : tw;
+
+            res = d3dc->GetMaskCache()->AddMaskQuad(sx, sy, x, y, sw, sh,
+                                                    w, ginfo->image);
+        }
     }
 
-    D3DDrawGlyphList(env, d3dtr,
-                     pData, pCtx,
-                     gbv->glyphs, gbv->numGlyphs, useCache);
-    free(gbv);
+    return res;
 }
 
+static HRESULT
+D3DTR_DrawLCDGlyphNoCache(D3DContext *d3dc, D3DSDOps *dstOps,
+                          GlyphInfo *ginfo, jint x, jint y,
+                          jint rowBytesOffset,
+                          jboolean rgbOrder, jint contrast)
+{
+    jfloat tx1, ty1, tx2, ty2;
+    jfloat dx1, dy1, dx2, dy2;
+    jfloat dtx1, dty1, dtx2, dty2;
+    jint tw, th;
+    jint sx, sy, sw, sh;
+    jint cx1, cy1, cx2, cy2;
+    jint x0;
+    jint w = ginfo->width;
+    jint h = ginfo->height;
+    TileFormat tileFormat = rgbOrder ? TILEFMT_3BYTE_RGB : TILEFMT_3BYTE_BGR;
+
+    IDirect3DDevice9 *pd3dDevice = d3dc->Get3DDevice();
+    D3DResource *pBlitTextureRes, *pCachedDestTextureRes;
+    IDirect3DTexture9 *pBlitTexture;
+    IDirect3DSurface9 *pCachedDestSurface, *pDst;
+    HRESULT res;
+
+    J2dTraceLn(J2D_TRACE_VERBOSE, "D3DTR_DrawLCDGlyphNoCache");
+
+    RETURN_STATUS_IF_NULL(dstOps->pResource, E_FAIL);
+    RETURN_STATUS_IF_NULL(pDst = dstOps->pResource->GetSurface(), E_FAIL);
+
+    res = d3dc->GetResourceManager()->GetBlitTexture(&pBlitTextureRes);
+    RETURN_STATUS_IF_FAILED(res);
+
+    res = d3dc->GetResourceManager()->
+        GetCachedDestTexture(dstOps->pResource->GetDesc()->Format,
+                             &pCachedDestTextureRes);
+    RETURN_STATUS_IF_FAILED(res);
+
+    pBlitTexture = pBlitTextureRes->GetTexture();
+    pCachedDestSurface = pCachedDestTextureRes->GetSurface();
+
+    if (glyphMode != MODE_NO_CACHE_LCD) {
+        D3DTR_DisableGlyphModeState(d3dc);
+
+        res = d3dc->BeginScene(STATE_TEXTUREOP);
+        RETURN_STATUS_IF_FAILED(res);
+        res = D3DTR_EnableLCDGlyphModeState(d3dc,dstOps, JNI_FALSE, contrast);
+        RETURN_STATUS_IF_FAILED(res);
+
+        glyphMode = MODE_NO_CACHE_LCD;
+    }
+
+    x0 = x;
+    tx1 = 0.0f;
+    ty1 = 0.0f;
+    dtx1 = 0.0f;
+    dty1 = 0.0f;
+    tw = D3DTR_NOCACHE_TILE_SIZE;
+    th = D3DTR_NOCACHE_TILE_SIZE;
+
+    for (sy = 0; sy < h; sy += th, y += th) {
+        x = x0;
+        sh = ((sy + th) > h) ? (h - sy) : th;
+
+        for (sx = 0; sx < w; sx += tw, x += tw) {
+            sw = ((sx + tw) > w) ? (w - sx) : tw;
+
+            // calculate the bounds of the tile to be copied from the
+            // destination into the cached tile
+            cx1 = x;
+            cy1 = y;
+            cx2 = cx1 + sw;
+            cy2 = cy1 + sh;
+
+            // need to clamp to the destination bounds, otherwise the
+            // StretchRect() call may fail
+            if (cx1 < 0)              cx1 = 0;
+            if (cy1 < 0)              cy1 = 0;
+            if (cx2 > dstOps->width)  cx2 = dstOps->width;
+            if (cy2 > dstOps->height) cy2 = dstOps->height;
+
+            if (cx2 > cx1 && cy2 > cy1) {
+                // copy LCD mask into glyph texture tile
+                d3dc->UploadTileToTexture(pBlitTextureRes,
+                                          ginfo->image+rowBytesOffset,
+                                          0, 0, sx, sy, sw, sh,
+                                          ginfo->rowBytes, tileFormat);
+
+                // update the lower-right glyph texture coordinates
+                tx2 = ((jfloat)sw) / D3DC_BLIT_TILE_SIZE;
+                ty2 = ((jfloat)sh) / D3DC_BLIT_TILE_SIZE;
+
+                // calculate the actual destination vertices
+                dx1 = (jfloat)x;
+                dy1 = (jfloat)y;
+                dx2 = dx1 + sw;
+                dy2 = dy1 + sh;
+
+                // copy destination into cached texture tile (the upper-left
+                // corner of the destination region will be positioned at the
+                // upper-left corner (0,0) of the texture)
+                RECT srcRect = { cx1, cy1, cx2, cy2 };
+                RECT dstRect = { cx1-x, cy1-y, cx2-x, cy2-y };
+                pd3dDevice->StretchRect(pDst, &srcRect,
+                                        pCachedDestSurface,
+                                        &dstRect,
+                                        D3DTEXF_NONE);
+
+                // update the remaining destination texture coordinates
+                dtx2 = ((jfloat)sw) / D3DTR_CACHED_DEST_WIDTH;
+                dty2 = ((jfloat)sh) / D3DTR_CACHED_DEST_HEIGHT;
+
+                // render composed texture to the destination surface
+                res = d3dc->pVCacher->DrawTexture( dx1,  dy1,  dx2,  dy2,
+                                                   tx1,  ty1,  tx2,  ty2,
+                                                   dtx1, dty1, dtx2, dty2);
+
+                // unfortunately we need to flush after each tile
+                d3dc->FlushVertexQueue();
+            }
+        }
+    }
+
+    return res;
+}
+
+// see DrawGlyphList.c for more on this macro...
+#define FLOOR_ASSIGN(l, r) \
+    if ((r)<0) (l) = ((int)floor(r)); else (l) = ((int)(r))
+
+HRESULT
+D3DTR_DrawGlyphList(D3DContext *d3dc, D3DSDOps *dstOps,
+                    jint totalGlyphs, jboolean usePositions,
+                    jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
+                    jfloat glyphListOrigX, jfloat glyphListOrigY,
+                    unsigned char *images, unsigned char *positions)
+{
+    int glyphCounter;
+    HRESULT res = S_OK;
+    J2dTraceLn(J2D_TRACE_INFO, "D3DTR_DrawGlyphList");
+
+    RETURN_STATUS_IF_NULL(d3dc, E_FAIL);
+    RETURN_STATUS_IF_NULL(d3dc->Get3DDevice(), E_FAIL);
+    RETURN_STATUS_IF_NULL(dstOps, E_FAIL);
+    RETURN_STATUS_IF_NULL(images, E_FAIL);
+    if (usePositions) {
+        RETURN_STATUS_IF_NULL(positions, E_FAIL);
+    }
+
+    glyphMode = MODE_NOT_INITED;
+    isCachedDestValid = JNI_FALSE;
+
+    for (glyphCounter = 0; glyphCounter < totalGlyphs; glyphCounter++) {
+        jint x, y;
+        jfloat glyphx, glyphy;
+        jboolean grayscale;
+        GlyphInfo *ginfo = (GlyphInfo *)jlong_to_ptr(NEXT_LONG(images));
+
+        if (ginfo == NULL) {
+            // this shouldn't happen, but if it does we'll just break out...
+            J2dRlsTraceLn(J2D_TRACE_ERROR,
+                          "D3DTR_DrawGlyphList: glyph info is null");
+            break;
+        }
+
+        grayscale = (ginfo->rowBytes == ginfo->width);
+
+        if (usePositions) {
+            jfloat posx = NEXT_FLOAT(positions);
+            jfloat posy = NEXT_FLOAT(positions);
+            glyphx = glyphListOrigX + posx + ginfo->topLeftX;
+            glyphy = glyphListOrigY + posy + ginfo->topLeftY;
+            FLOOR_ASSIGN(x, glyphx);
+            FLOOR_ASSIGN(y, glyphy);
+        } else {
+            glyphx = glyphListOrigX + ginfo->topLeftX;
+            glyphy = glyphListOrigY + ginfo->topLeftY;
+            FLOOR_ASSIGN(x, glyphx);
+            FLOOR_ASSIGN(y, glyphy);
+            glyphListOrigX += ginfo->advanceX;
+            glyphListOrigY += ginfo->advanceY;
+        }
+
+        if (ginfo->image == NULL) {
+            continue;
+        }
+
+        if (grayscale) {
+            // grayscale or monochrome glyph data
+            if (ginfo->width <= D3DTR_CACHE_CELL_WIDTH &&
+                ginfo->height <= D3DTR_CACHE_CELL_HEIGHT &&
+                SUCCEEDED(d3dc->InitGrayscaleGlyphCache()))
+            {
+                res = D3DTR_DrawGrayscaleGlyphViaCache(d3dc, ginfo, x, y);
+            } else {
+                res = D3DTR_DrawGrayscaleGlyphNoCache(d3dc, ginfo, x, y);
+            }
+        } else {
+            // LCD-optimized glyph data
+            jint rowBytesOffset = 0;
+
+            if (subPixPos) {
+                jint frac = (jint)((glyphx - x) * 3);
+                if (frac != 0) {
+                    rowBytesOffset = 3 - frac;
+                    x += 1;
+                }
+            }
+
+            if (rowBytesOffset == 0 &&
+                ginfo->width <= D3DTR_CACHE_CELL_WIDTH &&
+                ginfo->height <= D3DTR_CACHE_CELL_HEIGHT &&
+                SUCCEEDED(d3dc->InitLCDGlyphCache()))
+            {
+                res = D3DTR_DrawLCDGlyphViaCache(d3dc, dstOps,
+                                                 ginfo, x, y,
+                                                 glyphCounter, totalGlyphs,
+                                                 rgbOrder, lcdContrast);
+            } else {
+                res = D3DTR_DrawLCDGlyphNoCache(d3dc, dstOps,
+                                                ginfo, x, y,
+                                                rowBytesOffset,
+                                                rgbOrder, lcdContrast);
+            }
+        }
+
+        if (FAILED(res)) {
+            break;
+        }
+    }
+
+    D3DTR_DisableGlyphModeState(d3dc);
+    return res;
+}
+
+JNIEXPORT void JNICALL
+Java_sun_java2d_d3d_D3DTextRenderer_drawGlyphList
+    (JNIEnv *env, jobject self,
+     jint numGlyphs, jboolean usePositions,
+     jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
+     jfloat glyphListOrigX, jfloat glyphListOrigY,
+     jlongArray imgArray, jfloatArray posArray)
+{
+    unsigned char *images;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DTextRenderer_drawGlyphList");
+
+    images = (unsigned char *)
+        env->GetPrimitiveArrayCritical(imgArray, NULL);
+    if (images != NULL) {
+        D3DContext *d3dc = D3DRQ_GetCurrentContext();
+        D3DSDOps *dstOps = D3DRQ_GetCurrentDestination();
+
+        if (usePositions) {
+            unsigned char *positions = (unsigned char *)
+                env->GetPrimitiveArrayCritical(posArray, NULL);
+            if (positions != NULL) {
+                D3DTR_DrawGlyphList(d3dc, dstOps,
+                                    numGlyphs, usePositions,
+                                    subPixPos, rgbOrder, lcdContrast,
+                                    glyphListOrigX, glyphListOrigY,
+                                    images, positions);
+                env->ReleasePrimitiveArrayCritical(posArray,
+                                                   positions, JNI_ABORT);
+            }
+        } else {
+            D3DTR_DrawGlyphList(d3dc, dstOps,
+                                numGlyphs, usePositions,
+                                subPixPos, rgbOrder, lcdContrast,
+                                glyphListOrigX, glyphListOrigY,
+                                images, NULL);
+        }
+
+        // reset current state, and ensure rendering is flushed to dest
+        if (d3dc != NULL) {
+            d3dc->FlushVertexQueue();
+        }
+
+        env->ReleasePrimitiveArrayCritical(imgArray,
+                                           images, JNI_ABORT);
+    }
 }
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DTextRenderer.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DTextRenderer.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DTextRenderer.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DTextRenderer.h	2011-01-08 01:26:50.487202383 +0000
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef D3DTextRenderer_h_Included
+#define D3DTextRenderer_h_Included
+
+#include <jni.h>
+#include <jlong.h>
+#include "sun_java2d_pipe_BufferedTextPipe.h"
+#include "AccelGlyphCache.h"
+#include "D3DContext.h"
+#include "D3DSurfaceData.h"
+
+/**
+ * The following constants define the inner and outer bounds of the
+ * accelerated glyph cache.
+ */
+#define D3DTR_CACHE_WIDTH       512
+#define D3DTR_CACHE_HEIGHT      512
+#define D3DTR_CACHE_CELL_WIDTH  16
+#define D3DTR_CACHE_CELL_HEIGHT 16
+
+/**
+ * This constant defines the size of the tile to use in the
+ * D3DTR_DrawLCDGlyphNoCache() method.  See below for more on why we
+ * restrict this value to a particular size.
+ */
+#define D3DTR_NOCACHE_TILE_SIZE 32
+
+/**
+ * These constants define the size of the "cached destination" texture.
+ * This texture is only used when rendering LCD-optimized text, as that
+ * codepath needs direct access to the destination.  There is no way to
+ * access the framebuffer directly from a Direct3D shader, so we need to first
+ * copy the destination region corresponding to a particular glyph into
+ * this cached texture, and then that texture will be accessed inside the
+ * shader.  Copying the destination into this cached texture can be a very
+ * expensive operation (accounting for about half the rendering time for
+ * LCD text), so to mitigate this cost we try to bulk read a horizontal
+ * region of the destination at a time.  (These values are empirically
+ * derived for the common case where text runs horizontally.)
+ *
+ * Note: It is assumed in various calculations below that:
+ *     (D3DTR_CACHED_DEST_WIDTH  >= D3DTR_CACHE_CELL_WIDTH)  &&
+ *     (D3DTR_CACHED_DEST_WIDTH  >= D3DTR_NOCACHE_TILE_SIZE) &&
+ *     (D3DTR_CACHED_DEST_HEIGHT >= D3DTR_CACHE_CELL_HEIGHT) &&
+ *     (D3DTR_CACHED_DEST_HEIGHT >= D3DTR_NOCACHE_TILE_SIZE)
+ */
+#define D3DTR_CACHED_DEST_WIDTH  512
+#define D3DTR_CACHED_DEST_HEIGHT 32
+
+#define BYTES_PER_GLYPH_IMAGE \
+    sun_java2d_pipe_BufferedTextPipe_BYTES_PER_GLYPH_IMAGE
+#define BYTES_PER_GLYPH_POSITION \
+    sun_java2d_pipe_BufferedTextPipe_BYTES_PER_GLYPH_POSITION
+#define BYTES_PER_POSITIONED_GLYPH \
+    (BYTES_PER_GLYPH_IMAGE + BYTES_PER_GLYPH_POSITION)
+
+#define OFFSET_CONTRAST  sun_java2d_pipe_BufferedTextPipe_OFFSET_CONTRAST
+#define OFFSET_RGBORDER  sun_java2d_pipe_BufferedTextPipe_OFFSET_RGBORDER
+#define OFFSET_SUBPIXPOS sun_java2d_pipe_BufferedTextPipe_OFFSET_SUBPIXPOS
+#define OFFSET_POSITIONS sun_java2d_pipe_BufferedTextPipe_OFFSET_POSITIONS
+
+HRESULT D3DTR_EnableGlyphVertexCache(D3DContext *d3dc);
+HRESULT D3DTR_DisableGlyphVertexCache(D3DContext *d3dc);
+
+HRESULT D3DTR_DrawGlyphList(D3DContext *d3dc, D3DSDOps *dstOps,
+                            jint totalGlyphs, jboolean usePositions,
+                            jboolean subPixPos, jboolean rgbOrder,
+                            jint lcdContrast,
+                            jfloat glyphListOrigX, jfloat glyphListOrigY,
+                            unsigned char *images, unsigned char *positions);
+
+#endif /* D3DTextRenderer_h_Included */
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DVertexCacher.cpp openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DVertexCacher.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DVertexCacher.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DVertexCacher.cpp	2011-01-08 01:26:50.487202383 +0000
@@ -0,0 +1,823 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#include "D3DPipeline.h"
+#include "D3DVertexCacher.h"
+#include "D3DPaints.h"
+
+#include "math.h"
+
+// non-texturized macros
+
+#define ADD_VERTEX_XYC(X, Y, VCOLOR) \
+do { \
+    vertices[firstUnusedVertex].x = (X); \
+    vertices[firstUnusedVertex].y = (Y); \
+    vertices[firstUnusedVertex].color = (DWORD)(VCOLOR); \
+    firstUnusedVertex++; \
+} while (0)
+
+#define ADD_LINE_XYC(X1, Y1, X2, Y2, VCOLOR) \
+do { \
+    ADD_VERTEX_XYC(X1, Y1, VCOLOR); \
+    ADD_VERTEX_XYC(X2, Y2, VCOLOR); \
+    batches[currentBatch].pNum++;   \
+} while (0)
+
+#define ADD_LINE_SEG_XYC(X, Y, VCOLOR) \
+do { \
+    ADD_VERTEX_XYC(X, Y, VCOLOR); \
+    batches[currentBatch].pNum++;   \
+} while (0)
+
+#define ADD_TRIANGLE_XYC(X1, Y1, X2, Y2, X3, Y3, VCOLOR) \
+do { \
+    ADD_VERTEX_XYC(X1, Y1, VCOLOR); \
+    ADD_VERTEX_XYC(X2, Y2, VCOLOR); \
+    ADD_VERTEX_XYC(X3, Y3, VCOLOR); \
+    batches[currentBatch].pNum++;   \
+} while (0)
+
+// texturized macros
+
+#define ADD_VERTEX_XYUVC(X, Y, U1, V1, VCOLOR) \
+do { \
+    vertices[firstUnusedVertex].x = (X); \
+    vertices[firstUnusedVertex].y = (Y); \
+    vertices[firstUnusedVertex].tu1 = (U1); \
+    vertices[firstUnusedVertex].tv1 = (V1); \
+    vertices[firstUnusedVertex].color = (DWORD)(VCOLOR); \
+    firstUnusedVertex++; \
+} while (0)
+
+#define ADD_VERTEX_XYUVUVC(X, Y, U1, V1, U2, V2, VCOLOR) \
+do { \
+    vertices[firstUnusedVertex].tu2 = (U2); \
+    vertices[firstUnusedVertex].tv2 = (V2); \
+    ADD_VERTEX_XYUVC(X, Y, U1, V1, VCOLOR); \
+} while (0)
+
+#define ADD_TRIANGLE_XYUVC(X1, Y1, X2, Y2, X3, Y3,         \
+                           U1, V1, U2, V2, U3, V3, VCOLOR) \
+do { \
+    ADD_VERTEX_XYUVC(X1, Y1, U1, V1, VCOLOR); \
+    ADD_VERTEX_XYUVC(X2, Y2, U2, V2, VCOLOR); \
+    ADD_VERTEX_XYUVC(X3, Y3, U3, V3, VCOLOR); \
+    batches[currentBatch].pNum++;   \
+} while (0)
+
+#define ADD_TRIANGLE_XYUVUVC(X1, Y1, X2, Y2, X3, Y3,       \
+                             U11, V11, U12, V12, U13, V13, \
+                             U21, V21, U22, V22, U23, V23, \
+                             VCOLOR)                       \
+do { \
+    ADD_VERTEX_XYUVUVC(X1, Y1, U11, V11, U21, V21, VCOLOR); \
+    ADD_VERTEX_XYUVUVC(X2, Y2, U12, V12, U22, V22, VCOLOR); \
+    ADD_VERTEX_XYUVUVC(X3, Y3, U13, V13, U23, V23, VCOLOR); \
+    batches[currentBatch].pNum++;   \
+} while (0)
+
+// These are fudge factors for rendering lines found by experimenting.
+// They are used to tweak the geometry such that the rendering (mostly) matches
+// our software rendering on most hardware. The main goal was to pick the
+// numbers such that the beginning and ending pixels of lines match.
+#define LINE_FUDGE
+// fudge factors
+#ifdef LINE_FUDGE
+
+// Horiz/vertical
+#define HV_FF1 ( 0.0f)
+#define HV_FF2 ( 0.51f)
+// For the record: value below (or larger) is required for Intel 855, but
+// breaks Nvidia, ATI and Intel 965, and since the pipeline is disabled on
+// 855 anyway we'll use 0.51f.
+//#define HV_FF2 ( 0.5315f)
+#define HV_FF3 (-0.2f)
+// single pixel
+#define SP_FF4 ( 0.3f)
+
+// diagonal, down
+#define DD_FX1 (-0.1f)
+#define DD_FY1 (-0.25f)
+#define DD_FX2 ( 0.2f)
+#define DD_FY2 ( 0.304f)
+// For the record: with this value diagonal-down lines with Texture paint
+// are a bit off on all chipsets but Intel 965. So instead we'll use
+// .304f which makes it better for the rest, but at a price of a bit
+// of pixel/texel shifting on 965G
+//#define DD_FY2 ( 0.4f)
+// diagonal, up
+#define DU_FX1 (-0.1f)
+#define DU_FY1 ( 0.4f)
+#define DU_FX2 ( 0.3f)
+#define DU_FY2 (-0.3f)
+
+#else
+
+#define HV_FF1 (0.0f)
+#define HV_FF2 (0.0f)
+#define HV_FF3 (0.0f)
+#define SP_FF4 (0.0f)
+
+#define DD_FX1 (0.0f)
+#define DD_FY1 (0.0f)
+#define DD_FX2 (0.0f)
+#define DD_FY2 (0.0f)
+#define DU_FX1 (0.0f)
+#define DU_FY1 (0.0f)
+#define DU_FX2 (0.0f)
+#define DU_FY2 (0.0f)
+
+#endif
+
+HRESULT
+D3DVertexCacher::CreateInstance(D3DContext *pCtx, D3DVertexCacher **ppVC)
+{
+    HRESULT res;
+
+    J2dTraceLn(J2D_TRACE_INFO, "D3DVertexCacher::CreateInstance");
+
+    *ppVC = new D3DVertexCacher();
+    if (FAILED(res = (*ppVC)->Init(pCtx))) {
+        delete *ppVC;
+        *ppVC = NULL;
+    }
+    return res;
+}
+
+D3DVertexCacher::D3DVertexCacher()
+{
+    lpD3DDevice = NULL;
+    lpD3DVertexBuffer = NULL;
+}
+
+HRESULT
+D3DVertexCacher::Init(D3DContext *pCtx)
+{
+    D3DCAPS9 caps;
+
+    RETURN_STATUS_IF_NULL(pCtx, E_FAIL);
+
+    ReleaseDefPoolResources();
+
+    this->pCtx = pCtx;
+
+    firstPendingBatch = 0;
+    firstPendingVertex = 0;
+    firstUnusedVertex = 0;
+    currentBatch = 0;
+    ZeroMemory(vertices, sizeof(vertices));
+    ZeroMemory(batches, sizeof(batches));
+
+    lpD3DDevice = pCtx->Get3DDevice();
+    RETURN_STATUS_IF_NULL(lpD3DDevice, E_FAIL);
+
+    ZeroMemory(&caps, sizeof(caps));
+    lpD3DDevice->GetDeviceCaps(&caps);
+
+    D3DPOOL pool = (caps.DeviceType == D3DDEVTYPE_HAL) ?
+            D3DPOOL_DEFAULT : D3DPOOL_SYSTEMMEM;
+    // usage depends on whether we use hw or sw vertex processing
+    HRESULT res =
+        lpD3DDevice->CreateVertexBuffer(MAX_BATCH_SIZE*sizeof(J2DLVERTEX),
+            D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY, D3DFVF_J2DLVERTEX,
+            pool, &lpD3DVertexBuffer, NULL);
+    RETURN_STATUS_IF_FAILED(res);
+
+    res = lpD3DDevice->SetStreamSource(0, lpD3DVertexBuffer, 0,
+                                       sizeof(J2DLVERTEX));
+    RETURN_STATUS_IF_FAILED(res);
+
+    lpD3DDevice->SetFVF(D3DFVF_J2DLVERTEX);
+    return res;
+}
+
+void
+D3DVertexCacher::ReleaseDefPoolResources()
+{
+    SAFE_RELEASE(lpD3DVertexBuffer);
+    pCtx = NULL;
+}
+
+HRESULT D3DVertexCacher::DrawLine(int x1, int y1, int x2, int y2)
+{
+    HRESULT res;
+    if (SUCCEEDED(res = EnsureCapacity(D3DPT_LINELIST, 1*2))) {
+        float fx1, fy1, fx2, fy2;
+        if (y1 == y2) {
+            // horizontal
+            fy1  = (float)y1+HV_FF1;
+            fy2  = fy1;
+
+            if (x1 > x2) {
+                fx1 = (float)x2+HV_FF3;
+                fx2 = (float)x1+HV_FF2;
+            } else if (x1 < x2) {
+                fx1 = (float)x1+HV_FF3;
+                fx2 = (float)x2+HV_FF2;
+            } else {
+                // single point, offset a little so that a single
+                // pixel is rendered
+                fx1 = (float)x1-SP_FF4;
+                fy1 = (float)y1-SP_FF4;
+                fx2 = (float)x2+SP_FF4;
+                fy2 = (float)y2+SP_FF4;
+            }
+        } else if (x1 == x2) {
+            // vertical
+            fx1  = (float)x1+HV_FF1;
+            fx2  = fx1;
+            if (y1 > y2) {
+                fy1 = (float)y2+HV_FF3;
+                fy2 = (float)y1+HV_FF2;
+            } else {
+                fy1 = (float)y1+HV_FF3;
+                fy2 = (float)y2+HV_FF2;
+            }
+        } else {
+            // diagonal
+            if (x1 > x2 && y1 > y2) {
+                // ^
+                //  \ case -> inverse
+                fx1 = (float)x2;
+                fy1 = (float)y2;
+                fx2 = (float)x1;
+                fy2 = (float)y1;
+            } else if (x1 > x2 && y2 > y1) {
+                //  /
+                // v  case - inverse
+                fx1 = (float)x2;
+                fy1 = (float)y2;
+                fx2 = (float)x1;
+                fy2 = (float)y1;
+            } else {
+                // \      ^
+                //  v or /  - leave as is
+                fx1 = (float)x1;
+                fy1 = (float)y1;
+                fx2 = (float)x2;
+                fy2 = (float)y2;
+            }
+
+            if (fx2 > fx1 && fy2 > fy1) {
+                // \
+                //  v
+                fx1 += DD_FX1;
+                fy1 += DD_FY1;
+                fx2 += DD_FX2;
+                fy2 += DD_FY2;
+            } else {
+                //   ^
+                //  /
+                fx1 += DU_FX1;
+                fy1 += DU_FY1;
+                fx2 += DU_FX2;
+                fy2 += DU_FY2;
+            }
+        }
+        ADD_LINE_XYC(fx1, fy1, fx2, fy2, color);
+    }
+    return res;
+}
+
+HRESULT
+D3DVertexCacher::DrawPoly(jint nPoints, jboolean isClosed,
+                          jint transX, jint transY,
+                          jint *xPoints, jint *yPoints)
+{
+    HRESULT res;
+    jfloat mx = (jfloat)xPoints[0];
+    jfloat my = (jfloat)yPoints[0];
+    jboolean isEmpty = TRUE;
+
+    if (nPoints == 0) {
+        return S_OK;
+    }
+
+    if (isClosed &&
+        xPoints[nPoints - 1] == xPoints[0] &&
+        yPoints[nPoints - 1] == yPoints[0])
+    {
+        isClosed = FALSE;
+    }
+
+    // npoints is exactly the number of vertices we need,
+    // possibly plus one (if the path is closed)
+    UINT reqVerts = nPoints * 1;
+    int i = 0;
+    do {
+        // leave room for one possible additional closing point
+        UINT vertsInBatch = min(MAX_BATCH_SIZE-1, max(2, reqVerts));
+        if (SUCCEEDED(res = EnsureCapacity(D3DPT_LINESTRIP, vertsInBatch+1))) {
+            reqVerts -= vertsInBatch;
+            do {
+                jfloat x = (jfloat)xPoints[i];
+                jfloat y = (jfloat)yPoints[i];
+
+                isEmpty = isEmpty && (x == mx && y == my);
+
+                ADD_LINE_SEG_XYC(x + transX, y + transY, color);
+                i++;
+                vertsInBatch--;
+            } while (vertsInBatch > 0);
+            // include the last point from the current batch into the next
+            if (reqVerts > 0) {
+                i--;
+                reqVerts++;
+                // loop continues
+            } else if (isClosed && !isEmpty) {
+                // if this was the last batch, see if the closing point is needed;
+                // note that we have left the room for it
+                ADD_LINE_SEG_XYC(mx + transX, my + transY, color);
+                // for clarity, the loop is ended anyway
+                break;
+            } else if (isEmpty || !isClosed) {
+                // - either we went nowhere, then change the last point
+                // so that a single pixel is rendered
+                // - or it's not empty and not closed - add another
+                // point because on some boards the last point is not rendered
+                mx = xPoints[nPoints-1] + transX +SP_FF4;
+                my = yPoints[nPoints-1] + transY +SP_FF4;
+                ADD_LINE_SEG_XYC(mx, my, color);
+                // for clarity
+                break;
+            }
+        }
+    } while (reqVerts > 0 && SUCCEEDED(res));
+
+    return res;
+}
+
+HRESULT
+D3DVertexCacher::DrawScanlines(jint scanlineCount, jint *scanlines)
+{
+    HRESULT res;
+    float x1, x2, y;
+    UINT reqVerts = scanlineCount*2/*vertices per line*/;
+
+    if (scanlineCount == 0) {
+        return S_OK;
+    }
+
+    do {
+        UINT vertsInBatch = min(2*(MAX_BATCH_SIZE/2), reqVerts);
+        if (SUCCEEDED(res = EnsureCapacity(D3DPT_LINELIST, vertsInBatch))) {
+            reqVerts -= vertsInBatch;
+            do {
+                x1 = ((float)*(scanlines++)) +HV_FF3;
+                x2 = ((float)*(scanlines++)) +HV_FF2;
+                y  = ((float)*(scanlines++)) +HV_FF1;
+                ADD_LINE_XYC(x1, y, x2, y, color);
+                vertsInBatch -= 2;
+            } while (vertsInBatch > 0);
+        }
+    } while (reqVerts > 0 && SUCCEEDED(res));
+    return res;
+}
+
+HRESULT
+D3DVertexCacher::FillSpans(jint spanCount, jint *spans)
+{
+    HRESULT res;
+    float x1, y1, x2, y2;
+    UINT reqVerts = spanCount*2*3/*vertices per span: two triangles*/;
+
+    if (spanCount == 0) {
+        return S_OK;
+    }
+
+    do {
+        UINT vertsInBatch = min(6*(MAX_BATCH_SIZE/6), reqVerts);
+        if (SUCCEEDED(res = EnsureCapacity(D3DPT_TRIANGLELIST, vertsInBatch))) {
+            reqVerts -= vertsInBatch;
+            do {
+                x1 = ((float)*(spans++));
+                y1 = ((float)*(spans++));
+                x2 = ((float)*(spans++));
+                y2 = ((float)*(spans++));
+
+                ADD_TRIANGLE_XYC(x1, y1, x2, y1, x1, y2, color);
+                ADD_TRIANGLE_XYC(x1, y2, x2, y1, x2, y2, color);
+                vertsInBatch -= 6;
+            } while (vertsInBatch > 0);
+        }
+    } while (reqVerts > 0 && SUCCEEDED(res));
+
+    return res;
+}
+
+HRESULT D3DVertexCacher::DrawRect(int x1, int y1, int x2, int y2)
+{
+    HRESULT res;
+
+    if ((x2 - x1) < 2 || (y2 - y1) < 2) {
+        return FillRect(x1, y1, x2+1, y2+1);
+    }
+    if (SUCCEEDED(res = EnsureCapacity(D3DPT_LINELIST, 4*2))) {
+
+        float fx1 = (float)x1;
+        float fy1 = (float)y1;
+        float fx2 = (float)x2;
+        float fy2 = (float)y2;
+
+        // horiz: top left - top right
+        ADD_LINE_XYC(fx1+HV_FF3, fy1+HV_FF1, fx2-1.0f+HV_FF2, fy1+HV_FF1,color);
+        // horiz: bottom left - bottom right
+        ADD_LINE_XYC(fx1+1.0f+HV_FF3, fy2+HV_FF1, fx2+HV_FF2, fy2+HV_FF1,color);
+        // vert : top right - bottom right
+        ADD_LINE_XYC(fx2+HV_FF1, fy1+HV_FF3, fx2+HV_FF1, fy2-1.0f+HV_FF2,color);
+        // vert : top left - bottom left
+        ADD_LINE_XYC(fx1+HV_FF1, fy1+1.0f+HV_FF3, fx1+HV_FF1, fy2+HV_FF2,color);
+    }
+    return res;
+}
+
+HRESULT D3DVertexCacher::FillRect(int x1, int y1, int x2, int y2)
+{
+    HRESULT res;
+    if (SUCCEEDED(res = EnsureCapacity(D3DPT_TRIANGLELIST, 2*3))) {
+        float fx1 = (float)x1;
+        float fy1 = (float)y1;
+        float fx2 = (float)x2;
+        float fy2 = (float)y2;
+        ADD_TRIANGLE_XYUVC(fx1, fy1, fx2, fy1, fx1, fy2,
+                           0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
+                           color);
+        ADD_TRIANGLE_XYUVC(fx1, fy2, fx2, fy1, fx2, fy2,
+                           0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f,
+                           color);
+    }
+    return res;
+}
+
+HRESULT D3DVertexCacher::FillParallelogram(float fx11, float fy11,
+                                           float dx21, float dy21,
+                                           float dx12, float dy12)
+{
+    HRESULT res;
+    if (SUCCEEDED(res = EnsureCapacity(D3DPT_TRIANGLELIST, 2*3))) {
+        // correct texel to pixel mapping; see D3DContext::SetTransform()
+        // for non-id tx case
+        if (pCtx->IsIdentityTx()) {
+            fx11 -= 0.5f;
+            fy11 -= 0.5f;
+        }
+        dx21 += fx11;
+        dy21 += fy11;
+        float fx22 = dx21 + dx12;
+        float fy22 = dy21 + dy12;
+        dx12 += fx11;
+        dy12 += fy11;
+
+        ADD_TRIANGLE_XYUVC(fx11, fy11, dx21, dy21, dx12, dy12,
+                           0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
+                           color);
+        ADD_TRIANGLE_XYUVC(dx12, dy12, dx21, dy21, fx22, fy22,
+                           0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f,
+                           color);
+    }
+    return res;
+}
+
+#define ADJUST_PGRAM(V, DV, DIM) \
+    do { \
+        if ((DV) >= 0) { \
+            (DIM) += (DV); \
+        } else { \
+            (DIM) -= (DV); \
+            (V) += (DV); \
+        } \
+    } while (0)
+
+// Invert the following transform:
+// DeltaT(0, 0) == (0,       0)
+// DeltaT(1, 0) == (DX1,     DY1)
+// DeltaT(0, 1) == (DX2,     DY2)
+// DeltaT(1, 1) == (DX1+DX2, DY1+DY2)
+// TM00 = DX1,   TM01 = DX2,   (TM02 = X11)
+// TM10 = DY1,   TM11 = DY2,   (TM12 = Y11)
+// Determinant = TM00*TM11 - TM01*TM10
+//             =  DX1*DY2  -  DX2*DY1
+// Inverse is:
+// IM00 =  TM11/det,   IM01 = -TM01/det
+// IM10 = -TM10/det,   IM11 =  TM00/det
+// IM02 = (TM01 * TM12 - TM11 * TM02) / det,
+// IM12 = (TM10 * TM02 - TM00 * TM12) / det,
+
+#define DECLARE_MATRIX(MAT) \
+    float MAT ## 00, MAT ## 01, MAT ## 02, MAT ## 10, MAT ## 11, MAT ## 12
+
+#define GET_INVERTED_MATRIX(MAT, X11, Y11, DX1, DY1, DX2, DY2, RET_CODE) \
+    do { \
+        float det = DX1*DY2 - DX2*DY1; \
+        if (det == 0) { \
+            RET_CODE; \
+        } \
+        MAT ## 00 = DY2/det; \
+        MAT ## 01 = -DX2/det; \
+        MAT ## 10 = -DY1/det; \
+        MAT ## 11 = DX1/det; \
+        MAT ## 02 = (DX2 * Y11 - DY2 * X11) / det; \
+        MAT ## 12 = (DY1 * X11 - DX1 * Y11) / det; \
+    } while (0)
+
+#define TRANSFORM(MAT, TX, TY, X, Y) \
+    do { \
+        TX = (X) * MAT ## 00 + (Y) * MAT ## 01 + MAT ## 02; \
+        TY = (X) * MAT ## 10 + (Y) * MAT ## 11 + MAT ## 12; \
+    } while (0)
+
+HRESULT D3DVertexCacher::FillParallelogramAA(float fx11, float fy11,
+                                             float dx21, float dy21,
+                                             float dx12, float dy12)
+{
+    HRESULT res;
+    DECLARE_MATRIX(om);
+
+    GET_INVERTED_MATRIX(om, fx11, fy11, dx21, dy21, dx12, dy12,
+                        return D3D_OK);
+
+    if (SUCCEEDED(res = EnsureCapacity(D3DPT_TRIANGLELIST, 2*3))) {
+        float px = fx11, py = fy11;
+        float pw = 0.0f, ph = 0.0f;
+        ADJUST_PGRAM(px, dx21, pw);
+        ADJUST_PGRAM(py, dy21, ph);
+        ADJUST_PGRAM(px, dx12, pw);
+        ADJUST_PGRAM(py, dy12, ph);
+        float px1 = floor(px);
+        float py1 = floor(py);
+        float px2 = ceil(px + pw);
+        float py2 = ceil(py + ph);
+        float u11, v11, u12, v12, u21, v21, u22, v22;
+        TRANSFORM(om, u11, v11, px1, py1);
+        TRANSFORM(om, u21, v21, px2, py1);
+        TRANSFORM(om, u12, v12, px1, py2);
+        TRANSFORM(om, u22, v22, px2, py2);
+        ADD_TRIANGLE_XYUVUVC(px1, py1, px2, py1, px1, py2,
+                             u11, v11, u21, v21, u12, v12,
+                             5.0, 5.0, 6.0, 5.0, 5.0, 6.0,
+                             color);
+        ADD_TRIANGLE_XYUVUVC(px1, py2, px2, py1, px2, py2,
+                             u12, v12, u21, v21, u22, v22,
+                             5.0, 6.0, 6.0, 5.0, 6.0, 6.0,
+                             color);
+    }
+    return res;
+}
+
+HRESULT D3DVertexCacher::DrawParallelogramAA(float ox11, float oy11,
+                                             float ox21, float oy21,
+                                             float ox12, float oy12,
+                                             float ix11, float iy11,
+                                             float ix21, float iy21,
+                                             float ix12, float iy12)
+{
+    HRESULT res;
+    DECLARE_MATRIX(om);
+    DECLARE_MATRIX(im);
+
+    GET_INVERTED_MATRIX(im, ix11, iy11, ix21, iy21, ix12, iy12,
+                        // inner parallelogram is degenerate
+                        // therefore it encloses no area
+                        // fill outer
+                        return FillParallelogramAA(ox11, oy11,
+                                                   ox21, oy21,
+                                                   ox12, oy12));
+    GET_INVERTED_MATRIX(om, ox11, oy11, ox21, oy21, ox12, oy12,
+                        return D3D_OK);
+
+    if (SUCCEEDED(res = EnsureCapacity(D3DPT_TRIANGLELIST, 2*3))) {
+        float ox = ox11, oy = oy11;
+        float ow = 0.0f, oh = 0.0f;
+        ADJUST_PGRAM(ox, ox21, ow);
+        ADJUST_PGRAM(oy, oy21, oh);
+        ADJUST_PGRAM(ox, ox12, ow);
+        ADJUST_PGRAM(oy, oy12, oh);
+        float ox11 = floor(ox);
+        float oy11 = floor(oy);
+        float ox22 = ceil(ox + ow);
+        float oy22 = ceil(oy + oh);
+        float ou11, ov11, ou12, ov12, ou21, ov21, ou22, ov22;
+        TRANSFORM(om, ou11, ov11, ox11, oy11);
+        TRANSFORM(om, ou21, ov21, ox22, oy11);
+        TRANSFORM(om, ou12, ov12, ox11, oy22);
+        TRANSFORM(om, ou22, ov22, ox22, oy22);
+        float iu11, iv11, iu12, iv12, iu21, iv21, iu22, iv22;
+        TRANSFORM(im, iu11, iv11, ox11, oy11);
+        TRANSFORM(im, iu21, iv21, ox22, oy11);
+        TRANSFORM(im, iu12, iv12, ox11, oy22);
+        TRANSFORM(im, iu22, iv22, ox22, oy22);
+        ADD_TRIANGLE_XYUVUVC(ox11, oy11, ox22, oy11, ox11, oy22,
+                             ou11, ov11, ou21, ov21, ou12, ov12,
+                             iu11, iv11, iu21, iv21, iu12, iv12,
+                             color);
+        ADD_TRIANGLE_XYUVUVC(ox11, oy22, ox22, oy11, ox22, oy22,
+                             ou12, ov12, ou21, ov21, ou22, ov22,
+                             iu12, iv12, iu21, iv21, iu22, iv22,
+                             color);
+    }
+    return res;
+}
+
+HRESULT
+D3DVertexCacher::DrawTexture(float x1, float y1, float x2, float y2,
+                             float u1, float v1, float u2, float v2)
+{
+    HRESULT res;
+    if (SUCCEEDED(res = EnsureCapacity(D3DPT_TRIANGLELIST, 2*3))) {
+        // correct texel to pixel mapping; see D3DContext::SetTransform()
+        // for non-id tx case
+        if (pCtx->IsIdentityTx()) {
+            x1 -= 0.5f;
+            y1 -= 0.5f;
+            x2 -= 0.5f;
+            y2 -= 0.5f;
+        }
+
+        ADD_TRIANGLE_XYUVC(x1, y1, x2, y1, x1, y2,
+                           u1, v1, u2, v1, u1, v2,
+                           color);
+        ADD_TRIANGLE_XYUVC(x1, y2, x2, y1, x2, y2,
+                           u1, v2, u2, v1, u2, v2,
+                           color);
+    }
+    return res;
+}
+
+HRESULT
+D3DVertexCacher::DrawTexture(float  x1, float  y1, float  x2, float  y2,
+                             float u11, float v11, float u12, float v12,
+                             float u21, float v21, float u22, float v22)
+{
+    HRESULT res;
+    if (SUCCEEDED(res = EnsureCapacity(D3DPT_TRIANGLELIST, 2*3))) {
+        // correct texel to pixel mapping; see D3DContext::SetTransform()
+        // for non-id tx case
+        if (pCtx->IsIdentityTx()) {
+            x1 -= 0.5f;
+            y1 -= 0.5f;
+            x2 -= 0.5f;
+            y2 -= 0.5f;
+        }
+
+        ADD_TRIANGLE_XYUVUVC(x1, y1, x2, y1, x1, y2,
+                             u11, v11, u12, v11, u11, v12,
+                             u21, v21, u22, v21, u21, v22,
+                             color);
+        ADD_TRIANGLE_XYUVUVC(x1, y2, x2, y1, x2, y2,
+                             u11, v12, u12, v11, u12, v12,
+                             u21, v22, u22, v21, u22, v22,
+                             color);
+    }
+    return res;
+}
+
+HRESULT D3DVertexCacher::Render(int actionType)
+{
+    J2DLVERTEX *lpVert;
+    HRESULT res;
+    DWORD dwLockFlags;
+    UINT pendingVertices = firstUnusedVertex - firstPendingVertex;
+
+    // nothing to render
+    if (pendingVertices == 0) {
+        if (actionType == RESET_ACTION) {
+            firstPendingBatch = 0;
+            firstPendingVertex = 0;
+            firstUnusedVertex = 0;
+            currentBatch = 0;
+        }
+        return D3D_OK;
+    }
+
+    if (firstPendingVertex == 0) {
+        // no data in the buffer yet, we don't care about
+        // vertex buffer's contents
+        dwLockFlags = D3DLOCK_DISCARD;
+    } else {
+        // append to the existing data in the vertex buffer
+        dwLockFlags = D3DLOCK_NOOVERWRITE;
+    }
+
+    if (SUCCEEDED(res =
+        lpD3DVertexBuffer->Lock((UINT)firstPendingVertex*sizeof(J2DLVERTEX),
+                                (UINT)pendingVertices*sizeof(J2DLVERTEX),
+                                (void**)&lpVert, dwLockFlags)))
+    {
+        // copy only new vertices
+        memcpy((void *)lpVert,
+               (void *)(vertices + firstPendingVertex),
+               pendingVertices * sizeof(J2DLVERTEX));
+        res = lpD3DVertexBuffer->Unlock();
+        UINT currentVertex = firstPendingVertex;
+        UINT batchSize;
+        J2dTraceLn2(J2D_TRACE_VERBOSE,
+                    "D3DVC::Render Starting flushing of %d vertices "\
+                    "in %d batches",
+                    pendingVertices,
+                    (currentBatch - firstPendingBatch + 1));
+
+
+        for (UINT b = firstPendingBatch; b <= currentBatch; b++) {
+            D3DPRIMITIVETYPE pType = batches[b].pType;
+            UINT primCount = batches[b].pNum;
+            switch (pType) {
+                // the macro for adding a line segment adds one too many prims
+                case D3DPT_LINESTRIP: batchSize = primCount; primCount--; break;
+                case D3DPT_LINELIST: batchSize = primCount*2; break;
+                default: batchSize = primCount*3; break;
+            }
+            res = lpD3DDevice->DrawPrimitive(pType, currentVertex, primCount);
+            currentVertex += batchSize;
+            // init to something it can never be
+            batches[b].pType = (D3DPRIMITIVETYPE)0;
+            batches[b].pNum = 0;
+        }
+    } else {
+        DebugPrintD3DError(res, "Can't lock vertex buffer");
+    }
+
+    // REMIND: may need to rethink what to do in case of an error,
+    // should we try to render them later?
+    if (actionType == RESET_ACTION) {
+        firstPendingBatch = 0;
+        firstPendingVertex = 0;
+        firstUnusedVertex = 0;
+        currentBatch = 0;
+    } else {
+        firstPendingBatch = currentBatch;
+        firstPendingVertex = firstUnusedVertex;
+    }
+
+    return res;
+}
+
+HRESULT D3DVertexCacher::EnsureCapacity(D3DPRIMITIVETYPE newPType, UINT vNum)
+{
+    HRESULT res = D3D_OK;
+    if (vNum > MAX_BATCH_SIZE) {
+        // REMIND: need to define our own errors
+        return D3DERR_NOTAVAILABLE;
+    }
+    if ((firstUnusedVertex + vNum) > MAX_BATCH_SIZE) {
+        // if we can't fit new vertices in the vertex buffer,
+        // render whatever we have in the buffer and start
+        // from the beginning of the vertex buffer
+        J2dTraceLn2(J2D_TRACE_VERBOSE,
+                    "D3DVC::EnsureCapacity exceeded capacity. "\
+                    "current v: %d, requested vertices: %d\n",
+                    firstUnusedVertex, vNum);
+        if (FAILED(res = Render(RESET_ACTION))) {
+            return res;
+        }
+    }
+
+    J2dTraceLn5(J2D_TRACE_VERBOSE,
+                "D3DVC::EnsureCapacity current batch: %d "\
+                " batch.type=%d newType=%d vNum=%d firstUnusedV=%d",
+                currentBatch, batches[currentBatch].pType, newPType, vNum,
+                firstUnusedVertex);
+    // there should not be multiple linestrips in a batch,
+    // or they will be counted as a single line strip
+    if (batches[currentBatch].pType != newPType ||
+        batches[currentBatch].pType == D3DPT_LINESTRIP)
+    {
+        // if this is a first unused batch, use it
+        if (firstUnusedVertex == firstPendingVertex) {
+            // record the first batch and vertex scheduled for rendering
+            firstPendingBatch = currentBatch;
+            firstPendingVertex = firstUnusedVertex;
+        } else {
+            // otherwise go to the next batch
+            currentBatch++;
+        }
+        batches[currentBatch].pType = newPType;
+        batches[currentBatch].pNum = 0;
+    }
+    // firstUnusedVertex is updated when new vertices are added
+    // to the vertices array
+
+    return res;
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DVertexCacher.h openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DVertexCacher.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/d3d/D3DVertexCacher.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/d3d/D3DVertexCacher.h	2011-01-08 01:26:50.487202383 +0000
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef D3DVERTEXCACHER_H
+#define D3DVERTEXCACHER_H
+
+#include "jni.h"
+#include "D3DContext.h"
+
+#define MAX_BATCH_SIZE 1024
+#define APPEND_ACTION 0x0
+#define RESET_ACTION  0x1
+#define D3DFVF_J2DLVERTEX \
+    (D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX2 | \
+    D3DFVF_TEXCOORDSIZE2(0) | D3DFVF_TEXCOORDSIZE2(1) )
+typedef struct _J2DLVERTEX {
+    float x, y, z;
+    DWORD color;
+    float tu1, tv1;
+    float tu2, tv2;
+} J2DLVERTEX;
+
+typedef struct {
+    D3DPRIMITIVETYPE pType; // type of primitives in this batch
+    UINT pNum; // number of primitives of pType in this batch
+} VertexBatch;
+
+class D3DContext;
+
+class D3DPIPELINE_API D3DVertexCacher {
+public:
+    HRESULT Init(D3DContext *pCtx);
+            ~D3DVertexCacher() { ReleaseDefPoolResources(); }
+    void    ReleaseDefPoolResources();
+
+    jint    GetColor() { return color; }
+    void    SetColor(jint newColor) { color = newColor; }
+    HRESULT DrawLine(int x1, int y1, int x2, int y2);
+    HRESULT DrawPoly(jint nPoints, jboolean isClosed,
+                     jint transX, jint transY,
+                     jint *xPoints, jint *yPoints);
+    HRESULT DrawScanlines(jint scanlineCount, jint *scanlines);
+    HRESULT DrawRect(int x1, int y1, int x2, int y2);
+    HRESULT FillRect(int x1, int y1, int x2, int y2);
+    HRESULT FillParallelogramAA(float fx11, float fy11,
+                                float dx21, float dy21,
+                                float dx12, float dy12);
+    HRESULT DrawParallelogramAA(float ox11, float oy11,
+                                float ox21, float oy21,
+                                float ox12, float oy12,
+                                float ix11, float iy11,
+                                float ix21, float iy21,
+                                float ix12, float iy12);
+    HRESULT FillParallelogram(float fx11, float fy11,
+                              float dx21, float dy21,
+                              float dx12, float dy12);
+    HRESULT FillSpans(jint spansCount, jint *spans);
+    HRESULT DrawTexture(float dx1, float dy1, float dx2, float dy2,
+                        float tx1, float ty1, float tx2, float ty2);
+    HRESULT DrawTexture(float  dx1, float  dy1, float  dx2, float  dy2,
+                        float t1x1, float t1y1, float t1x2, float t1y2,
+                        float t2x1, float t2y1, float t2x2, float t2y2);
+    HRESULT Render(int actionType = APPEND_ACTION);
+    UINT    GetFreeVertices() { return (MAX_BATCH_SIZE - firstUnusedVertex); }
+
+static
+    HRESULT CreateInstance(D3DContext *pCtx, D3DVertexCacher **ppVC);
+
+private:
+            D3DVertexCacher();
+    HRESULT EnsureCapacity(D3DPRIMITIVETYPE newPType, UINT vNum);
+
+private:
+    UINT firstPendingBatch;
+    UINT firstPendingVertex;
+    UINT firstUnusedVertex;
+    UINT currentBatch;
+    J2DLVERTEX              vertices[MAX_BATCH_SIZE];
+    VertexBatch             batches[MAX_BATCH_SIZE];
+    IDirect3DVertexBuffer9  *lpD3DVertexBuffer;
+    IDirect3DDevice9        *lpD3DDevice;
+    D3DContext              *pCtx;
+    jint                    color;
+};
+
+#endif // D3DVERTEXCACHER_H
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/opengl/WGLGraphicsConfig.c openjdk/jdk/src/windows/native/sun/java2d/opengl/WGLGraphicsConfig.c
--- openjdk.orig/jdk/src/windows/native/sun/java2d/opengl/WGLGraphicsConfig.c	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/opengl/WGLGraphicsConfig.c	2011-01-08 01:26:50.487202383 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -501,7 +501,7 @@
     WGLGraphicsConfigInfo *wglinfo;
     const unsigned char *versionstr;
     const char *extstr;
-    jint caps = sun_java2d_opengl_OGLContext_CAPS_EMPTY;
+    jint caps = CAPS_EMPTY;
     int attrKeys[] = { WGL_DOUBLE_BUFFER_ARB, WGL_ALPHA_BITS_ARB };
     int attrVals[2];
 
@@ -626,10 +626,10 @@
     // get config-specific capabilities
     j2d_wglGetPixelFormatAttribivARB(hdc, pixfmt, 0, 2, attrKeys, attrVals);
     if (attrVals[0]) {
-        caps |= sun_java2d_opengl_OGLContext_CAPS_DOUBLEBUFFERED;
+        caps |= CAPS_DOUBLEBUFFERED;
     }
     if (attrVals[1] > 0) {
-        caps |= sun_java2d_opengl_OGLContext_CAPS_STORED_ALPHA;
+        caps |= CAPS_STORED_ALPHA;
     }
 
     // create the scratch pbuffer
@@ -712,7 +712,7 @@
     J2dTraceLn(J2D_TRACE_INFO, "WGLGraphicsConfig_getOGLCapabilities");
 
     if (wglinfo == NULL || wglinfo->context == NULL) {
-        return sun_java2d_opengl_OGLContext_CAPS_EMPTY;
+        return CAPS_EMPTY;
     }
 
     return wglinfo->context->caps;
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/opengl/WGLSurfaceData.c openjdk/jdk/src/windows/native/sun/java2d/opengl/WGLSurfaceData.c
--- openjdk.orig/jdk/src/windows/native/sun/java2d/opengl/WGLSurfaceData.c	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/opengl/WGLSurfaceData.c	2011-01-08 01:26:50.487202383 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -44,11 +44,21 @@
 extern UnlockFunc                   OGLSD_Unlock;
 extern DisposeFunc                  OGLSD_Dispose;
 
+extern OGLPixelFormat PixelFormats[];
+extern void AwtWindow_UpdateWindow(JNIEnv *env, jobject peer,
+                                   jint w, jint h, HBITMAP hBitmap);
+extern HBITMAP BitmapUtil_CreateBitmapFromARGBPre(int width, int height,
+                                                  int srcStride,
+                                                  int* imageData);
+extern void AwtComponent_GetInsets(JNIEnv *env, jobject peer, RECT *insets);
+
+extern void
+    OGLSD_SetNativeDimensions(JNIEnv *env, OGLSDOps *oglsdo, jint w, jint h);
+
 JNIEXPORT void JNICALL
 Java_sun_java2d_opengl_WGLSurfaceData_initOps(JNIEnv *env, jobject wglsd,
                                               jlong pConfigInfo,
-                                              jlong pPeerData,
-                                              jint xoff, jint yoff)
+                                              jobject peer, jlong hwnd)
 {
     OGLSDOps *oglsdo = (OGLSDOps *)SurfaceData_InitOps(env, wglsd,
                                                        sizeof(OGLSDOps));
@@ -71,10 +81,17 @@
     oglsdo->drawableType = OGLSD_UNDEFINED;
     oglsdo->activeBuffer = GL_FRONT;
     oglsdo->needsInit = JNI_TRUE;
-    oglsdo->xOffset = xoff;
-    oglsdo->yOffset = yoff;
+    if (peer != NULL) {
+        RECT insets;
+        AwtComponent_GetInsets(env, peer, &insets);
+        oglsdo->xOffset = -insets.left;
+        oglsdo->yOffset = -insets.bottom;
+    } else {
+        oglsdo->xOffset = 0;
+        oglsdo->yOffset = 0;
+    }
 
-    wglsdo->peerData = pPeerData;
+    wglsdo->window = (HWND)jlong_to_ptr(hwnd);
     wglsdo->configInfo = (WGLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
     if (wglsdo->configInfo == NULL) {
         free(wglsdo);
@@ -96,14 +113,14 @@
     J2dTraceLn(J2D_TRACE_INFO, "OGLSD_DestroyOGLSurface");
 
     if (oglsdo->drawableType == OGLSD_PBUFFER) {
-        if (wglsdo->drawable.pbuffer != 0) {
+        if (wglsdo->pbuffer != 0) {
             if (wglsdo->pbufferDC != 0) {
-                j2d_wglReleasePbufferDCARB(wglsdo->drawable.pbuffer,
+                j2d_wglReleasePbufferDCARB(wglsdo->pbuffer,
                                            wglsdo->pbufferDC);
                 wglsdo->pbufferDC = 0;
             }
-            j2d_wglDestroyPbufferARB(wglsdo->drawable.pbuffer);
-            wglsdo->drawable.pbuffer = 0;
+            j2d_wglDestroyPbufferARB(wglsdo->pbuffer);
+            wglsdo->pbuffer = 0;
         }
     }
 }
@@ -256,7 +273,7 @@
     if (dstOps->drawableType == OGLSD_PBUFFER) {
         dstHDC = dstWGLOps->pbufferDC;
     } else {
-        dstHDC = GetDC(dstWGLOps->drawable.window);
+        dstHDC = GetDC(dstWGLOps->window);
     }
 
     // get the hdc for the source surface
@@ -284,7 +301,7 @@
         J2dRlsTraceLn(J2D_TRACE_ERROR,
                       "OGLSD_MakeOGLContextCurrent: could not make current");
         if (dstOps->drawableType != OGLSD_PBUFFER) {
-            ReleaseDC(dstWGLOps->drawable.window, dstHDC);
+            ReleaseDC(dstWGLOps->window, dstHDC);
         }
         return NULL;
     }
@@ -297,7 +314,7 @@
     }
 
     if (dstOps->drawableType != OGLSD_PBUFFER) {
-        ReleaseDC(dstWGLOps->drawable.window, dstHDC);
+        ReleaseDC(dstWGLOps->window, dstHDC);
     }
 
     return oglc;
@@ -340,7 +357,7 @@
         return JNI_FALSE;
     }
 
-    window = AwtComponent_GetHWnd(env, wglsdo->peerData);
+    window = wglsdo->window;
     if (!IsWindow(window)) {
         J2dRlsTraceLn(J2D_TRACE_ERROR,
                       "OGLSD_InitOGLWindow: disposed component");
@@ -369,7 +386,6 @@
     oglsdo->isOpaque = JNI_TRUE;
     oglsdo->width = wbounds.right - wbounds.left;
     oglsdo->height = wbounds.bottom - wbounds.top;
-    wglsdo->drawable.window = window;
     wglsdo->pbufferDC = 0;
 
     J2dTraceLn2(J2D_TRACE_VERBOSE, "  created window: w=%d h=%d",
@@ -505,9 +521,11 @@
     oglsdo->isOpaque = isOpaque;
     oglsdo->width = width;
     oglsdo->height = height;
-    wglsdo->drawable.pbuffer = pbuffer;
+    wglsdo->pbuffer = pbuffer;
     wglsdo->pbufferDC = pbufferDC;
 
+    OGLSD_SetNativeDimensions(env, oglsdo, width, height);
+
     return JNI_TRUE;
 }
 
@@ -543,3 +561,83 @@
                       "OGLSD_SwapBuffers: error while releasing dc");
     }
 }
+
+/*
+ * Class:     sun_java2d_opengl_WGLSurfaceData
+ * Method:    updateWindowAccelImpl
+ * Signature: (JJII)Z
+ */
+JNIEXPORT jboolean JNICALL
+    Java_sun_java2d_opengl_WGLSurfaceData_updateWindowAccelImpl
+  (JNIEnv *env, jclass clazz, jlong pData, jobject peer, jint w, jint h)
+{
+    OGLSDOps *oglsdo = (OGLSDOps *)jlong_to_ptr(pData);
+    OGLPixelFormat pf = PixelFormats[0/*PF_INT_ARGB_PRE*/];
+    HBITMAP hBitmap = NULL;
+    void *pDst;
+    jint srcx, srcy, dstx, dsty, width, height;
+    jint pixelStride = 4;
+    jint scanStride = pixelStride * w;
+
+    J2dTraceLn(J2D_TRACE_INFO, "WGLSurfaceData_updateWindowAccelImpl");
+
+    if (w <= 0 || h <= 0) {
+        return JNI_TRUE;
+    }
+    if (oglsdo == NULL) {
+        return JNI_FALSE;
+    }
+    RESET_PREVIOUS_OP();
+
+    width = w;
+    height = h;
+    srcx = srcy = dstx = dsty = 0;
+
+    pDst = malloc(height * scanStride);
+    if (pDst == NULL) {
+        return JNI_FALSE;
+    }
+    ZeroMemory(pDst, height * scanStride);
+
+    // the code below is mostly copied from OGLBlitLoops_SurfaceToSwBlit
+
+    j2d_glPixelStorei(GL_PACK_SKIP_PIXELS, dstx);
+    j2d_glPixelStorei(GL_PACK_ROW_LENGTH, scanStride / pixelStride);
+    j2d_glPixelStorei(GL_PACK_ALIGNMENT, pf.alignment);
+
+    // this accounts for lower-left origin of the source region
+    srcx = oglsdo->xOffset + srcx;
+    srcy = oglsdo->yOffset + oglsdo->height - (srcy + 1);
+    // we must read one scanline at a time because there is no way
+    // to read starting at the top-left corner of the source region
+    while (height > 0) {
+        j2d_glPixelStorei(GL_PACK_SKIP_ROWS, dsty);
+        j2d_glReadPixels(srcx, srcy, width, 1,
+                         pf.format, pf.type, pDst);
+        srcy--;
+        dsty++;
+        height--;
+    }
+
+    j2d_glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
+    j2d_glPixelStorei(GL_PACK_SKIP_ROWS, 0);
+    j2d_glPixelStorei(GL_PACK_ROW_LENGTH, 0);
+    j2d_glPixelStorei(GL_PACK_ALIGNMENT, 4);
+
+    // the pixels read from the surface are already premultiplied
+    // REMIND: commented until translucent window support is integrated
+//    hBitmap = BitmapUtil_CreateBitmapFromARGBPre(w, h, scanStride,
+//                                                 (int*)pDst);
+    free(pDst);
+
+    if (hBitmap == NULL) {
+        return JNI_FALSE;
+    }
+
+    // REMIND: commented until translucent window support is integrated
+    // AwtWindow_UpdateWindow(env, peer, w, h, hBitmap);
+
+    // hBitmap is released in UpdateWindow
+
+    return JNI_TRUE;
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/opengl/WGLSurfaceData.h openjdk/jdk/src/windows/native/sun/java2d/opengl/WGLSurfaceData.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/opengl/WGLSurfaceData.h	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/opengl/WGLSurfaceData.h	2011-01-08 01:26:50.487202383 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,12 +35,9 @@
  * OGLSurfaceData.  It is referenced by the native OGLSDOps structure.
  */
 typedef struct _WGLSDOps {
-    jlong peerData;
     WGLGraphicsConfigInfo *configInfo;
-    union {
-        HWND        window;
-        HPBUFFERARB pbuffer;
-    } drawable;
+    HWND        window;
+    HPBUFFERARB pbuffer;
     HDC pbufferDC;
 } WGLSDOps;
 
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/windows/GDIBlitLoops.cpp openjdk/jdk/src/windows/native/sun/java2d/windows/GDIBlitLoops.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/windows/GDIBlitLoops.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/windows/GDIBlitLoops.cpp	2011-01-08 01:26:50.487202383 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,8 +25,8 @@
 
 #include <sun_java2d_windows_GDIBlitLoops.h>
 #include "gdefs.h"
-#include "ddrawUtils.h"
 #include "Trace.h"
+#include "GDIWindowSurfaceData.h"
 
 static RGBQUAD *byteGrayPalette = NULL;
 
@@ -60,7 +60,7 @@
 
     SurfaceDataRasInfo srcInfo;
     SurfaceDataOps *srcOps = SurfaceData_GetOps(env, srcData);
-    Win32SDOps *dstOps = Win32SurfaceData_GetOps(env, dstData);
+    GDIWinSDOps *dstOps = GDIWindowSurfaceData_GetOps(env, dstData);
     jint lockFlags;
 
     srcInfo.bounds.x1 = srcx;
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/windows/GDIRenderer.cpp openjdk/jdk/src/windows/native/sun/java2d/windows/GDIRenderer.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/windows/GDIRenderer.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/windows/GDIRenderer.cpp	2011-01-08 01:26:50.487202383 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,11 +26,10 @@
 #include "sun_java2d_windows_GDIRenderer.h"
 #include "java_awt_geom_PathIterator.h"
 
-#include "Win32SurfaceData.h"
+#include "GDIWindowSurfaceData.h"
 #include "awt_Component.h"
 #include "awt_Pen.h"
 #include "awt_Brush.h"
-#include "ddrawUtils.h"
 
 #include "jni.h"
 
@@ -133,7 +132,7 @@
     J2dTraceLn5(J2D_TRACE_VERBOSE,
                 "  color=0x%x x1=%-4d y1=%-4d x2=%-4d y2=%-4d",
                 color, x1, y1, x2, y2);
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -184,7 +183,7 @@
         return;
     }
 
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -241,7 +240,7 @@
         return;
     }
 
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -279,7 +278,7 @@
         return;
     }
 
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -315,7 +314,7 @@
         return;
     }
 
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -385,7 +384,7 @@
         return;
     }
 
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -432,7 +431,7 @@
         return;
     }
 
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -476,7 +475,7 @@
         return;
     }
 
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -543,7 +542,7 @@
         return;
     }
 
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -589,7 +588,7 @@
         return;
     }
 
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -652,7 +651,7 @@
         return;
     }
 
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -698,7 +697,7 @@
     J2dTraceLn4(J2D_TRACE_VERBOSE,
                 "  color=0x%x transx=%-4d transy=%-4d isfill=%-4d",
                 color, transX, transY, isfill);
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, sData);
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, sData);
     if (wsdo == NULL) {
         return;
     }
@@ -849,8 +848,6 @@
 
 } /* extern "C" */
 
-extern int currNumDevices;
-
 INLINE BOOL RectInMonitorRect(RECT *rCheck, RECT *rContainer)
 {
     // Assumption: left <= right, top <= bottom
@@ -878,8 +875,8 @@
      jint dx, jint dy,
      jint width, jint height)
 {
-    Win32SDOps *wsdo = Win32SurfaceData_GetOps(env, wsd);
-    J2dTraceLn(J2D_TRACE_INFO, "Win32SurfaceData_devCopyArea");
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOps(env, wsd);
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWindowSurfaceData_devCopyArea");
     J2dTraceLn4(J2D_TRACE_VERBOSE, "   srcx=%-4d srcy=%-4d dx=%-4d dy=%-4d",
                 srcx, srcy, dx, dy);
     J2dTraceLn2(J2D_TRACE_VERBOSE, "     w=%-4d h=%-4d", width, height);
@@ -892,61 +889,6 @@
         return;
     }
 
-    if (DDCanBlt(wsdo)) {
-        // We try to use ddraw for this copy because it tends to be faster
-        // than GDI.  We punt if:
-        //      - the source rect is clipped (GDI does a better job of
-        //      validating the clipped area)
-        //      - there is only one monitor
-        //       OR
-        //      - the src and dest rectangles are both wholly within the device
-        //      associated with this surfaceData
-        // REMIND: There may be a bug looming out here where the user
-        // moves an overlapping window between the time that we check the
-        // clip and the time that the Blt is executed, then we may not be
-        // invalidating the src region the way we should.
-
-        // Here, rSrc, rDst are the src/dst rectangles in screen coordinates.
-        // r[Src|Dst]Absolute are the src/dst rectangles in virtual
-        // screen space (where all monitors occupy the same coords).
-        RECT rSrc = {srcx, srcy, srcx + width, srcy + height};
-        RECT rDst, rSrcAbsolute, rDstAbsolute;
-        POINT clientOrigin = {0, 0};
-        MONITOR_INFO *mi = wsdo->device->GetMonitorInfo();
-        ::ScreenToClient(wsdo->window, &clientOrigin);
-        ::OffsetRect(&rSrc,
-            (-clientOrigin.x - wsdo->insets.left),
-            (-clientOrigin.y - wsdo->insets.top));
-        rSrcAbsolute = rSrc;
-        ::OffsetRect(&rSrc, (-mi->rMonitor.left), (-mi->rMonitor.top));
-        rDst = rSrc;
-        ::OffsetRect(&rDst, dx, dy);
-        rDstAbsolute = rSrcAbsolute;
-        ::OffsetRect(&rDstAbsolute, dx, dy);
-
-        if (DDClipCheck(wsdo, &rSrc) &&
-            (currNumDevices <= 1 ||
-             (RectInMonitorRect(&rSrcAbsolute, &mi->rMonitor) &&
-              RectInMonitorRect(&rDstAbsolute, &mi->rMonitor))))
-        {
-            AwtComponent *comp = NULL;
-
-            // Bug 4362500: Win2k pointer garbage on screen->screen DD blts
-            if (IS_WIN2000) {
-                comp = Win32SurfaceData_GetComp(env, wsdo);
-                if (comp != NULL) {
-                    comp->SendMessage(WM_AWT_HIDECURSOR, NULL);
-                }
-            }
-
-            DDBlt(env,wsdo, wsdo, &rDst, &rSrc);
-
-            if (comp != NULL) {
-                comp->SendMessage(WM_AWT_SHOWCURSOR, NULL);
-            }
-            return;
-        }
-    }
     HDC hDC = wsdo->GetDC(env, wsdo, 0, NULL, NULL, NULL, 0);
     if (hDC == NULL) {
         return;
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.cpp openjdk/jdk/src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.cpp	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.cpp	2011-01-08 01:26:50.487202383 +0000
@@ -0,0 +1,1204 @@
+/*
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "sun_java2d_windows_GDIWindowSurfaceData.h"
+
+#include "GDIWindowSurfaceData.h"
+#include "GraphicsPrimitiveMgr.h"
+#include "Region.h"
+#include "Disposer.h"
+#include "WindowsFlags.h"
+#include "awt_Component.h"
+#include "awt_Palette.h"
+#include "awt_Win32GraphicsDevice.h"
+#include "gdefs.h"
+#include "Trace.h"
+#include "Devices.h"
+
+#include "jni_util.h"
+
+static LockFunc GDIWinSD_Lock;
+static GetRasInfoFunc GDIWinSD_GetRasInfo;
+static UnlockFunc GDIWinSD_Unlock;
+static DisposeFunc GDIWinSD_Dispose;
+static SetupFunc GDIWinSD_Setup;
+static GetDCFunc GDIWinSD_GetDC;
+static ReleaseDCFunc GDIWinSD_ReleaseDC;
+static InvalidateSDFunc GDIWinSD_InvalidateSD;
+
+static HBRUSH   nullbrush;
+static HPEN     nullpen;
+
+static jclass xorCompClass;
+
+static jboolean beingShutdown = JNI_FALSE;
+extern CriticalSection windowMoveLock;
+
+extern "C"
+{
+GeneralDisposeFunc DisposeThreadGraphicsInfo;
+jobject JNI_GetCurrentThread(JNIEnv *env);
+int threadInfoIndex = TLS_OUT_OF_INDEXES;
+
+static jclass threadClass = NULL;
+static jmethodID currentThreadMethodID = NULL;
+
+void SetupThreadGraphicsInfo(JNIEnv *env, GDIWinSDOps *wsdo) {
+    J2dTraceLn(J2D_TRACE_INFO, "SetupThreadGraphicsInfo");
+
+    // REMIND: handle error when creation fails
+    ThreadGraphicsInfo *info =
+        (ThreadGraphicsInfo*)TlsGetValue(threadInfoIndex);
+    if (info == NULL) {
+        info = new ThreadGraphicsInfo;
+        ZeroMemory(info, sizeof(ThreadGraphicsInfo));
+        TlsSetValue(threadInfoIndex, (LPVOID)info);
+        J2dTraceLn2(J2D_TRACE_VERBOSE,
+                    "  current batch limit for for thread 0x%x is %d",
+                     GetCurrentThreadId(), ::GdiGetBatchLimit());
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  setting to the limit to 1");
+        // Fix for bug 4374079
+        ::GdiSetBatchLimit(1);
+
+        Disposer_AddRecord(env, JNI_GetCurrentThread(env),
+                           DisposeThreadGraphicsInfo,
+                           ptr_to_jlong(info));
+    }
+
+    HDC oldhDC = info->hDC;
+    // the hDC is NULL for offscreen surfaces - we don't store it
+    // in TLS as it must be created new every time.
+    if (((oldhDC == NULL) && wsdo->window != NULL) || (info->wsdo != wsdo)) {
+
+        // Init graphics state, either because this is our first time
+        // using it in this thread or because this thread is now
+        // dealing with a different window than it was last time.
+
+        // Release cached DC. We use deferred DC releasing mechanism because
+        // the DC is associated with cached wsdo and component peer,
+        // which may've been disposed by this time, and we have
+        // no means of checking against it.
+        if (oldhDC != NULL) {
+            MoveDCToPassiveList(oldhDC);
+            info->hDC = NULL;
+        }
+
+        if (wsdo->window != NULL){
+            HDC hDC;
+            // This is a window surface
+            // First, init the HDC object
+            AwtComponent *comp = GDIWindowSurfaceData_GetComp(env, wsdo);
+            if (comp == NULL) {
+                return;
+            }
+            hDC = comp->GetDCFromComponent();
+            if (hDC != NULL) {
+                ::SelectObject(hDC, nullbrush);
+                ::SelectObject(hDC, nullpen);
+                ::SelectClipRgn(hDC, (HRGN) NULL);
+                ::SetROP2(hDC, R2_COPYPEN);
+                wsdo->device->SelectPalette(hDC);
+                // Note that on NT4 we don't need to do a realize here: the
+                // palette-sharing takes care of color issues for us.  But
+                // on win98 if we don't realize a DC's palette, that
+                // palette does not appear to have correct access to the
+                // logical->system mapping.
+                wsdo->device->RealizePalette(hDC);
+
+                // Second, init the rest of the graphics state
+                ::GetClientRect(wsdo->window, &info->bounds);
+                // Make window-relative from client-relative
+                ::OffsetRect(&info->bounds, wsdo->insets.left, wsdo->insets.top);
+                //Likewise, translate GDI calls from client-relative to window-relative
+                ::OffsetViewportOrgEx(hDC, -wsdo->insets.left, -wsdo->insets.top, NULL);
+            }
+
+            // Finally, set these new values in the info for this thread
+            info->hDC = hDC;
+        }
+
+        // cached brush and pen are not associated with any DC, and can be
+        // reused, but have to set type to 0 to indicate that no pen/brush
+        // were set to the new hdc
+        info->type = 0;
+
+        if (info->clip != NULL) {
+            env->DeleteWeakGlobalRef(info->clip);
+        }
+        info->clip = NULL;
+
+        if (info->comp != NULL) {
+            env->DeleteWeakGlobalRef(info->comp);
+        }
+        info->comp = NULL;
+
+        info->xorcolor = 0;
+        info->patrop = PATCOPY;
+
+        info->wsdo = wsdo;
+    }
+}
+
+/**
+ * Releases native data stored in Thread local storage.
+ * Called by the Disposer when the associated thread dies.
+ */
+void DisposeThreadGraphicsInfo(JNIEnv *env, jlong tgi) {
+    J2dTraceLn(J2D_TRACE_INFO, "DisposeThreadGraphicsInfo");
+    ThreadGraphicsInfo *info = (ThreadGraphicsInfo*)jlong_to_ptr(tgi);
+    if (info != NULL) {
+        if (info->hDC != NULL) {
+            // move the DC from the active dcs list to
+            // the passive dc list to be released later
+            MoveDCToPassiveList(info->hDC);
+        }
+
+        if (info->clip != NULL) {
+            env->DeleteWeakGlobalRef(info->clip);
+        }
+        if (info->comp != NULL) {
+            env->DeleteWeakGlobalRef(info->comp);
+        }
+
+        if (info->brush != NULL) {
+            info->brush->Release();
+        }
+        if (info->pen != NULL) {
+            info->pen->Release();
+        }
+
+        delete info;
+    }
+}
+
+/**
+ * Returns current Thread object.
+ */
+jobject
+JNI_GetCurrentThread(JNIEnv *env) {
+    return env->CallStaticObjectMethod(threadClass, currentThreadMethodID);
+} /* JNI_GetCurrentThread() */
+
+/**
+ * Return the data associated with this thread.
+ * NOTE: This function assumes that the SetupThreadGraphicsInfo()
+ * function has already been called for this situation (thread,
+ * window, etc.), so we can assume that the thread info contains
+ * a valid hDC.  This should usually be the case since GDIWinSD_Setup
+ * is called as part of the GetOps() process.
+ */
+ThreadGraphicsInfo *GetThreadGraphicsInfo(JNIEnv *env,
+                                          GDIWinSDOps *wsdo) {
+    return (ThreadGraphicsInfo*)TlsGetValue(threadInfoIndex);
+}
+
+__inline HDC GetThreadDC(JNIEnv *env, GDIWinSDOps *wsdo) {
+    ThreadGraphicsInfo *info =
+        (ThreadGraphicsInfo *)GetThreadGraphicsInfo(env, wsdo);
+    if (!info) {
+        return (HDC) NULL;
+    }
+    return info->hDC;
+}
+
+} // extern "C"
+
+/**
+ * This source file contains support code for loops using the
+ * SurfaceData interface to talk to a Win32 drawable from native
+ * code.
+ */
+
+static BOOL GDIWinSD_CheckMonitorArea(GDIWinSDOps *wsdo,
+                                     SurfaceDataBounds *bounds,
+                                     HDC hDC)
+{
+    HWND hW = wsdo->window;
+    BOOL retCode = TRUE;
+
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWinSD_CheckMonitorArea");
+    int numScreens;
+    {
+        Devices::InstanceAccess devices;
+        numScreens = devices->GetNumDevices();
+    }
+    if( numScreens > 1 ) {
+
+        MONITOR_INFO *miInfo;
+        RECT rSect ={0,0,0,0};
+        RECT rView ={bounds->x1, bounds->y1, bounds->x2, bounds->y2};
+        retCode = FALSE;
+
+        miInfo = wsdo->device->GetMonitorInfo();
+
+        POINT ptOrig = {0, 0};
+        ::ClientToScreen(hW, &ptOrig);
+        ::OffsetRect(&rView,
+            (ptOrig.x), (ptOrig.y));
+
+        ::IntersectRect(&rSect,&rView,&(miInfo->rMonitor));
+
+        if( FALSE == ::IsRectEmpty(&rSect) ) {
+            if( TRUE == ::EqualRect(&rSect,&rView) ) {
+                retCode = TRUE;
+            }
+        }
+    }
+    return retCode;
+}
+
+extern "C" {
+
+void
+initThreadInfoIndex()
+{
+    if (threadInfoIndex == TLS_OUT_OF_INDEXES) {
+        threadInfoIndex = TlsAlloc();
+    }
+}
+
+
+/**
+ * Utility function to make sure that native and java-level
+ * surface depths are matched.  They can be mismatched when display-depths
+ * change, either between the creation of the Java surfaceData structure
+ * and the native ddraw surface, or later when a surface is automatically
+ * adjusted to be the new display depth (even if it was created in a different
+ * depth to begin with)
+ */
+BOOL SurfaceDepthsCompatible(int javaDepth, int nativeDepth)
+{
+    if (nativeDepth != javaDepth) {
+        switch (nativeDepth) {
+        case 0: // Error condition: something is wrong with the surface
+        case 8:
+        case 24:
+            // Java and native surface depths should match exactly for
+            // these cases
+            return FALSE;
+            break;
+        case 16:
+            // Java surfaceData should be 15 or 16 bits
+            if (javaDepth < 15 || javaDepth > 16) {
+                return FALSE;
+            }
+            break;
+        case 32:
+            // Could have this native depth for either 24- or 32-bit
+            // Java surfaceData
+            if (javaDepth != 24 && javaDepth != 32) {
+                return FALSE;
+            }
+            break;
+        default:
+            // should not get here, but if we do something is odd, so
+            // just register a failure
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+
+
+/*
+ * Class:     sun_java2d_windows_GDIWindowSurfaceData
+ * Method:    initIDs
+ * Signature: ()V
+ */
+JNIEXPORT void JNICALL
+Java_sun_java2d_windows_GDIWindowSurfaceData_initIDs(JNIEnv *env, jclass wsd,
+                                                 jclass XORComp)
+{
+    jclass tc;
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWindowSurfaceData_initIDs");
+    nullbrush = (HBRUSH) ::GetStockObject(NULL_BRUSH);
+    nullpen = (HPEN) ::GetStockObject(NULL_PEN);
+
+    initThreadInfoIndex();
+
+    xorCompClass = (jclass)env->NewGlobalRef(XORComp);
+
+    tc = env->FindClass("java/lang/Thread");
+    DASSERT(tc != NULL);
+    threadClass = (jclass)env->NewGlobalRef(tc);
+    DASSERT(threadClass != NULL);
+    currentThreadMethodID =
+        env->GetStaticMethodID(threadClass,
+                               "currentThread",  "()Ljava/lang/Thread;");
+    DASSERT(currentThreadMethodID != NULL);
+}
+
+/*
+ * Class:     sun_java2d_windows_GDIWindowSurfaceData
+ * Method:    initOps
+ * Signature: (Ljava/lang/Object;IIIIII)V
+ */
+JNIEXPORT void JNICALL
+Java_sun_java2d_windows_GDIWindowSurfaceData_initOps(JNIEnv *env, jobject wsd,
+                                                 jobject peer, jint depth,
+                                                 jint redMask, jint greenMask,
+                                                 jint blueMask, jint screen)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWindowSurfaceData_initOps");
+    GDIWinSDOps *wsdo = (GDIWinSDOps *)SurfaceData_InitOps(env, wsd, sizeof(GDIWinSDOps));
+    wsdo->sdOps.Lock = GDIWinSD_Lock;
+    wsdo->sdOps.GetRasInfo = GDIWinSD_GetRasInfo;
+    wsdo->sdOps.Unlock = GDIWinSD_Unlock;
+    wsdo->sdOps.Dispose = GDIWinSD_Dispose;
+    wsdo->sdOps.Setup = GDIWinSD_Setup;
+    wsdo->GetDC = GDIWinSD_GetDC;
+    wsdo->ReleaseDC = GDIWinSD_ReleaseDC;
+    wsdo->InvalidateSD = GDIWinSD_InvalidateSD;
+    wsdo->invalid = JNI_FALSE;
+    wsdo->lockType = WIN32SD_LOCK_UNLOCKED;
+    wsdo->peer = env->NewWeakGlobalRef(peer);
+    wsdo->depth = depth;
+    wsdo->pixelMasks[0] = redMask;
+    wsdo->pixelMasks[1] = greenMask;
+    wsdo->pixelMasks[2] = blueMask;
+    // Init the DIB pixelStride and pixel masks according to
+    // the pixel depth. In the 8-bit case, there are no
+    // masks as a palette DIB is used instead. Likewise
+    // in the 24-bit case, Windows doesn't expect the masks
+    switch (depth) {
+        case 8:
+            wsdo->pixelStride = 1;
+            break;
+        case 15: //555
+            wsdo->pixelStride = 2;
+            break;
+        case 16: //565
+            wsdo->pixelStride = 2;
+            break;
+        case 24:
+            wsdo->pixelStride = 3;
+            break;
+        case 32: //888
+            wsdo->pixelStride = 4;
+            break;
+    }
+    // GDIWindowSurfaceData_GetWindow will throw NullPointerException
+    // if wsdo->window is NULL
+    wsdo->window = GDIWindowSurfaceData_GetWindow(env, wsdo);
+    J2dTraceLn2(J2D_TRACE_VERBOSE, "  wsdo=0x%x wsdo->window=0x%x",
+                wsdo, wsdo->window);
+
+    {
+        Devices::InstanceAccess devices;
+        wsdo->device = devices->GetDeviceReference(screen, FALSE);
+    }
+    if (wsdo->device == NULL ||
+        !SurfaceDepthsCompatible(depth, wsdo->device->GetBitDepth()))
+    {
+        if (wsdo->device != NULL) {
+            J2dTraceLn2(J2D_TRACE_WARNING,
+                        "GDIWindowSurfaceData_initOps: Surface depth mismatch: "\
+                        "wsdo->depth=%d device depth=%d. Surface invalidated.",
+                        wsdo->depth, wsdo->device->GetBitDepth());
+        } else {
+            J2dTraceLn1(J2D_TRACE_WARNING,
+                        "GDIWindowSurfaceData_initOps: Incorrect "\
+                        "screen number (screen=%d). Surface invalidated.",
+                        screen);
+        }
+
+        wsdo->invalid = JNI_TRUE;
+    }
+    wsdo->surfaceLock = new CriticalSection();
+    wsdo->bitmap = NULL;
+    wsdo->bmdc = NULL;
+    wsdo->bmCopyToScreen = FALSE;
+}
+
+JNIEXPORT GDIWinSDOps * JNICALL
+GDIWindowSurfaceData_GetOps(JNIEnv *env, jobject sData)
+{
+    SurfaceDataOps *ops = SurfaceData_GetOps(env, sData);
+    // REMIND: There was originally a condition check here to make sure
+    // that we were really dealing with a GDIWindowSurfaceData object, but
+    // it did not allow for the existence of other win32-accelerated
+    // surface data objects (e.g., Win32OffScreenSurfaceData).  I've
+    // removed the check for now, but we should replace it with another,
+    // more general check against Win32-related surfaces.
+    return (GDIWinSDOps *) ops;
+}
+
+JNIEXPORT GDIWinSDOps * JNICALL
+GDIWindowSurfaceData_GetOpsNoSetup(JNIEnv *env, jobject sData)
+{
+    // use the 'no setup' version of GetOps
+    SurfaceDataOps *ops = SurfaceData_GetOpsNoSetup(env, sData);
+    return (GDIWinSDOps *) ops;
+}
+
+JNIEXPORT AwtComponent * JNICALL
+GDIWindowSurfaceData_GetComp(JNIEnv *env, GDIWinSDOps *wsdo)
+{
+    PDATA pData;
+    jobject localObj = env->NewLocalRef(wsdo->peer);
+
+    if (localObj == NULL || (pData = JNI_GET_PDATA(localObj)) == NULL) {
+        J2dTraceLn1(J2D_TRACE_WARNING,
+                    "GDIWindowSurfaceData_GetComp: Null pData? pData=0x%x",
+                    pData);
+        if (beingShutdown == JNI_TRUE) {
+            wsdo->invalid = JNI_TRUE;
+            return (AwtComponent *) NULL;
+        }
+        try {
+            AwtToolkit::GetInstance().VerifyActive();
+        } catch (awt_toolkit_shutdown&) {
+            beingShutdown = JNI_TRUE;
+            wsdo->invalid = JNI_TRUE;
+            return (AwtComponent *) NULL;
+        }
+        if (wsdo->invalid == JNI_TRUE) {
+            SurfaceData_ThrowInvalidPipeException(env,
+                "GDIWindowSurfaceData: bounds changed");
+        } else {
+            JNU_ThrowNullPointerException(env, "component argument pData");
+        }
+        return (AwtComponent *) NULL;
+    }
+    return static_cast<AwtComponent*>(pData);
+}
+
+JNIEXPORT HWND JNICALL
+GDIWindowSurfaceData_GetWindow(JNIEnv *env, GDIWinSDOps *wsdo)
+{
+    HWND window = wsdo->window;
+
+    if (window == (HWND) NULL) {
+        AwtComponent *comp = GDIWindowSurfaceData_GetComp(env, wsdo);
+        if (comp == NULL) {
+            J2dTraceLn(J2D_TRACE_WARNING,
+                   "GDIWindowSurfaceData_GetWindow: null component");
+            return (HWND) NULL;
+        }
+        comp->GetInsets(&wsdo->insets);
+        window = comp->GetHWnd();
+        if (::IsWindow(window) == FALSE) {
+            J2dRlsTraceLn(J2D_TRACE_ERROR,
+                          "GDIWindowSurfaceData_GetWindow: disposed component");
+            JNU_ThrowNullPointerException(env, "disposed component");
+            return (HWND) NULL;
+        }
+        wsdo->window = window;
+    }
+
+    return window;
+}
+
+} /* extern "C" */
+
+static jboolean GDIWinSD_SimpleClip(JNIEnv *env, GDIWinSDOps *wsdo,
+                                   SurfaceDataBounds *bounds,
+                                   HDC hDC)
+{
+    RECT rClip;
+
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWinSD_SimpleClip");
+    if (hDC == NULL) {
+        return JNI_FALSE;
+    }
+
+    int nComplexity = ::GetClipBox(hDC, &rClip);
+
+    switch (nComplexity) {
+    case COMPLEXREGION:
+        {
+            J2dTraceLn(J2D_TRACE_VERBOSE,
+                       "  complex clipping region");
+            // if complex user/system clip, more detailed testing required
+            // check to see if the view itself has a complex clip.
+            // ::GetClipBox is only API which returns overlapped window status
+            // so we set the rView as our clip, and then see if resulting
+            // clip is complex.
+            // Only other way to figure this out would be to walk the
+            // overlapping windows (no API to get the actual visible clip
+            // list).  Then we'd still have to merge that info with the
+            // clip region for the dc (if it exists).
+            // REMIND: we can cache the CreateRectRgnIndirect result,
+            // and only override with ::SetRectRgn
+
+            // First, create a region handle (need existing HRGN for
+            // the following call).
+            HRGN rgnSave = ::CreateRectRgn(0, 0, 0, 0);
+            int  clipStatus = ::GetClipRgn(hDC, rgnSave);
+            if (-1 == clipStatus) {
+                J2dTraceLn(J2D_TRACE_WARNING,
+                           "GDIWinSD_SimpleClip: failed due to clip status");
+                ::DeleteObject(rgnSave);
+                return JNI_FALSE;
+            }
+            HRGN rgnBounds = ::CreateRectRgn(
+                bounds->x1 - wsdo->insets.left,
+                bounds->y1 - wsdo->insets.top,
+                bounds->x2 - wsdo->insets.left,
+                bounds->y2 - wsdo->insets.top);
+            ::SelectClipRgn(hDC, rgnBounds);
+            nComplexity = ::GetClipBox(hDC, &rClip);
+            ::SelectClipRgn(hDC, clipStatus? rgnSave: NULL);
+            ::DeleteObject(rgnSave);
+            ::DeleteObject(rgnBounds);
+
+            // Now, test the new clip box.  If it's still not a
+            // SIMPLE region, then our bounds must intersect part of
+            // the clipping article
+            if (SIMPLEREGION != nComplexity) {
+                J2dTraceLn(J2D_TRACE_WARNING,
+                           "GDIWinSD_SimpleClip: failed due to complexity");
+                return JNI_FALSE;
+            }
+        }
+        // NOTE: No break here - we want to fall through into the
+        // SIMPLE case, adjust our bounds by the new rClip rect
+        // and make sure that our locking bounds are not empty.
+    case SIMPLEREGION:
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  simple clipping region");
+        // Constrain the bounds to the given clip box
+        if (bounds->x1 < rClip.left) {
+            bounds->x1 = rClip.left;
+        }
+        if (bounds->y1 < rClip.top) {
+            bounds->y1 = rClip.top;
+        }
+        if (bounds->x2 > rClip.right) {
+            bounds->x2 = rClip.right;
+        }
+        if (bounds->y2 > rClip.bottom) {
+            bounds->y2 = rClip.bottom;
+        }
+        // If the bounds are 0 or negative, then the bounds have
+        // been obscured by the clip box, so return FALSE
+        if ((bounds->x2 <= bounds->x1) ||
+            (bounds->y2 <= bounds->y1)) {
+            // REMIND: We should probably do something different here
+            // instead of simply returning FALSE.  Since the bounds are
+            // empty we won't end up drawing anything, so why spend the
+            // effort of returning false and having GDI do a LOCK_BY_DIB?
+            // Perhaps we need a new lock code that will indicate that we
+            // shouldn't bother drawing?
+            J2dTraceLn(J2D_TRACE_WARNING,
+                       "GDIWinSD_SimpleClip: failed due to empty bounds");
+            return JNI_FALSE;
+        }
+        break;
+    case NULLREGION:
+    case ERROR:
+    default:
+        J2dTraceLn1(J2D_TRACE_ERROR,
+                   "GDIWinSD_SimpleClip: failed due to incorrect complexity=%d",
+                    nComplexity);
+        return JNI_FALSE;
+    }
+
+    return JNI_TRUE;
+}
+
+static jint GDIWinSD_Lock(JNIEnv *env,
+                         SurfaceDataOps *ops,
+                         SurfaceDataRasInfo *pRasInfo,
+                         jint lockflags)
+{
+    GDIWinSDOps *wsdo = (GDIWinSDOps *) ops;
+    int ret = SD_SUCCESS;
+    HDC hDC;
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWinSD_Lock");
+
+    /* This surfaceLock replaces an earlier implementation which used a
+    monitor associated with the peer.  That implementation was prone
+    to deadlock problems, so it was replaced by a lock that does not
+    have dependencies outside of this thread or object.
+    However, this lock doesn't necessarily do all that we want.
+    For example, a user may issue a call which results in a DIB lock
+    and another call which results in a DDraw Blt.  We can't guarantee
+    what order these operations happen in (they are driver and
+    video-card dependent), so locking around the issue of either of
+    those calls won't necessarily guarantee a particular result.
+    The real solution might be to move away from mixing our
+    rendering API's.  That is, if we only used DDraw, then we could
+    guarantee that all rendering operations would happen in a given
+    order.  Similarly for GDI.  But by mixing them, we leave our
+    code at the mercy of driver bugs.*/
+    wsdo->surfaceLock->Enter();
+    if (wsdo->invalid == JNI_TRUE) {
+        J2dTraceLn(J2D_TRACE_WARNING, "GDIWinSD_Lock: surface is invalid");
+        wsdo->surfaceLock->Leave();
+        if (beingShutdown != JNI_TRUE) {
+            SurfaceData_ThrowInvalidPipeException(env,
+                "GDIWindowSurfaceData: bounds changed");
+        }
+        return SD_FAILURE;
+    }
+    if (wsdo->lockType != WIN32SD_LOCK_UNLOCKED) {
+        wsdo->surfaceLock->Leave();
+        if (!safe_ExceptionOccurred(env)) {
+            JNU_ThrowInternalError(env, "Win32 LockRasData cannot nest locks");
+        }
+        return SD_FAILURE;
+    }
+
+    hDC = wsdo->GetDC(env, wsdo, 0, NULL, NULL, NULL, 0);
+    if (hDC == NULL) {
+        wsdo->surfaceLock->Leave();
+        if (beingShutdown != JNI_TRUE) {
+            JNU_ThrowNullPointerException(env, "HDC for component");
+        }
+        return SD_FAILURE;
+    }
+
+    if (lockflags & SD_LOCK_RD_WR) {
+        // Do an initial clip to the client region of the window
+        RECT crect;
+        ::GetClientRect(wsdo->window, &crect);
+
+        // Translate to window coords
+        crect.left += wsdo->insets.left;
+        crect.top += wsdo->insets.top;
+        crect.right += wsdo->insets.left;
+        crect.bottom += wsdo->insets.top;
+
+        SurfaceDataBounds *bounds = &pRasInfo->bounds;
+
+        if (bounds->x1 < crect.left) {
+            bounds->x1 = crect.left;
+        }
+        if (bounds->y1 < crect.top) {
+            bounds->y1 = crect.top;
+        }
+        if (bounds->x2 > crect.right) {
+            bounds->x2 = crect.right;
+        }
+        if (bounds->y2 > crect.bottom) {
+            bounds->y2 = crect.bottom;
+        }
+
+        if (bounds->x2 > bounds->x1 && bounds->y2 > bounds->y1) {
+            wsdo->lockType = WIN32SD_LOCK_BY_DIB;
+            if (lockflags & SD_LOCK_FASTEST) {
+                ret = SD_SLOWLOCK;
+            }
+            J2dTraceLn(J2D_TRACE_VERBOSE, " locked by DIB");
+        } else {
+            wsdo->ReleaseDC(env, wsdo, hDC);
+            wsdo->lockType = WIN32SD_LOCK_UNLOCKED;
+            wsdo->surfaceLock->Leave();
+            ret = SD_FAILURE;
+            J2dTraceLn(J2D_TRACE_ERROR,
+                       "GDIWinSD_Lock: error locking by DIB");
+        }
+    } else {
+        J2dTraceLn(J2D_TRACE_VERBOSE, "GDIWinSD_Lock: surface wasn't locked");
+        /* They didn't lock for anything - we won't give them anything */
+        wsdo->ReleaseDC(env, wsdo, hDC);
+        wsdo->lockType = WIN32SD_LOCK_UNLOCKED;
+        wsdo->surfaceLock->Leave();
+        ret = SD_FAILURE;
+    }
+
+    wsdo->lockFlags = lockflags;
+    return ret;
+}
+
+static void GDIWinSD_GetRasInfo(JNIEnv *env,
+                               SurfaceDataOps *ops,
+                               SurfaceDataRasInfo *pRasInfo)
+{
+    GDIWinSDOps *wsdo = (GDIWinSDOps *) ops;
+    jint lockflags = wsdo->lockFlags;
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWinSD_GetRasInfo");
+    HDC hDC = GetThreadDC(env, wsdo);
+
+    if (wsdo->lockType == WIN32SD_LOCK_UNLOCKED) {
+        memset(pRasInfo, 0, sizeof(*pRasInfo));
+        return;
+    }
+
+    if (wsdo->lockType == WIN32SD_LOCK_BY_DIB) {
+        int x, y, w, h;
+        int pixelStride = wsdo->pixelStride;
+        // do not subtract insets from x,y as we take care of it in SD_GetDC
+        x = pRasInfo->bounds.x1;
+        y = pRasInfo->bounds.y1;
+        w = pRasInfo->bounds.x2 - x;
+        h = pRasInfo->bounds.y2 - y;
+
+        struct tagBitmapheader  {
+            BITMAPINFOHEADER bmiHeader;
+            union {
+                DWORD           dwMasks[3];
+                RGBQUAD         palette[256];
+            } colors;
+        } bmi;
+
+        // Need to create bitmap if we don't have one already or
+        // if the existing one is not large enough for this operation
+        // or if we are in 8 bpp display mode (because we need to
+        // make sure that the latest palette info gets loaded into
+        // the bitmap)
+        // REMIND: we should find some way to dynamically force bitmap
+        // recreation only when the palette changes
+        if (pixelStride == 1 || !wsdo->bitmap || (w > wsdo->bmWidth) ||
+            (h > wsdo->bmHeight))
+        {
+            if (wsdo->bitmap) {
+                // delete old objects
+                J2dTraceLn(J2D_TRACE_VERBOSE,
+                           "GDIWinSD_GetRasInfo: recreating GDI bitmap");
+                if (wsdo->bmdc) {   // should not be null
+                    ::SelectObject(wsdo->bmdc, wsdo->oldmap);
+                    ::DeleteDC(wsdo->bmdc);
+                    wsdo->bmdc = 0;
+                }
+                ::DeleteObject(wsdo->bitmap);
+                wsdo->bitmap = 0;
+            }
+            bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
+            bmi.bmiHeader.biWidth = w;
+            bmi.bmiHeader.biHeight = -h;
+            wsdo->bmWidth = w;
+            wsdo->bmHeight = h;
+            bmi.bmiHeader.biPlanes = 1;
+            bmi.bmiHeader.biBitCount = pixelStride * 8;
+            // 1,3 byte use BI_RGB, 2,4 byte use BI_BITFIELD...
+            bmi.bmiHeader.biCompression =
+                (pixelStride & 1)
+                    ? BI_RGB
+                    : BI_BITFIELDS;
+            bmi.bmiHeader.biSizeImage = 0;
+            bmi.bmiHeader.biXPelsPerMeter = 0;
+            bmi.bmiHeader.biYPelsPerMeter = 0;
+            bmi.bmiHeader.biClrUsed = 0;
+            bmi.bmiHeader.biClrImportant = 0;
+            if (pixelStride == 1) {
+                // we can use systemEntries here because
+                // RGBQUAD is xRGB and systemEntries are stored as xRGB
+                memcpy(bmi.colors.palette, wsdo->device->GetSystemPaletteEntries(),
+                       sizeof(bmi.colors.palette));
+            } else {
+                // For non-index cases, init the masks for the pixel depth
+                for (int i = 0; i < 3; i++) {
+                    bmi.colors.dwMasks[i] = wsdo->pixelMasks[i];
+                }
+            }
+
+            // REMIND: This would be better if moved to the Lock function
+            // so that errors could be dealt with.
+            wsdo->bitmap = ::CreateDIBSection(hDC, (BITMAPINFO *) &bmi,
+                                              DIB_RGB_COLORS, &wsdo->bmBuffer, NULL, 0);
+            if (wsdo->bitmap != 0) {
+                // scanStride is cached along with reuseable bitmap
+                // Round up to the next DWORD boundary
+                wsdo->bmScanStride = (wsdo->bmWidth * pixelStride + 3) & ~3;
+                wsdo->bmdc = ::CreateCompatibleDC(hDC);
+                if (wsdo->bmdc == 0) {
+                    ::DeleteObject(wsdo->bitmap);
+                    wsdo->bitmap = 0;
+                } else {
+                    wsdo->oldmap = (HBITMAP) ::SelectObject(wsdo->bmdc,
+                                                            wsdo->bitmap);
+                }
+            }
+        }
+        if (wsdo->bitmap != 0) {
+            if (lockflags & SD_LOCK_NEED_PIXELS) {
+                int ret = ::BitBlt(wsdo->bmdc, 0, 0, w, h,
+                                   hDC, x, y, SRCCOPY);
+                ::GdiFlush();
+            }
+            wsdo->x = x;
+            wsdo->y = y;
+            wsdo->w = w;
+            wsdo->h = h;
+            pRasInfo->rasBase = (char *)wsdo->bmBuffer - (x*pixelStride +
+                                y*wsdo->bmScanStride);
+            pRasInfo->pixelStride = pixelStride;
+            pRasInfo->pixelBitOffset = 0;
+            pRasInfo->scanStride = wsdo->bmScanStride;
+            if (lockflags & SD_LOCK_WRITE) {
+                // If the user writes to the bitmap then we should
+                // copy the bitmap to the screen during Unlock
+                wsdo->bmCopyToScreen = TRUE;
+            }
+        } else {
+            pRasInfo->rasBase = NULL;
+            pRasInfo->pixelStride = 0;
+            pRasInfo->pixelBitOffset = 0;
+            pRasInfo->scanStride = 0;
+        }
+    } else {
+        /* They didn't lock for anything - we won't give them anything */
+        pRasInfo->rasBase = NULL;
+        pRasInfo->pixelStride = 0;
+        pRasInfo->pixelBitOffset = 0;
+        pRasInfo->scanStride = 0;
+    }
+    if (wsdo->lockFlags & SD_LOCK_LUT) {
+        pRasInfo->lutBase =
+            (long *) wsdo->device->GetSystemPaletteEntries();
+        pRasInfo->lutSize = 256;
+    } else {
+        pRasInfo->lutBase = NULL;
+        pRasInfo->lutSize = 0;
+    }
+    if (wsdo->lockFlags & SD_LOCK_INVCOLOR) {
+        pRasInfo->invColorTable = wsdo->device->GetSystemInverseLUT();
+        ColorData *cData = wsdo->device->GetColorData();
+        pRasInfo->redErrTable = cData->img_oda_red;
+        pRasInfo->grnErrTable = cData->img_oda_green;
+        pRasInfo->bluErrTable = cData->img_oda_blue;
+    } else {
+        pRasInfo->invColorTable = NULL;
+        pRasInfo->redErrTable = NULL;
+        pRasInfo->grnErrTable = NULL;
+        pRasInfo->bluErrTable = NULL;
+    }
+    if (wsdo->lockFlags & SD_LOCK_INVGRAY) {
+        pRasInfo->invGrayTable =
+            wsdo->device->GetColorData()->pGrayInverseLutData;
+    } else {
+        pRasInfo->invGrayTable = NULL;
+    }
+}
+
+static void GDIWinSD_Setup(JNIEnv *env,
+                          SurfaceDataOps *ops)
+{
+    // Call SetupTGI to ensure that this thread already has a DC that is
+    // compatible with this window.  This means that we won't be calling
+    // ::SendMessage(GETDC) in the middle of a lock procedure, which creates
+    // a potential deadlock situation.
+    // Note that calling SetupTGI here means that anybody needing a DC
+    // later in this rendering process need only call GetTGI, which
+    // assumes that the TGI structure is valid for this thread/window.
+    SetupThreadGraphicsInfo(env, (GDIWinSDOps*)ops);
+}
+
+
+static void GDIWinSD_Unlock(JNIEnv *env,
+                           SurfaceDataOps *ops,
+                           SurfaceDataRasInfo *pRasInfo)
+{
+    GDIWinSDOps *wsdo = (GDIWinSDOps *) ops;
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWinSD_Unlock");
+    HDC hDC = GetThreadDC(env, wsdo);
+
+    if (wsdo->lockType == WIN32SD_LOCK_UNLOCKED) {
+        if (!safe_ExceptionOccurred(env)) {
+            JNU_ThrowInternalError(env,
+                                   "Unmatched unlock on Win32 SurfaceData");
+        }
+        return;
+    }
+
+    if (wsdo->lockType == WIN32SD_LOCK_BY_DIB) {
+        if (wsdo->lockFlags & SD_LOCK_WRITE) {
+            J2dTraceLn(J2D_TRACE_VERBOSE,
+                       "GDIWinSD_Unlock: do Blt of the bitmap");
+            if (wsdo->bmCopyToScreen && ::IsWindowVisible(wsdo->window)) {
+                // Don't bother copying to screen if our window has gone away
+                // or if the bitmap was not actually written to during this
+                // Lock/Unlock procedure.
+                ::BitBlt(hDC, wsdo->x, wsdo->y, wsdo->w, wsdo->h,
+                    wsdo->bmdc, 0, 0, SRCCOPY);
+                ::GdiFlush();
+            }
+            wsdo->bmCopyToScreen = FALSE;
+        }
+        wsdo->lockType = WIN32SD_LOCK_UNLOCKED;
+        wsdo->ReleaseDC(env, wsdo, hDC);
+    }
+    wsdo->surfaceLock->Leave();
+}
+
+/*
+ * REMIND: This mechanism is just a prototype of a way to manage a
+ * small cache of DC objects.  It is incomplete in the following ways:
+ *
+ * - It is not thread-safe!  It needs appropriate locking and release calls
+ *   (perhaps the AutoDC mechanisms from Kestrel)
+ * - It does hardly any error checking (What if GetDCEx returns NULL?)
+ * - It cannot handle printer DCs and their resolution
+ * - It should probably "live" in the native SurfaceData object to allow
+ *   alternate implementations for printing and embedding
+ * - It doesn't handle XOR
+ * - It caches the client bounds to determine if clipping is really needed
+ *   (no way to invalidate the cached bounds and there is probably a better
+ *    way to manage clip validation in any case)
+ */
+
+#define COLORFOR(c)     (PALETTERGB(((c)>>16)&0xff,((c)>>8)&0xff,((c)&0xff)))
+
+COLORREF CheckGrayColor(GDIWinSDOps *wsdo, int c) {
+    if (wsdo->device->GetGrayness() != GS_NOTGRAY) {
+        int g = (77 *(c & 0xFF) +
+                 150*((c >> 8) & 0xFF) +
+                 29 *((c >> 16) & 0xFF) + 128) / 256;
+        c = g | (g << 8) | (g << 16);
+    }
+    return COLORFOR(c);
+}
+
+static HDC GDIWinSD_GetDC(JNIEnv *env, GDIWinSDOps *wsdo,
+                         jint type, jint *patrop,
+                         jobject clip, jobject comp, jint color)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWinSD_GetDC");
+
+    if (wsdo->invalid == JNI_TRUE) {
+        if (beingShutdown != JNI_TRUE) {
+            SurfaceData_ThrowInvalidPipeException(env, "bounds changed");
+        }
+        return (HDC) NULL;
+    }
+
+    ThreadGraphicsInfo *info = GetThreadGraphicsInfo(env, wsdo);
+    GDIWinSD_InitDC(env, wsdo, info, type, patrop, clip, comp, color);
+    return info->hDC;
+}
+
+JNIEXPORT void JNICALL
+GDIWinSD_InitDC(JNIEnv *env, GDIWinSDOps *wsdo, ThreadGraphicsInfo *info,
+               jint type, jint *patrop,
+               jobject clip, jobject comp, jint color)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWinSD_InitDC");
+
+    // init clip
+    if (clip == NULL) {
+        if (info->type & CLIP) {
+            ::SelectClipRgn(info->hDC, (HRGN) NULL);
+            info->type ^= CLIP;
+        }
+        if (info->clip != NULL) {
+            env->DeleteWeakGlobalRef(info->clip);
+            info->clip = NULL;
+        }
+    } else if (!env->IsSameObject(clip, info->clip)) {
+        SurfaceDataBounds span;
+        RegionData clipInfo;
+        if (Region_GetInfo(env, clip, &clipInfo)) {
+            // return; // REMIND: What to do here?
+        }
+
+        if (Region_IsEmpty(&clipInfo)) {
+            HRGN hrgn = ::CreateRectRgn(0, 0, 0, 0);
+            ::SelectClipRgn(info->hDC, hrgn);
+            ::DeleteObject(hrgn);
+            info->type |= CLIP;
+        } else if (Region_IsRectangular(&clipInfo)) {
+            if (clipInfo.bounds.x1 <= info->bounds.left &&
+                clipInfo.bounds.y1 <= info->bounds.top &&
+                clipInfo.bounds.x2 >= info->bounds.right &&
+                clipInfo.bounds.y2 >= info->bounds.bottom)
+            {
+                if (info->type & CLIP) {
+                    ::SelectClipRgn(info->hDC, (HRGN) NULL);
+                    info->type ^= CLIP;
+                }
+            } else {
+                // Make the window-relative rect a client-relative
+                // one for Windows
+                HRGN hrgn =
+                    ::CreateRectRgn(clipInfo.bounds.x1 - wsdo->insets.left,
+                                    clipInfo.bounds.y1 - wsdo->insets.top,
+                                    clipInfo.bounds.x2 - wsdo->insets.left,
+                                    clipInfo.bounds.y2 - wsdo->insets.top);
+                ::SelectClipRgn(info->hDC, hrgn);
+                ::DeleteObject(hrgn);
+                info->type |= CLIP;
+            }
+        } else {
+            int leftInset = wsdo->insets.left;
+            int topInset = wsdo->insets.top;
+            Region_StartIteration(env, &clipInfo);
+            jint numrects = Region_CountIterationRects(&clipInfo);
+            DWORD nCount = sizeof(RGNDATAHEADER) + numrects * sizeof(RECT);
+            RGNDATA *lpRgnData = (RGNDATA *) safe_Malloc(nCount);
+            lpRgnData->rdh.dwSize = sizeof(RGNDATAHEADER);
+            lpRgnData->rdh.iType = RDH_RECTANGLES;
+            lpRgnData->rdh.nCount = numrects;
+            lpRgnData->rdh.nRgnSize = 0;
+            lpRgnData->rdh.rcBound.left = clipInfo.bounds.x1 - leftInset;
+            lpRgnData->rdh.rcBound.top = clipInfo.bounds.y1 - topInset;
+            lpRgnData->rdh.rcBound.right = clipInfo.bounds.x2 - leftInset;
+            lpRgnData->rdh.rcBound.bottom = clipInfo.bounds.y2 - topInset;
+            RECT *pRect = (RECT *) &(((RGNDATA *)lpRgnData)->Buffer);
+            while (Region_NextIteration(&clipInfo, &span)) {
+                pRect->left = span.x1 - leftInset;
+                pRect->top = span.y1 - topInset;
+                pRect->right = span.x2 - leftInset;
+                pRect->bottom = span.y2 - topInset;
+                pRect++;
+            }
+            Region_EndIteration(env, &clipInfo);
+            HRGN hrgn = ::ExtCreateRegion(NULL, nCount, lpRgnData);
+            free(lpRgnData);
+            ::SelectClipRgn(info->hDC, hrgn);
+            ::DeleteObject(hrgn);
+            info->type |= CLIP;
+        }
+        if (info->clip != NULL) {
+            env->DeleteWeakGlobalRef(info->clip);
+        }
+        info->clip = env->NewWeakGlobalRef(clip);
+    }
+
+    // init composite
+    if ((comp == NULL) || !env->IsInstanceOf(comp, xorCompClass)) {
+        if (info->comp != NULL) {
+            env->DeleteWeakGlobalRef(info->comp);
+            info->comp = NULL;
+            info->patrop = PATCOPY;
+            ::SetROP2(info->hDC, R2_COPYPEN);
+        }
+    } else {
+        if (!env->IsSameObject(comp, info->comp)) {
+            info->xorcolor = GrPrim_CompGetXorColor(env, comp);
+            if (info->comp != NULL) {
+                env->DeleteWeakGlobalRef(info->comp);
+            }
+            info->comp = env->NewWeakGlobalRef(comp);
+            info->patrop = PATINVERT;
+            ::SetROP2(info->hDC, R2_XORPEN);
+        }
+        color ^= info->xorcolor;
+    }
+
+    if (patrop != NULL) {
+        *patrop = info->patrop;
+    }
+
+    // init brush and pen
+    if (type & BRUSH) {
+        if (info->brushclr != color || (info->brush == NULL)) {
+            if (info->type & BRUSH) {
+                ::SelectObject(info->hDC, nullbrush);
+                info->type ^= BRUSH;
+            }
+            if (info->brush != NULL) {
+                info->brush->Release();
+            }
+            info->brush = AwtBrush::Get(CheckGrayColor(wsdo, color));
+            info->brushclr = color;
+        }
+        if ((info->type & BRUSH) == 0) {
+            ::SelectObject(info->hDC, info->brush->GetHandle());
+            info->type ^= BRUSH;
+        }
+    } else if (type & NOBRUSH) {
+        if (info->type & BRUSH) {
+            ::SelectObject(info->hDC, nullbrush);
+            info->type ^= BRUSH;
+        }
+    }
+    if (type & PEN) {
+        if (info->penclr != color || (info->pen == NULL)) {
+            if (info->type & PEN) {
+                ::SelectObject(info->hDC, nullpen);
+                info->type ^= PEN;
+            }
+            if (info->pen != NULL) {
+                info->pen->Release();
+            }
+            info->pen = AwtPen::Get(CheckGrayColor(wsdo, color));
+            info->penclr = color;
+        }
+        if ((info->type & PEN) == 0) {
+            ::SelectObject(info->hDC, info->pen->GetHandle());
+            info->type ^= PEN;
+        }
+    } else if (type & NOPEN) {
+        if (info->type & PEN) {
+            ::SelectObject(info->hDC, nullpen);
+            info->type ^= PEN;
+        }
+    }
+}
+
+static void GDIWinSD_ReleaseDC(JNIEnv *env, GDIWinSDOps *wsdo, HDC hDC)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWinSD_ReleaseDC");
+    // Don't actually do anything here: every thread holds its own
+    // wsdo-specific DC until the thread goes away or the wsdo
+    // is disposed.
+}
+
+
+static void GDIWinSD_InvalidateSD(JNIEnv *env, GDIWinSDOps *wsdo)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWinSD_InvalidateSD");
+    J2dTraceLn2(J2D_TRACE_VERBOSE, "  wsdo=0x%x wsdo->window=0x%x",
+                wsdo, wsdo->window);
+
+    wsdo->invalid = JNI_TRUE;
+}
+
+
+
+/*
+ * Method:    GDIWinSD_Dispose
+ */
+static void
+GDIWinSD_Dispose(JNIEnv *env, SurfaceDataOps *ops)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWinSD_Dispose");
+    // ops is assumed non-null as it is checked in SurfaceData_DisposeOps
+    GDIWinSDOps *wsdo = (GDIWinSDOps*)ops;
+    if (wsdo->bitmap) {
+        // delete old objects
+        J2dTraceLn(J2D_TRACE_VERBOSE, "  disposing the GDI bitmap");
+        if (wsdo->bmdc) {   // should not be null
+            ::SelectObject(wsdo->bmdc, wsdo->oldmap);
+            ::DeleteDC(wsdo->bmdc);
+            wsdo->bmdc = 0;
+        }
+        ::DeleteObject(wsdo->bitmap);
+        wsdo->bitmap = 0;
+    }
+    env->DeleteWeakGlobalRef(wsdo->peer);
+    if (wsdo->device != NULL) {
+        wsdo->device->Release();
+        wsdo->device = NULL;
+    }
+    delete wsdo->surfaceLock;
+}
+
+
+/*
+ * Class:     sun_java2d_windows_GDIWindowSurfaceData
+ * Method:    invalidateSD
+ * Signature: ()V
+ */
+JNIEXPORT void JNICALL
+Java_sun_java2d_windows_GDIWindowSurfaceData_invalidateSD(JNIEnv *env, jobject wsd)
+{
+    J2dTraceLn(J2D_TRACE_INFO, "GDIWindowSurfaceData_invalidateSD");
+    GDIWinSDOps *wsdo = GDIWindowSurfaceData_GetOpsNoSetup(env, wsd);
+    if (wsdo != NULL) {
+        wsdo->InvalidateSD(env, wsdo);
+    }
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h openjdk/jdk/src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/src/windows/native/sun/java2d/windows/GDIWindowSurfaceData.h	2011-01-08 01:26:50.487202383 +0000
@@ -0,0 +1,246 @@
+/*
+ * Copyright 1999-2008 Sun Microsystems Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+#ifndef _WIN32SURFACEDATA_H_
+#define _WIN32SURFACEDATA_H_
+
+
+#include "SurfaceData.h"
+
+#include "colordata.h"
+#include "awt_Brush.h"
+#include "awt_Pen.h"
+#include "awt_Win32GraphicsDevice.h"
+
+#include "stdhdrs.h"
+
+
+#define TEST_SURFACE_BITS(a,f) (((a)&(f)) == (f))
+
+/**
+ * This include file contains support definitions for loops using the
+ * SurfaceData interface to talk to a Win32 drawable from native code.
+ */
+
+typedef struct _GDIWinSDOps GDIWinSDOps;
+
+#define CONTEXT_NORMAL 0
+#define CONTEXT_DISPLAY_CHANGE 1
+#define CONTEXT_ENTER_FULL_SCREEN 2
+#define CONTEXT_CHANGE_BUFFER_COUNT 3
+#define CONTEXT_EXIT_FULL_SCREEN 4
+
+/*
+ * The definitions of the various attribute flags for requesting
+ * which rendering objects should be selected into the HDC returned
+ * from GetDC().
+ */
+#define PEN             1
+#define NOPEN           2
+#define BRUSH           4
+#define NOBRUSH         8
+#define CLIP            16              /* For tracking purposes only */
+#define PENBRUSH        (PEN | BRUSH)
+#define PENONLY         (PEN | NOBRUSH)
+#define BRUSHONLY       (BRUSH | NOPEN)
+
+/*
+ * This function retrieves an HDC for rendering to the destination
+ * managed by the indicated GDIWinSDOps structure.
+ *
+ * The env parameter should be the JNIEnv of the surrounding JNI context.
+ *
+ * The ops parameter should be a pointer to the ops object upon which
+ * this function is being invoked.
+ *
+ * The flags parameter should be an inclusive OR of any of the attribute
+ * flags defined above.
+ *
+ * The patrop parameter should be a pointer to a jint that will receive
+ * the appropriate ROP code (PATCOPY or PATINVERT) based on the current
+ * composite, or NULL if the ROP code will be ignored by the caller.
+ *
+ * The clip parameter should be a pointer to a rectangle indicating the
+ * desired clip.
+ *
+ * The comp parameter should be a pointer to a Composite object, or NULL
+ * which means the Src (default) compositing rule will be used.
+ *
+ * The pixel parameter should be a 24-bit XRGB value indicating the
+ * color that will be used for rendering.  The upper 8 bits are allowed
+ * to be any value.
+ *
+ * The ReleaseDC function should be called to release the lock on the DC
+ * after a given atomic set of rendering operations is complete.
+ *
+ * Note to callers:
+ *      This function may use JNI methods so it is important that the
+ *      caller not have any outstanding GetPrimitiveArrayCritical or
+ *      GetStringCritical locks which have not been released.
+ */
+typedef HDC GetDCFunc(JNIEnv *env,
+                      GDIWinSDOps *wsdo,
+                      jint flags,
+                      jint *patrop,
+                      jobject clip,
+                      jobject comp,
+                      jint color);
+
+/*
+ * This function releases an HDC that was retrieved from the GetDC
+ * function of the indicated GDIWinSDOps structure.
+ *
+ * The env parameter should be the JNIEnv of the surrounding JNI context.
+ *
+ * The ops parameter should be a pointer to the ops object upon which
+ * this function is being invoked.
+ *
+ * The hdc parameter should be the handle to the HDC object that was
+ * returned from the GetDC function.
+ *
+ * Note to callers:
+ *      This function may use JNI methods so it is important that the
+ *      caller not have any outstanding GetPrimitiveArrayCritical or
+ *      GetStringCritical locks which have not been released.
+ */
+typedef void ReleaseDCFunc(JNIEnv *env,
+                           GDIWinSDOps *wsdo,
+                           HDC hdc);
+
+
+typedef void InvalidateSDFunc(JNIEnv *env,
+                              GDIWinSDOps *wsdo);
+
+/*
+ * A structure that holds all state global to the native surfaceData
+ * object.
+ *
+ * Note:
+ * This structure will be shared between different threads that
+ * operate on the same surfaceData, so it should not contain any
+ * variables that could be changed by one thread thus placing other
+ * threads in a state of confusion.  For example, the hDC field was
+ * removed because each thread now has its own shared DC.  But the
+ * window field remains because once it is set for a given wsdo
+ * structure it stays the same until that structure is destroyed.
+ */
+struct _GDIWinSDOps {
+    SurfaceDataOps      sdOps;
+    jboolean            invalid;
+    GetDCFunc           *GetDC;
+    ReleaseDCFunc       *ReleaseDC;
+    InvalidateSDFunc    *InvalidateSD;
+    jint                lockType;       // REMIND: store in TLS
+    jint                lockFlags;      // REMIND: store in TLS
+    jobject             peer;
+    HWND                window;
+    RECT                insets;
+    jint                depth;
+    jint                pixelStride;    // Bytes per pixel
+    DWORD               pixelMasks[3];  // RGB Masks for Windows DIB creation
+    HBITMAP             bitmap;         // REMIND: store in TLS
+    HBITMAP             oldmap;         // REMIND: store in TLS
+    HDC                 bmdc;           // REMIND: store in TLS
+    int                 bmScanStride;   // REMIND: store in TLS
+    int                 bmWidth;        // REMIND: store in TLS
+    int                 bmHeight;       // REMIND: store in TLS
+    void                *bmBuffer;      // REMIND: store in TLS
+    jboolean            bmCopyToScreen; // Used to track whether we
+                                        // actually should copy the bitmap
+                                        // to the screen
+    AwtBrush            *brush;         // used for offscreen surfaces only
+    jint                brushclr;
+    AwtPen              *pen;           // used for offscreen surfaces only
+    jint                penclr;
+
+    int                 x, y, w, h;     // REMIND: store in TLS
+    CriticalSection     *surfaceLock;   // REMIND: try to remove
+    AwtWin32GraphicsDevice *device;
+};
+
+#define WIN32SD_LOCK_UNLOCKED   0       /* surface is not locked */
+#define WIN32SD_LOCK_BY_NULL    1       /* surface locked for NOP */
+#define WIN32SD_LOCK_BY_DIB     2       /* surface locked by BitBlt */
+
+extern "C" {
+
+/*
+ * Structure for holding the graphics state of a thread.
+ */
+typedef struct {
+    HDC         hDC;
+    GDIWinSDOps *wsdo;
+    RECT        bounds;
+    jobject     clip;
+    jobject     comp;
+    jint        xorcolor;
+    jint        patrop;
+    jint        type;
+    AwtBrush    *brush;
+    jint        brushclr;
+    AwtPen      *pen;
+    jint        penclr;
+} ThreadGraphicsInfo;
+
+
+/*
+ * This function returns a pointer to a native GDIWinSDOps structure
+ * for accessing the indicated Win32 SurfaceData Java object.  It
+ * verifies that the indicated SurfaceData object is an instance
+ * of GDIWindowSurfaceData before returning and will return NULL if the
+ * wrong SurfaceData object is being accessed.  This function will
+ * throw the appropriate Java exception if it returns NULL so that
+ * the caller can simply return.
+ *
+ * Note to callers:
+ *      This function uses JNI methods so it is important that the
+ *      caller not have any outstanding GetPrimitiveArrayCritical or
+ *      GetStringCritical locks which have not been released.
+ *
+ *      The caller may continue to use JNI methods after this method
+ *      is called since this function will not leave any outstanding
+ *      JNI Critical locks unreleased.
+ */
+JNIEXPORT GDIWinSDOps * JNICALL
+GDIWindowSurfaceData_GetOps(JNIEnv *env, jobject sData);
+
+JNIEXPORT GDIWinSDOps * JNICALL
+GDIWindowSurfaceData_GetOpsNoSetup(JNIEnv *env, jobject sData);
+
+JNIEXPORT HWND JNICALL
+GDIWindowSurfaceData_GetWindow(JNIEnv *env, GDIWinSDOps *wsdo);
+
+JNIEXPORT void JNICALL
+GDIWinSD_InitDC(JNIEnv *env, GDIWinSDOps *wsdo, ThreadGraphicsInfo *info,
+               jint type, jint *patrop,
+               jobject clip, jobject comp, jint color);
+
+JNIEXPORT AwtComponent * JNICALL
+GDIWindowSurfaceData_GetComp(JNIEnv *env, GDIWinSDOps *wsdo);
+
+} /* extern "C" */
+
+
+#endif _WIN32SURFACEDATA_H_
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/windows/WindowsFlags.cpp openjdk/jdk/src/windows/native/sun/java2d/windows/WindowsFlags.cpp
--- openjdk.orig/jdk/src/windows/native/sun/java2d/windows/WindowsFlags.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/windows/WindowsFlags.cpp	2011-01-08 01:26:50.487202383 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,15 +28,11 @@
 #include <awt.h>
 #include "Trace.h"
 #include "WindowsFlags.h"
-#include "dxInit.h"
 
-BOOL      ddVramForced;       // disable punting of ddraw buffers
 BOOL      accelReset;         // reset registry 2d acceleration settings
-BOOL      useDD;              // ddraw enabled flag
 BOOL      useD3D;             // d3d enabled flag
 BOOL      forceD3DUsage;      // force d3d on or off
 jboolean  g_offscreenSharing; // JAWT accelerated surface sharing
-BOOL      useDDLock;          // Disabled for win2k/XP
 BOOL      checkRegistry;      // Diagnostic tool: outputs 2d registry settings
 BOOL      disableRegistry;    // Diagnostic tool: disables registry interaction
 BOOL      setHighDPIAware;    // Whether to set the high-DPI awareness flag
@@ -44,19 +40,15 @@
 extern WCHAR *j2dAccelKey;       // Name of java2d root key
 extern WCHAR *j2dAccelDriverKey; // Name of j2d per-device key
 
-static jfieldID ddEnabledID;
 static jfieldID d3dEnabledID;
 static jfieldID d3dSetID;
-static jfieldID ddSetID;
 static jclass   wFlagsClassID;
 
 void SetIDs(JNIEnv *env, jclass wFlagsClass)
 {
     wFlagsClassID = (jclass)env->NewGlobalRef(wFlagsClass);
-    ddEnabledID = env->GetStaticFieldID(wFlagsClass, "ddEnabled", "Z");
     d3dEnabledID = env->GetStaticFieldID(wFlagsClass, "d3dEnabled", "Z");
     d3dSetID = env->GetStaticFieldID(wFlagsClass, "d3dSet", "Z");
-    ddSetID = env->GetStaticFieldID(wFlagsClass, "ddSet", "Z");
 }
 
 BOOL GetStaticBoolean(JNIEnv *env, jclass wfClass, const char *fieldName)
@@ -74,8 +66,6 @@
 
 void GetFlagValues(JNIEnv *env, jclass wFlagsClass)
 {
-    useDD = env->GetStaticBooleanField(wFlagsClass, ddEnabledID);
-    jboolean ddSet = env->GetStaticBooleanField(wFlagsClass, ddSetID);
     jboolean d3dEnabled = env->GetStaticBooleanField(wFlagsClass, d3dEnabledID);
     jboolean d3dSet = env->GetStaticBooleanField(wFlagsClass, d3dSetID);
     if (!d3dSet) {
@@ -99,90 +89,23 @@
     }
     useD3D = d3dEnabled;
     forceD3DUsage = d3dSet;
-    ddVramForced = GetStaticBoolean(env, wFlagsClass, "ddVramForced");
     g_offscreenSharing = GetStaticBoolean(env, wFlagsClass,
                                           "offscreenSharingEnabled");
-    useDDLock = GetStaticBoolean(env, wFlagsClass, "ddLockEnabled");
-    jboolean ddLockSet = GetStaticBoolean(env, wFlagsClass, "ddLockSet");
     accelReset = GetStaticBoolean(env, wFlagsClass, "accelReset");
     checkRegistry = GetStaticBoolean(env, wFlagsClass, "checkRegistry");
     disableRegistry = GetStaticBoolean(env, wFlagsClass, "disableRegistry");
     jstring javaVersionString = (jstring)GetStaticObject(env, wFlagsClass,
                                                          "javaVersion",
                                                          "Ljava/lang/String;");
-    jboolean isCopy;
-    const jchar *javaVersion = env->GetStringChars(javaVersionString,
-                                             &isCopy);
-    jsize versionLength = env->GetStringLength(javaVersionString);
-    size_t j2dRootKeyLength = wcslen(J2D_ACCEL_KEY_ROOT);
-    j2dAccelKey = (WCHAR *)safe_Calloc((j2dRootKeyLength + versionLength + 2),
-                                       sizeof(WCHAR));
-    wcscpy(j2dAccelKey, J2D_ACCEL_KEY_ROOT);
-    wcscat(j2dAccelKey, javaVersion);
-    wcscat(j2dAccelKey, L"\\");
-    j2dAccelDriverKey =
-        (WCHAR *)safe_Calloc((wcslen(j2dAccelKey) +
-                              wcslen(J2D_ACCEL_DRIVER_SUBKEY) + 1),
-                             sizeof(WCHAR));
-    wcscpy(j2dAccelDriverKey, j2dAccelKey);
-    wcscat(j2dAccelDriverKey, J2D_ACCEL_DRIVER_SUBKEY);
-    env->ReleaseStringChars(javaVersionString, javaVersion);
 
     setHighDPIAware =
         (IS_WINVISTA && GetStaticBoolean(env, wFlagsClass, "setHighDPIAware"));
 
-    // Change default value of some flags based on OS-specific requirements
-    if (IS_WINVISTA && !(ddSet && useDD)) {
-        // Disable ddraw on vista due to issues with mixing GDI and ddraw
-        // unless ddraw is forced
-        SetDDEnabledFlag(env, FALSE);
-        J2dRlsTraceLn(J2D_TRACE_WARNING,
-                      "GetFlagValues: DDraw/D3D is disabled on Windows Vista");
-    }
-
-    if (IS_NT && !(IS_WIN2000)) {
-        // Do not enable d3d on NT4; d3d is only supported through
-        // software on that platform
-        SetD3DEnabledFlag(env, FALSE, FALSE);
-        J2dRlsTraceLn(J2D_TRACE_WARNING,
-                      "GetFlagValues: D3D is disabled on Win NT");
-    }
-    if (IS_WIN64 && !d3dSet) {
-        // Only enable d3d on Itanium if user forces it on.
-        // D3d was not functioning on initial XP Itanium releases
-        // so we do not want it suddenly enabled in the field without
-        // having tested that codepath first.
-        SetD3DEnabledFlag(env, FALSE, FALSE);
-        J2dRlsTraceLn(J2D_TRACE_WARNING,
-                      "GetFlagValues: D3D is disabled on 64-bit OSs");
-    }
-    if (IS_WIN2000 && !ddLockSet) { // valid for win2k, XP, and future OSs
-        // Fix for cursor flicker on win2k and XP (bug 4409306).  The
-        // fix is to avoid using DDraw for locking the
-        // screen.  Ideally, we will handle most operations to the
-        // screen through new GDI Blt loops (GDIBlitLoops.cpp),
-        // but failing there we will punt to GDI instead of DDraw for
-        // locking the screen.
-        useDDLock = FALSE;
-        J2dRlsTraceLn(J2D_TRACE_WARNING,
-                      "GetFlagValues: DDraw screen locking is "\
-                      "disabled (W2K, XP+)");
-    }
     J2dTraceLn(J2D_TRACE_INFO, "WindowsFlags (native):");
-    J2dTraceLn1(J2D_TRACE_INFO, "  ddEnabled = %s",
-                (useDD ? "true" : "false"));
-    J2dTraceLn1(J2D_TRACE_INFO, "  ddSet = %s",
-                (ddSet ? "true" : "false"));
-    J2dTraceLn1(J2D_TRACE_INFO, "  ddVramForced = %s",
-                (ddVramForced ? "true" : "false"));
     J2dTraceLn1(J2D_TRACE_INFO, "  d3dEnabled = %s",
                 (useD3D ? "true" : "false"));
     J2dTraceLn1(J2D_TRACE_INFO, "  d3dSet = %s",
                 (forceD3DUsage ? "true" : "false"));
-    J2dTraceLn1(J2D_TRACE_INFO, "  ddLockEnabled = %s",
-                (useDDLock ? "true" : "false"));
-    J2dTraceLn1(J2D_TRACE_INFO, "  ddLockSet = %s",
-                (ddLockSet ? "true" : "false"));
     J2dTraceLn1(J2D_TRACE_INFO, "  offscreenSharing = %s",
                 (g_offscreenSharing ? "true" : "false"));
     J2dTraceLn1(J2D_TRACE_INFO, "  accelReset = %s",
@@ -208,13 +131,12 @@
     }
 }
 
-void SetDDEnabledFlag(JNIEnv *env, BOOL ddEnabled)
-{
-    useDD = ddEnabled;
-    if (env == NULL) {
-        env = (JNIEnv * ) JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    }
-    env->SetStaticBooleanField(wFlagsClassID, ddEnabledID, ddEnabled);
+BOOL IsD3DEnabled() {
+    return useD3D;
+}
+
+BOOL IsD3DForced() {
+    return forceD3DUsage;
 }
 
 extern "C" {
diff -Nru openjdk.orig/jdk/src/windows/native/sun/java2d/windows/WindowsFlags.h openjdk/jdk/src/windows/native/sun/java2d/windows/WindowsFlags.h
--- openjdk.orig/jdk/src/windows/native/sun/java2d/windows/WindowsFlags.h	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/java2d/windows/WindowsFlags.h	2011-01-08 01:26:50.487202383 +0000
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,19 +27,17 @@
 #ifndef WINDOWSFLAGS_H
 #define WINDOWSFLAGS_H
 
-extern BOOL      ddVramForced;       // disable punting of ddraw buffers
 extern BOOL      accelReset;         // reset registry 2d acceleration settings
-extern BOOL      useDD;              // ddraw enabled flag
 extern BOOL      useD3D;             // d3d enabled flag
 extern BOOL      forceD3DUsage;      // force d3d on or off
 extern jboolean  g_offscreenSharing; // JAWT accelerated surface sharing
-extern BOOL      useDDLock;          // Disabled for win2k/XP
 extern BOOL      checkRegistry;      // Diag tool: outputs 2d registry settings
 extern BOOL      disableRegistry;    // Diag tool: disables registry interaction
 extern BOOL      setHighDPIAware;    // whether to set High DPI Aware flag on Vista
 
 void SetD3DEnabledFlag(JNIEnv *env, BOOL d3dEnabled, BOOL d3dSet);
 
-void SetDDEnabledFlag(JNIEnv *env, BOOL ddEnabled);
+BOOL IsD3DEnabled();
+BOOL IsD3DForced();
 
 #endif WINDOWSFLAGS_H
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt_Component.cpp openjdk/jdk/src/windows/native/sun/windows/awt_Component.cpp
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt_Component.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Component.cpp	2011-01-08 01:26:50.491202427 +0000
@@ -45,7 +45,6 @@
 #include "awt_Unicode.h"
 #include "awt_Window.h"
 #include "awt_Win32GraphicsDevice.h"
-#include "ddrawUtils.h"
 #include "Hashtable.h"
 #include "ComCtl32Util.h"
 
@@ -165,6 +164,11 @@
     jint x1, x2, y1, y2;
     jobject region;
 };
+// Struct for _GetInsets function
+struct GetInsetsStruct {
+    jobject window;
+    RECT *insets;
+};
 /************************************************************************/
 
 //////////////////////////////////////////////////////////////////////////
@@ -412,7 +416,10 @@
     jobject peer = GetPeer(env);
     jobject target = env->GetObjectField(peer, AwtObject::targetID);
     BOOL res = env->GetBooleanField(target, focusableID);
-    res &= GetContainer()->IsFocusableWindow();
+    AwtWindow *pCont = GetContainer();
+    if (pCont) {
+        res &= pCont->IsFocusableWindow();
+    }
     env->DeleteLocalRef(target);
     return res;
 }
@@ -1915,25 +1922,6 @@
                                                   *((SIZE *)lParam));
           mr = mrConsume;
           break;
-      case WM_AWT_DD_CREATE_SURFACE:
-      {
-          return (LRESULT)WmDDCreateSurface((Win32SDOps*)wParam);
-      }
-      case WM_AWT_DD_ENTER_FULLSCREEN:
-      {
-          mr = WmDDEnterFullScreen((HMONITOR)wParam);
-          break;
-      }
-      case WM_AWT_DD_EXIT_FULLSCREEN:
-      {
-          mr = WmDDExitFullScreen((HMONITOR)wParam);
-          break;
-      }
-      case WM_AWT_DD_SET_DISPLAY_MODE:
-      {
-          mr = WmDDSetDisplayMode((HMONITOR)wParam, (DDrawDisplayMode*)lParam);
-          break;
-      }
       case WM_UNDOCUMENTED_CLICKMENUBAR:
       {
           if (::IsWindow(AwtWindow::GetModalBlocker(GetHWnd()))) {
@@ -2196,7 +2184,8 @@
         }
     }
 
-    AwtFrame *owner = GetContainer()->GetOwningFrameOrDialog();
+    AwtWindow *pCont = GetContainer();
+    AwtFrame *owner = pCont ? pCont->GetOwningFrameOrDialog() : NULL;
 
     if (owner == NULL) {
         ::SetFocus(hwnd);
@@ -4749,31 +4738,6 @@
     return pixelArray;
 }
 
-BOOL AwtComponent::WmDDCreateSurface(Win32SDOps* wsdo) {
-    return DDCreateSurface(wsdo);
-}
-
-// This method is fully implemented in AwtWindow
-MsgRouting AwtComponent::WmDDEnterFullScreen(HMONITOR monitor) {
-    DASSERT(FALSE);
-    return mrDoDefault;
-}
-
-// This method is fully implemented in AwtWindow
-MsgRouting AwtComponent::WmDDExitFullScreen(HMONITOR monitor) {
-    DASSERT(FALSE);
-    return mrDoDefault;
-}
-
-MsgRouting AwtComponent::WmDDSetDisplayMode(HMONITOR monitor,
-    DDrawDisplayMode* pDisplayMode) {
-
-    DDSetDisplayMode(monitor, *pDisplayMode);
-
-    delete pDisplayMode;
-    return mrDoDefault;
-}
-
 void *
 AwtComponent::GetNativeFocusOwner() {
     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
@@ -5318,7 +5282,8 @@
     MSG* msg = CreateMessage(message, wParam, MAKELPARAM(x, y), x, y);
     // If the window is not focusable but if this is a focusing
     // message we should skip it then and perform our own actions.
-    if (((AwtWindow*)GetContainer())->IsFocusableWindow() || !ActMouseMessage(msg)) {
+    AwtWindow *pCont = GetContainer();
+    if ((pCont && pCont->IsFocusableWindow()) || !ActMouseMessage(msg)) {
         PostHandleEventMessage(msg, TRUE);
     } else {
         delete msg;
@@ -5830,7 +5795,10 @@
                 AwtComponent* p = (AwtComponent*)pData;
                 // If the window is not focusable but if this is a focusing
                 // message we should skip it then and perform our own actions.
-                if (((AwtWindow*)p->GetContainer())->IsFocusableWindow() || !p->ActMouseMessage(&msg)) {
+                AwtWindow *pCont = (AwtWindow*)(p->GetContainer());
+                if ((pCont && pCont->IsFocusableWindow()) ||
+                    !p->ActMouseMessage(&msg))
+                {
                     // Create copy for local msg
                     MSG* pCopiedMsg = new MSG;
                     memmove(pCopiedMsg, &msg, sizeof(MSG));
@@ -6369,6 +6337,46 @@
     return p->GetHWnd();
 }
 
+static void _GetInsets(void* param)
+{
+    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+
+    GetInsetsStruct *gis = (GetInsetsStruct *)param;
+    jobject self = gis->window;
+
+    gis->insets->left = gis->insets->top =
+        gis->insets->right = gis->insets->bottom = 0;
+
+    PDATA pData;
+    JNI_CHECK_PEER_GOTO(self, ret);
+    AwtComponent *component = (AwtComponent *)pData;
+
+    component->GetInsets(gis->insets);
+
+  ret:
+    env->DeleteGlobalRef(self);
+    delete gis;
+}
+
+/**
+ * This method is called from the WGL pipeline when it needs to retrieve
+ * the insets associated with a ComponentPeer's C++ level object.
+ */
+void AwtComponent_GetInsets(JNIEnv *env, jobject peer, RECT *insets)
+{
+    TRY;
+
+    GetInsetsStruct *gis = new GetInsetsStruct;
+    gis->window = env->NewGlobalRef(peer);
+    gis->insets = insets;
+
+    AwtToolkit::GetInstance().InvokeFunction(_GetInsets, gis);
+    // global refs and mds are deleted in _UpdateWindow
+
+    CATCH_BAD_ALLOC;
+
+}
+
 JNIEXPORT void JNICALL
 Java_java_awt_Component_initIDs(JNIEnv *env, jclass cls)
 {
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt_Component.h openjdk/jdk/src/windows/native/sun/windows/awt_Component.h
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt_Component.h	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Component.h	2011-01-08 01:26:50.491202427 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -32,7 +32,7 @@
 #include "awt_Brush.h"
 #include "awt_Pen.h"
 #include "awt_Win32GraphicsDevice.h"
-#include "Win32SurfaceData.h"
+#include "GDIWindowSurfaceData.h"
 
 #include "java_awt_Component.h"
 #include "sun_awt_windows_WComponentPeer.h"
@@ -62,8 +62,6 @@
 
 class AwtDropTarget;
 
-class DDrawDisplayMode;
-
 struct WmComponentSetFocusData;
 
 /*
@@ -203,7 +201,8 @@
      */
     AwtComponent* GetParent();
 
-    /* Get the component's immediate container. */
+    /* Get the component's immediate container. Note: may return NULL while
+       the component is being reparented in full-screen mode by Direct3D */
     class AwtWindow* GetContainer();
 
     /* Is a component a container? Used by above method */
@@ -600,11 +599,6 @@
 
     jintArray CreatePrintedPixels(SIZE &loc, SIZE &size);
 
-    virtual BOOL WmDDCreateSurface(Win32SDOps* wsdo);
-    virtual MsgRouting WmDDEnterFullScreen(HMONITOR monitor);
-    virtual MsgRouting WmDDExitFullScreen(HMONITOR monitor);
-    virtual MsgRouting WmDDSetDisplayMode(HMONITOR monitor, DDrawDisplayMode* pDisplayMode);
-
     static void * GetNativeFocusOwner();
     static void * GetNativeFocusedWindow();
     static void   ClearGlobalFocusOwner();
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt_DrawingSurface.cpp openjdk/jdk/src/windows/native/sun/windows/awt_DrawingSurface.cpp
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt_DrawingSurface.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_DrawingSurface.cpp	2011-01-08 01:26:50.491202427 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,12 +25,10 @@
 
 #define _JNI_IMPLEMENTATION_
 #include "awt_DrawingSurface.h"
-#include "WindowsFlags.h"
 #include "awt_Component.h"
 
 jclass jawtVImgClass;
 jclass jawtComponentClass;
-jclass jawtW32ossdClass;
 jfieldID jawtPDataID;
 jfieldID jawtSDataID;
 jfieldID jawtSMgrID;
@@ -82,31 +80,7 @@
 {
     TRY;
 
-    JNIEnv* env = parent->env;
-    jobject target = parent->target;
-    if (JNU_IsNull(env, target)) {
-        DTRACE_PRINTLN("NULL target");
-        return JAWT_LOCK_ERROR;
-    }
-    Win32SDOps * ops =
-        (Win32SDOps *)((void*)env->GetLongField(target, jawtPDataID));
-    if (ops == NULL) {
-        DTRACE_PRINTLN("NULL ops");
-        return JAWT_LOCK_ERROR;
-    }
-    ddrawSurface = ops->lpSurface;
-    if (ddrawSurface == NULL) {
-        DTRACE_PRINTLN("NULL lpSurface");
-        return JAWT_LOCK_ERROR;
-    }
-    DXSurface *dxSurface = ddrawSurface->GetDXSurface();
-    if (dxSurface == NULL) {
-        DTRACE_PRINTLN("NULL dxSurface");
-        return JAWT_LOCK_ERROR;
-    }
-    platformInfo = this;
-    ds = parent;
-    return 0;
+    return JAWT_LOCK_ERROR;
 
     CATCH_BAD_ALLOC_RET(JAWT_LOCK_ERROR);
 }
@@ -248,58 +222,12 @@
 jint JNICALL JAWTOffscreenDrawingSurface::LockSurface
     (JAWT_DrawingSurface* ds)
 {
-    TRY;
-
-    if (ds == NULL) {
-        DTRACE_PRINTLN("Drawing Surface is NULL");
-        return JAWT_LOCK_ERROR;
-    }
-    JAWTOffscreenDrawingSurface* pds =
-        static_cast<JAWTOffscreenDrawingSurface*>(ds);
-    jint val = pds->info.Init(pds);
-    if ((val & JAWT_LOCK_ERROR) != 0) {
-            return val;
-    }
-    DDrawSurface *ddrawSurface = pds->info.ddrawSurface;
-    if (ddrawSurface == NULL) {
-        return JAWT_LOCK_ERROR;
-    }
-    ddrawSurface->GetExclusiveAccess();
-    DXSurface *dxSurface = ddrawSurface->GetDXSurface();
-    if (!dxSurface) {
-        return JAWT_LOCK_ERROR;
-    }
-    switch (dxSurface->GetVersionID()) {
-    case VERSION_DX7:
-        {
-            pds->info.dx7Surface = dxSurface->GetDDSurface();
-            break;
-        }
-    default:
-        // Leave info values at default and return error
-        DTRACE_PRINTLN1("unknown jawt offscreen version: %d\n",
-                        dxSurface->GetVersionID());
-        return JAWT_LOCK_ERROR;
-    }
-    return 0;
-
-    CATCH_BAD_ALLOC_RET(JAWT_LOCK_ERROR);
+    return JAWT_LOCK_ERROR;
 }
 
 void JNICALL JAWTOffscreenDrawingSurface::UnlockSurface
     (JAWT_DrawingSurface* ds)
 {
-    TRY_NO_VERIFY;
-
-    if (ds == NULL) {
-        DTRACE_PRINTLN("Drawing Surface is NULL");
-        return;
-    }
-    JAWTOffscreenDrawingSurface* pds =
-        static_cast<JAWTOffscreenDrawingSurface*>(ds);
-    pds->info.ddrawSurface->ReleaseExclusiveAccess();
-
-    CATCH_BAD_ALLOC;
 }
 
 /* C exports */
@@ -313,31 +241,9 @@
     if (env->IsInstanceOf(target, jawtComponentClass)) {
         return new JAWTDrawingSurface(env, target);
     }
-    // Sharing native offscreen surfaces is disabled by default in
-    // this release.  Sharing is enabled via the -Dsun.java2d.offscreenSharing
-    // flag.
-    if (g_offscreenSharing && env->IsInstanceOf(target, jawtVImgClass)) {
-        jobject sMgr, sData;
-        sMgr = env->GetObjectField(target, jawtSMgrID);
-        if (!sMgr) {
-            return NULL;
-        }
-        sData = env->GetObjectField(sMgr, jawtSDataID);
-        if (!sData || !(env->IsInstanceOf(sData, jawtW32ossdClass))) {
-            return NULL;
-        }
-        return new JAWTOffscreenDrawingSurface(env, sData);
-    } else {
-        if (!g_offscreenSharing) {
-            DTRACE_PRINTLN(
-                "GetDrawingSurface target must be a Component");
-        } else {
-            DTRACE_PRINTLN(
-                "GetDrawingSurface target must be a Component or VolatileImage");
-        }
-        return NULL;
-    }
 
+    DTRACE_PRINTLN("GetDrawingSurface target must be a Component");
+    return NULL;
 
     CATCH_BAD_ALLOC_RET(NULL);
 }
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt_DrawingSurface.h openjdk/jdk/src/windows/native/sun/windows/awt_DrawingSurface.h
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt_DrawingSurface.h	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_DrawingSurface.h	2011-01-08 01:26:50.491202427 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,7 +30,7 @@
 #include <jawt.h>
 #include <jawt_md.h>
 #include "awt_Component.h"
-#include "ddrawObject.h"
+#include <ddraw.h>
 
 class JAWTDrawingSurface;
 class JAWTOffscreenDrawingSurface;
@@ -84,8 +84,6 @@
 public:
     jint Init(JAWTOffscreenDrawingSurface* parent);
 
-public:
-    DDrawSurface *ddrawSurface;
 };
 
 /*
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt.h openjdk/jdk/src/windows/native/sun/windows/awt.h
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt.h	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt.h	2011-01-08 01:26:50.491202427 +0000
@@ -144,6 +144,7 @@
 #endif
 #define IS_NT      (IS_WIN32 && !(::GetVersion() & 0x80000000))
 #define IS_WIN2000 (IS_NT && LOBYTE(LOWORD(::GetVersion())) >= 5)
+#define IS_WIN2003 (IS_NT && LOBYTE(LOWORD(::GetVersion())) == 5 && HIBYTE(LOWORD(::GetVersion())) >= 2)
 #define IS_WINXP   (IS_NT && (IS_WIN2000 && HIBYTE(LOWORD(::GetVersion())) >= 1) || LOBYTE(LOWORD(::GetVersion())) > 5)
 #define IS_WINVISTA (IS_NT && LOBYTE(LOWORD(::GetVersion())) >= 6)
 #define IS_WIN32S  (IS_WIN32 && !IS_NT && LOBYTE(LOWORD(::GetVersion())) < 4)
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awtmsg.h openjdk/jdk/src/windows/native/sun/windows/awtmsg.h
--- openjdk.orig/jdk/src/windows/native/sun/windows/awtmsg.h	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awtmsg.h	2011-01-08 01:26:50.491202427 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -252,17 +252,6 @@
     WM_AWT_HIDECURSOR,
     WM_AWT_CREATE_PRINTED_PIXELS,
 
-    /* Synchronize ddraw fullscreen events on Windows event thread */
-    WM_AWT_DD_CREATE_SURFACE,
-    WM_AWT_DD_ENTER_FULLSCREEN,
-    WM_AWT_DD_EXIT_FULLSCREEN,
-    WM_AWT_DD_SET_DISPLAY_MODE,
-    WM_AWT_DD_RESTORE_DISPLAY_MODE,
-
-    /* Synchronize D3D device creation on Windows event thread */
-    WM_AWT_D3D_CREATE_DEVICE,
-    WM_AWT_D3D_RELEASE_DEVICE,
-
     // Tray messages
     WM_AWT_TRAY_NOTIFY,
 
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt_Toolkit.cpp openjdk/jdk/src/windows/native/sun/windows/awt_Toolkit.cpp
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt_Toolkit.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Toolkit.cpp	2011-01-08 01:26:50.491202427 +0000
@@ -52,12 +52,13 @@
 #include "CmdIDList.h"
 #include "awt_new.h"
 #include "awt_Unicode.h"
-#include "ddrawUtils.h"
 #include "debug_trace.h"
 #include "debug_mem.h"
 
 #include "ComCtl32Util.h"
 
+#include "D3DPipelineManager.h"
+
 #include <awt_DnDDT.h>
 #include <awt_DnDDS.h>
 
@@ -78,11 +79,12 @@
 extern jclass jawtVImgClass;
 extern jclass jawtVSMgrClass;
 extern jclass jawtComponentClass;
-extern jclass jawtW32ossdClass;
 extern jfieldID jawtPDataID;
 extern jfieldID jawtSDataID;
 extern jfieldID jawtSMgrID;
 
+extern void DWMResetCompositionEnabled();
+
 /************************************************************************
  * Utilities
  */
@@ -268,20 +270,6 @@
         DTrace_DisableMutex();
         DMem_DisableMutex();
 #endif DEBUG
-        // Release any resources that have not yet been released
-        // Note that releasing DirectX objects is necessary for some
-        // failure situations on win9x (such as the primary remaining
-        // locked on application exit) but cannot be done during
-        // PROCESS_DETACH on XP.  On NT and win2k calling this ends up
-        // in a catch() clause in the calling function, but on XP
-        // the process simply hangs during the release of the ddraw
-        // device object.  Thus we check for NT here and do not bother
-        // with the release on any NT flavored OS.  Note that XP is
-        // based on NT, so the IS_NT check is valid for NT4, win2k,
-        // XP, and presumably XP follow-ons.
-        if (!IS_NT) {
-            DDRelease();
-        }
         break;
     }
     return TRUE;
@@ -464,6 +452,11 @@
     awt_dnd_uninitialize();
     awt_clipboard_uninitialize((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2));
 
+    // dispose Direct3D-related resources. This should be done
+    // before AwtObjectList::Cleanup() as the d3d will attempt to
+    // shutdown when the last of its windows is disposed of
+    D3DPipelineManager::DeleteInstance();
+
     AwtObjectList::Cleanup();
     AwtFont::Cleanup();
 
@@ -696,20 +689,6 @@
           AwtObjectList::Cleanup();
           return 0;
       }
-      case WM_AWT_D3D_CREATE_DEVICE: {
-          DDraw *ddObject = (DDraw*)wParam;
-          if (ddObject != NULL) {
-              ddObject->InitD3DContext();
-          }
-          return 0;
-      }
-      case WM_AWT_D3D_RELEASE_DEVICE: {
-          DDraw *ddObject = (DDraw*)wParam;
-          if (ddObject != NULL) {
-              ddObject->ReleaseD3DContext();
-          }
-          return 0;
-      }
       case WM_SYSCOLORCHANGE: {
 
           jclass systemColorClass = env->FindClass("java/awt/SystemColor");
@@ -744,6 +723,17 @@
           }
           return 0;
       }
+#ifndef WM_DWMCOMPOSITIONCHANGED
+#define WM_DWMCOMPOSITIONCHANGED        0x031E
+#define WM_DWMNCRENDERINGCHANGED        0x031F
+#define WM_DWMCOLORIZATIONCOLORCHANGED  0x0320
+#define WM_DWMWINDOWMAXIMIZEDCHANGED    0x0321
+#endif // WM_DWMCOMPOSITIONCHANGED
+      case WM_DWMCOMPOSITIONCHANGED: {
+          DWMResetCompositionEnabled();
+          return 0;
+      }
+
       case WM_TIMER: {
           // Create an artifical MouseExit message if the mouse left to
           // a non-java window (bad mouse!)
@@ -892,17 +882,6 @@
           // Reinitialize screens
           initScreens(env);
 
-          // Invalidate current DDraw object; the object must be recreated
-          // when we first try to create a new DDraw surface.  Note that we
-          // don't recreate the ddraw object directly here because of
-          // multi-threading issues; we'll just leave that to the first
-          // time an object tries to create a DDraw surface under the new
-          // display depth (which will happen after the displayChange event
-          // propagation at the end of this case).
-          if (DDCanReplaceSurfaces(NULL)) {
-              DDInvalidateDDInstance(NULL);
-          }
-
           // Notify Java side - call WToolkit.displayChanged()
           jclass clazz = env->FindClass("sun/awt/windows/WToolkit");
           env->CallStaticVoidMethod(clazz, AwtToolkit::displayChangeMID);
@@ -1563,9 +1542,6 @@
     DASSERT(vSMgrClassLocal != 0);
     jclass componentClassLocal = env->FindClass("java/awt/Component");
     DASSERT(componentClassLocal != 0);
-    jclass w32ossdClassLocal =
-        env->FindClass("sun/java2d/windows/Win32OffScreenSurfaceData");
-    DASSERT(w32ossdClassLocal != 0);
     jawtSMgrID = env->GetFieldID(vImgClassLocal, "volSurfaceManager",
                                  "Lsun/awt/image/VolatileSurfaceManager;");
     DASSERT(jawtSMgrID != 0);
@@ -1578,7 +1554,6 @@
     // Save these classes in global references for later use
     jawtVImgClass = (jclass)env->NewGlobalRef(vImgClassLocal);
     jawtComponentClass = (jclass)env->NewGlobalRef(componentClassLocal);
-    jawtW32ossdClass = (jclass)env->NewGlobalRef(w32ossdClassLocal);
 
     CATCH_BAD_ALLOC;
 }
@@ -1885,7 +1860,6 @@
 
     // Synchronize both GDI and DDraw
     VERIFY(::GdiFlush());
-    DDSync();
 
     CATCH_BAD_ALLOC;
 }
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt_Win32GraphicsDevice.cpp openjdk/jdk/src/windows/native/sun/windows/awt_Win32GraphicsDevice.cpp
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt_Win32GraphicsDevice.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Win32GraphicsDevice.cpp	2011-01-08 01:26:50.491202427 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,7 +43,6 @@
 #include <sun_awt_Win32GraphicsDevice.h>
 #include "awt_Canvas.h"
 #include "awt_Win32GraphicsDevice.h"
-#include "ddrawUtils.h"
 #include "java_awt_Transparency.h"
 #include "java_awt_color_ColorSpace.h"
 #include "sun_awt_Win32GraphicsDevice.h"
@@ -60,7 +59,6 @@
 jfieldID    AwtWin32GraphicsDevice::dynamicColorModelID;
 jfieldID    AwtWin32GraphicsDevice::indexCMrgbID;
 jfieldID    AwtWin32GraphicsDevice::indexCMcacheID;
-jfieldID    AwtWin32GraphicsDevice::accelerationEnabledID;
 jmethodID   AwtWin32GraphicsDevice::paletteChangedMID;
 BOOL        AwtWin32GraphicsDevice::primaryPalettized;
 int         AwtWin32GraphicsDevice::primaryIndex = 0;
@@ -455,7 +453,7 @@
 /**
  * Update our dynamic IndexedColorModel.  This happens after
  * a change to the system palette.  Any surfaces stored in vram
- * (Win32OffScreenSurfaceData and Win32SurfaceData objects)
+ * (Win32OffScreenSurfaceData and GDIWindowSurfaceData objects)
  * refer to this colorModel and use its lookup table and inverse
  * lookup to calculate correct index values for rgb colors.  So
  * the colorModel must always reflect the current state of the
@@ -602,14 +600,6 @@
 void AwtWin32GraphicsDevice::SetJavaDevice(JNIEnv *env, jobject objPtr)
 {
     javaDevice = env->NewWeakGlobalRef(objPtr);
-    // We may have discovered earlier that the device is not
-    // accelerated, but there were no way to notify the GraphicsDevice
-    // about it because the DirectDraw initialization happens before those
-    // are created (from the static initializer of Win32GraphicsEnvironment).
-    DDrawObjectStruct *tmpDdInstance = GetDDInstanceForDevice((HMONITOR)monitor);
-    if (tmpDdInstance == NULL || !tmpDdInstance->accelerated) {
-        DisableOffscreenAcceleration();
-    }
 }
 
 /**
@@ -619,10 +609,7 @@
  */
 void AwtWin32GraphicsDevice::DisableOffscreenAcceleration()
 {
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    if (!JNU_IsNull(env, javaDevice)) {
-        env->SetBooleanField(javaDevice, accelerationEnabledID, JNI_FALSE);
-    }
+    // REMIND: noop for now
 }
 
 /**
@@ -695,23 +682,6 @@
     }
 }
 
-DxCapabilities *AwtWin32GraphicsDevice::GetDxCapsForDevice(MHND hMonitor)
-{
-    Devices::InstanceAccess devices;
-
-    if (hMonitor == NULL) {
-        return devices->GetDevice(0)->GetDxCaps();
-    } else {
-        int devicesNum = devices->GetNumDevices();
-        for (int i = 0; i < devicesNum; ++i) {
-            if (devices->GetDevice(i)->GetMonitor() == hMonitor) {
-                return devices->GetDevice(i)->GetDxCaps();
-            }
-        }
-    }
-    return (DxCapabilities*)NULL;
-}
-
 MHND AwtWin32GraphicsDevice::GetMonitor(int deviceIndex)
 {
     Devices::InstanceAccess devices;
@@ -860,8 +830,6 @@
     AwtWin32GraphicsDevice::indexCMcacheID =
         env->GetFieldID(AwtWin32GraphicsDevice::indexCMClass,
         "lookupcache", "[I");
-    AwtWin32GraphicsDevice::accelerationEnabledID =
-        env->GetFieldID(cls, "offscreenAccelerationEnabled", "Z");
 
     /* method ids */
     AwtWin32GraphicsDevice::paletteChangedMID = env->GetStaticMethodID(
@@ -871,7 +839,6 @@
     DASSERT(AwtWin32GraphicsDevice::dynamicColorModelID);
     DASSERT(AwtWin32GraphicsDevice::indexCMrgbID);
     DASSERT(AwtWin32GraphicsDevice::indexCMcacheID);
-    DASSERT(AwtWin32GraphicsDevice::accelerationEnabledID);
 
     DASSERT(AwtWin32GraphicsDevice::paletteChangedMID);
 
@@ -1012,7 +979,7 @@
 JNIEXPORT void JNICALL
 Java_sun_awt_Win32GraphicsDevice_enterFullScreenExclusive(
         JNIEnv* env, jobject graphicsDevice,
-        jboolean useDD, jint screen, jobject windowPeer) {
+        jint screen, jobject windowPeer) {
 
     TRY;
 
@@ -1023,39 +990,12 @@
                                              // with the WWindowPeer object
     HWND hWnd = window->GetHWnd();
 
-    if (useDD) {
-        HMONITOR monitor = (HMONITOR)AwtWin32GraphicsDevice::GetMonitor(screen);
-        /**
-         * We call SendMessage with a timeout of 1000 ms because we would like
-         * this call to be synchronous, but we want to avoid any possibility
-         * of deadlocking here.
-         */
-        DWORD_PTR eventResult;
-        LRESULT sendResult;
-        sendResult = ::SendMessageTimeout(hWnd, WM_AWT_DD_ENTER_FULLSCREEN,
-                                          (WPARAM)monitor, NULL,
-                                          SMTO_NORMAL, 1000, &eventResult);
-        if (sendResult == 0) {
-            // Not the end of the world, but we would like to know about
-            // it and fix the problem/deadlock if one exists
-            int error = GetLastError();
-            if (error == 0) {
-                J2dTraceLn(J2D_TRACE_ERROR,
-                           "SendMessage(ENTER_FULLSCREEN) timed out");
-            } else {
-                J2dTraceLn1(J2D_TRACE_ERROR,
-                            "SendMessage(ENTER_FULLSCREEN) failed with error %d",
-                            error);
-            }
-        }
-    } else {
-        if (!::SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0,
-                            SWP_NOMOVE|SWP_NOOWNERZORDER|SWP_NOSIZE))
-        {
-            J2dTraceLn1(J2D_TRACE_ERROR,
-                        "Error %d setting topmost attribute to fs window",
-                        ::GetLastError());
-        }
+    if (!::SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0,
+                        SWP_NOMOVE|SWP_NOOWNERZORDER|SWP_NOSIZE))
+    {
+        J2dTraceLn1(J2D_TRACE_ERROR,
+                    "Error %d setting topmost attribute to fs window",
+                    ::GetLastError());
     }
 
     CATCH_BAD_ALLOC;
@@ -1070,7 +1010,7 @@
 JNIEXPORT void JNICALL
 Java_sun_awt_Win32GraphicsDevice_exitFullScreenExclusive(
         JNIEnv* env, jobject graphicsDevice,
-        jboolean useDD, jint screen, jobject windowPeer) {
+        jint screen, jobject windowPeer) {
 
     TRY;
 
@@ -1081,45 +1021,18 @@
                                              // with the WWindowPeer object
     HWND hWnd = window->GetHWnd();
 
-    if (useDD) {
-        HMONITOR monitor = (HMONITOR)AwtWin32GraphicsDevice::GetMonitor(screen);
-        /**
-         * We call SendMessage with a timeout of 1000 ms because we would like
-         * this call to be synchronous, but we want to avoid any possibility
-         * of deadlocking here.
-         */
-        DWORD_PTR eventResult;
-        LRESULT sendResult;
-        sendResult = ::SendMessageTimeout(hWnd, WM_AWT_DD_EXIT_FULLSCREEN,
-                                          (WPARAM)monitor, NULL,
-                                          SMTO_NORMAL, 1000, &eventResult);
-        if (sendResult == 0) {
-            // Not the end of the world, but we would like to know about
-            // it and fix the problem/deadlock if one exists
-            int error = GetLastError();
-            if (error == 0) {
-                J2dTraceLn(J2D_TRACE_ERROR,
-                           "SendMessage(EXIT_FULLSCREEN) timed out");
-            } else {
-                J2dTraceLn1(J2D_TRACE_ERROR,
-                            "SendMessage(EXIT_FULLSCREEN) failed with error %d",
-                            error);
-            }
-        }
-    } else {
-        if (!::SetWindowPos(hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
-                            SWP_NOMOVE|SWP_NOOWNERZORDER|SWP_NOSIZE))
-        {
-            J2dTraceLn1(J2D_TRACE_ERROR,
-                        "Error %d unsetting topmost attribute to fs window",
-                        ::GetLastError());
-        }
+    if (!::SetWindowPos(hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
+                        SWP_NOMOVE|SWP_NOOWNERZORDER|SWP_NOSIZE))
+    {
+        J2dTraceLn1(J2D_TRACE_ERROR,
+                    "Error %d unsetting topmost attribute to fs window",
+                    ::GetLastError());
     }
 
     CATCH_BAD_ALLOC;
 }
 
-static jobject CreateDisplayMode(JNIEnv* env, jint width, jint height,
+jobject CreateDisplayMode(JNIEnv* env, jint width, jint height,
     jint bitDepth, jint refreshRate) {
 
     TRY;
@@ -1146,24 +1059,6 @@
     CATCH_BAD_ALLOC_RET(NULL);
 }
 
-/*
- * Class:     sun_awt_Win32GraphicsDevice
- * Method:    isDDEnabledOnDeviceNative
- * Signature: (I)Z
- */
-JNIEXPORT jboolean JNICALL
-Java_sun_awt_Win32GraphicsDevice_isDDEnabledOnDeviceNative
-    (JNIEnv* env, jobject graphicsDevice, jint screen)
-{
-    TRY;
-
-    HMONITOR monitor = (HMONITOR)AwtWin32GraphicsDevice::GetMonitor(screen);
-    return DeviceUseDDraw(monitor);
-
-    CATCH_BAD_ALLOC_RET(FALSE);
-}
-
-
 /**
  * A utility function which retrieves a DISPLAY_DEVICE information
  * given a screen number.
@@ -1206,37 +1101,23 @@
 {
     TRY;
 
-    HMONITOR monitor = (HMONITOR)AwtWin32GraphicsDevice::GetMonitor(screen);
-    if (DeviceUseDDraw(monitor)) {
-        DDrawDisplayMode dm;
+    DEVMODE dm;
+    LPTSTR pName = NULL;
 
-        if (!DDGetDisplayMode(monitor, dm)) {
-            JNU_ThrowInternalError(env,
-                "Could not get display mode");
-            return NULL;
-        }
-
-        return CreateDisplayMode(env, dm.width,
-            dm.height, dm.bitDepth, dm.refreshRate);
-    } else {
-        DEVMODE dm;
-        LPTSTR pName = NULL;
-
-        dm.dmSize = sizeof(dm);
-        dm.dmDriverExtra = 0;
-
-        _DISPLAY_DEVICE displayDevice;
-        if (GetAttachedDisplayDevice(screen, &displayDevice)) {
-            pName = displayDevice.strDevName;
-        }
-        if (!EnumDisplaySettings(pName, ENUM_CURRENT_SETTINGS, &dm))
-        {
-            return NULL;
-        }
+    dm.dmSize = sizeof(dm);
+    dm.dmDriverExtra = 0;
 
-        return CreateDisplayMode(env, dm.dmPelsWidth,
-            dm.dmPelsHeight, dm.dmBitsPerPel, dm.dmDisplayFrequency);
+    _DISPLAY_DEVICE displayDevice;
+    if (GetAttachedDisplayDevice(screen, &displayDevice)) {
+        pName = displayDevice.strDevName;
     }
+    if (!EnumDisplaySettings(pName, ENUM_CURRENT_SETTINGS, &dm))
+    {
+        return NULL;
+    }
+
+    return CreateDisplayMode(env, dm.dmPelsWidth,
+        dm.dmPelsHeight, dm.dmBitsPerPel, dm.dmDisplayFrequency);
 
     CATCH_BAD_ALLOC_RET(NULL);
 }
@@ -1253,96 +1134,43 @@
 {
     TRY;
 
-    HMONITOR monitor = (HMONITOR)AwtWin32GraphicsDevice::GetMonitor(screen);
-    if (DeviceUseDDraw(monitor)) {
-        PDATA pData;
-
-        JNI_CHECK_PEER_RETURN(windowPeer);
-
-        AwtWindow * window = (AwtWindow * )pData; // safe cast; we are called
-                                                  // with the WWindowPeer object
-        HWND hWnd = window->GetHWnd();
-
-        DDrawDisplayMode *dm = new DDrawDisplayMode(width, height, bitDepth,
-                                                    refreshRate);
-
-        /**
-         * We call SendMessage with a timeout of 1000 ms because we would like
-         * this call to be synchronous, but we want to avoid any possibility
-         * of deadlocking here.
-         * Also, note that we have to free the dm object in the message
-         * processing code since we may return from the SendMessageTimeout
-         * before that object has been used.
-         */
-        DWORD_PTR eventResult;
-        LRESULT sendResult;
-        sendResult = ::SendMessageTimeout(hWnd, WM_AWT_DD_SET_DISPLAY_MODE,
-                                          (WPARAM)monitor, (LPARAM)dm,
-                                          SMTO_NORMAL, 1000, &eventResult);
-        if (sendResult == 0) {
-            // Not the end of the world, but we would like to know about
-            // it and fix the problem/deadlock if one exists
-            int error = GetLastError();
-            if (error == 0) {
-                J2dTraceLn(J2D_TRACE_ERROR,
-                           "SendMessage(SET_DISPLAY_MODE) timed out");
-            } else {
-                J2dTraceLn1(J2D_TRACE_ERROR,
-                           "SendMessage(SET_DISPLAY_MODE) failed with error %d",
-                           error);
-            }
-        } else {
-            // see comment in awt_Window.cpp WmDDEnterFullScreenMode
-            // Since the event to reshape the window will come to the owner
-            // frame, we need to reshape the window by ourselves.
-            // Note that we do not need to reshape it on the exit
-            // from full screen mode, this is already handled in
-            // GraphicsDevice.setFullScreenWindow .
-            if (window->GetOwningFrameOrDialog() != NULL) {
-                RECT* r = new RECT;
-                ::SetRect(r, 0, 0, width, height);
-                window->SendMessage(WM_AWT_RESHAPE_COMPONENT, 0, (LPARAM)r);
-            }
-        }
-    } else {
         DEVMODE dm;
 
-        dm.dmSize = sizeof(dm);
-        dm.dmDriverExtra = 0;
-        dm.dmPelsWidth = width;
-        dm.dmPelsHeight = height;
-        dm.dmBitsPerPel = bitDepth;
-        dm.dmDisplayFrequency = refreshRate;
-        dm.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT |
-            DM_BITSPERPEL | DM_DISPLAYFREQUENCY;
-
-        // ChangeDisplaySettings works only on the primary screen.
-        // ChangeDisplaySettingsEx is not available on NT,
-        // so it'd be nice not to break it if we can help it.
-        if (screen == AwtWin32GraphicsDevice::GetDefaultDeviceIndex()) {
-            if (ChangeDisplaySettings(&dm, CDS_FULLSCREEN) !=
-                DISP_CHANGE_SUCCESSFUL)
-            {
-                JNU_ThrowInternalError(env,
-                                       "Could not set display mode");
-            }
-            return;
-        }
-
-        // make sure the function pointer for fn_change_display_settings_ex
-        // is initialized
-        load_user_procs();
-
-        _DISPLAY_DEVICE displayDevice;
-        if (fn_change_display_settings_ex == NULL ||
-            !GetAttachedDisplayDevice(screen, &displayDevice) ||
-            ((*fn_change_display_settings_ex)
-                 (displayDevice.strDevName, &dm, NULL, CDS_FULLSCREEN, NULL) !=
-              DISP_CHANGE_SUCCESSFUL))
+    dm.dmSize = sizeof(dm);
+    dm.dmDriverExtra = 0;
+    dm.dmPelsWidth = width;
+    dm.dmPelsHeight = height;
+    dm.dmBitsPerPel = bitDepth;
+    dm.dmDisplayFrequency = refreshRate;
+    dm.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT |
+        DM_BITSPERPEL | DM_DISPLAYFREQUENCY;
+
+    // ChangeDisplaySettings works only on the primary screen.
+    // ChangeDisplaySettingsEx is not available on NT,
+    // so it'd be nice not to break it if we can help it.
+    if (screen == AwtWin32GraphicsDevice::GetDefaultDeviceIndex()) {
+        if (ChangeDisplaySettings(&dm, CDS_FULLSCREEN) !=
+            DISP_CHANGE_SUCCESSFUL)
         {
             JNU_ThrowInternalError(env,
                                    "Could not set display mode");
         }
+        return;
+    }
+
+    // make sure the function pointer for fn_change_display_settings_ex
+    // is initialized
+    load_user_procs();
+
+    _DISPLAY_DEVICE displayDevice;
+    if (fn_change_display_settings_ex == NULL ||
+        !GetAttachedDisplayDevice(screen, &displayDevice) ||
+        ((*fn_change_display_settings_ex)
+             (displayDevice.strDevName, &dm, NULL, CDS_FULLSCREEN, NULL) !=
+          DISP_CHANGE_SUCCESSFUL))
+    {
+        JNU_ThrowInternalError(env,
+                               "Could not set display mode");
     }
 
     CATCH_BAD_ALLOC;
@@ -1355,7 +1183,7 @@
     jobject arrayList;
 };
 
-static void addDisplayMode(JNIEnv* env, jobject arrayList, jint width,
+void addDisplayMode(JNIEnv* env, jobject arrayList, jint width,
     jint height, jint bitDepth, jint refreshRate) {
 
     TRY;
@@ -1383,22 +1211,6 @@
     CATCH_BAD_ALLOC;
 }
 
-static void enumDMCallback(DDrawDisplayMode& dm, void* pContext) {
-
-    TRY;
-
-    EnumDisplayModeParam* pParam = (EnumDisplayModeParam*)pContext;
-    JNIEnv* env = pParam->env;
-    jobject arrayList = pParam->arrayList;
-
-    if (dm.bitDepth >= 8) {
-        addDisplayMode(env, arrayList, dm.width, dm.height,
-                       dm.bitDepth, dm.refreshRate);
-    }
-
-    CATCH_BAD_ALLOC;
-}
-
 /*
  * Class:     sun_awt_Win32GraphicsDevice
  * Method:    enumDisplayModes
@@ -1410,72 +1222,30 @@
 
     TRY;
 
-    HMONITOR monitor = (HMONITOR)AwtWin32GraphicsDevice::GetMonitor(screen);
-    if (DeviceUseDDraw(monitor)) {
-        EnumDisplayModeParam param(env, arrayList);
-
-        if (!DDEnumDisplayModes(monitor, NULL, enumDMCallback, &param)) {
-            JNU_ThrowInternalError(env,
-                "Could not get display modes");
-            return;
-        }
-    } else {
-        DEVMODE dm;
-        LPTSTR pName = NULL;
-        _DISPLAY_DEVICE displayDevice;
+    DEVMODE dm;
+    LPTSTR pName = NULL;
+    _DISPLAY_DEVICE displayDevice;
 
 
-        if (GetAttachedDisplayDevice(screen, &displayDevice)) {
-            pName = displayDevice.strDevName;
-        }
+    if (GetAttachedDisplayDevice(screen, &displayDevice)) {
+        pName = displayDevice.strDevName;
+    }
 
-        dm.dmSize = sizeof(dm);
-        dm.dmDriverExtra = 0;
+    dm.dmSize = sizeof(dm);
+    dm.dmDriverExtra = 0;
 
-        BOOL bContinue = TRUE;
-        for (int i = 0; bContinue; i++) {
-            bContinue = EnumDisplaySettings(pName, i, &dm);
-            if (dm.dmBitsPerPel >= 8) {
-                addDisplayMode(env, arrayList, dm.dmPelsWidth, dm.dmPelsHeight,
-                               dm.dmBitsPerPel, dm.dmDisplayFrequency);
-            }
+    BOOL bContinue = TRUE;
+    for (int i = 0; bContinue; i++) {
+        bContinue = EnumDisplaySettings(pName, i, &dm);
+        if (dm.dmBitsPerPel >= 8) {
+            addDisplayMode(env, arrayList, dm.dmPelsWidth, dm.dmPelsHeight,
+                           dm.dmBitsPerPel, dm.dmDisplayFrequency);
         }
     }
 
     CATCH_BAD_ALLOC;
 }
 
-void checkDMCallback(DDrawDisplayMode& dm, void* pContext) {
-    jboolean* isCalled = (jboolean*)pContext;
-    *isCalled = JNI_TRUE;
-}
-
-/*
- * Class:     sun_awt_Win32GraphicsDevice
- * Method:    isDisplayModeAvailable
- * Signature: (IIII)Z
- */
-JNIEXPORT jboolean JNICALL Java_sun_awt_Win32GraphicsDevice_isDisplayModeAvailable
-    (JNIEnv* env, jobject graphicsDevice, jint screen, jint width, jint height,
-    jint bitDepth, jint refreshRate) {
-
-    TRY;
-
-    DDrawDisplayMode dm(width, height, bitDepth, refreshRate);
-    jboolean isCalled = JNI_FALSE;
-    HMONITOR monitor = (HMONITOR)AwtWin32GraphicsDevice::GetMonitor(screen);
-
-    if (!DDEnumDisplayModes(monitor, &dm, checkDMCallback, &isCalled)) {
-            JNU_ThrowInternalError(env,
-                    "Could not get display modes");
-            return JNI_FALSE;
-    }
-
-    return isCalled;
-
-    CATCH_BAD_ALLOC_RET(JNI_FALSE);
-}
-
 /*
  * Class:     sun_awt_Win32GraphicsDevice
  * Method:    makeColorModel
@@ -1502,17 +1272,3 @@
     Devices::InstanceAccess devices;
     devices->GetDevice(screen)->SetJavaDevice(env, thisPtr);
 }
-
-/*
- * Class:     sun_awt_Win32GraphicsDevice
- * Method:    getDeviceMemoryNative
- * Signature: (I)I
- */
-JNIEXPORT jint JNICALL
-    Java_sun_awt_Win32GraphicsDevice_getDeviceMemoryNative
-    (JNIEnv *env, jobject thisPtr, jint screen)
-{
-    Devices::InstanceAccess devices;
-    return DDGetAvailableMemory(
-        (HMONITOR)devices->GetDevice(screen)->GetMonitor());
-}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt_Win32GraphicsDevice.h openjdk/jdk/src/windows/native/sun/windows/awt_Win32GraphicsDevice.h
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt_Win32GraphicsDevice.h	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Win32GraphicsDevice.h	2011-01-08 01:26:50.491202427 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -34,7 +34,6 @@
 #include "awt_Palette.h"
 #include "awt_MMStub.h"
 #include "Devices.h"
-#include "dxCapabilities.h"
 
 class AwtPalette;
 class Devices;
@@ -63,7 +62,6 @@
     int                     GetBitDepth() { return colorData->bitsperpixel; }
     MHND                    GetMonitor() { return monitor; }
     MONITOR_INFO            *GetMonitorInfo() { return pMonitorInfo; }
-    DxCapabilities          *GetDxCaps() { return &dxCaps; }
     jobject                 GetJavaDevice() { return javaDevice; }
     int                     GetDeviceIndex() { return screen; }
     void                    Release();
@@ -86,7 +84,6 @@
     static BOOL             IsPrimaryPalettized() { return primaryPalettized; }
     static int              GetDefaultDeviceIndex() { return primaryIndex; }
     static void             DisableOffscreenAccelerationForDevice(MHND hMonitor);
-    static DxCapabilities   *GetDxCapsForDevice(MHND hMonitor);
     static HDC              GetDCFromScreen(int screen);
     static int              GetScreenFromMHND(MHND mon);
 
@@ -97,7 +94,6 @@
     static jfieldID         dynamicColorModelID;
     static jfieldID         indexCMrgbID;
     static jfieldID         indexCMcacheID;
-    static jfieldID         accelerationEnabledID;
     static jmethodID        paletteChangedMID;
 
 private:
@@ -112,7 +108,6 @@
     MONITOR_INFO            *pMonitorInfo;
     jobject                 javaDevice;
     Devices                 *devicesArray;
-    DxCapabilities          dxCaps;
 };
 
 #endif AWT_WIN32GRAPHICSDEVICE_H
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt_Win32GraphicsEnv.cpp openjdk/jdk/src/windows/native/sun/windows/awt_Win32GraphicsEnv.cpp
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt_Win32GraphicsEnv.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Win32GraphicsEnv.cpp	2011-01-08 01:26:50.491202427 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,7 +31,8 @@
 #include "awt_Win32GraphicsDevice.h"
 #include "Devices.h"
 #include "WindowsFlags.h"
-#include "dxInit.h"
+
+BOOL DWMIsCompositionEnabled();
 
 void initScreens(JNIEnv *env) {
 
@@ -39,8 +40,6 @@
         JNU_ThrowInternalError(env, "Could not update the devices array.");
         return;
     }
-
-    InitDirectX();
 }
 
 /**
@@ -54,7 +53,7 @@
 static void
 SetProcessDPIAwareProperty()
 {
-    typedef BOOL SetProcessDPIAwareFunc(void);
+    typedef BOOL (WINAPI SetProcessDPIAwareFunc)(void);
     static BOOL bAlreadySet = FALSE;
 
     // setHighDPIAware is set in WindowsFlags.cpp
@@ -64,7 +63,7 @@
 
     bAlreadySet = TRUE;
 
-    HINSTANCE hLibUser32Dll = ::LoadLibrary(TEXT("user32.dll"));
+    HMODULE hLibUser32Dll = ::LoadLibrary(TEXT("user32.dll"));
 
     if (hLibUser32Dll != NULL) {
         SetProcessDPIAwareFunc *lpSetProcessDPIAware =
@@ -77,6 +76,76 @@
     }
 }
 
+#define DWM_COMP_UNDEFINED (~(TRUE|FALSE))
+static int dwmIsCompositionEnabled = DWM_COMP_UNDEFINED;
+
+/**
+ * This function is called from toolkit event handling code when
+ * WM_DWMCOMPOSITIONCHANGED event is received
+ */
+void DWMResetCompositionEnabled() {
+    dwmIsCompositionEnabled = DWM_COMP_UNDEFINED;
+    (void)DWMIsCompositionEnabled();
+}
+
+/**
+ * Returns true if dwm composition is enabled, false if it is not applicable
+ * (if the OS is not Vista) or dwm composition is disabled.
+ *
+ * Note: since DWM composition state changes are very rare we load/unload the
+ * dll on every change.
+ */
+BOOL DWMIsCompositionEnabled() {
+    typedef HRESULT (WINAPI DwmIsCompositionEnabledFunc)(BOOL*);
+
+    // cheaper to check than whether it's vista or not
+    if (dwmIsCompositionEnabled != DWM_COMP_UNDEFINED) {
+        return (BOOL)dwmIsCompositionEnabled;
+    }
+
+    if (!IS_WINVISTA) {
+        dwmIsCompositionEnabled = FALSE;
+        return FALSE;
+    }
+
+    BOOL bRes = FALSE;
+    HMODULE hDwmApiDll = ::LoadLibrary(TEXT("dwmapi.dll"));
+
+    if (hDwmApiDll != NULL) {
+        DwmIsCompositionEnabledFunc *lpDwmIsCompEnabled =
+            (DwmIsCompositionEnabledFunc*)
+                GetProcAddress(hDwmApiDll, "DwmIsCompositionEnabled");
+        if (lpDwmIsCompEnabled != NULL) {
+            BOOL bEnabled;
+            HRESULT res = lpDwmIsCompEnabled(&bEnabled);
+            if (SUCCEEDED(res)) {
+                bRes = bEnabled;
+                J2dTraceLn1(J2D_TRACE_VERBOSE, " composition enabled: %d",bRes);
+            } else {
+                J2dTraceLn1(J2D_TRACE_ERROR,
+                            "IsDWMCompositionEnabled: error %x when detecting"\
+                            "if composition is enabled", res);
+            }
+        } else {
+            J2dTraceLn(J2D_TRACE_ERROR,
+                       "IsDWMCompositionEnabled: no DwmIsCompositionEnabled() "\
+                       "in dwmapi.dll");
+        }
+        ::FreeLibrary(hDwmApiDll);
+    } else {
+        J2dTraceLn(J2D_TRACE_ERROR,
+                   "IsDWMCompositionEnabled: error opening dwmapi.dll");
+    }
+
+    dwmIsCompositionEnabled = bRes;
+
+    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+    JNU_CallStaticMethodByName(env, NULL,
+                              "sun/awt/Win32GraphicsEnvironment",
+                              "dwmCompositionChanged", "(Z)V", (jboolean)bRes);
+    return bRes;
+}
+
 /*
  * Class:     sun_awt_Win32GraphicsEnvironment
  * Method:    initDisplay
@@ -89,6 +158,8 @@
     // This method needs to be called prior to any display-related activity
     SetProcessDPIAwareProperty();
 
+    DWMIsCompositionEnabled();
+
     initScreens(env);
 }
 
@@ -306,3 +377,14 @@
 
     CATCH_BAD_ALLOC_RET(0);
 }
+
+/*
+ * Class:     sun_awt_Win32GraphicsEnvironment
+ * Method:    isVistaOS
+ * Signature: ()Z
+ */
+JNIEXPORT jboolean JNICALL Java_sun_awt_Win32GraphicsEnvironment_isVistaOS
+  (JNIEnv *env, jclass wgeclass)
+{
+    return IS_WINVISTA;
+}
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt_Window.cpp openjdk/jdk/src/windows/native/sun/windows/awt_Window.cpp
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt_Window.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Window.cpp	2011-01-08 01:26:50.491202427 +0000
@@ -33,7 +33,6 @@
 #include "awt_Toolkit.h"
 #include "awt_Window.h"
 #include "awt_dlls.h"
-#include "ddrawUtils.h"
 #include "awt_Win32GraphicsDevice.h"
 #include "awt_BitmapUtil.h"
 #include "awt_IconCursor.h"
@@ -743,7 +742,7 @@
     insetsChanged = !::EqualRect( &m_old_insets, &m_insets );
     ::CopyRect( &m_old_insets, &m_insets );
 
-    if (insetsChanged && DDCanReplaceSurfaces(GetHWnd())) {
+    if (insetsChanged) {
         // Since insets are changed we need to update the surfaceData object
         // to reflect that change
         env->CallVoidMethod(peer, AwtComponent::replaceSurfaceDataLaterMID);
@@ -932,50 +931,6 @@
     }
 }
 
-MsgRouting AwtWindow::WmDDEnterFullScreen(HMONITOR monitor) {
-    /**
-     * DirectDraw expects to receive a top-level window. This object may
-     * be an AwtWindow instance, which has an owning AwtFrame window, or
-     * an AwtFrame object which does not have an owner.
-     * What we want is the top-level Frame hWnd, whether we were handed a
-     * top-level AwtFrame, or some owned AwtWindow.  We get this by calling
-     * GetTopLevelHWnd(), which returns the hwnd of a top-level AwtFrame
-     * object (if this window has an owner) which we then pass
-     * into DirectDraw.
-     */
-    HWND hWnd = GetTopLevelHWnd();
-    if (!::IsWindowVisible(hWnd)) {
-        // Sometimes there are problems going into fullscreen on an owner frame
-        // that is not yet visible; make sure the FS window is visible first
-        ::ShowWindow(hWnd, SW_SHOWNA);
-    }
-    /*
-     * Fix for 6225472.
-     * Non-focusable window should be set alwaysOnTop to overlap the taskbar.
-     */
-    AwtWindow* window = (AwtWindow *)AwtComponent::GetComponent(GetHWnd());
-    if (window != NULL && !window->IsFocusableWindow()) {
-        JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-        Java_sun_awt_windows_WWindowPeer_setAlwaysOnTopNative(env, GetPeer(env), (jboolean)TRUE);
-    }
-
-    DDEnterFullScreen(monitor, GetHWnd(), hWnd);
-    return mrDoDefault;
-}
-
-MsgRouting AwtWindow::WmDDExitFullScreen(HMONITOR monitor) {
-    HWND hWnd = GetTopLevelHWnd();
-    DDExitFullScreen(monitor, hWnd);
-
-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-    jboolean alwaysOnTop = JNU_CallMethodByName(env, NULL, GetTarget(env),
-                                                "isAlwaysOnTop", "()Z").z;
-
-    // We should restore alwaysOnTop state as it's anyway dropped here.
-    Java_sun_awt_windows_WWindowPeer_setAlwaysOnTopNative(env, GetPeer(env), alwaysOnTop);
-    return mrDoDefault;
-}
-
 MsgRouting AwtWindow::WmCreate()
 {
     return mrDoDefault;
@@ -1334,10 +1289,8 @@
     SendComponentEvent(java_awt_event_ComponentEvent_COMPONENT_RESIZED);
     // Need to replace surfaceData on resize to catch changes to
     // various component-related values, such as insets
-    if (DDCanReplaceSurfaces(GetHWnd())) {
-        JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
-        env->CallVoidMethod(m_peerObject, AwtComponent::replaceSurfaceDataLaterMID);
-    }
+    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
+    env->CallVoidMethod(m_peerObject, AwtComponent::replaceSurfaceDataLaterMID);
 }
 
 BOOL CALLBACK InvalidateChildRect(HWND hWnd, LPARAM)
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/awt_Window.h openjdk/jdk/src/windows/native/sun/windows/awt_Window.h
--- openjdk.orig/jdk/src/windows/native/sun/windows/awt_Window.h	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/awt_Window.h	2011-01-08 01:26:50.491202427 +0000
@@ -167,8 +167,6 @@
     virtual MsgRouting WmClose();
     virtual MsgRouting WmDestroy();
     virtual MsgRouting WmShowWindow(BOOL show, UINT status);
-    virtual MsgRouting WmDDEnterFullScreen(HMONITOR monitor);
-    virtual MsgRouting WmDDExitFullScreen(HMONITOR monitor);
     virtual MsgRouting WmGetMinMaxInfo(LPMINMAXINFO lpmmi);
     virtual MsgRouting WmMove(int x, int y);
     virtual MsgRouting WmSize(UINT type, int w, int h);
diff -Nru openjdk.orig/jdk/src/windows/native/sun/windows/Devices.cpp openjdk/jdk/src/windows/native/sun/windows/Devices.cpp
--- openjdk.orig/jdk/src/windows/native/sun/windows/Devices.cpp	2011-01-07 21:33:08.000000000 +0000
+++ openjdk/jdk/src/windows/native/sun/windows/Devices.cpp	2011-01-08 01:26:50.491202427 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -84,6 +84,7 @@
 #include "Devices.h"
 #include "Trace.h"
 #include "awt_Multimon.h"
+#include "D3DPipelineManager.h"
 
 Devices* Devices::theInstance = NULL;
 CriticalSection Devices::arrayLock;
@@ -133,13 +134,12 @@
     AwtWin32GraphicsDevice** rawDevices = newDevices->GetRawArray();
     int i;
     for (i = 0; i < numScreens; ++i) {
+        J2dTraceLn2(J2D_TRACE_VERBOSE, "  hmon[%d]=0x%x", i, monHds[i]);
         rawDevices[i] = new AwtWin32GraphicsDevice(i, monHds[i], newDevices);
     }
     for (i = 0; i < numScreens; ++i) {
         rawDevices[i]->Initialize();
     }
-    free(monHds);
-
     {
         CriticalSection::Lock l(arrayLock);
 
@@ -161,12 +161,14 @@
                             "Devices::UpdateInstance: device removed: %d", i);
                 oldDevices->GetDevice(i)->Invalidate(env);
             }
-
             // Now that we have a new array in place, remove this (possibly the
             // last) reference to the old instance.
             oldDevices->Release();
         }
+        D3DPipelineManager::HandleAdaptersChange((HMONITOR*)monHds,
+                                                 theInstance->GetNumDevices());
     }
+    free(monHds);
 
     return TRUE;
 }
diff -Nru openjdk.orig/jdk/test/java/awt/FullScreen/BufferStrategyExceptionTest/BufferStrategyExceptionTest.java openjdk/jdk/test/java/awt/FullScreen/BufferStrategyExceptionTest/BufferStrategyExceptionTest.java
--- openjdk.orig/jdk/test/java/awt/FullScreen/BufferStrategyExceptionTest/BufferStrategyExceptionTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/java/awt/FullScreen/BufferStrategyExceptionTest/BufferStrategyExceptionTest.java	2011-01-08 01:26:50.491202427 +0000
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2006-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/**
+ * @test
+ * @bug 6366813 6459844
+ * @summary Tests that no exception is thrown if a frame is resized just
+ * before we create a bufferStrategy
+ * @author Dmitri.Trembovetski area=FullScreen/BufferStrategy
+ * @run main/othervm -Dsun.java2d.opengl=true BufferStrategyExceptionTest
+ * @run main/othervm BufferStrategyExceptionTest
+ */
+
+import java.awt.AWTException;
+import java.awt.BufferCapabilities;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.ImageCapabilities;
+import java.awt.image.BufferStrategy;
+import java.awt.image.BufferedImage;
+
+/**
+ * The purpose of this test is to make sure that we do not throw an
+ * IllegalStateException during the creation of BufferStrategy if
+ * a window has been resized just before our creation attempt.
+ *
+ * We test both windowed and fullscreen mode, although the exception has
+ * been observed in full screen mode only.
+ */
+public class BufferStrategyExceptionTest {
+    private static final int TEST_REPS = 20;
+
+    public static void main(String[] args) {
+        GraphicsDevice gd =
+            GraphicsEnvironment.getLocalGraphicsEnvironment().
+                getDefaultScreenDevice();
+
+        for (int i = 0; i < TEST_REPS; i++) {
+            TestFrame f = new TestFrame();
+            f.pack();
+            f.setSize(400, 400);
+            f.setVisible(true);
+            if (i % 2 == 0) {
+                gd.setFullScreenWindow(f);
+            }
+            // generate a resize event which will invalidate the peer's
+            // surface data and hopefully cause an exception during
+            // BufferStrategy creation in TestFrame.render()
+            Dimension d = f.getSize();
+            d.width -= 5; d.height -= 5;
+            f.setSize(d);
+
+            f.render();
+            gd.setFullScreenWindow(null);
+            sleep(100);
+            f.dispose();
+        }
+        System.out.println("Test passed.");
+    }
+
+    private static void sleep(long msecs) {
+        try {
+            Thread.sleep(msecs);
+        } catch (InterruptedException ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    private static final BufferedImage bi =
+        new BufferedImage(200, 200, BufferedImage.TYPE_INT_RGB);
+
+    static class TestFrame extends Frame {
+        TestFrame() {
+            setUndecorated(true);
+            setIgnoreRepaint(true);
+            setSize(400, 400);
+        }
+
+        public void render() {
+            ImageCapabilities imgBackBufCap = new ImageCapabilities(true);
+            ImageCapabilities imgFrontBufCap = new ImageCapabilities(true);
+            BufferCapabilities bufCap =
+                new BufferCapabilities(imgFrontBufCap,
+                    imgBackBufCap, BufferCapabilities.FlipContents.COPIED);
+            try {
+
+                createBufferStrategy(2, bufCap);
+            } catch (AWTException ex) {
+                createBufferStrategy(2);
+            }
+
+            BufferStrategy bs = getBufferStrategy();
+            do {
+                Graphics g =  bs.getDrawGraphics();
+                g.setColor(Color.green);
+                g.fillRect(0, 0, getWidth(), getHeight());
+
+                g.setColor(Color.red);
+                g.drawString("Rendering test", 20, 20);
+
+                g.drawImage(bi, 50, 50, null);
+
+                g.dispose();
+                bs.show();
+            } while (bs.contentsLost()||bs.contentsRestored());
+        }
+    }
+
+}
diff -Nru openjdk.orig/jdk/test/java/awt/FullScreen/MultimonFullscreenTest/MultimonFullscreenTest.java openjdk/jdk/test/java/awt/FullScreen/MultimonFullscreenTest/MultimonFullscreenTest.java
--- openjdk.orig/jdk/test/java/awt/FullScreen/MultimonFullscreenTest/MultimonFullscreenTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/java/awt/FullScreen/MultimonFullscreenTest/MultimonFullscreenTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,387 @@
+/*
+ * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/**
+ * @test
+ * @bug 5041219
+ * @bug 5101561
+ * @bug 5035272
+ * @bug 5096011
+ * @bug 5101712
+ * @bug 5098624
+ * @summary Here are a few assertions worth verification:
+ *  - the fullscreen window is positioned at 0,0
+ *  - the fs window appears on the correct screen
+ *  - if the exclusive FS mode is supported, no other widndow should
+ *    overlap the fs window (including the taskbar).
+ *    You could, however, alt+tab out of a fullscreen window, or at least
+ *    minimize it (if you've entered the fs mode with a Window, you'll need
+ *    to minimize the owner frame).
+ *    Note that there may be issues with FS exclusive mode with ddraw and
+ *    multiple fullscreen windows (one per device).
+ *  - if display mode is supported that it did change
+ *  - that the original display mode is restored once
+ *    the ws window is disposed
+ *  All of the above should work with and w/o DirectDraw
+ *  (-Dsun.java2d.noddraw=true) on windows, and w/ and w/o opengl on X11
+ *  (-Dsun.java2d.opengl=True).
+ * @run main/manual/othervm -Dsun.java2d.pmoffscreen=true MultimonFullscreenTest
+ * @run main/manual/othervm -Dsun.java2d.pmoffscreen=false MultimonFullscreenTest
+ * @run main/manual/othervm -Dsun.java2d.d3d=True MultimonFullscreenTest
+ * @run main/manual/othervm -Dsun.java2d.noddraw=true MultimonFullscreenTest
+ * @run main/manual/othervm -Dsun.java2d.opengl=True MultimonFullscreenTest
+ */
+
+import java.awt.Button;
+import java.awt.Checkbox;
+import java.awt.CheckboxGroup;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Dialog;
+import java.awt.DisplayMode;
+import java.awt.Font;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.GridLayout;
+import java.awt.Panel;
+import java.awt.Rectangle;
+import java.awt.Window;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.ItemEvent;
+import java.awt.event.ItemListener;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.image.BufferStrategy;
+import java.util.HashMap;
+import java.util.Random;
+
+/**
+ */
+
+public class MultimonFullscreenTest extends Frame implements ActionListener {
+    GraphicsDevice  defDev = GraphicsEnvironment.getLocalGraphicsEnvironment().
+            getDefaultScreenDevice();
+    GraphicsDevice  gd[] = GraphicsEnvironment.getLocalGraphicsEnvironment().
+            getScreenDevices();
+    HashMap<Button, GraphicsDevice> deviceMap;
+
+    private static boolean dmChange = false;
+    static boolean setNullOnDispose = false;
+    static boolean useFSFrame = true;
+    static boolean useFSWindow = false;
+    static boolean useFSDialog = false;
+    static boolean useBS = false;
+    static boolean runRenderLoop = false;
+    static boolean addHWChildren = false;
+    static volatile boolean done = true;
+
+    public MultimonFullscreenTest(String title) {
+        super(title);
+        addWindowListener(new WindowAdapter() {
+            public void windowClosing(WindowEvent e) {
+                System.exit(0);
+            }
+        });
+        Panel p = new Panel();
+        deviceMap = new HashMap<Button, GraphicsDevice>(gd.length);
+        int num = 0;
+        for (GraphicsDevice dev : gd) {
+            Button b;
+            if (dev == defDev) {
+                b = new Button("Primary screen: " + num);
+                System.out.println("Primary Dev : " + dev + " Bounds: " +
+                        dev.getDefaultConfiguration().getBounds());
+            } else {
+                b = new Button("Secondary screen " + num);
+                System.out.println("Secondary Dev : " + dev + " Bounds: " +
+                        dev.getDefaultConfiguration().getBounds());
+            }
+            b.addActionListener(this);
+            p.add(b);
+            deviceMap.put(b, dev);
+            num++;
+        }
+        add("South", p);
+        Panel p1 = new Panel();
+        p1.setLayout(new GridLayout(2,0));
+        Checkbox cb = new Checkbox("Change DM on entering FS");
+        cb.addItemListener(new ItemListener() {
+            public void itemStateChanged(ItemEvent e) {
+                dmChange = ((Checkbox)e.getSource()).getState();
+            }
+        });
+        p1.add(cb);
+//        cb = new Checkbox("Exit FS on window dispose");
+//        cb.addItemListener(new ItemListener() {
+//            public void itemStateChanged(ItemEvent e) {
+//                setNullOnDispose = ((Checkbox)e.getSource()).getState();
+//            }
+//        });
+//        p1.add(cb);
+        CheckboxGroup cbg = new CheckboxGroup();
+        cb = new Checkbox("Use Frame to enter FS", cbg, true);
+        cb.addItemListener(new ItemListener() {
+            public void itemStateChanged(ItemEvent e) {
+                useFSFrame = true;
+                useFSWindow = false;
+                useFSDialog = false;
+            }
+        });
+        p1.add(cb);
+        cb = new Checkbox("Use Window to enter FS", cbg, false);
+        cb.addItemListener(new ItemListener() {
+            public void itemStateChanged(ItemEvent e) {
+                useFSFrame = false;
+                useFSWindow = true;
+                useFSDialog = false;
+            }
+        });
+        p1.add(cb);
+        cb = new Checkbox("Use Dialog to enter FS", cbg, false);
+        cb.addItemListener(new ItemListener() {
+            public void itemStateChanged(ItemEvent e) {
+                useFSFrame = false;
+                useFSWindow = false;
+                useFSDialog = true;
+            }
+        });
+        p1.add(cb);
+        cb = new Checkbox("Run render loop");
+        cb.addItemListener(new ItemListener() {
+            public void itemStateChanged(ItemEvent e) {
+                runRenderLoop = ((Checkbox)e.getSource()).getState();
+            }
+        });
+        p1.add(cb);
+        cb = new Checkbox("Use BufferStrategy in render loop");
+        cb.addItemListener(new ItemListener() {
+            public void itemStateChanged(ItemEvent e) {
+                useBS = ((Checkbox)e.getSource()).getState();
+            }
+        });
+        p1.add(cb);
+        cb = new Checkbox("Add Children to FS window");
+        cb.addItemListener(new ItemListener() {
+            public void itemStateChanged(ItemEvent e) {
+                addHWChildren = ((Checkbox)e.getSource()).getState();
+            }
+        });
+        p1.add(cb);
+        add("North", p1);
+
+        pack();
+        setVisible(true);
+    }
+
+    Font f = new Font("Dialog", Font.BOLD, 24);
+    Random rnd = new Random();
+    public void renderDimensions(Graphics g, Rectangle rectWndBounds,
+                                 GraphicsConfiguration gc) {
+        g.setColor(new Color(rnd.nextInt(0xffffff)));
+        g.fillRect(0, 0, rectWndBounds.width, rectWndBounds.height);
+
+        g.setColor(new Color(rnd.nextInt(0xffffff)));
+        Rectangle rectStrBounds;
+
+        g.setFont(f);
+
+        rectStrBounds = g.getFontMetrics().
+                getStringBounds(rectWndBounds.toString(), g).getBounds();
+        rectStrBounds.height += 30;
+        g.drawString(rectWndBounds.toString(), 50, rectStrBounds.height);
+        int oldHeight = rectStrBounds.height;
+        String isFSupported = "Exclusive Fullscreen mode supported: " +
+                              gc.getDevice().isFullScreenSupported();
+        rectStrBounds = g.getFontMetrics().
+                getStringBounds(isFSupported, g).getBounds();
+        rectStrBounds.height += (10 + oldHeight);
+        g.drawString(isFSupported, 50, rectStrBounds.height);
+
+        oldHeight = rectStrBounds.height;
+        String isDMChangeSupported = "Display Mode Change supported: " +
+                              gc.getDevice().isDisplayChangeSupported();
+        rectStrBounds = g.getFontMetrics().
+                getStringBounds(isDMChangeSupported, g).getBounds();
+        rectStrBounds.height += (10 + oldHeight);
+        g.drawString(isDMChangeSupported, 50, rectStrBounds.height);
+
+        oldHeight = rectStrBounds.height;
+        String usingBS = "Using BufferStrategy: " + useBS;
+        rectStrBounds = g.getFontMetrics().
+                getStringBounds(usingBS, g).getBounds();
+        rectStrBounds.height += (10 + oldHeight);
+        g.drawString(usingBS, 50, rectStrBounds.height);
+
+        final String m_strQuitMsg = "Double-click to dispose FullScreen Window";
+        rectStrBounds = g.getFontMetrics().
+                getStringBounds(m_strQuitMsg, g).getBounds();
+        g.drawString(m_strQuitMsg,
+                (rectWndBounds.width - rectStrBounds.width) / 2,
+                (rectWndBounds.height - rectStrBounds.height) / 2);
+
+
+    }
+
+    public void actionPerformed(ActionEvent ae) {
+        GraphicsDevice dev = deviceMap.get(ae.getSource());
+        System.err.println("Setting FS on device:"+dev);
+        final Window fsWindow;
+
+        if (useFSWindow) {
+            fsWindow = new Window(this, dev.getDefaultConfiguration()) {
+                public void paint(Graphics g) {
+                    renderDimensions(g, getBounds(),
+                                     this.getGraphicsConfiguration());
+                }
+            };
+        } else if (useFSDialog) {
+            fsWindow = new Dialog((Frame)null, "FS Dialog on device "+dev, false,
+                                 dev.getDefaultConfiguration());
+            fsWindow.add(new Component() {
+                public void paint(Graphics g) {
+                    renderDimensions(g, getBounds(),
+                                     this.getGraphicsConfiguration());
+                }
+            });
+        } else {
+            fsWindow = new Frame("FS Frame on device "+dev,
+                                 dev.getDefaultConfiguration())
+            {
+                public void paint(Graphics g) {
+                    renderDimensions(g, getBounds(),
+                                     this.getGraphicsConfiguration());
+                }
+            };
+            if (addHWChildren) {
+                fsWindow.add("South", new Panel() {
+                    public void paint(Graphics g) {
+                        g.setColor(Color.red);
+                        g.fillRect(0, 0, getWidth(), getHeight());
+                    }
+                });
+                fsWindow.add("North", new Button("Button, sucka!"));
+            }
+        }
+        fsWindow.addMouseListener(new MouseAdapter() {
+            public void mouseClicked(MouseEvent e) {
+                if (e.getClickCount() > 1) {
+                    done = true;
+                    fsWindow.dispose();
+                }
+            }
+        });
+
+        fsWindow.addWindowListener(new WindowHandler());
+        dev.setFullScreenWindow(fsWindow);
+        if (dmChange && dev.isDisplayChangeSupported()) {
+            DisplayMode dms[] = dev.getDisplayModes();
+            DisplayMode myDM = null;
+            for (DisplayMode dm : dms) {
+                if (dm.getWidth() == 800 && dm.getHeight() == 600 &&
+                    (dm.getBitDepth() >= 16 ||
+                     dm.getBitDepth() == DisplayMode.BIT_DEPTH_MULTI) &&
+                     (dm.getRefreshRate() >= 60 ||
+                      dm.getRefreshRate() == DisplayMode.REFRESH_RATE_UNKNOWN))
+                {
+                    myDM = dm;
+                    break;
+                }
+            }
+            if (myDM != null) {
+                System.err.println("Setting Display Mode: "+
+                        myDM.getWidth() + "x" + myDM.getHeight() + "x" +
+                        myDM.getBitDepth() + "@" + myDM.getRefreshRate() +
+                        "Hz on device" + dev);
+                dev.setDisplayMode(myDM);
+            } else {
+                System.err.println("Can't find suitable display mode.");
+            }
+        }
+        done = false;
+        if (runRenderLoop) {
+            Thread updateThread = new Thread(new Runnable() {
+                public void run() {
+                    BufferStrategy bs = null;
+                    if (useBS) {
+                        fsWindow.createBufferStrategy(2);
+                        bs = fsWindow.getBufferStrategy();
+                    }
+                    while (!done) {
+                        if (useBS) {
+                            Graphics g = bs.getDrawGraphics();
+                            renderDimensions(g, fsWindow.getBounds(),
+                                           fsWindow.getGraphicsConfiguration());
+                            bs.show();
+                        } else {
+                            fsWindow.repaint();
+                        }
+                        try {
+                            Thread.sleep(1000);
+                        } catch (InterruptedException e) {}
+                    }
+                    if (useBS) {
+                        bs.dispose();
+                    }
+                }
+            });
+            updateThread.start();
+        }
+    }
+
+    public static void main(String args[]) {
+        for (String s : args) {
+            if (s.equalsIgnoreCase("-dm")) {
+                System.err.println("Do Display Change after entering FS mode");
+                dmChange = true;
+            } else if (s.equalsIgnoreCase("-usewindow")) {
+                System.err.println("Using Window to enter FS mode");
+                useFSWindow = true;
+            } else if (s.equalsIgnoreCase("-setnull")) {
+                System.err.println("Setting null FS window on dispose");
+                setNullOnDispose = true;
+            } else {
+                System.err.println("Usage: MultimonFullscreenTest " +
+                        "[-dm][-usewindow][-setnull]");
+            }
+
+        }
+        MultimonFullscreenTest fs =
+                new MultimonFullscreenTest("Test Full Screen");
+    }
+    class WindowHandler extends WindowAdapter {
+        public void windowClosing(WindowEvent we) {
+            done = true;
+            Window w = (Window)we.getSource();
+            if (setNullOnDispose) {
+                w.getGraphicsConfiguration().getDevice().setFullScreenWindow(null);
+            }
+            w.dispose();
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/test/java/awt/FullScreen/NoResizeEventOnDMChangeTest/NoResizeEventOnDMChangeTest.java openjdk/jdk/test/java/awt/FullScreen/NoResizeEventOnDMChangeTest/NoResizeEventOnDMChangeTest.java
--- openjdk.orig/jdk/test/java/awt/FullScreen/NoResizeEventOnDMChangeTest/NoResizeEventOnDMChangeTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/java/awt/FullScreen/NoResizeEventOnDMChangeTest/NoResizeEventOnDMChangeTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,216 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/*
+ * @test
+ * @bug 6646411
+ * @summary Tests that full screen window and its children receive resize
+            event when display mode changes
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @run main/othervm NoResizeEventOnDMChangeTest
+ * @run main/othervm -Dsun.java2d.d3d=false NoResizeEventOnDMChangeTest
+ */
+
+import java.awt.Canvas;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.DisplayMode;
+import java.awt.EventQueue;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.Window;
+import java.awt.event.ComponentAdapter;
+import java.awt.event.ComponentEvent;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+
+public class NoResizeEventOnDMChangeTest {
+    public static void main(String[] args) {
+        final GraphicsDevice gd = GraphicsEnvironment.
+            getLocalGraphicsEnvironment().getDefaultScreenDevice();
+
+        if (!gd.isFullScreenSupported()) {
+            System.out.println("Full screen not supported, test passed");
+            return;
+        }
+
+        DisplayMode dm = gd.getDisplayMode();
+        final DisplayMode dms[] = new DisplayMode[2];
+        for (DisplayMode dm1 : gd.getDisplayModes()) {
+            if (dm1.getWidth()  != dm.getWidth() ||
+                dm1.getHeight() != dm.getHeight())
+            {
+                dms[0] = dm1;
+                break;
+            }
+        }
+        if (dms[0] == null) {
+            System.out.println("Test Passed: all DMs have same dimensions");
+            return;
+        }
+        dms[1] = dm;
+
+        Frame f = new Frame() {
+            @Override
+            public void paint(Graphics g) {
+                g.setColor(Color.red);
+                g.fillRect(0, 0, getWidth(), getHeight());
+                g.setColor(Color.green);
+                g.drawRect(0, 0, getWidth()-1, getHeight()-1);
+            }
+        };
+        f.setUndecorated(true);
+        testFSWindow(gd, dms, f);
+
+        Window w = new Window(f) {
+            @Override
+            public void paint(Graphics g) {
+                g.setColor(Color.magenta);
+                g.fillRect(0, 0, getWidth(), getHeight());
+                g.setColor(Color.cyan);
+                g.drawRect(0, 0, getWidth()-1, getHeight()-1);
+            }
+        };
+        testFSWindow(gd, dms, w);
+        System.out.println("Test Passed.");
+    }
+
+    private static void testFSWindow(final GraphicsDevice gd,
+                                     final DisplayMode dms[],
+                                     final Window fsWin)
+    {
+        System.out.println("Testing FS window: "+fsWin);
+        Component c = new Canvas() {
+            @Override
+            public void paint(Graphics g) {
+                g.setColor(Color.blue);
+                g.fillRect(0, 0, getWidth(), getHeight());
+                g.setColor(Color.magenta);
+                g.drawRect(0, 0, getWidth()-1, getHeight()-1);
+                g.setColor(Color.red);
+                g.drawString("FS Window   : " + fsWin, 50, 50);
+                DisplayMode dm =
+                    getGraphicsConfiguration().getDevice().getDisplayMode();
+                g.drawString("Display Mode: " +
+                             dm.getWidth() + "x" + dm.getHeight(), 50, 75);
+            }
+        };
+        fsWin.add("Center", c);
+        fsWin.addWindowListener(new WindowAdapter() {
+            @Override
+            public void windowClosing(WindowEvent e) {
+                fsWin.dispose();
+                if (fsWin.getOwner() != null) {
+                    fsWin.getOwner().dispose();
+                }
+            }
+        });
+
+        try {
+            EventQueue.invokeAndWait(new Runnable() {
+                public void run() {
+                    gd.setFullScreenWindow(fsWin);
+                }
+            });
+        } catch (Exception ex) {}
+
+        sleep(1000);
+
+        final ResizeEventChecker r1 = new ResizeEventChecker();
+        final ResizeEventChecker r2 = new ResizeEventChecker();
+
+        if (gd.isDisplayChangeSupported()) {
+            fsWin.addComponentListener(r1);
+            c.addComponentListener(r2);
+            for (final DisplayMode dm1 : dms) {
+                try {
+                    EventQueue.invokeAndWait(new Runnable() {
+                        public void run() {
+                            System.err.printf("----------- Setting DM %dx%d:\n",
+                                              dm1.getWidth(), dm1.getHeight());
+                            try {
+                                gd.setDisplayMode(dm1);
+                                r1.incDmChanges();
+                                r2.incDmChanges();
+                            } catch (IllegalArgumentException iae) {}
+                        }
+                    });
+                } catch (Exception ex) {}
+                for (int i = 0; i < 3; i++) {
+                    fsWin.repaint();
+                    sleep(1000);
+                }
+            }
+            fsWin.removeComponentListener(r1);
+            c.removeComponentListener(r2);
+        }
+        try {
+           EventQueue.invokeAndWait(new Runnable() {
+               public void run() {
+                   gd.setFullScreenWindow(null);
+                    fsWin.dispose();
+                    if (fsWin.getOwner() != null) {
+                        fsWin.getOwner().dispose();
+                    }
+                }
+            });
+        } catch (Exception ex) {}
+
+        System.out.printf("FS Window: resizes=%d, dm changes=%d\n",
+                           r1.getResizes(), r1.getDmChanges());
+        System.out.printf("Component: resizes=%d, dm changes=%d\n",
+                          r2.getResizes(), r2.getDmChanges());
+        if (r1.getResizes() < r1.getDmChanges()) {
+            throw new RuntimeException("FS Window didn't receive all resizes!");
+        }
+        if (r2.getResizes() < r2.getDmChanges()) {
+            throw new RuntimeException("Component didn't receive all resizes!");
+        }
+    }
+
+    static void sleep(long ms) {
+        try {
+            Thread.sleep(ms);
+        } catch (InterruptedException ex) {}
+    }
+    static class ResizeEventChecker extends ComponentAdapter {
+        int dmChanges;
+        int resizes;
+
+        @Override
+        public synchronized void componentResized(ComponentEvent e) {
+            System.out.println("Received resize event for "+e.getSource());
+            resizes++;
+        }
+        public synchronized int getResizes() {
+            return resizes;
+        }
+        public synchronized void incDmChanges() {
+            dmChanges++;
+        }
+        public synchronized int getDmChanges() {
+            return dmChanges;
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/test/java/awt/FullScreen/SetFSWindow/FSFrame.java openjdk/jdk/test/java/awt/FullScreen/SetFSWindow/FSFrame.java
--- openjdk.orig/jdk/test/java/awt/FullScreen/SetFSWindow/FSFrame.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/java/awt/FullScreen/SetFSWindow/FSFrame.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,204 @@
+/*
+ * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6240507 6662642
+ * @summary verify that isFullScreenSupported and getFullScreenWindow work
+ * correctly with and without a SecurityManager. Note that the test may fail
+ * on older Gnome versions (see bug 6500686).
+ * @run main FSFrame
+ * @run main/othervm -Dsun.java2d.noddraw=true FSFrame
+ * @author cheth
+ */
+
+import java.awt.*;
+import java.awt.image.*;
+import java.applet.*;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import javax.imageio.ImageIO;
+
+public class FSFrame extends Frame implements Runnable {
+
+    // Don't start the test until the window is visible
+    boolean visible = false;
+    Robot robot = null;
+    static volatile boolean done = false;
+
+    public void paint(Graphics g) {
+        if (!visible && getWidth() != 0 && getHeight() != 0) {
+            visible = true;
+            try {
+                GraphicsDevice gd = getGraphicsConfiguration().getDevice();
+                robot = new Robot(gd);
+            } catch (Exception e) {
+                System.out.println("Problem creating robot: cannot verify FS " +
+                                   "window display");
+            }
+        }
+        g.setColor(Color.green);
+        g.fillRect(0, 0, getWidth(), getHeight());
+    }
+
+    @Override
+    public void update(Graphics g) {
+        paint(g);
+    }
+
+    boolean checkColor(int x, int y, BufferedImage bImg) {
+        int pixelColor;
+        int correctColor = Color.green.getRGB();
+        pixelColor = bImg.getRGB(x, y);
+        if (pixelColor != correctColor) {
+            System.out.println("FAILURE: pixelColor " +
+                               Integer.toHexString(pixelColor) +
+                               " != correctColor " +
+                               Integer.toHexString(correctColor) +
+                               " at coordinates (" + x + ", " + y + ")");
+            return false;
+        }
+        return true;
+    }
+
+    void checkFSDisplay(boolean fsSupported) {
+        GraphicsConfiguration gc = getGraphicsConfiguration();
+        GraphicsDevice gd = gc.getDevice();
+        Rectangle r = gc.getBounds();
+        Insets in = null;
+        if (!fsSupported) {
+            in = Toolkit.getDefaultToolkit().getScreenInsets(gc);
+            r = new Rectangle(in.left, in.top,
+                              r.width -  (in.left + in.right),
+                              r.height - (in.top  + in.bottom));
+        }
+        BufferedImage bImg = robot.createScreenCapture(r);
+        // Check that all four corners and middle pixel match the window's
+        // fill color
+        if (robot == null) {
+            return;
+        }
+        boolean colorCorrect = true;
+        colorCorrect &= checkColor(0, 0, bImg);
+        colorCorrect &= checkColor(0, bImg.getHeight() - 1, bImg);
+        colorCorrect &= checkColor(bImg.getWidth() - 1, 0, bImg);
+        colorCorrect &= checkColor(bImg.getWidth() - 1, bImg.getHeight() - 1, bImg);
+        colorCorrect &= checkColor(bImg.getWidth() / 2, bImg.getHeight() / 2, bImg);
+        if (!colorCorrect) {
+            System.err.println("Test failed for mode: fsSupported="+fsSupported);
+            if (in != null) {
+                System.err.println("screen insets   : " + in);
+            }
+            System.err.println("screen shot rect: " + r);
+            String name = "FSFrame_fs_"+
+                    (fsSupported?"supported":"not_supported")+".png";
+            try {
+                ImageIO.write(bImg, "png", new File(name));
+                System.out.println("Dumped screen shot to "+name);
+            } catch (IOException ex) {}
+            throw new Error("Some pixel colors not correct; FS window may not" +
+                            " have been displayed correctly");
+        }
+    }
+
+    void checkFSFunctionality(boolean withSecurity) {
+        GraphicsDevice gd = getGraphicsConfiguration().getDevice();
+        if (withSecurity) {
+            SecurityManager sm = new SecurityManager();
+            System.setSecurityManager(sm);
+        }
+        try {
+            // None of these should throw an exception
+            final boolean fs = gd.isFullScreenSupported();
+            System.out.println("FullscreenSupported: " + (fs ? "yes" : "no"));
+            gd.setFullScreenWindow(this);
+            try {
+                // Give the system time to set the FS window and display it
+                // properly
+                Thread.sleep(2000);
+            } catch (Exception e) {}
+            if (!withSecurity) {
+                // See if FS window got displayed correctly
+                try {
+                    EventQueue.invokeAndWait(new Runnable() {
+                        public void run() {
+                            repaint();
+                            checkFSDisplay(fs);
+                        }
+                    });
+                } catch (InvocationTargetException ex) {
+                    ex.printStackTrace();
+                } catch (InterruptedException ex) {
+                    ex.printStackTrace();
+                }
+            }
+            // reset window
+            gd.setFullScreenWindow(null);
+            try {
+                // Give the system time to set the FS window and display it
+                // properly
+                Thread.sleep(2000);
+            } catch (Exception e) {}
+        } catch (SecurityException e) {
+            e.printStackTrace();
+            throw new Error("Failure: should not get an exception when " +
+                            "calling isFSSupported or setFSWindow");
+        }
+    }
+
+    public void run() {
+        boolean firstTime = true;
+        while (!done) {
+            if (visible) {
+                checkFSFunctionality(false);
+                checkFSFunctionality(true);
+                done = true;
+            } else {
+                // sleep while we wait
+                try {
+                    // Give the system time to set the FS window and display it
+                    // properly
+                    Thread.sleep(100);
+                } catch (Exception e) {}
+            }
+        }
+        System.out.println("PASS");
+    }
+
+    public static void main(String args[]) {
+        FSFrame frame = new FSFrame();
+        frame.setUndecorated(true);
+        Thread t = new Thread(frame);
+        frame.setSize(500, 500);
+        frame.setVisible(true);
+        t.start();
+        while (!done) {
+            try {
+                // Do not exit the main thread until the test is finished
+                Thread.sleep(1000);
+            } catch (Exception e) {}
+        }
+        frame.dispose();
+    }
+}
diff -Nru openjdk.orig/jdk/test/java/awt/image/MemoryLeakTest/MemoryLeakTest.java openjdk/jdk/test/java/awt/image/MemoryLeakTest/MemoryLeakTest.java
--- openjdk.orig/jdk/test/java/awt/image/MemoryLeakTest/MemoryLeakTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/java/awt/image/MemoryLeakTest/MemoryLeakTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,175 @@
+/*
+ * Copyright 1998-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/* @test
+   @bug 4078566 6658398
+   @summary Test for a memory leak in Image.
+   @run main/manual MemoryLeakTest
+*/
+
+import java.applet.Applet;
+import java.lang.*;
+import java.awt.*;
+import java.awt.event.*;
+
+class Globals {
+  static boolean testPassed=false;
+  static Thread mainThread=null;
+}
+
+public class MemoryLeakTest extends Applet {
+
+public static void main(String args[]) throws Exception {
+  new TestDialog(new Frame(), "MemoryLeakTest").start();
+  new MemoryLeak().start();
+  Globals.mainThread = Thread.currentThread();
+  try {
+    Thread.sleep(300000);
+  } catch (InterruptedException e) {
+    if (!Globals.testPassed)
+      throw new Exception("MemoryLeakTest failed.");
+  }
+}
+
+}
+
+class TestDialog extends Dialog
+    implements ActionListener {
+
+TextArea output;
+Button passButton;
+Button failButton;
+String name;
+
+public TestDialog(Frame frame, String name)
+{
+  super(frame, name + " Pass/Fail Dialog");
+  this.name = name;
+  output = new TextArea(11, 50);
+  add("North", output);
+  output.append("Do the following steps on Solaris only.\n");
+  output.append("Maximize and minimize the Memory Leak Test window.\n");
+  output.append("Execute the following after minimize.\n");
+  output.append("    ps -al | egrep -i 'java|PPID'\n");
+  output.append("Examine the size of the process under SZ.\n");
+  output.append("Maximize and minimize the Memory Leak Test window again.\n");
+  output.append("Execute the following after minimize.\n");
+  output.append("    ps -al | egrep -i 'java|PPID'\n");
+  output.append("Examine the size of the process under SZ.\n");
+  output.append("If the two SZ values are the same, plus or minus one,\n");
+  output.append("then click Pass, else click Fail.");
+  Panel buttonPanel = new Panel();
+  passButton = new Button("Pass");
+  failButton = new Button("Fail");
+  passButton.addActionListener(this);
+  failButton.addActionListener(this);
+  buttonPanel.add(passButton);
+  buttonPanel.add(failButton);
+  add("South", buttonPanel);
+  pack();
+}
+
+public void start()
+{
+  show();
+}
+
+public void actionPerformed(ActionEvent event)
+{
+    if ( event.getSource() == passButton ) {
+      Globals.testPassed = true;
+      System.err.println(name + " Passed.");
+    }
+    else if ( event.getSource() == failButton ) {
+      Globals.testPassed = false;
+      System.err.println(name + " Failed.");
+    }
+    this.dispose();
+    if (Globals.mainThread != null)
+      Globals.mainThread.interrupt();
+}
+
+}
+
+
+class MemoryLeak extends Frame implements ComponentListener
+{
+private Image osImage;
+
+public MemoryLeak()
+{
+    super("Memory Leak Test");
+    setSize(200, 200);
+    addComponentListener(this);
+}
+
+public static void main(String args[])
+{
+   new MemoryLeak().start();
+}
+
+public void start()
+{
+  show();
+}
+
+public void paint(Graphics g) {
+    if (osImage != null) {
+        g.drawImage(osImage, 0, 0, this);
+    }
+}
+
+public void update(Graphics g)
+{
+    paint(g);
+}
+
+public void componentResized(ComponentEvent e)
+{
+    Image oldimage = osImage;
+    osImage = createImage(getSize().width, getSize().height);
+    Graphics g = osImage.getGraphics();
+    if (oldimage != null) {
+        g.drawImage(oldimage, 0, 0, getSize().width, getSize().height, this);
+        oldimage.flush();
+    } else {
+        g.setColor(Color.blue);
+        g.drawLine(0, 0, getSize().width, getSize().height);
+    }
+    g.dispose();
+}
+
+public void componentMoved(ComponentEvent e) {}
+
+public void componentShown(ComponentEvent e)
+{
+    osImage = createImage(getSize().width, getSize().height);
+    Graphics g = osImage.getGraphics();
+    g.setColor(Color.blue);
+    g.drawLine(0, 0, getSize().width, getSize().height);
+    g.dispose();
+}
+
+public void componentHidden(ComponentEvent e) {}
+
+}
diff -Nru openjdk.orig/jdk/test/java/awt/Multiscreen/DeviceIdentificationTest/DeviceIdentificationTest.java openjdk/jdk/test/java/awt/Multiscreen/DeviceIdentificationTest/DeviceIdentificationTest.java
--- openjdk.orig/jdk/test/java/awt/Multiscreen/DeviceIdentificationTest/DeviceIdentificationTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/java/awt/Multiscreen/DeviceIdentificationTest/DeviceIdentificationTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,168 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/**
+ * @test
+ * @bug 6614214
+ * @summary Verifies that we enter the fs mode on the correct screen.
+ * Here is how to test: start the test on on a multi-screen system.
+ * Verify that the display is correctly tracked by dragging the frame back
+ * and forth between screens. Then verify that the correct device enters
+ * the full-screen mode - when "Enter FS mode" is pressed it should enter on
+ * the device where the frame is.
+ *
+ * Then change the order of the monitors in the DisplayProperties dialog,
+ * (while the app is running) and see that it still works.
+ * Restart the app, verify again.
+ *
+ * Now change the primary monitor on the system and verify with the
+ * app running, as well as after restarting it that we still enter the
+ * fs mode on the right device.
+ *
+ * @run main/manual/othervm DeviceIdentificationTest
+ * @run main/manual/othervm -Dsun.java2d.noddraw=true DeviceIdentificationTest
+ * @run main/manual/othervm -Dsun.java2d.opengl=True DeviceIdentificationTest
+ */
+
+import java.awt.Button;
+import java.awt.Color;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.Panel;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.ComponentAdapter;
+import java.awt.event.ComponentEvent;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+
+public class DeviceIdentificationTest {
+
+    public static void main(String args[]) {
+        final Frame f = new Frame("DeviceIdentificationTest");
+        f.addWindowListener(new WindowAdapter() {
+            public void windowClosing(WindowEvent e) {
+                f.dispose();
+            }
+        });
+        f.addComponentListener(new ComponentAdapter() {
+            public void componentMoved(ComponentEvent e) {
+                f.setTitle("Currently on: "+
+                           f.getGraphicsConfiguration().getDevice());
+            }
+        });
+
+        Panel p = new Panel();
+        Button b = new Button("Print Current Devices");
+        b.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                GraphicsDevice gds[] =
+                    GraphicsEnvironment.getLocalGraphicsEnvironment().
+                        getScreenDevices();
+                int i = 0;
+                System.err.println("--- Devices: ---");
+                for (GraphicsDevice gd : gds) {
+                    System.err.println("Device["+i+"]= "+ gd);
+                    System.err.println("  bounds = "+
+                        gd.getDefaultConfiguration().getBounds());
+                    i++;
+                }
+                System.err.println("-------------------");
+            }
+        });
+        p.add(b);
+
+        b = new Button("Print My Device");
+        b.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                GraphicsConfiguration gc = f.getGraphicsConfiguration();
+                GraphicsDevice gd = gc.getDevice();
+                System.err.println("--- My Device ---");
+                System.err.println("Device  = "+ gd);
+                System.err.println(" bounds = "+
+                        gd.getDefaultConfiguration().getBounds());
+            }
+        });
+        p.add(b);
+
+        b = new Button("Create FS Frame on my Device");
+        b.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                GraphicsConfiguration gc = f.getGraphicsConfiguration();
+                final GraphicsDevice gd = gc.getDevice();
+                System.err.println("--- Creating FS Frame on Device ---");
+                System.err.println("Device  = "+ gd);
+                System.err.println(" bounds = "+
+                        gd.getDefaultConfiguration().getBounds());
+                final Frame fsf = new Frame("Full-screen Frame on dev"+gd, gc) {
+                    public void paint(Graphics g) {
+                        g.setColor(Color.green);
+                        g.fillRect(0, 0, getWidth(), getHeight());
+                        g.setColor(Color.red);
+                        g.drawString("FS on device: "+gd, 200, 200);
+                        g.drawString("Click to exit Full-screen.", 200, 250);
+                    }
+                };
+                fsf.setUndecorated(true);
+                fsf.addMouseListener(new MouseAdapter() {
+                    public void mouseClicked(MouseEvent e) {
+                        gd.setFullScreenWindow(null);
+                        fsf.dispose();
+                    }
+                });
+                gd.setFullScreenWindow(fsf);
+            }
+        });
+        p.add(b);
+        f.add("North", p);
+
+        p = new Panel();
+        b = new Button("Test Passed");
+        b.setBackground(Color.green);
+        b.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                System.out.println("Test Passed");
+                f.dispose();
+            }
+        });
+        p.add(b);
+        b = new Button("Test Failed");
+        b.setBackground(Color.red);
+        b.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                System.out.println("Test FAILED");
+                f.dispose();
+                throw new RuntimeException("Test FAILED");
+            }
+        });
+        p.add(b);
+        f.add("South", p);
+
+        f.pack();
+        f.setVisible(true);
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/DirectX/AcceleratedScaleTest/AcceleratedScaleTest.java openjdk/jdk/test/sun/java2d/DirectX/AcceleratedScaleTest/AcceleratedScaleTest.java
--- openjdk.orig/jdk/test/sun/java2d/DirectX/AcceleratedScaleTest/AcceleratedScaleTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/DirectX/AcceleratedScaleTest/AcceleratedScaleTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.awt.Color;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsEnvironment;
+import java.awt.RenderingHints;
+import java.awt.Toolkit;
+import java.awt.image.BufferedImage;
+import java.awt.image.VolatileImage;
+import java.io.File;
+import java.io.IOException;
+import javax.imageio.ImageIO;
+
+/**
+ * @test
+ * @bug 6429665
+ * @bug 6588884
+ * @summary Tests that the transform is correctly handled
+ * @author Dmitri.Trembovetski area=Graphics
+ * @run main AcceleratedScaleTest
+ * @run main/othervm -Dsun.java2d.d3d=true AcceleratedScaleTest
+ * @run main/othervm -Dsun.java2d.opengl=true AcceleratedScaleTest
+ */
+public class AcceleratedScaleTest {
+    private static final int IMAGE_SIZE = 200;
+    private static VolatileImage destVI;
+
+    private static void initVI(GraphicsConfiguration gc) {
+        int res;
+        if (destVI == null) {
+            res = VolatileImage.IMAGE_INCOMPATIBLE;
+        } else {
+            res = destVI.validate(gc);
+        }
+        if (res == VolatileImage.IMAGE_INCOMPATIBLE) {
+            if (destVI != null) destVI.flush();
+            destVI = gc.createCompatibleVolatileImage(IMAGE_SIZE, IMAGE_SIZE);
+            destVI.validate(gc);
+            res = VolatileImage.IMAGE_RESTORED;
+        }
+        if (res == VolatileImage.IMAGE_RESTORED) {
+            Graphics vig = destVI.getGraphics();
+            vig.setColor(Color.red);
+            vig.fillRect(0, 0, destVI.getWidth(), destVI.getHeight());
+            vig.dispose();
+        }
+    }
+
+    public static void main(String[] args) {
+        Frame f = new Frame();
+        f.pack();
+        GraphicsConfiguration gc = f.getGraphicsConfiguration();
+        if (gc.getColorModel().getPixelSize() < 16) {
+            System.out.printf("Bit depth: %d . Test considered passed.",
+                              gc.getColorModel().getPixelSize());
+            f.dispose();
+            return;
+        }
+
+        BufferedImage bi =
+            new BufferedImage(IMAGE_SIZE/4, IMAGE_SIZE/4,
+                              BufferedImage.TYPE_INT_RGB);
+        Graphics2D g = (Graphics2D)bi.getGraphics();
+        g.setColor(Color.red);
+        g.fillRect(0, 0, bi.getWidth(), bi.getHeight());
+        BufferedImage snapshot;
+        do {
+            initVI(gc);
+            g = (Graphics2D)destVI.getGraphics();
+            // "accelerate" BufferedImage
+            for (int i = 0; i < 5; i++) {
+                g.drawImage(bi, 0, 0, null);
+            }
+            g.setColor(Color.white);
+            g.fillRect(0, 0, destVI.getWidth(), destVI.getHeight());
+
+            // this will force the use of Transform primitive instead of
+            // Scale (the latter doesn't do bilinear filtering required by
+            // VALUE_RENDER_QUALITY, which triggers the bug in D3D pipeline
+            g.setRenderingHint(RenderingHints.KEY_RENDERING,
+                               RenderingHints.VALUE_RENDER_QUALITY);
+            g.drawImage(bi, 0, 0, destVI.getWidth(), destVI.getHeight(), null);
+            g.fillRect(0, 0, destVI.getWidth(), destVI.getHeight());
+
+            g.drawImage(bi, 0, 0, destVI.getWidth(), destVI.getHeight(), null);
+
+            snapshot = destVI.getSnapshot();
+        } while (destVI.contentsLost());
+
+        f.dispose();
+        int whitePixel = Color.white.getRGB();
+        for (int y = 0; y < snapshot.getHeight(); y++) {
+            for (int x = 0; x < snapshot.getWidth(); x++) {
+                if (snapshot.getRGB(x, y) == whitePixel) {
+                    System.out.printf("Found untouched pixel at %dx%d\n", x, y);
+                    System.out.println("Dumping the dest. image to " +
+                                       "AcceleratedScaleTest_dst.png");
+                    try {
+                        ImageIO.write(snapshot, "png",
+                                      new File("AcceleratedScaleTest_dst.png"));
+                    } catch (IOException ex) {
+                        ex.printStackTrace();
+                    }
+                    throw new RuntimeException("Test failed.");
+                }
+            }
+        }
+        System.out.println("Test Passed.");
+    }
+
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/DirectX/AccelPaintsTest/AccelPaintsTest.java openjdk/jdk/test/sun/java2d/DirectX/AccelPaintsTest/AccelPaintsTest.java
--- openjdk.orig/jdk/test/sun/java2d/DirectX/AccelPaintsTest/AccelPaintsTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/DirectX/AccelPaintsTest/AccelPaintsTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,180 @@
+/*
+ * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 6659345
+ * @summary Tests that various paints work correctly when preceeded by a
+ * textured operaiton.
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @run main/othervm AccelPaintsTest
+ * @run main/othervm -Dsun.java2d.opengl=True AccelPaintsTest
+ */
+
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.EventQueue;
+import java.awt.GradientPaint;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsEnvironment;
+import java.awt.LinearGradientPaint;
+import java.awt.MultipleGradientPaint.CycleMethod;
+import java.awt.Paint;
+import java.awt.RadialGradientPaint;
+import java.awt.Rectangle;
+import java.awt.Shape;
+import java.awt.TexturePaint;
+import java.awt.Transparency;
+import java.awt.geom.Rectangle2D;
+import java.awt.image.BufferedImage;
+import java.awt.image.VolatileImage;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import javax.imageio.ImageIO;
+import javax.swing.JFrame;
+import javax.swing.JPanel;
+
+public class AccelPaintsTest extends JPanel {
+    BufferedImage bi =
+        new BufferedImage(80, 100, BufferedImage.TYPE_INT_ARGB_PRE);
+
+    RadialGradientPaint rgp =
+        new RadialGradientPaint(100, 100, 100, new float[] {0f, 0.2f, 0.6f, 1f},
+            new Color[] { Color.red,
+                          Color.yellow,
+                          Color.blue,
+                          Color.green},
+            CycleMethod.REFLECT);
+    LinearGradientPaint lgp =
+            new LinearGradientPaint(30, 30, 120, 130, new float[] {0f, 0.2f, 0.6f, 1f},
+            new Color[] {Color.red,
+                         Color.yellow,
+                         Color.blue,
+                         Color.green});
+    GradientPaint gp =
+            new GradientPaint(30, 30, Color.red, 120, 130, Color.yellow, true);
+
+    TexturePaint tp =
+            new TexturePaint(bi, new Rectangle2D.Float(30, 30, 120, 130));
+
+
+    public AccelPaintsTest() {
+        Graphics g = bi.getGraphics();
+        g.setColor(Color.blue);
+        g.fillRect(0, 0, bi.getWidth(), bi.getHeight());
+
+        setPreferredSize(new Dimension(250, 4*120));
+    }
+
+    private void renderWithPaint(Graphics2D g2d, Paint p) {
+        g2d.drawImage(bi, 130, 30, null);
+
+        g2d.setPaint(p);
+        g2d.fillRect(30, 30, 80, 100);
+    }
+
+    private void render(Graphics2D g2d) {
+        renderWithPaint(g2d, rgp);
+        g2d.translate(0, 100);
+
+        renderWithPaint(g2d, lgp);
+        g2d.translate(0, 100);
+
+        renderWithPaint(g2d, gp);
+        g2d.translate(0, 100);
+
+        renderWithPaint(g2d, tp);
+        g2d.translate(0, 100);
+    }
+
+    private void test() {
+        GraphicsConfiguration gc =
+            GraphicsEnvironment.getLocalGraphicsEnvironment().
+                getDefaultScreenDevice().getDefaultConfiguration();
+        if (gc.getColorModel().getPixelSize() < 16) {
+            System.out.println("<16 bit depth detected, test passed");
+            return;
+        }
+
+        VolatileImage vi =
+            gc.createCompatibleVolatileImage(250, 4*120, Transparency.OPAQUE);
+        BufferedImage res;
+        do {
+            vi.validate(gc);
+            Graphics2D g2d = vi.createGraphics();
+            g2d.setColor(Color.white);
+            g2d.fillRect(0, 0, vi.getWidth(), vi.getHeight());
+
+            render(g2d);
+
+            res = vi.getSnapshot();
+        } while (vi.contentsLost());
+
+        for (int y = 0; y < bi.getHeight(); y++) {
+            for (int x = 0; x < bi.getWidth(); x++) {
+                if (res.getRGB(x, y) == Color.black.getRGB()) {
+                    System.err.printf("Test FAILED: found black at %d,%d\n",
+                                      x, y);
+                    try {
+                        String fileName = "AccelPaintsTest.png";
+                        ImageIO.write(res, "png", new File(fileName));
+                        System.err.println("Dumped rendering to " + fileName);
+                    } catch (IOException e) {}
+                    throw new RuntimeException("Test FAILED: found black");
+                }
+            }
+        }
+    }
+
+    protected void paintComponent(Graphics g) {
+        super.paintComponent(g);
+        Graphics2D g2d = (Graphics2D)g;
+
+        render(g2d);
+    }
+
+    public static void main(String[] args)
+        throws InterruptedException, InvocationTargetException
+    {
+
+        if (args.length > 0 && args[0].equals("-show")) {
+            EventQueue.invokeAndWait(new Runnable() {
+                public void run() {
+                    JFrame f = new JFrame("RadialGradientTest");
+                    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+                    AccelPaintsTest t = new AccelPaintsTest();
+                    f.add(t);
+                    f.pack();
+                    f.setVisible(true);
+                }
+            });
+        } else {
+            AccelPaintsTest t = new AccelPaintsTest();
+            t.test();
+            System.out.println("Test Passed.");
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/DirectX/IAEforEmptyFrameTest/IAEforEmptyFrameTest.java openjdk/jdk/test/sun/java2d/DirectX/IAEforEmptyFrameTest/IAEforEmptyFrameTest.java
--- openjdk.orig/jdk/test/sun/java2d/DirectX/IAEforEmptyFrameTest/IAEforEmptyFrameTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/DirectX/IAEforEmptyFrameTest/IAEforEmptyFrameTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6668439
+ * @summary Verifies that no exceptions are thrown when frame is resized to 0x0
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @run main/othervm IAEforEmptyFrameTest
+ * @run main/othervm -Dsun.java2d.d3d=false IAEforEmptyFrameTest
+ */
+import javax.swing.JFrame;
+
+public class IAEforEmptyFrameTest {
+    public static void main(String[] args) {
+        JFrame f = null;
+        try {
+            f = new JFrame("IAEforEmptyFrameTest");
+            f.setUndecorated(true);
+            f.setBounds(100, 100, 320, 240);
+            f.setVisible(true);
+            try { Thread.sleep(1000); } catch (Exception z) {}
+            f.setBounds(0, 0, 0, 0);
+            try { Thread.sleep(1000); } catch (Exception z) {}
+            f.dispose();
+        } finally {
+            f.dispose();
+        };
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/DirectX/InfiniteValidationLoopTest/InfiniteValidationLoopTest.java openjdk/jdk/test/sun/java2d/DirectX/InfiniteValidationLoopTest/InfiniteValidationLoopTest.java
--- openjdk.orig/jdk/test/sun/java2d/DirectX/InfiniteValidationLoopTest/InfiniteValidationLoopTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/DirectX/InfiniteValidationLoopTest/InfiniteValidationLoopTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6648018
+ * @summary Tests that we don't run into infinite validation loop when copying
+            a VolatileImage to the screen
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @run main/othervm InfiniteValidationLoopTest
+ * @run main/othervm -Dsun.java2d.d3d=false InfiniteValidationLoopTest
+ */
+import java.awt.Color;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.GraphicsConfiguration;
+import static java.awt.image.VolatileImage.*;
+import java.awt.image.VolatileImage;
+import java.util.concurrent.CountDownLatch;
+
+public class InfiniteValidationLoopTest extends Frame {
+    private static volatile boolean failed = false;
+    private static final int LOOP_THRESHOLD = 50;
+    private static volatile CountDownLatch latch;
+    private VolatileImage vi;
+
+    public InfiniteValidationLoopTest() {
+        super("InfiniteValidationLoopTest");
+    }
+
+    @Override
+    public void paint(Graphics g) {
+        try {
+            runTest(g);
+        } finally {
+            latch.countDown();
+        }
+    }
+
+    private void runTest(Graphics g) {
+        int status = IMAGE_OK;
+        int count1 = 0;
+        do {
+            GraphicsConfiguration gc = getGraphicsConfiguration();
+            int count2 = 0;
+            while (vi == null || (status = vi.validate(gc)) != IMAGE_OK) {
+                if (++count2 > LOOP_THRESHOLD) {
+                    System.err.println("Infinite loop detected: count2="+count2);
+                    failed = true;
+                    return;
+                }
+                if (vi == null || status == IMAGE_INCOMPATIBLE) {
+                    if (vi != null) { vi.flush(); vi = null; }
+                    vi = gc.createCompatibleVolatileImage(100, 100);
+                    continue;
+                }
+                if (status == IMAGE_RESTORED) {
+                    Graphics gg = vi.getGraphics();
+                    gg.setColor(Color.green);
+                    gg.fillRect(0, 0, vi.getWidth(), vi.getHeight());
+                    break;
+                }
+            }
+            g.drawImage(vi, getInsets().left, getInsets().top, null);
+            if (++count1 > LOOP_THRESHOLD) {
+                System.err.println("Infinite loop detected: count1="+count1);
+                failed = true;
+                return;
+            }
+        } while (vi.contentsLost());
+    }
+
+    public static void main(String[] args) {
+        latch = new CountDownLatch(1);
+        InfiniteValidationLoopTest t1 = new InfiniteValidationLoopTest();
+        t1.pack();
+        t1.setSize(200, 200);
+        t1.setVisible(true);
+        try { latch.await(); } catch (InterruptedException ex) {}
+        t1.dispose();
+
+        latch = new CountDownLatch(1);
+        t1 = new InfiniteValidationLoopTest();
+        t1.pack();
+        t1.setSize(50, 50);
+        t1.setVisible(true);
+        try { latch.await(); } catch (InterruptedException ex) {}
+        t1.dispose();
+
+        if (failed) {
+            throw new
+                RuntimeException("Failed: infinite validattion loop detected");
+        }
+        System.out.println("Test PASSED");
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/DirectX/OnScreenRenderingResizeTest/OnScreenRenderingResizeTest.java openjdk/jdk/test/sun/java2d/DirectX/OnScreenRenderingResizeTest/OnScreenRenderingResizeTest.java
--- openjdk.orig/jdk/test/sun/java2d/DirectX/OnScreenRenderingResizeTest/OnScreenRenderingResizeTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/DirectX/OnScreenRenderingResizeTest/OnScreenRenderingResizeTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/*
+ * @test
+ * @bug 6664068 6666931
+ * @summary Tests that resizing a window to which a tight loop is rendering
+ * doesn't produce artifacts or crashes
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @run main/othervm OnScreenRenderingResizeTest
+ * @run main/othervm -Dsun.java2d.d3d=false OnScreenRenderingResizeTest
+ */
+
+import java.awt.AWTException;
+import java.awt.Color;
+import java.awt.EventQueue;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.Insets;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.Robot;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.image.BufferedImage;
+import java.awt.image.VolatileImage;
+import java.io.File;
+import java.io.IOException;
+import javax.imageio.ImageIO;
+
+public class OnScreenRenderingResizeTest {
+
+    private static volatile boolean done = false;
+    private static volatile boolean nocheck = false;
+
+    private static final int FRAME_W = 256;
+    private static final int FRAME_H = 256;
+    private static final int IMAGE_W = 128;
+    private static final int IMAGE_H = 128;
+    private static long RUN_TIME = 1000*20;
+
+    private static final Color renderColor = Color.green;
+    private static final Color bgColor = Color.white;
+
+    public static void main(String[] args) {
+
+        for (String arg : args) {
+            if ("-inf".equals(arg)) {
+                System.err.println("Test will run indefinitely");
+                RUN_TIME = Long.MAX_VALUE;
+            } else  if ("-nocheck".equals(arg)) {
+                System.err.println("Test will not check rendering results");
+                nocheck = true;
+            } else {
+                System.err.println("Usage: OnScreenRenderingResizeTest [-inf][-nocheck]");
+            }
+        }
+
+        BufferedImage output =
+            new BufferedImage(IMAGE_W, IMAGE_H, BufferedImage.TYPE_INT_RGB);
+        output.setAccelerationPriority(0.0f);
+        Graphics g = output.getGraphics();
+        g.setColor(renderColor);
+        g.fillRect(0, 0, output.getWidth(), output.getHeight());
+
+        final Frame frame = new Frame("OnScreenRenderingResizeTest") {
+            public void paint(Graphics g) {}
+            public void update(Graphics g) {}
+        };
+        frame.setBackground(bgColor);
+        frame.pack();
+        frame.setSize(FRAME_W, FRAME_H);
+        frame.addWindowListener(new WindowAdapter() {
+            public void windowClosing(WindowEvent e) {
+                done = true;
+            }
+        });
+        try {
+            EventQueue.invokeAndWait(new Runnable() {
+                public void run() {
+                    frame.setVisible(true);
+                }
+            });
+            // wait for Vista's effects to complete
+            Thread.sleep(2000);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+
+        GraphicsConfiguration gc = frame.getGraphicsConfiguration();
+        int maxW = gc.getBounds().width /2;
+        int maxH = gc.getBounds().height/2;
+        int minW = frame.getWidth();
+        int minH = frame.getHeight();
+        int incW = 10, incH = 10, cnt = 0;
+        Robot robot = null;
+        if (!nocheck && gc.getColorModel().getPixelSize() > 8) {
+            try {
+                robot = new Robot();
+            } catch (AWTException ex) {
+                System.err.println("Robot creation failed, continuing.");
+            }
+        } else {
+            System.err.println("No screen rendering checks.");
+        }
+
+        VolatileImage vi = gc.createCompatibleVolatileImage(512, 512);
+        vi.validate(gc);
+
+        long timeStarted = System.currentTimeMillis();
+        while (!done && (System.currentTimeMillis() - timeStarted) < RUN_TIME) {
+
+            if (++cnt > 100) {
+                int w = frame.getWidth() + incW;
+                int h = frame.getHeight() + incH;
+                if (w < minW || w > maxW ) {
+                    incW = -incW;
+                }
+                if (h < minH || h > maxH ) {
+                    incH = -incH;
+                }
+                frame.setSize(w, h);
+                cnt = 0;
+            }
+
+            // try to put the device into non-default state, for example,
+            // this operation below will set the transform
+            vi.validate(gc);
+            Graphics2D vig = (Graphics2D)vi.getGraphics();
+            vig.rotate(30.0f, vi.getWidth()/2, vi.getHeight()/2);
+            vig.drawImage(output, 0, 0,
+                          vi.getWidth(), vi.getHeight(), null);
+
+            Insets in = frame.getInsets();
+            frame.getGraphics().drawImage(output, in.left, in.top, null);
+            if (cnt == 90 && robot != null) {
+                // area where we blitted to should be either white or green
+                Point p = frame.getLocationOnScreen();
+                p.move(in.left+10, in.top+10);
+                BufferedImage bi =
+                    robot.createScreenCapture(
+                        new Rectangle(p.x, p.y, IMAGE_W/2, IMAGE_H/2));
+                int accepted1[] = { Color.white.getRGB(), Color.green.getRGB()};
+                checkBI(bi, accepted1);
+
+                // the are where we didn't render should stay white
+                p = frame.getLocationOnScreen();
+                p.move(in.left, in.top+IMAGE_H+5);
+                bi = robot.createScreenCapture(
+                    new Rectangle(p.x, p.y,
+                                  frame.getWidth()-in.left-in.right,
+                                  frame.getHeight()-in.top-in.bottom-5-IMAGE_H));
+                int accepted2[] = { Color.white.getRGB() };
+                checkBI(bi, accepted1);
+            }
+
+            Thread.yield();
+        }
+        frame.dispose();
+        System.out.println("Test Passed");
+    }
+
+    private static void checkBI(BufferedImage bi, int accepted[]) {
+        for (int x = 0; x < bi.getWidth(); x++) {
+            for (int y = 0; y < bi.getHeight(); y++) {
+                int pix = bi.getRGB(x, y);
+                boolean found = false;
+                for (int acc : accepted) {
+                    if (pix == acc) {
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found) {
+                    try {
+                        String name = "OnScreenRenderingResizeTest.png";
+                        ImageIO.write(bi, "png", new File(name));
+                        System.out.println("Screen shot file: " + name);
+                    } catch (IOException ex) {}
+
+                    throw new
+                        RuntimeException("Test failed at " + x + "-" + y +
+                                         " rgb=0x" + Integer.toHexString(pix));
+                }
+            }
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/DirectX/OverriddenInsetsTest/OverriddenInsetsTest.java openjdk/jdk/test/sun/java2d/DirectX/OverriddenInsetsTest/OverriddenInsetsTest.java
--- openjdk.orig/jdk/test/sun/java2d/DirectX/OverriddenInsetsTest/OverriddenInsetsTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/DirectX/OverriddenInsetsTest/OverriddenInsetsTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,150 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6694230
+ * @summary Tests that components overriding getInsets paint correctly
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @run main/othervm OverriddenInsetsTest
+ * @run main/othervm -Dsun.java2d.opengl=True OverriddenInsetsTest
+ */
+
+import java.awt.Color;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.GraphicsEnvironment;
+import java.awt.Insets;
+import java.awt.Panel;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.Robot;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import javax.imageio.ImageIO;
+
+public class OverriddenInsetsTest {
+
+    public static final Insets INSETS1 = new Insets(25,25,0,0);
+    public static final Insets INSETS2 = new Insets(100,100,0,0);
+    static final CountDownLatch lock = new CountDownLatch(1);
+    static boolean failed = false;
+
+    public static void main(String[] args) {
+
+        if (GraphicsEnvironment.getLocalGraphicsEnvironment().
+                getDefaultScreenDevice().getDefaultConfiguration().
+                    getColorModel().getPixelSize() < 16)
+        {
+            System.out.println("<16 bit mode detected, test passed");
+        }
+
+        final Frame f = new Frame("OverriddenInsetsTest");
+        f.setSize(260,260);
+
+        f.addWindowListener(new WindowAdapter() {
+            public void windowClosing(WindowEvent e) {
+                f.setVisible(false);
+                System.exit(0);
+            }
+        });
+
+        f.setBackground(Color.gray);
+        Panel p1 = new Panel() {
+            public Insets getInsets() {
+                return INSETS1;
+            }
+        };
+        p1.setLayout(null);
+        p1.setSize(250, 250);
+
+        Panel p = new Panel(){
+            @Override
+            public Insets getInsets() {
+                return INSETS2;
+            }
+
+            public void paint(Graphics g) {
+                // make sure Vista is done with its effects
+                try {
+                    Thread.sleep(2000);
+                } catch (InterruptedException ex) {}
+                g.setColor(Color.red);
+                g.drawRect(0,0,getWidth()-1,getHeight()-1 );
+                g.setColor(Color.blue);
+                g.fillRect(0,0,getWidth()/2,getHeight()/2);
+
+                Point p = getLocationOnScreen();
+                try {
+                    Robot r = new Robot();
+                    BufferedImage bi =
+                        r.createScreenCapture(new
+                            Rectangle(p.x, p.y, getWidth()/2, getHeight()/2));
+                    for (int y = 0; y < bi.getHeight(); y++) {
+                        for (int x = 0; x < bi.getWidth(); x++) {
+                            if (bi.getRGB(x, y) != Color.blue.getRGB()) {
+                                failed = true;
+                                System.err.printf("Test failed at %d %d c=%x\n",
+                                                  x, y, bi.getRGB(x, y));
+                                String name = "OverriddenInsetsTest_res.png";
+                                try {
+                                    ImageIO.write(bi, "png", new File(name));
+                                    System.out.println("Dumped res to: "+name);
+                                } catch (IOException e) {}
+                                return;
+                            }
+                        }
+                    }
+                } catch (Exception e) {
+                    failed = true;
+                } finally {
+                    lock.countDown();
+                }
+            }
+        };
+        p.setSize(200, 200);
+
+        p1.add(p);
+        p.setLocation(50, 50);
+        f.add(p1);
+        f.setVisible(true);
+
+        try {
+            lock.await();
+        } catch (InterruptedException ex) {
+            ex.printStackTrace();
+        }
+        if (args.length <= 0 || !"-show".equals(args[0])) {
+            f.dispose();
+        }
+
+        if (failed) {
+            throw new RuntimeException("Test FAILED.");
+        }
+        System.out.println("Test PASSED");
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/DirectX/RenderingToCachedGraphicsTest/RenderingToCachedGraphicsTest.java openjdk/jdk/test/sun/java2d/DirectX/RenderingToCachedGraphicsTest/RenderingToCachedGraphicsTest.java
--- openjdk.orig/jdk/test/sun/java2d/DirectX/RenderingToCachedGraphicsTest/RenderingToCachedGraphicsTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/DirectX/RenderingToCachedGraphicsTest/RenderingToCachedGraphicsTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,174 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6648018 6652662
+ * @summary Verifies that rendering to a cached onscreen Graphics works
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @run main/othervm RenderingToCachedGraphicsTest
+ * @run main/othervm -Dsun.java2d.d3d=false RenderingToCachedGraphicsTest
+ */
+import java.awt.Canvas;
+import java.awt.Color;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.GraphicsEnvironment;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.Robot;
+import java.awt.Toolkit;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.image.BufferStrategy;
+import java.awt.image.BufferedImage;
+import static java.awt.image.VolatileImage.*;
+import java.awt.image.VolatileImage;
+import java.io.File;
+import java.util.concurrent.CountDownLatch;
+import javax.imageio.ImageIO;
+
+public class RenderingToCachedGraphicsTest extends Frame {
+    private static volatile boolean failed = false;
+    private static volatile CountDownLatch latch;
+    private Graphics cachedGraphics;
+    private Canvas renderCanvas;
+
+    public RenderingToCachedGraphicsTest() {
+        super("Test starts in 2 seconds");
+        renderCanvas = new Canvas() {
+            @Override
+            public void paint(Graphics g) {
+                if (getWidth() < 100 || getHeight() < 100) {
+                    repaint();
+                    return;
+                }
+                // wait for a bit so that Vista's Window manager's animation
+                // effects on window's appearance are completed (6652662)
+                try { Thread.sleep(2000); } catch (InterruptedException ex) {}
+
+                try {
+                    runTest();
+                } catch (Throwable t) {
+                    failed = true;
+                } finally {
+                    latch.countDown();
+                }
+            }
+            @Override
+            public void update(Graphics g) {}
+        };
+
+        add("Center", renderCanvas);
+    }
+
+    private void runTest() {
+        // this will cause screen update manager to dump the accelerated surface
+        // for this canvas
+        renderCanvas.createBufferStrategy(2);
+        BufferStrategy bs = renderCanvas.getBufferStrategy();
+        do {
+            Graphics bsg = bs.getDrawGraphics();
+            bsg.setColor(Color.blue);
+            bsg.fillRect(0, 0,
+                         renderCanvas.getWidth(), renderCanvas.getHeight());
+        } while (bs.contentsLost() || bs.contentsRestored());
+
+        // grab the "unaccelerated" onscreen surface
+        cachedGraphics = renderCanvas.getGraphics();
+        cachedGraphics.setColor(Color.red);
+        cachedGraphics.fillRect(0, 0, getWidth(), getHeight());
+
+        bs.dispose();
+        bs = null;
+        // now the update manager should be able to accelerate onscreen
+        // rendering to it again
+
+        cachedGraphics.setColor(Color.green);
+        // this causes restoration  of the new accelerated onscreen surface
+        // (it is created in "lost" state)
+        cachedGraphics.fillRect(0, 0,
+                                renderCanvas.getWidth(),
+                                renderCanvas.getHeight());
+        Toolkit.getDefaultToolkit().sync();
+        // and now we should be able to render to it
+        cachedGraphics.fillRect(0, 0,
+                                renderCanvas.getWidth(),
+                                renderCanvas.getHeight());
+        Toolkit.getDefaultToolkit().sync();
+
+        Robot robot = null;
+        try {
+            robot = new Robot();
+        } catch (Exception e) {
+            e.printStackTrace();
+            failed = true;
+            return;
+        }
+
+        Point p = renderCanvas.getLocationOnScreen();
+        Rectangle r = new Rectangle(p.x, p.y,
+                                    renderCanvas.getWidth(),
+                                    renderCanvas.getHeight());
+        BufferedImage bi = robot.createScreenCapture(r);
+        for (int y = 0; y < bi.getHeight(); y++) {
+            for (int x = 0; x < bi.getWidth(); x++) {
+                if (bi.getRGB(x, y) != Color.green.getRGB()) {
+                    System.err.println("Colors mismatch!");
+                    String name = "RenderingToCachedGraphicsTest.png";
+                    try {
+                        ImageIO.write(bi, "png", new File(name));
+                        System.err.println("Dumped grabbed image to: "+name);
+                    } catch (Exception e) {}
+                    failed = true;
+                    return;
+                }
+            }
+        }
+    }
+
+    public static void main(String[] args) {
+        int depth = GraphicsEnvironment.getLocalGraphicsEnvironment().
+            getDefaultScreenDevice().getDefaultConfiguration().
+                getColorModel().getPixelSize();
+        if (depth < 16) {
+            System.out.println("Test PASSED (depth < 16bit)");
+            return;
+        }
+
+        latch = new CountDownLatch(1);
+        RenderingToCachedGraphicsTest t1 = new RenderingToCachedGraphicsTest();
+        t1.pack();
+        t1.setSize(300, 300);
+        t1.setVisible(true);
+
+        try { latch.await(); } catch (InterruptedException ex) {}
+        t1.dispose();
+
+        if (failed) {
+            throw new
+                RuntimeException("Failed: rendering didn't show up");
+        }
+        System.out.println("Test PASSED");
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/DirectX/StrikeDisposalCrashTest/StrikeDisposalCrashTest.java openjdk/jdk/test/sun/java2d/DirectX/StrikeDisposalCrashTest/StrikeDisposalCrashTest.java
--- openjdk.orig/jdk/test/sun/java2d/DirectX/StrikeDisposalCrashTest/StrikeDisposalCrashTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/DirectX/StrikeDisposalCrashTest/StrikeDisposalCrashTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/**
+ * @test
+ * @bug 6705443
+ * @summary tests that we don't crash during exit if font strikes were disposed
+ * during the lifetime of the application
+ *
+ * @run main/othervm -Dsun.java2d.font.reftype=weak StrikeDisposalCrashTest
+ * @run main/othervm -Dsun.java2d.font.reftype=weak -Dsun.java2d.noddraw=true StrikeDisposalCrashTest
+ * @run main/othervm -Dsun.java2d.font.reftype=weak -Dsun.java2d.opengl=True StrikeDisposalCrashTest
+ */
+
+import java.awt.Font;
+import java.awt.Frame;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.RenderingHints;
+import java.awt.Toolkit;
+import java.awt.image.VolatileImage;
+
+public class StrikeDisposalCrashTest {
+
+    public static void main(String[] args) {
+        System.setProperty("sun.java2d.font.reftype", "weak");
+
+        GraphicsDevice gd[] =
+            GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();
+
+        Frame frames[] = new Frame[gd.length];
+        for (int i = 0; i < frames.length; i++) {
+            GraphicsConfiguration gc = gd[i].getDefaultConfiguration();
+            Frame f = new Frame("Frame on "+gc, gc);
+            f.setSize(100, 100);
+            f.setLocation(gc.getBounds().x, gc.getBounds().y);
+            f.pack();
+            frames[i] = f;
+        }
+
+        Font f1 = new Font("Dialog", Font.PLAIN, 10);
+        Font f2 = new Font("Dialog", Font.ITALIC, 12);
+
+        for (int i = 0; i < frames.length/2; i++) {
+            // making sure the glyphs are cached in the accel. cache on
+            // one frame, then the other
+            renderText(frames[i], f1);
+            renderText(frames[frames.length -1 - i], f1);
+
+            // and now the other way around, with different glyphs
+            renderText(frames[frames.length -1 - i], f2);
+            renderText(frames[i], f2);
+        }
+
+        // try to force strike disposal (note that we have to use
+        // -Dsun.java2d.font.reftype=weak to facilitate the disposal)
+
+        System.gc();
+        System.runFinalization();
+        System.gc();
+        System.runFinalization();
+
+        for (Frame f : frames) {
+            f.dispose();
+        }
+
+        System.err.println("Exiting. If the test crashed after this it FAILED");
+    }
+
+    private static final String text =
+        "The quick brown fox jumps over the lazy dog 1234567890";
+    private static void renderText(Frame frame, Font f1) {
+        VolatileImage vi = frame.createVolatileImage(256, 32);
+        vi.validate(frame.getGraphicsConfiguration());
+
+        Graphics2D g = vi.createGraphics();
+        g.setFont(f1);
+        g.drawString(text, 0, vi.getHeight()/2);
+        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
+                           RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
+        g.drawString(text, 0, vi.getHeight()/2);
+        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
+                           RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);
+        g.drawString(text, 0, vi.getHeight()/2);
+        Toolkit.getDefaultToolkit().sync();
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/DirectX/SwingOnScreenScrollingTest/SwingOnScreenScrollingTest.java openjdk/jdk/test/sun/java2d/DirectX/SwingOnScreenScrollingTest/SwingOnScreenScrollingTest.java
--- openjdk.orig/jdk/test/sun/java2d/DirectX/SwingOnScreenScrollingTest/SwingOnScreenScrollingTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/DirectX/SwingOnScreenScrollingTest/SwingOnScreenScrollingTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/*
+ * @test
+ * @bug 6630702
+ * @summary Tests that scrolling after paint() is performed correctly.
+ *          This is really only applicable to Vista
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @run main/othervm SwingOnScreenScrollingTest
+ * run main/othervm -Dsun.java2d.opengl=True SwingOnScreenScrollingTest
+ */
+
+import java.awt.AWTException;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.EventQueue;
+import java.awt.Graphics;
+import java.awt.GraphicsEnvironment;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.Robot;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.lang.reflect.InvocationTargetException;
+import javax.imageio.ImageIO;
+import javax.swing.JFrame;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+
+public class SwingOnScreenScrollingTest extends JPanel {
+
+    static JScrollPane pane;
+    static SwingOnScreenScrollingTest test;
+
+    public SwingOnScreenScrollingTest() {
+    }
+
+    public static void main(String[] args) {
+        int size = GraphicsEnvironment.
+            getLocalGraphicsEnvironment().
+                getDefaultScreenDevice().
+                    getDefaultConfiguration().getColorModel().getPixelSize();
+        if (size < 16) {
+            System.err.println("<16 bit display mode detected. Test PASSED");
+            return;
+        }
+
+        final JFrame f = new JFrame("SwingOnScreenScrollingTest");
+        try {
+            EventQueue.invokeAndWait(new Runnable() {
+                public void run() {
+                    test = new SwingOnScreenScrollingTest();
+                    pane = new JScrollPane(test);
+                    f.add(pane);
+                    f.pack();
+                    f.setSize(100, 200);
+                    f.setVisible(true);
+                }
+            });
+        } catch (InvocationTargetException ex) {
+            ex.printStackTrace();
+        } catch (InterruptedException ex) {
+            ex.printStackTrace();
+        }
+        try {
+            Thread.sleep(500);
+        } catch (InterruptedException ex) {
+            ex.printStackTrace();
+        }
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                BufferedImage bi;
+                bi = new BufferedImage(100, 300,
+                                       BufferedImage.TYPE_INT_RGB);
+                Graphics gg = bi.getGraphics();
+                test.paint(gg);
+                for (int y = 80; y < 200; y +=10) {
+                    test.scrollRectToVisible(new Rectangle(0, y, 100, 100));
+                    try {
+                        Thread.sleep(200);
+                    } catch (InterruptedException ex) {
+                        ex.printStackTrace();
+                    }
+                }
+                Point p = pane.getViewport().getLocationOnScreen();
+                Robot r = null;
+                try {
+                    r = new Robot();
+                } catch (AWTException ex) {
+                    throw new RuntimeException(ex);
+                }
+                bi = r.createScreenCapture(new Rectangle(p.x+5, p.y+5, 30, 30));
+                for (int y = 0; y < bi.getHeight(); y++) {
+                    for (int x = 0; x < bi.getHeight(); x++) {
+                        int rgb = bi.getRGB(x, y);
+                        if (bi.getRGB(x, y) != Color.red.getRGB()) {
+                            System.err.printf("Test Failed at (%d,%d) c=0x%x\n",
+                                              x, y, rgb);
+                            try {
+                                String name =
+                                    "SwingOnScreenScrollingTest_out.png";
+                                ImageIO.write(bi, "png", new File(name));
+                                System.err.println("Wrote grabbed image to "+
+                                                   name);
+                            } catch (Throwable ex) {}
+                            throw new RuntimeException("Test failed");
+                        }
+                    }
+                }
+                System.out.println("Test PASSED.");
+                f.dispose();
+            }
+        });
+    }
+
+    protected void paintComponent(Graphics g) {
+        g.setColor(Color.green);
+        g.fillRect(0, 0, getWidth(), 100);
+        g.setColor(Color.red);
+        g.fillRect(0, 100, getWidth(), getHeight()-100);
+    }
+
+    public Dimension getPreferredSize() {
+        return new Dimension(100, 300);
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/DirectX/TransformedPaintTest/TransformedPaintTest.java openjdk/jdk/test/sun/java2d/DirectX/TransformedPaintTest/TransformedPaintTest.java
--- openjdk.orig/jdk/test/sun/java2d/DirectX/TransformedPaintTest/TransformedPaintTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/DirectX/TransformedPaintTest/TransformedPaintTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,219 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6689025
+ * @summary Tests that transformed Paints are rendered correctly
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @run main/othervm TransformedPaintTest
+ * @run main/othervm -Dsun.java2d.opengl=True TransformedPaintTest
+ */
+
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.EventQueue;
+import java.awt.GradientPaint;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsEnvironment;
+import java.awt.LinearGradientPaint;
+import java.awt.MultipleGradientPaint.CycleMethod;
+import java.awt.Paint;
+import java.awt.RadialGradientPaint;
+import java.awt.TexturePaint;
+import java.awt.geom.Rectangle2D;
+import java.awt.image.BufferedImage;
+import java.awt.image.VolatileImage;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import javax.imageio.ImageIO;
+import javax.swing.JFrame;
+import javax.swing.JPanel;
+
+public class TransformedPaintTest {
+
+    private static enum PaintType {
+        COLOR,
+        GRADIENT,
+        LINEAR_GRADIENT,
+        RADIAL_GRADIENT,
+        TEXTURE
+    };
+
+    private static final int CELL_SIZE = 100;
+    private static final int R_WIDTH = 3 * CELL_SIZE;
+    private static final int R_HEIGHT = PaintType.values().length * CELL_SIZE;
+
+    private Paint createPaint(PaintType type, int startx, int starty,
+                              int w, int h)
+    {
+        // make sure that the blue color doesn't show up when filling a
+        // w by h rect
+        w++; h++;
+
+        int endx = startx + w;
+        int endy = starty + h;
+        Rectangle2D.Float r = new Rectangle2D.Float(startx, starty, w, h);
+        switch (type) {
+            case COLOR: return Color.red;
+            case GRADIENT: return
+                new GradientPaint(startx, starty, Color.red,
+                                  endx, endy, Color.green);
+            case LINEAR_GRADIENT: return
+                new LinearGradientPaint(startx, starty, endx, endy,
+                    new float[] { 0.0f, 0.999f, 1.0f },
+                    new Color[] { Color.red, Color.green, Color.blue });
+            case RADIAL_GRADIENT: return
+                new RadialGradientPaint(startx, starty,
+                    (float)Math.sqrt(w * w + h * h),
+                    new float[] { 0.0f, 0.999f, 1.0f },
+                    new Color[] { Color.red, Color.green, Color.blue },
+                    CycleMethod.NO_CYCLE);
+            case TEXTURE: {
+                BufferedImage bi =
+                    new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
+                Graphics2D g = (Graphics2D) bi.getGraphics();
+                g.setPaint(createPaint(PaintType.LINEAR_GRADIENT, 0, 0, w, h));
+                g.fillRect(0, 0, w, h);
+                return new TexturePaint(bi, r);
+            }
+        }
+        return Color.green;
+    }
+
+    private void renderLine(PaintType type, Graphics2D g,
+                            int startx, int starty, int w, int h)
+    {
+        Paint p = createPaint(type, startx, starty, w, h);
+        g.setPaint(p);
+
+        // first, no transform
+        g.fillRect(startx, starty, w, h);
+
+        // translation only
+        g.translate(w, 0);
+        g.fillRect(startx, starty, w, h);
+        g.translate(-w, 0);
+
+        // complex transform
+        g.translate(startx + w*2, starty);
+        g.rotate(Math.toRadians(90), w/2, h/2);
+        g.translate(-startx, -starty);
+        g.fillRect(startx, starty, w, h);
+    }
+
+    private void render(Graphics2D g, int w, int h) {
+        int paintTypes = PaintType.values().length;
+        int ystep = h / paintTypes;
+        int y = 0;
+
+        for (PaintType type : PaintType.values()) {
+            renderLine(type, (Graphics2D)g.create(),
+                       0, y, h / paintTypes, h / paintTypes);
+            y += ystep;
+        }
+    }
+
+    private void checkBI(BufferedImage bi) {
+        for (int y = 0; y < bi.getHeight(); y++) {
+            for (int x = 0; x < bi.getWidth(); x++) {
+                if (bi.getRGB(x, y) == Color.blue.getRGB()) {
+                    try {
+                        String fileName = "TransformedPaintTest_res.png";
+                        ImageIO.write(bi, "png", new File(fileName));
+                        System.err.println("Dumped image to: " + fileName);
+                    } catch (IOException ex) {}
+                    throw new RuntimeException("Test failed, blue color found");
+                }
+            }
+        }
+    }
+
+    private void runTest() {
+        GraphicsConfiguration gc = GraphicsEnvironment.
+            getLocalGraphicsEnvironment().getDefaultScreenDevice().
+                getDefaultConfiguration();
+
+        if (gc.getColorModel().getPixelSize() < 16) {
+            System.out.println("8-bit desktop depth found, test passed");
+            return;
+        }
+
+        VolatileImage vi = gc.createCompatibleVolatileImage(R_WIDTH, R_HEIGHT);
+        BufferedImage bi = null;
+        do {
+            vi.validate(gc);
+            Graphics2D g = vi.createGraphics();
+            render(g, vi.getWidth(), vi.getHeight());
+            bi = vi.getSnapshot();
+        } while (vi.contentsLost());
+
+        checkBI(bi);
+        System.out.println("Test PASSED.");
+    }
+
+    private static void showFrame(final TransformedPaintTest t) {
+        JFrame f = new JFrame("TransformedPaintTest");
+        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        final BufferedImage bi =
+            new BufferedImage(R_WIDTH, R_HEIGHT, BufferedImage.TYPE_INT_RGB);
+        JPanel p = new JPanel() {
+            @Override
+            protected void paintComponent(Graphics g) {
+                super.paintComponent(g);
+                Graphics2D g2d = (Graphics2D) g;
+                t.render(g2d, R_WIDTH, R_HEIGHT);
+                t.render(bi.createGraphics(), R_WIDTH, R_HEIGHT);
+                g2d.drawImage(bi, R_WIDTH + 5, 0, null);
+
+                g.setColor(Color.black);
+                g.drawString("Rendered to Back Buffer", 10, 20);
+                g.drawString("Rendered to BufferedImage", R_WIDTH + 15, 20);
+            }
+        };
+        p.setPreferredSize(new Dimension(2 * R_WIDTH + 5, R_HEIGHT));
+        f.add(p);
+        f.pack();
+        f.setVisible(true);
+    }
+
+    public static void main(String[] args) throws
+        InterruptedException, InvocationTargetException
+    {
+        boolean show = (args.length > 0 && "-show".equals(args[0]));
+
+        final TransformedPaintTest t = new TransformedPaintTest();
+        if (show) {
+            EventQueue.invokeAndWait(new Runnable() {
+                public void run() {
+                    showFrame(t);
+                }
+            });
+        } else {
+            t.runTest();
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/GdiRendering/InsetClipping.java openjdk/jdk/test/sun/java2d/GdiRendering/InsetClipping.java
--- openjdk.orig/jdk/test/sun/java2d/GdiRendering/InsetClipping.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/GdiRendering/InsetClipping.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,112 @@
+/*
+ * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/**
+ * @test
+ * @bug 4873505 6588884
+ * @author cheth
+ * @summary verifies that drawImage behaves the bounds of a complex
+ * clip shape.  This was a problem with our GDI renderer on Windows, where
+ * we would ignore the window insets.
+ * @run main InsetClipping
+*/
+
+/**
+ * This test works by setting up a clip area that equals the visible area
+ * of the Frame.  When we perform any rendering operation to that window,
+ * we should not see the results of the operation because they should be
+ * clipped out.  We create an Image with one color (red) and use a
+ * different background fill color (blue).  We fill the area with the
+ * background color, then set the clip, then draw the image; if we detect
+ * the image color at pixel (0, 0) then we did not clip correctly and the
+ * test fails.
+ */
+
+import java.awt.*;
+import java.awt.geom.*;
+import java.awt.image.*;
+
+
+public class InsetClipping extends Frame {
+    BufferedImage image;
+    Area area;
+    static boolean painted = false;
+    static Color imageColor = Color.red;
+    static Color fillColor = Color.blue;
+
+    public InsetClipping() {
+
+        image  = new BufferedImage( 300, 300,BufferedImage.TYPE_INT_RGB);
+        Graphics g2 = image.createGraphics();
+        g2.setColor(imageColor);
+        g2.fillRect(0,0, 300,300);
+    }
+
+    public void paint(Graphics g) {
+        Insets insets = getInsets();
+        area = new Area( new Rectangle(0,0, getWidth(), getHeight()));
+        area.subtract(new Area(new Rectangle(insets.left, insets.top,
+                                      getWidth() - insets.right,
+                                      getHeight() - insets.bottom)));
+        g.setColor(fillColor);
+        g.fillRect(0, 0, getWidth(), getHeight());
+        g.setClip(area);
+        g.drawImage(image, 0, 0, null);
+        painted = true;
+    }
+
+    public static void main(String args[]) {
+        InsetClipping clipTest = new InsetClipping();
+        clipTest.setSize(300, 300);
+        clipTest.setVisible(true);
+        while (!painted) {
+            try {
+                Thread.sleep(100);
+            } catch (Exception e) {}
+        }
+        try {
+            Robot robot = new Robot();
+            Point clientLoc = clipTest.getLocationOnScreen();
+            Insets insets = clipTest.getInsets();
+            clientLoc.x += insets.left;
+            clientLoc.y += insets.top;
+            BufferedImage clientPixels =
+                robot.createScreenCapture(new Rectangle(clientLoc.x,
+                                                        clientLoc.y,
+                                                        clientLoc.x + 2,
+                                                        clientLoc.y + 2));
+            try {
+                Thread.sleep(2000);
+            } catch (Exception e) {}
+            int pixelVal = clientPixels.getRGB(0, 0);
+            clipTest.dispose();
+            if ((new Color(pixelVal)).equals(fillColor)) {
+                System.out.println("Passed");
+            } else {
+                throw new Error("Failed: incorrect color in pixel (0, 0)");
+            }
+        } catch (Exception e) {
+            System.out.println("Problems creating Robot");
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/OpenGL/DrawBufImgOp.java openjdk/jdk/test/sun/java2d/OpenGL/DrawBufImgOp.java
--- openjdk.orig/jdk/test/sun/java2d/OpenGL/DrawBufImgOp.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/OpenGL/DrawBufImgOp.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,483 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/*
+ * @test
+ * @bug 6514990
+ * @summary Verifies that calling
+ * Graphics2D.drawImage(BufferedImage, BufferedImageOp, x, y) to an
+ * OpenGL-accelerated destination produces the same results when performed
+ * in software via BufferedImageOp.filter().
+ * @run main/othervm -Dsun.java2d.opengl=True DrawBufImgOp -ignore
+ * @author campbelc
+ */
+
+import java.awt.*;
+import java.awt.image.*;
+import java.io.File;
+import javax.imageio.ImageIO;
+
+/**
+ * REMIND: This testcase was originally intended to automatically compare
+ * the results of the software BufferedImageOp implementations against
+ * the OGL-accelerated codepaths.  However, there are just too many open
+ * bugs in the mediaLib-based codepaths (see below), which means that
+ * creating the reference image may cause crashes or exceptions,
+ * and even if we work around those cases using the "-ignore" flag,
+ * the visual results of the reference image are often buggy as well
+ * (so the comparison will fail even though the OGL results are correct).
+ * Therefore, for now we will run the testcase with the "-ignore" flag
+ * but without the "-compare" flag, so at least it will be checking for
+ * any exceptions/crashes in the OGL code.  When we fix all of the
+ * outstanding bugs with the software codepaths, we can remove the
+ * "-ignore" flag and maybe even restore the "-compare" flag.  In the
+ * meantime, it stil functions well as a manual testcase (with either
+ * the "-show" or "-dump" options).
+ */
+public class DrawBufImgOp extends Canvas {
+
+    private static final int TESTW = 600;
+    private static final int TESTH = 500;
+    private static boolean done;
+
+    /*
+     * If true, skips tests that are known to trigger bugs (which in
+     * turn may cause crashes, exceptions, or other artifacts).
+     */
+    private static boolean ignore;
+
+    // Test both pow2 and non-pow2 sized images
+    private static final int[] srcSizes = { 32, 17 };
+    private static final int[] srcTypes = {
+        BufferedImage.TYPE_INT_RGB,
+        BufferedImage.TYPE_INT_ARGB,
+        BufferedImage.TYPE_INT_ARGB_PRE,
+        BufferedImage.TYPE_INT_BGR,
+        BufferedImage.TYPE_3BYTE_BGR,
+        BufferedImage.TYPE_4BYTE_ABGR,
+        BufferedImage.TYPE_USHORT_565_RGB,
+        BufferedImage.TYPE_BYTE_GRAY,
+        BufferedImage.TYPE_USHORT_GRAY,
+    };
+
+    private static final RescaleOp
+        rescale1band, rescale3band, rescale4band;
+    private static final LookupOp
+        lookup1bandbyte, lookup3bandbyte, lookup4bandbyte;
+    private static final LookupOp
+        lookup1bandshort, lookup3bandshort, lookup4bandshort;
+    private static final ConvolveOp
+        convolve3x3zero, convolve5x5zero, convolve7x7zero;
+    private static final ConvolveOp
+        convolve3x3noop, convolve5x5noop, convolve7x7noop;
+
+    static {
+        rescale1band = new RescaleOp(0.5f, 10.0f, null);
+        rescale3band = new RescaleOp(
+            new float[] {  0.6f,  0.4f, 0.6f },
+            new float[] { 10.0f, -3.0f, 5.0f },
+            null);
+        rescale4band = new RescaleOp(
+            new float[] {  0.6f, 0.4f, 0.6f, 0.9f },
+            new float[] { -1.0f, 5.0f, 3.0f, 1.0f },
+            null);
+
+        // REMIND: we should probably test non-zero offsets, but that
+        // would require massaging the source image data to avoid going
+        // outside the lookup table array bounds
+        int offset = 0;
+        {
+            byte invert[] = new byte[256];
+            byte halved[] = new byte[256];
+            for (int j = 0; j < 256 ; j++) {
+                invert[j] = (byte) (255-j);
+                halved[j] = (byte) (j / 2);
+            }
+            ByteLookupTable lut1 = new ByteLookupTable(offset, invert);
+            lookup1bandbyte = new LookupOp(lut1, null);
+            ByteLookupTable lut3 =
+                new ByteLookupTable(offset,
+                                    new byte[][] {invert, halved, invert});
+            lookup3bandbyte = new LookupOp(lut3, null);
+            ByteLookupTable lut4 =
+                new ByteLookupTable(offset,
+                               new byte[][] {invert, halved, invert, halved});
+            lookup4bandbyte = new LookupOp(lut4, null);
+        }
+
+        {
+            short invert[] = new short[256];
+            short halved[] = new short[256];
+            for (int j = 0; j < 256 ; j++) {
+                invert[j] = (short) ((255-j) * 255);
+                halved[j] = (short) ((j / 2) * 255);
+            }
+            ShortLookupTable lut1 = new ShortLookupTable(offset, invert);
+            lookup1bandshort = new LookupOp(lut1, null);
+            ShortLookupTable lut3 =
+                new ShortLookupTable(offset,
+                                     new short[][] {invert, halved, invert});
+            lookup3bandshort = new LookupOp(lut3, null);
+            ShortLookupTable lut4 =
+                new ShortLookupTable(offset,
+                              new short[][] {invert, halved, invert, halved});
+            lookup4bandshort = new LookupOp(lut4, null);
+        }
+
+        // 3x3 blur
+        float[] data3 = {
+            0.1f, 0.1f, 0.1f,
+            0.1f, 0.2f, 0.1f,
+            0.1f, 0.1f, 0.1f,
+        };
+        Kernel k3 = new Kernel(3, 3, data3);
+
+        // 5x5 edge
+        float[] data5 = {
+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,
+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,
+            -1.0f, -1.0f, 24.0f, -1.0f, -1.0f,
+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,
+            -1.0f, -1.0f, -1.0f, -1.0f, -1.0f,
+        };
+        Kernel k5 = new Kernel(5, 5, data5);
+
+        // 7x7 blur
+        float[] data7 = {
+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,
+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,
+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,
+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,
+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,
+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,
+            0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f, 0.02f,
+        };
+        Kernel k7 = new Kernel(7, 7, data7);
+
+        convolve3x3zero = new ConvolveOp(k3, ConvolveOp.EDGE_ZERO_FILL, null);
+        convolve5x5zero = new ConvolveOp(k5, ConvolveOp.EDGE_ZERO_FILL, null);
+        convolve7x7zero = new ConvolveOp(k7, ConvolveOp.EDGE_ZERO_FILL, null);
+
+        convolve3x3noop = new ConvolveOp(k3, ConvolveOp.EDGE_NO_OP, null);
+        convolve5x5noop = new ConvolveOp(k5, ConvolveOp.EDGE_NO_OP, null);
+        convolve7x7noop = new ConvolveOp(k7, ConvolveOp.EDGE_NO_OP, null);
+    }
+
+    public void paint(Graphics g) {
+        synchronized (this) {
+            if (done) {
+                return;
+            }
+        }
+
+        VolatileImage vimg = createVolatileImage(TESTW, TESTH);
+        vimg.validate(getGraphicsConfiguration());
+
+        Graphics2D g2d = vimg.createGraphics();
+        renderTest(g2d);
+        g2d.dispose();
+
+        g.drawImage(vimg, 0, 0, null);
+
+        Toolkit.getDefaultToolkit().sync();
+
+        synchronized (this) {
+            done = true;
+            notifyAll();
+        }
+    }
+
+    /*
+     * foreach source image size (once with pow2, once with non-pow2)
+     *
+     *   foreach BufferedImage type
+     *
+     *     RescaleOp (1 band)
+     *     RescaleOp (3 bands, if src has 3 bands)
+     *     RescaleOp (4 bands, if src has 4 bands)
+     *
+     *     foreach LookupTable type (once with ByteLUT, once with ShortLUT)
+     *       LookupOp (1 band)
+     *       LookupOp (3 bands, if src has 3 bands)
+     *       LookupOp (4 bands, if src has 4 bands)
+     *
+     *     foreach edge condition (once with ZERO_FILL, once with EDGE_NO_OP)
+     *       ConvolveOp (3x3)
+     *       ConvolveOp (5x5)
+     *       ConvolveOp (7x7)
+     */
+    private void renderTest(Graphics2D g2d) {
+        g2d.setColor(Color.white);
+        g2d.fillRect(0, 0, TESTW, TESTH);
+
+        int yorig = 2;
+        int xinc = 34;
+        int yinc = srcSizes[0] + srcSizes[1] + 2 + 2;
+
+        for (int srcType : srcTypes) {
+            int y = yorig;
+
+            for (int srcSize : srcSizes) {
+                int x = 2;
+                System.out.printf("type=%d size=%d\n", srcType, srcSize);
+
+                BufferedImage srcImg = makeSourceImage(srcSize, srcType);
+                ColorModel srcCM = srcImg.getColorModel();
+
+                // RescaleOp
+                g2d.drawImage(srcImg, rescale1band, x, y);
+                x += xinc;
+                // REMIND: 3-band RescaleOp.filter() throws IAE for images
+                //         that contain an alpha channel (bug to be filed)
+                if (srcCM.getNumColorComponents() == 3 &&
+                    !(ignore && srcCM.hasAlpha()))
+                {
+                    g2d.drawImage(srcImg, rescale3band, x, y);
+                }
+                x += xinc;
+                if (srcCM.getNumComponents() == 4) {
+                    g2d.drawImage(srcImg, rescale4band, x, y);
+                }
+                x += xinc;
+
+                // LookupOp
+                // REMIND: Our LUTs are only 256 elements long, so won't
+                //         currently work with USHORT_GRAY data
+                if (srcType != BufferedImage.TYPE_USHORT_GRAY) {
+                    g2d.drawImage(srcImg, lookup1bandbyte, x, y);
+                    x += xinc;
+                    if (srcCM.getNumColorComponents() == 3) {
+                        g2d.drawImage(srcImg, lookup3bandbyte, x, y);
+                    }
+                    x += xinc;
+                    if (srcCM.getNumComponents() == 4) {
+                        g2d.drawImage(srcImg, lookup4bandbyte, x, y);
+                    }
+                    x += xinc;
+
+                    // REMIND: LookupOp.createCompatibleDestImage() throws
+                    //         IAE for 3BYTE_BGR/4BYTE_ABGR (bug to be filed)
+                    if (!(ignore &&
+                          (srcType == BufferedImage.TYPE_3BYTE_BGR ||
+                           srcType == BufferedImage.TYPE_4BYTE_ABGR)))
+                    {
+                        g2d.drawImage(srcImg, lookup1bandshort, x, y);
+                        x += xinc;
+                        // REMIND: 3-band LookupOp.filter() throws IAE for
+                        //         images that contain an alpha channel
+                        //         (bug to be filed)
+                        if (srcCM.getNumColorComponents() == 3 &&
+                            !(ignore && srcCM.hasAlpha()))
+                        {
+                            g2d.drawImage(srcImg, lookup3bandshort, x, y);
+                        }
+                        x += xinc;
+                        if (srcCM.getNumComponents() == 4) {
+                            g2d.drawImage(srcImg, lookup4bandshort, x, y);
+                        }
+                        x += xinc;
+                    } else {
+                        x += 3*xinc;
+                    }
+                } else {
+                    x += 6*xinc;
+                }
+
+                // ConvolveOp
+                // REMIND: ConvolveOp.filter() throws ImagingOpException
+                //         for 3BYTE_BGR (see 4957775)
+                if (srcType != BufferedImage.TYPE_3BYTE_BGR) {
+                    g2d.drawImage(srcImg, convolve3x3zero, x, y);
+                    x += xinc;
+                    g2d.drawImage(srcImg, convolve5x5zero, x, y);
+                    x += xinc;
+                    g2d.drawImage(srcImg, convolve7x7zero, x, y);
+                    x += xinc;
+
+                    g2d.drawImage(srcImg, convolve3x3noop, x, y);
+                    x += xinc;
+                    g2d.drawImage(srcImg, convolve5x5noop, x, y);
+                    x += xinc;
+                    g2d.drawImage(srcImg, convolve7x7noop, x, y);
+                    x += xinc;
+                } else {
+                    x += 6*xinc;
+                }
+
+                y += srcSize + 2;
+            }
+
+            yorig += yinc;
+        }
+    }
+
+    private BufferedImage makeSourceImage(int size, int type) {
+        int s2 = size/2;
+        BufferedImage img = new BufferedImage(size, size, type);
+        Graphics2D g2d = img.createGraphics();
+        g2d.setComposite(AlphaComposite.Src);
+        g2d.setColor(Color.orange);
+        g2d.fillRect(0, 0, size, size);
+        g2d.setColor(Color.red);
+        g2d.fillRect(0, 0, s2, s2);
+        g2d.setColor(Color.green);
+        g2d.fillRect(s2, 0, s2, s2);
+        g2d.setColor(Color.blue);
+        g2d.fillRect(0, s2, s2, s2);
+        g2d.setColor(new Color(255, 255, 0, 128));
+        g2d.fillRect(s2, s2, s2, s2);
+        g2d.setColor(Color.pink);
+        g2d.fillOval(s2-3, s2-3, 6, 6);
+        g2d.dispose();
+        return img;
+    }
+
+    public BufferedImage makeReferenceImage() {
+        BufferedImage img = new BufferedImage(TESTW, TESTH,
+                                              BufferedImage.TYPE_INT_RGB);
+        Graphics2D g2d = img.createGraphics();
+        renderTest(g2d);
+        g2d.dispose();
+        return img;
+    }
+
+    public Dimension getPreferredSize() {
+        return new Dimension(TESTW, TESTH);
+    }
+
+    private static void compareImages(BufferedImage refImg,
+                                      BufferedImage testImg,
+                                      int tolerance)
+    {
+        int x1 = 0;
+        int y1 = 0;
+        int x2 = refImg.getWidth();
+        int y2 = refImg.getHeight();
+
+        for (int y = y1; y < y2; y++) {
+            for (int x = x1; x < x2; x++) {
+                Color expected = new Color(refImg.getRGB(x, y));
+                Color actual   = new Color(testImg.getRGB(x, y));
+                if (!isSameColor(expected, actual, tolerance)) {
+                    throw new RuntimeException("Test failed at x="+x+" y="+y+
+                                               " (expected="+expected+
+                                               " actual="+actual+
+                                               ")");
+                }
+            }
+        }
+    }
+
+    private static boolean isSameColor(Color c1, Color c2, int e) {
+        int r1 = c1.getRed();
+        int g1 = c1.getGreen();
+        int b1 = c1.getBlue();
+        int r2 = c2.getRed();
+        int g2 = c2.getGreen();
+        int b2 = c2.getBlue();
+        int rmin = Math.max(r2-e, 0);
+        int gmin = Math.max(g2-e, 0);
+        int bmin = Math.max(b2-e, 0);
+        int rmax = Math.min(r2+e, 255);
+        int gmax = Math.min(g2+e, 255);
+        int bmax = Math.min(b2+e, 255);
+        if (r1 >= rmin && r1 <= rmax &&
+            g1 >= gmin && g1 <= gmax &&
+            b1 >= bmin && b1 <= bmax)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static void main(String[] args) throws Exception {
+        boolean show = false;
+        boolean dump = false;
+        boolean compare = false;
+
+        for (String arg : args) {
+            if (arg.equals("-show")) {
+                show = true;
+            } else if (arg.equals("-dump")) {
+                dump = true;
+            } else if (arg.equals("-compare")) {
+                compare = true;
+            } else if (arg.equals("-ignore")) {
+                ignore = true;
+            }
+        }
+
+        DrawBufImgOp test = new DrawBufImgOp();
+        Frame frame = new Frame();
+        frame.add(test);
+        frame.pack();
+        frame.setVisible(true);
+
+        // Wait until the component's been painted
+        synchronized (test) {
+            while (!done) {
+                try {
+                    test.wait();
+                } catch (InterruptedException e) {
+                    throw new RuntimeException("Failed: Interrupted");
+                }
+            }
+        }
+
+        GraphicsConfiguration gc = frame.getGraphicsConfiguration();
+        if (gc.getColorModel() instanceof IndexColorModel) {
+            System.out.println("IndexColorModel detected: " +
+                               "test considered PASSED");
+            frame.dispose();
+            return;
+        }
+
+        // Grab the screen region
+        BufferedImage capture = null;
+        try {
+            Robot robot = new Robot();
+            Point pt1 = test.getLocationOnScreen();
+            Rectangle rect = new Rectangle(pt1.x, pt1.y, TESTW, TESTH);
+            capture = robot.createScreenCapture(rect);
+        } catch (Exception e) {
+            throw new RuntimeException("Problems creating Robot");
+        } finally {
+            if (!show) {
+                frame.dispose();
+            }
+        }
+
+        // Compare the images (allow for +/- 1 bit differences in color comps)
+        if (dump || compare) {
+            BufferedImage ref = test.makeReferenceImage();
+            if (dump) {
+                ImageIO.write(ref,     "png",
+                              new File("DrawBufImgOp.ref.png"));
+                ImageIO.write(capture, "png",
+                              new File("DrawBufImgOp.cap.png"));
+            }
+            if (compare) {
+                test.compareImages(ref, capture, 1);
+            }
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/pipe/hw/RSLAPITest/RSLAPITest.java openjdk/jdk/test/sun/java2d/pipe/hw/RSLAPITest/RSLAPITest.java
--- openjdk.orig/jdk/test/sun/java2d/pipe/hw/RSLAPITest/RSLAPITest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/pipe/hw/RSLAPITest/RSLAPITest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,308 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/*
+ * @test
+ * @bug 6635805 6653780 6667607
+ * @summary Tests that the resource sharing layer API is not broken
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @compile -XDignore.symbol.file=true RSLAPITest.java
+ * @run main/othervm RSLAPITest
+ * @run main/othervm -Dsun.java2d.noddraw=true RSLAPITest
+ * @run main/othervm -Dsun.java2d.opengl=True RSLAPITest
+ */
+
+import java.awt.Graphics;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+import java.awt.Rectangle;
+import java.awt.Transparency;
+import java.awt.image.VolatileImage;
+import java.util.HashSet;
+import sun.java2d.DestSurfaceProvider;
+import sun.java2d.Surface;
+import sun.java2d.pipe.BufferedContext;
+import sun.java2d.pipe.RenderQueue;
+import sun.java2d.pipe.hw.AccelDeviceEventListener;
+import sun.java2d.pipe.hw.AccelGraphicsConfig;
+import sun.java2d.pipe.hw.AccelSurface;
+import static java.awt.Transparency.*;
+import java.lang.reflect.Field;
+import static sun.java2d.pipe.hw.AccelSurface.*;
+import static sun.java2d.pipe.hw.ContextCapabilities.*;
+
+public class RSLAPITest {
+    private static volatile boolean failed = false;
+
+    public static void main(String[] args) {
+        GraphicsEnvironment ge =
+                GraphicsEnvironment.getLocalGraphicsEnvironment();
+        GraphicsDevice gd = ge.getDefaultScreenDevice();
+        GraphicsConfiguration gc = gd.getDefaultConfiguration();
+        testGC(gc);
+
+        if (failed) {
+            throw new RuntimeException("Test FAILED. See err output for more");
+        }
+
+        System.out.println("Test PASSED.");
+    }
+
+    private static void testInvalidType(AccelSurface surface, int type) {
+        long ret = surface.getNativeResource(type);
+        System.out.printf("  getNativeResource(%d)=0x%x\n", type, ret);
+        if (ret != 0l) {
+            System.err.printf(
+                    "FAILED: surface.getNativeResource(%d) returned" +
+                    " 0x%s. It should have have returned 0L\n",
+                    type, ret);
+            failed = true;
+        }
+    }
+
+    private static void testD3DDeviceResourceField(final AccelSurface surface) {
+        try {
+            Class d3dc = Class.forName("sun.java2d.d3d.D3DSurfaceData");
+            if (d3dc.isInstance(surface)) {
+                Field f = d3dc.getDeclaredField("D3D_DEVICE_RESOURCE");
+                f.setAccessible(true);
+                int d3dDR = (Integer)f.get(null);
+
+                System.out.printf(
+                        "  getNativeResource(D3D_DEVICE_RESOURCE)=0x%x\n",
+                        surface.getNativeResource(d3dDR));
+            }
+        } catch (ClassNotFoundException e) {}
+        catch (IllegalAccessException e) {}
+        catch (NoSuchFieldException e) {
+            System.err.println("Failed: D3DSurfaceData.D3D_DEVICE_RESOURCE" +
+                               " field not found!");
+            failed = true;
+        }
+    }
+
+    private static void printSurface(Surface s) {
+        if (s instanceof AccelSurface) {
+            final AccelSurface surface = (AccelSurface) s;
+            System.out.println(" Accel Surface: ");
+            System.out.println("  type=" + surface.getType());
+            System.out.println("  bounds=" + surface.getBounds());
+            System.out.println("  nativeBounds=" + surface.getNativeBounds());
+            System.out.println("  isSurfaceLost=" + surface.isSurfaceLost());
+            System.out.println("  isValid=" + surface.isValid());
+            RenderQueue rq = surface.getContext().getRenderQueue();
+            rq.lock();
+            try {
+                rq.flushAndInvokeNow(new Runnable() {
+                    public void run() {
+                        System.out.printf("  getNativeResource(TEXTURE)=0x%x\n",
+                            surface.getNativeResource(TEXTURE));
+                        System.out.printf("  getNativeResource(RT_TEXTURE)=0x%x\n",
+                            surface.getNativeResource(RT_TEXTURE));
+                        System.out.printf("  getNativeResource(RT_PLAIN)=0x%x\n",
+                            surface.getNativeResource(RT_PLAIN));
+                        System.out.printf(
+                            "  getNativeResource(FLIP_BACKBUFFER)=0x%x\n",
+                            surface.getNativeResource(FLIP_BACKBUFFER));
+
+                        testD3DDeviceResourceField(surface);
+
+                        testInvalidType(surface, -1);
+                        testInvalidType(surface, -150);
+                        testInvalidType(surface, 300);
+                        testInvalidType(surface, Integer.MAX_VALUE);
+                        testInvalidType(surface, Integer.MIN_VALUE);
+                    }
+                });
+            } finally {
+                rq.unlock();
+            }
+        } else {
+            System.out.println("null accelerated surface");
+        }
+    }
+
+    private static void printAGC(AccelGraphicsConfig agc) {
+        System.out.println("Accelerated Graphics Config: " + agc);
+        System.out.println("Capabilities:");
+        System.out.printf("AGC caps: 0x%x\n",
+                          agc.getContextCapabilities().getCaps());
+        System.out.println(agc.getContextCapabilities());
+    }
+
+    private static void testGC(GraphicsConfiguration gc) {
+        if (!(gc instanceof AccelGraphicsConfig)) {
+            System.out.println("Test passed: no hw accelerated configs found.");
+            return;
+        }
+        System.out.println("AccelGraphicsConfig exists, testing.");
+        AccelGraphicsConfig agc = (AccelGraphicsConfig) gc;
+        printAGC(agc);
+
+        testContext(agc);
+
+        VolatileImage vi = gc.createCompatibleVolatileImage(10, 10);
+        vi.validate(gc);
+        if (vi instanceof DestSurfaceProvider) {
+            System.out.println("Passed: VI is DestSurfaceProvider");
+            Surface s = ((DestSurfaceProvider) vi).getDestSurface();
+            if (s instanceof AccelSurface) {
+                System.out.println("Passed: Obtained Accel Surface");
+                printSurface((AccelSurface) s);
+            }
+            Graphics g = vi.getGraphics();
+            if (g instanceof DestSurfaceProvider) {
+                System.out.println("Passed: VI graphics is " +
+                                   "DestSurfaceProvider");
+                printSurface(((DestSurfaceProvider) g).getDestSurface());
+            }
+        } else {
+            System.out.println("VI is not DestSurfaceProvider");
+        }
+        testVICreation(agc, CAPS_RT_TEXTURE_ALPHA, TRANSLUCENT, RT_TEXTURE);
+        testVICreation(agc, CAPS_RT_TEXTURE_OPAQUE, OPAQUE, RT_TEXTURE);
+        testVICreation(agc, CAPS_RT_PLAIN_ALPHA, TRANSLUCENT, RT_PLAIN);
+        testVICreation(agc, agc.getContextCapabilities().getCaps(), OPAQUE,
+                       TEXTURE);
+        testForNPEDuringCreation(agc);
+    }
+
+    private static void testVICreation(AccelGraphicsConfig agc, int cap,
+                                       int transparency, int type)
+    {
+        int caps = agc.getContextCapabilities().getCaps();
+        int w = 11, h = 17;
+
+        VolatileImage vi =
+            agc.createCompatibleVolatileImage(w, h, transparency, type);
+        if ((cap & caps) != 0) {
+            if (vi == null) {
+                System.out.printf("Failed: cap=%d is supported but " +
+                                  "image wasn't created\n", cap);
+                throw new RuntimeException("Failed: image wasn't created " +
+                                           "for supported cap");
+            } else {
+                if (!(vi instanceof DestSurfaceProvider)) {
+                    throw new RuntimeException("Failed: created VI is not " +
+                                               "DestSurfaceProvider");
+                }
+                Surface s = ((DestSurfaceProvider) vi).getDestSurface();
+                if (s instanceof AccelSurface) {
+                    AccelSurface as = (AccelSurface) s;
+                    printSurface(as);
+                    if (as.getType() != type) {
+                        throw new RuntimeException("Failed: returned VI is" +
+                                " of incorrect type: " + as.getType() +
+                                " requested type=" + type);
+                    } else {
+                        System.out.printf("Passed: VI of type %d was " +
+                                "created for cap=%d\n", type, cap);
+                    }
+                    if (as.getType() == TEXTURE) {
+                        boolean ex = false;
+                        try {
+                            Graphics g = vi.getGraphics();
+                            g.dispose();
+                        } catch (UnsupportedOperationException e) {
+                            ex = true;
+                        }
+                        if (!ex) {
+                            throw new RuntimeException("Failed: " +
+                                "texture.getGraphics() didn't throw exception");
+                        } else {
+                            System.out.println("Passed: VI.getGraphics()" +
+                                    " threw exception for texture-based VI");
+                        }
+                    }
+                } else {
+                    System.out.printf("Passed: VI of type %d was " +
+                            "created for cap=%d but accel surface is null\n",
+                            type, cap);
+                }
+            }
+        } else {
+            if (vi != null) {
+                throw new RuntimeException("Failed: created VI for " +
+                                           "unsupported cap=" + cap);
+            }
+        }
+    }
+
+    private static void testContext(final AccelGraphicsConfig agc) {
+        BufferedContext c = agc.getContext();
+        final AccelDeviceEventListener l = new AccelDeviceEventListener() {
+            public void onDeviceDispose() {
+                System.out.println("onDeviceDispose invoked");
+                agc.removeDeviceEventListener(this);
+            }
+            public void onDeviceReset() {
+                System.out.println("onDeviceReset invoked");
+            }
+        };
+        agc.addDeviceEventListener(l);
+
+        RenderQueue rq = c.getRenderQueue();
+        rq.lock();
+        try {
+            c.saveState();
+            rq.flushNow();
+            c.restoreState();
+            rq.flushNow();
+            System.out.println("Passed: Save/Restore");
+        } finally {
+            rq.unlock();
+        }
+    }
+
+    private static void testForNPEDuringCreation(AccelGraphicsConfig agc) {
+        int iterations = 100;
+        HashSet<VolatileImage> vis = new HashSet<VolatileImage>();
+        GraphicsConfiguration gc = (GraphicsConfiguration)agc;
+        Rectangle r = gc.getBounds();
+        long ram = gc.getDevice().getAvailableAcceleratedMemory();
+        if (ram > 0) {
+            // guesstimate the number of iterations needed to exhaust vram
+            int i = 2 *
+                (int)(ram / (r.width * r.height * gc.getColorModel().getPixelSize()/8));
+            iterations = Math.max(iterations, i);
+            System.err.println("iterations="+iterations);
+        }
+        for (int i = 0; i < iterations; i++) {
+            VolatileImage vi =
+                agc.createCompatibleVolatileImage(r.width, r.height,
+                                                  Transparency.OPAQUE,
+                                                  AccelSurface.RT_PLAIN);
+            if (vi == null) {
+                break;
+            }
+            vis.add(vi);
+        }
+        for (VolatileImage vi : vis) {
+            vi.flush();
+        }
+        vis = null;
+
+        System.out.println("Passed: testing for possible NPEs " +
+                           "during VI creation");
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/pipe/hw/VSyncedBufferStrategyTest/VSyncedBufferStrategyTest.java openjdk/jdk/test/sun/java2d/pipe/hw/VSyncedBufferStrategyTest/VSyncedBufferStrategyTest.java
--- openjdk.orig/jdk/test/sun/java2d/pipe/hw/VSyncedBufferStrategyTest/VSyncedBufferStrategyTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/pipe/hw/VSyncedBufferStrategyTest/VSyncedBufferStrategyTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,338 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/*
+ * @test
+ * @bug 6678218 6681745 6691737
+ * @summary Tests that v-synced BufferStrategies works (if vsync is supported)
+ * @author Dmitri.Trembovetski@sun.com: area=Graphics
+ * @compile -XDignore.symbol.file=true VSyncedBufferStrategyTest.java
+ * @run main/manual/othervm VSyncedBufferStrategyTest
+ * @run main/manual/othervm -Dsun.java2d.opengl=True VSyncedBufferStrategyTest
+ */
+
+import java.awt.AWTException;
+import java.awt.BufferCapabilities;
+import java.awt.BufferCapabilities.FlipContents;
+import java.awt.Button;
+import java.awt.Canvas;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.EventQueue;
+import java.awt.FlowLayout;
+import java.awt.Font;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.HeadlessException;
+import java.awt.ImageCapabilities;
+import java.awt.Panel;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.image.BufferStrategy;
+import java.util.concurrent.CountDownLatch;
+import javax.swing.JButton;
+import javax.swing.JFrame;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JTextArea;
+
+public class VSyncedBufferStrategyTest extends Canvas implements Runnable {
+
+    private static final int BLOCK_W = 50;
+    private static final int BLOCK_H = 200;
+
+    BufferStrategy bs;
+    Thread renderThread;
+
+    int blockX = 10;
+    int blockY = 10;
+
+    private volatile boolean done = false;
+    private volatile boolean requestVSync;
+    private boolean currentBSVSynced;
+
+    public VSyncedBufferStrategyTest(boolean requestVSync) {
+        this.requestVSync = requestVSync;
+        this.currentBSVSynced = !requestVSync;
+        renderThread = new Thread(this);
+        renderThread.start();
+    }
+
+    private static final BufferCapabilities defaultBC =
+        new BufferCapabilities(
+                new ImageCapabilities(true),
+                new ImageCapabilities(true),
+                null);
+
+    private void createBS(boolean requestVSync) {
+        if (bs != null && requestVSync == currentBSVSynced) {
+            return;
+        }
+
+        BufferCapabilities bc = defaultBC;
+        if (requestVSync) {
+            bc = new sun.java2d.pipe.hw.ExtendedBufferCapabilities(
+                    new ImageCapabilities(true),
+                    new ImageCapabilities(true),
+                    FlipContents.COPIED,
+                    sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType.VSYNC_ON);
+        }
+        try {
+            createBufferStrategy(2, bc);
+        } catch (AWTException e) {
+            System.err.println("Warning: cap is not supported: "+bc);
+            e.printStackTrace();
+            createBufferStrategy(2);
+        }
+        currentBSVSynced = requestVSync;
+        bs = getBufferStrategy();
+        String s =
+            getParent() instanceof Frame ?
+                ((Frame)getParent()).getTitle() : "parent";
+        System.out.println("Created BS for \"" + s + "\" frame, bs="+bs);
+    }
+
+    @Override
+    public void paint(Graphics g) {
+    }
+    @Override
+    public void update(Graphics g) {
+    }
+
+    @Override
+    public void run() {
+        while (!isShowing()) {
+            try { Thread.sleep(5); } catch (InterruptedException e) {}
+        }
+        try { Thread.sleep(2000); } catch (InterruptedException e) {}
+
+        try {
+            while (!done && isShowing()) {
+                createBS(requestVSync);
+                do {
+                    step();
+                    Graphics g = bs.getDrawGraphics();
+                    render(g);
+                    if (!bs.contentsRestored()) {
+                        bs.show();
+                    }
+                } while (bs.contentsLost());
+                Thread.yield();
+            }
+        } catch (Throwable e) {
+            // since we're not bothering with proper synchronization, exceptions
+            // may be thrown when the frame is closed
+            if (isShowing()) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    int inc = 5;
+    private void step() {
+        blockX += inc;
+        if (blockX > getWidth() - BLOCK_W - 10) {
+            inc = -inc;
+            blockX += inc;
+        }
+        if (blockX < 10) {
+            inc = -inc;
+            blockX += inc;
+        }
+    }
+
+    private void render(Graphics g) {
+        g.setColor(Color.white);
+        g.fillRect(0, 0, getWidth(), getHeight());
+
+        g.setColor(Color.black);
+        g.fillRect(blockX, blockY, BLOCK_W, BLOCK_H);
+    }
+
+    private void setRequestVSync(boolean reqVSync) {
+        requestVSync = reqVSync;
+    }
+
+    @Override
+    public Dimension getPreferredSize() {
+        return new Dimension(BLOCK_W*10+20, BLOCK_H+20);
+    }
+
+    private static int frameNum = 0;
+    private static Frame createAndShowBSFrame() {
+        final Frame f = new Frame("Not V-Synced");
+
+        int myNum;
+        synchronized (VSyncedBufferStrategyTest.class) {
+            myNum = frameNum++;
+        }
+
+        final VSyncedBufferStrategyTest component =
+                new VSyncedBufferStrategyTest(false);
+        f.setIgnoreRepaint(true);
+        f.add("Center", component);
+
+        Panel p = new Panel();
+
+        Button b = new Button("Request VSync");
+        b.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                f.setTitle("Possibly V-Synced");
+                component.setRequestVSync(true);
+            }
+        });
+        p.add(b);
+
+        b = new Button("Relinquish VSync");
+        b.addActionListener(new ActionListener() {
+            int inc = 1;
+            public void actionPerformed(ActionEvent e) {
+                f.setTitle("Not V-Synced");
+                component.setRequestVSync(false);
+                f.setSize(f.getWidth()+inc, f.getHeight());
+                inc = -inc;
+            }
+        });
+        p.add(b);
+
+        f.add("South", p);
+
+        f.pack();
+        f.setLocation(10, myNum * f.getHeight());
+        f.setVisible(true);
+        f.addWindowListener(new WindowAdapter() {
+            @Override
+            public void windowClosing(WindowEvent e) {
+                component.done = true;
+                f.dispose();
+            }
+            @Override
+            public void windowClosed(WindowEvent e) {
+                component.done = true;
+            }
+        });
+
+        return f;
+    }
+
+    private static final String description =
+        "Tests that v-synced BufferStrategy works. Note that it in some\n" +
+        "cases the v-sync can not be enabled, and it is accepted.\n" +
+        "The following however is true: only one buffer strategy at a time can\n"+
+        "be created v-synced. In order for other BS to become v-synced, the one\n"+
+        "that currently is v-synched (or its window) needs to be disposed.\n" +
+        "Try the following scenarios:\n" +
+        "  - click the \"Request VSync\" button in one of the frames. If the\n"+
+        "    behavior of the animation changes - the animation becomes smooth\n" +
+        "    it had successfully created a v-synced BS. Note that the animation\n" +
+        "    in other frames may also become smoother - this is a side-effect\n"+
+        "    of one of the BS-es becoming v-synched\n" +
+        "  - click the \"Relinquish VSync\" button on the same frame. If the\n"+
+        "    behavior changes to the original (tearing)- it had successfully\n" +
+        "    created a non-vsynced strategy.\n" +
+        "  - next, try making another one v-synced. It should succeed.\n" +
+        "  - next, try making another one v-synced - while there's already\n" +
+        "    a v-synced frame. It should not succeed - meaning, it shouldn't\n" +
+        "    appear to become smoother, and the behavior of the current v-synced\n" +
+        "    frame shouldn't change.\n" +
+        "\n" +
+        "If there aren't any BufferStrategy-related exceptions or other\n" +
+        "issues, and the scenarios worked, the test passed, otherwise it\n"+
+        "failed.\n";
+
+    private static void createAndShowDescGUI(final Frame f3, final Frame f1,
+                                             final Frame f2)
+        throws HeadlessException, RuntimeException
+    {
+        final JFrame desc =
+            new JFrame("VSyncedBufferStrategyTest - Description");
+        desc.addWindowListener(new WindowAdapter() {
+
+            @Override
+            public void windowClosing(WindowEvent e) {
+                f1.dispose();
+                f2.dispose();
+                f3.dispose();
+                l.countDown();
+            }
+        });
+        JPanel p = new JPanel();
+        JButton bPassed = new JButton("Passed");
+        bPassed.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                desc.dispose();
+                f1.dispose();
+                f2.dispose();
+                f3.dispose();
+                l.countDown();
+            }
+        });
+        JButton bFailed = new JButton("Failed");
+        bFailed.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                failed = true;
+                desc.dispose();
+                f1.dispose();
+                f2.dispose();
+                f3.dispose();
+                l.countDown();
+            }
+        });
+        p.setLayout(new FlowLayout());
+        p.add(bPassed);
+        p.add(bFailed);
+        JTextArea ta = new JTextArea(24, 75);
+        ta.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
+        ta.setEditable(false);
+        ta.setText(description);
+        desc.add("Center", new JScrollPane(ta));
+        desc.add("South", p);
+        desc.pack();
+        desc.setLocation(BLOCK_W*10+50, 0);
+        desc.setVisible(true);
+    }
+
+    private static void createTestFrames() {
+        Frame f1 = createAndShowBSFrame();
+        Frame f2 = createAndShowBSFrame();
+        Frame f3 = createAndShowBSFrame();
+        createAndShowDescGUI(f1, f2, f3);
+    }
+
+    static boolean failed = false;
+    static CountDownLatch l = new CountDownLatch(1);
+    public static void main(String[] args) throws Exception {
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                createTestFrames();
+            }
+        });
+        l.await();
+        if (failed) {
+            throw new RuntimeException("Test FAILED");
+        }
+        System.out.println("Test PASSED");
+    }
+
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/pipe/MutableColorTest/MutableColorTest.java openjdk/jdk/test/sun/java2d/pipe/MutableColorTest/MutableColorTest.java
--- openjdk.orig/jdk/test/sun/java2d/pipe/MutableColorTest/MutableColorTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/pipe/MutableColorTest/MutableColorTest.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/**
+ * @test
+ * @bug 6613860 6691934
+ * @summary Tests that the pipelines can handle (in somewhat limited
+ * manner) mutable Colors
+ *
+ * @run main/othervm MutableColorTest
+ * @run main/othervm -Dsun.java2d.noddraw=true MutableColorTest
+ * @run main/othervm -Dsun.java2d.opengl=True MutableColorTest
+ */
+
+import java.awt.Color;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.GraphicsEnvironment;
+import java.awt.Image;
+import java.awt.Transparency;
+import java.awt.geom.Ellipse2D;
+import java.awt.image.BufferedImage;
+import java.awt.image.VolatileImage;
+import java.io.File;
+import java.io.IOException;
+import javax.imageio.ImageIO;
+
+public class MutableColorTest {
+
+    static Image bmImage;
+    static Image argbImage;
+
+    static class EvilColor extends Color {
+        Color colors[] = { Color.red, Color.green, Color.blue };
+        int currentIndex = 0;
+        EvilColor() {
+            super(Color.red.getRGB());
+        }
+
+        @Override
+        public int getRGB() {
+            return colors[currentIndex].getRGB();
+        }
+        void nextColor() {
+            currentIndex++;
+        }
+    }
+
+    private static int testImage(Image im,
+                                 boolean doClip, boolean doTx)
+    {
+        int w = im.getWidth(null);
+        int h = im.getHeight(null);
+        Graphics2D g = (Graphics2D)im.getGraphics();
+        EvilColor evilColor = new EvilColor();
+        g.setColor(evilColor);
+        g.fillRect(0, 0, w, h);
+        g.dispose();
+
+        evilColor.nextColor();
+
+        g = (Graphics2D)im.getGraphics();
+
+        if (doTx) {
+            g.rotate(Math.PI/2.0, w/2, h/2);
+        }
+        g.setColor(evilColor);
+        g.fillRect(0, 0, w, h);
+        if (doClip) {
+            g.clip(new Ellipse2D.Float(0, 0, w, h));
+        }
+        g.fillRect(0, h/3, w, h/3);
+
+        // tests native BlitBg loop
+        g.drawImage(bmImage, 0, 2*h/3, evilColor, null);
+        // tests General BlitBg loop
+        g.drawImage(argbImage, 0, 2*h/3+h/3/2, evilColor, null);
+
+        return evilColor.getRGB();
+    }
+
+    private static void testResult(final String desc,
+                                   final BufferedImage snapshot,
+                                   final int evilColor) {
+        for (int y = 0; y < snapshot.getHeight(); y++) {
+            for (int x = 0; x < snapshot.getWidth(); x++) {
+                int snapRGB = snapshot.getRGB(x, y);
+                if (snapRGB != evilColor) {
+                    System.err.printf("Wrong RGB for %s at (%d,%d): 0x%x " +
+                        "instead of 0x%x\n", desc, x, y, snapRGB, evilColor);
+                    String fileName = "MutableColorTest_"+desc+".png";
+                    try {
+                        ImageIO.write(snapshot, "png", new File(fileName));
+                        System.err.println("Dumped snapshot to "+fileName);
+                    } catch (IOException ex) {}
+                    throw new RuntimeException("Test FAILED.");
+                }
+            }
+        }
+    }
+
+    public static void main(String[] args) {
+        GraphicsConfiguration gc =
+            GraphicsEnvironment.getLocalGraphicsEnvironment().
+                getDefaultScreenDevice().getDefaultConfiguration();
+
+        bmImage = gc.createCompatibleImage(64, 64, Transparency.BITMASK);
+        argbImage = gc.createCompatibleImage(64, 64, Transparency.TRANSLUCENT);
+
+        if (gc.getColorModel().getPixelSize() > 8) {
+            VolatileImage vi =
+                gc.createCompatibleVolatileImage(64, 64, Transparency.OPAQUE);
+            do {
+                if (vi.validate(gc) == VolatileImage.IMAGE_INCOMPATIBLE) {
+                    vi = gc.createCompatibleVolatileImage(64, 64,
+                                                          Transparency.OPAQUE);
+                    vi.validate(gc);
+                }
+
+                int color = testImage(vi, false, false);
+                testResult("vi_noclip_notx", vi.getSnapshot(), color);
+
+                color = testImage(vi, true, true);
+                testResult("vi_clip_tx", vi.getSnapshot(), color);
+
+                color = testImage(vi, true, false);
+                testResult("vi_clip_notx", vi.getSnapshot(), color);
+
+                color = testImage(vi, false, true);
+                testResult("vi_noclip_tx", vi.getSnapshot(), color);
+            } while (vi.contentsLost());
+        }
+
+        BufferedImage bi = new BufferedImage(64, 64, BufferedImage.TYPE_INT_RGB);
+        int color = testImage(bi, false, false);
+        testResult("bi_noclip_notx", bi, color);
+
+        color = testImage(bi, true, true);
+        testResult("bi_clip_tx", bi, color);
+
+        color = testImage(bi, true, false);
+        testResult("bi_clip_notx", bi, color);
+
+        color = testImage(bi, false, true);
+        testResult("bi_noclip_tx", bi, color);
+
+        System.err.println("Test passed.");
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/SunGraphics2D/DrawImageBilinear.java openjdk/jdk/test/sun/java2d/SunGraphics2D/DrawImageBilinear.java
--- openjdk.orig/jdk/test/sun/java2d/SunGraphics2D/DrawImageBilinear.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/SunGraphics2D/DrawImageBilinear.java	2011-01-08 01:26:50.495202471 +0000
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2007-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+/*
+ * @test
+ * @bug 5009033 6603000 6666362
+ * @summary Verifies that images transformed with bilinear filtering do not
+ * leave artifacts at the edges.
+ * @run main/othervm DrawImageBilinear
+ * @run main/othervm -Dsun.java2d.opengl=True DrawImageBilinear
+ * @author campbelc
+ */
+
+import java.awt.Canvas;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Dimension;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GraphicsConfiguration;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.Robot;
+import java.awt.Toolkit;
+import java.awt.image.BufferedImage;
+import java.awt.image.IndexColorModel;
+import java.awt.image.VolatileImage;
+
+public class DrawImageBilinear extends Canvas {
+
+    private static final int SIZE = 5;
+
+    private static boolean done;
+    private BufferedImage bimg1, bimg2;
+    private VolatileImage vimg;
+    private static volatile BufferedImage capture;
+    private static void doCapture(Component test) {
+        // Grab the screen region
+        try {
+            Robot robot = new Robot();
+            Point pt1 = test.getLocationOnScreen();
+            Rectangle rect =
+                new Rectangle(pt1.x, pt1.y, test.getWidth(), test.getHeight());
+            capture = robot.createScreenCapture(rect);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void renderPattern(Graphics g) {
+        g.setColor(Color.red);
+        g.fillRect(0, 0, SIZE, SIZE);
+        //g.setColor(Color.green);
+        //g.drawRect(0, 0, SIZE-1, SIZE-1);
+        g.dispose();
+    }
+
+    public void paint(Graphics g) {
+        Graphics2D g2d = (Graphics2D)g;
+
+        if (bimg1 == null) {
+            bimg1 = (BufferedImage)createImage(SIZE, SIZE);
+            bimg1.setAccelerationPriority(0.0f);
+            renderPattern(bimg1.createGraphics());
+
+            bimg2 = (BufferedImage)createImage(SIZE, SIZE);
+            renderPattern(bimg2.createGraphics());
+
+            vimg = createVolatileImage(SIZE, SIZE);
+            vimg.validate(getGraphicsConfiguration());
+            renderPattern(vimg.createGraphics());
+        }
+
+        do {
+            g2d.setColor(Color.white);
+            g2d.fillRect(0, 0, getWidth(), getHeight());
+
+            g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION,
+                                 RenderingHints.VALUE_INTERPOLATION_BILINEAR);
+
+            // first time will be a sw->surface blit
+            g2d.drawImage(bimg1, 10, 10, 40, 40, null);
+
+            // second time will be a texture->surface blit
+            g2d.drawImage(bimg2, 80, 10, 40, 40, null);
+            g2d.drawImage(bimg2, 80, 10, 40, 40, null);
+
+            // third time will be a pbuffer->surface blit
+            if (vimg.validate(getGraphicsConfiguration()) != VolatileImage.IMAGE_OK) {
+                renderPattern(vimg.createGraphics());
+            }
+            g2d.drawImage(vimg, 150, 10, 40, 40, null);
+
+            Toolkit.getDefaultToolkit().sync();
+        } while (vimg.contentsLost());
+
+        synchronized (this) {
+            if (!done) {
+                doCapture(this);
+                done = true;
+            }
+            notifyAll();
+        }
+    }
+
+    public Dimension getPreferredSize() {
+        return new Dimension(200, 100);
+    }
+
+    private static void testRegion(BufferedImage bi,
+                                   Rectangle affectedRegion)
+    {
+        int x1 = affectedRegion.x;
+        int y1 = affectedRegion.y;
+        int x2 = x1 + affectedRegion.width;
+        int y2 = y1 + affectedRegion.height;
+
+        for (int y = y1; y < y2; y++) {
+            for (int x = x1; x < x2; x++) {
+                int actual = bi.getRGB(x, y);
+                if ((actual != 0xfffe0000) && (actual != 0xffff0000)) {
+                    throw new RuntimeException("Test failed at x="+x+" y="+y+
+                                               " (expected=0xffff0000"+
+                                               " actual=0x"+
+                                               Integer.toHexString(actual) +
+                                               ")");
+                }
+            }
+        }
+    }
+
+    public static void main(String[] args) {
+        boolean show = false;
+        for (String arg : args) {
+            if ("-show".equals(arg)) {
+                show = true;
+            }
+        }
+
+        DrawImageBilinear test = new DrawImageBilinear();
+        Frame frame = new Frame();
+        frame.add(test);
+        frame.pack();
+        frame.setVisible(true);
+
+        // Wait until the component's been painted
+        synchronized (test) {
+            while (!done) {
+                try {
+                    test.wait();
+                } catch (InterruptedException e) {
+                    throw new RuntimeException("Failed: Interrupted");
+                }
+            }
+        }
+
+        GraphicsConfiguration gc = frame.getGraphicsConfiguration();
+        if (gc.getColorModel() instanceof IndexColorModel) {
+            System.out.println("IndexColorModel detected: " +
+                               "test considered PASSED");
+            frame.dispose();
+            return;
+        }
+
+        if (!show) {
+            frame.dispose();
+        }
+        if (capture == null) {
+            throw new RuntimeException("Failed: capture is null");
+        }
+
+        // Test background color
+        int pixel = capture.getRGB(5, 5);
+        if (pixel != 0xffffffff) {
+            throw new RuntimeException("Failed: Incorrect color for " +
+                                       "background");
+        }
+
+        // Test pixels
+        testRegion(capture, new Rectangle(10, 10, 40, 40));
+        testRegion(capture, new Rectangle(80, 10, 40, 40));
+        testRegion(capture, new Rectangle(150, 10, 40, 40));
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/SunGraphics2D/PolyVertTest.java openjdk/jdk/test/sun/java2d/SunGraphics2D/PolyVertTest.java
--- openjdk.orig/jdk/test/sun/java2d/SunGraphics2D/PolyVertTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/SunGraphics2D/PolyVertTest.java	2011-01-08 01:26:50.499202515 +0000
@@ -0,0 +1,661 @@
+/*
+ * Copyright 2002-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 4678208 4771101 6328481 6588884
+ * @summary verify the pixelization of degenerate polylines and polygons
+ * @run main PolyVertTest
+ * @run main/othervm -Dsun.java2d.d3d=True PolyVertTest -hwonly
+ * @run main/othervm -Dsun.java2d.opengl=True PolyVertTest -hwonly
+ */
+
+import java.awt.*;
+import java.awt.event.*;
+import java.awt.geom.*;
+import java.awt.image.*;
+
+public class PolyVertTest {
+    static int TESTWIDTH;
+    static int TESTHEIGHT;
+    static final int REG_TEST_WIDTH = 10;
+    static final int REG_TEST_HEIGHT = 10;
+    static final int FULL_TEST_WIDTH = 50;
+    static final int FULL_TEST_HEIGHT = 200;
+
+    static final int FRINGE = 2;
+    static final int GREEN = Color.green.getRGB();
+    static final int RED   = Color.red.getRGB();
+
+    static BufferedImage refImg;
+    static BufferedImage errorImg;
+    static Graphics errorG;
+    static Component testCanvas;
+
+    static int totalbadpixels;
+    static int totalfuzzypixels;
+    static int numbadtests;
+    static int numfuzzytests;
+    static int numframes;
+    static int fuzzystarty;
+
+    static boolean counting;
+    static boolean showerrors;
+    static boolean showresults;
+    static boolean fringe;
+    static boolean forceerror;
+    static boolean fulltest = true;
+    static boolean hwonly;
+
+    static WindowListener windowCloser = new WindowAdapter() {
+        public void windowClosing(WindowEvent e) {
+            e.getWindow().hide();
+            if (--numframes <= 0) {
+                System.exit(0);
+            }
+        }
+    };
+
+    public PolyVertTest() {
+        /*
+        setBackground(Color.white);
+        setForeground(Color.black);
+        */
+    }
+
+    static int polypts[][][] = {
+        {
+            // void polygon (no points)
+            {}, {},
+        },
+        {
+            // one point
+            { 0 }, { 0 },
+        },
+        {
+            // two points
+            { 0, 5 }, { 0, 0 },
+            { 0, 0, 6, 1,
+              10, 0, 6, 1,
+              20, 0, 6, 1 },
+            { 0, 0, 6, 1,
+              10, 0, 1, 1, 15, 0, 1, 1,
+              20, 0, 1, 1, 25, 0, 1, 1 },
+            { 10, 0, 1, 1,
+              20, 0, 1, 1 },
+        },
+        {
+            // open triangle
+            { 0, 5, 5 }, { 0, 0, 5 },
+
+            { 0, 0, 6, 1, 5, 1, 1, 5,
+
+              10, 0, 6, 1, 15, 1, 1, 5, 11, 1, 1, 1,
+              12, 2, 1, 1, 13, 3, 1, 1, 14, 4, 1, 1,
+
+              20, 0, 6, 1, 25, 1, 1, 5, 21, 1, 1, 1,
+              22, 2, 1, 1, 23, 3, 1, 1, 24, 4, 1, 1 },
+
+            { 0, 0, 6, 1, 5, 1, 1, 5,
+
+              10, 0, 6, 1, 15, 1, 1, 5, 11, 1, 1, 1,
+              12, 2, 1, 1, 13, 3, 1, 1, 14, 4, 1, 1,
+
+              20, 0, 6, 1, 25, 1, 1, 5, 21, 1, 1, 1,
+              22, 2, 1, 1, 23, 3, 1, 1, 24, 4, 1, 1 },
+
+            { 10, 0, 1, 1,
+              20, 0, 1, 1 },
+        },
+        {
+            // closed triangle
+            { 0, 5, 5, 0 }, { 0, 0, 5, 0 },
+
+            { 0, 0, 6, 1, 5, 1, 1, 5, 1, 1, 1, 1,
+              2, 2, 1, 1, 3, 3, 1, 1, 4, 4, 1, 1,
+
+              10, 0, 6, 1, 15, 1, 1, 5, 11, 1, 1, 1,
+              12, 2, 1, 1, 13, 3, 1, 1, 14, 4, 1, 1,
+
+              20, 0, 6, 1, 25, 1, 1, 5, 21, 1, 1, 1,
+              22, 2, 1, 1, 23, 3, 1, 1, 24, 4, 1, 1 },
+
+            { 1, 0, 5, 1, 5, 1, 1, 5, 1, 1, 1, 1,
+              2, 2, 1, 1, 3, 3, 1, 1, 4, 4, 1, 1,
+
+              10, 0, 6, 1, 15, 1, 1, 5, 11, 1, 1, 1,
+              12, 2, 1, 1, 13, 3, 1, 1, 14, 4, 1, 1,
+
+              20, 0, 6, 1, 25, 1, 1, 5, 21, 1, 1, 1,
+              22, 2, 1, 1, 23, 3, 1, 1, 24, 4, 1, 1 },
+
+            { 0, 0, 1, 1,
+              10, 0, 1, 1,
+              20, 0, 1, 1 },
+        },
+        {
+            // empty line
+            { 0, 0 }, { 0, 0 },
+            { 0, 0, 1, 1,
+              10, 0, 1, 1,
+              20, 0, 1, 1 },
+        },
+        {
+            // empty triangle
+            { 0, 0, 0 }, { 0, 0, 0 },
+            { 0, 0, 1, 1,
+              10, 0, 1, 1,
+              20, 0, 1, 1 },
+        },
+    };
+
+    public static void render(Graphics2D g2d) {
+        g2d.setColor(Color.white);
+        g2d.fillRect(0, 0, TESTWIDTH, TESTHEIGHT);
+        g2d.setColor(Color.black);
+
+        if (forceerror) {
+            g2d.fillRect(2, 2, 2, 2);
+            g2d.fillRect(15, 5, 1, 1);
+        }
+
+        if (!fulltest) {
+            g2d.draw(new Rectangle2D.Double(5, 5, 0, 0));
+            return;
+        }
+
+        g2d.drawLine(10, 10, 10, 10);
+        g2d.draw(new Line2D.Double(20, 10, 20, 10));
+
+        g2d.drawRect(10, 20, 0, 0);
+        g2d.draw(new Rectangle2D.Double(20, 20, 0, 0));
+
+        g2d.setXORMode(Color.white);
+
+        g2d.drawLine(10, 30, 10, 30);
+        g2d.draw(new Line2D.Double(20, 30, 20, 30));
+
+        g2d.drawRect(10, 40, 0, 0);
+        g2d.draw(new Rectangle2D.Double(20, 40, 0, 0));
+
+        g2d.setPaintMode();
+
+        int y = 50;
+        for (int i = 0; i < polypts.length; i++) {
+            int data[][] = polypts[i];
+            int xpoints[] = data[0];
+            int ypoints[] = data[1];
+            int npoints = xpoints.length;
+            g2d.translate(10, y);
+            g2d.drawPolyline(xpoints, ypoints, npoints);
+            g2d.translate(10, 0);
+            g2d.drawPolygon(xpoints, ypoints, npoints);
+            g2d.translate(10, 0);
+            g2d.draw(new Polygon(xpoints, ypoints, npoints));
+            g2d.translate(-30, -y);
+            y += 10;
+        }
+        g2d.setXORMode(Color.white);
+        for (int i = 0; i < polypts.length; i++) {
+            int data[][] = polypts[i];
+            int xpoints[] = data[0];
+            int ypoints[] = data[1];
+            int npoints = xpoints.length;
+            g2d.translate(10, y);
+            g2d.drawPolyline(xpoints, ypoints, npoints);
+            g2d.translate(10, 0);
+            g2d.drawPolygon(xpoints, ypoints, npoints);
+            g2d.translate(10, 0);
+            g2d.draw(new Polygon(xpoints, ypoints, npoints));
+            g2d.translate(-30, -y);
+            y += 10;
+        }
+        g2d.setPaintMode();
+    }
+
+    public Dimension getPreferredSize() {
+        return new Dimension(500, 500);
+    }
+
+    public static void usage(int exitcode) {
+        System.err.println("usage: java PolyVertTest [<option>]*");
+        System.err.println("    -usage         "+
+                           "print this usage summary");
+        System.err.println("    -count         "+
+                           "run all tests and accumulate error counts");
+        System.err.println("    -forceerror    "+
+                           "force at least one error in each test");
+        System.err.println("    -fringe        "+
+                           "draw a yellow fringe around problems");
+        System.err.println("    -showerrors    "+
+                           "display results window for tests with problems");
+        System.err.println("    -showresults   "+
+                           "display results window for all tests");
+        System.err.println("    -quicktest     "+
+                           "only run test cases reported in bug reports");
+        System.err.println("    -fulltest      "+
+                           "run full suite of test cases for a 'unit test'");
+        System.err.println("    -hwonly        "+
+                           "only run tests for screen and VolatileImage");
+        System.exit(exitcode);
+    }
+
+    public static void main(String argv[]) {
+        for (int i = 0; i < argv.length; i++) {
+            String arg = argv[i];
+            if (arg.equalsIgnoreCase("-count")) {
+                counting = true;
+            } else if (arg.equalsIgnoreCase("-forceerror")) {
+                forceerror = true;
+            } else if (arg.equalsIgnoreCase("-fringe")) {
+                fringe = true;
+            } else if (arg.equalsIgnoreCase("-showerrors")) {
+                showerrors = true;
+            } else if (arg.equalsIgnoreCase("-showresults")) {
+                showresults = true;
+            } else if (arg.equalsIgnoreCase("-quicktest")) {
+                fulltest = false;
+            } else if (arg.equalsIgnoreCase("-fulltest")) {
+                fulltest = true;
+            } else if (arg.equalsIgnoreCase("-hwonly")) {
+                hwonly = true;
+            } else if (arg.equalsIgnoreCase("-usage")) {
+                usage(0);
+            } else {
+                System.err.println("unknown option: "+arg);
+                usage(1);
+            }
+        }
+
+        if (fulltest) {
+            TESTWIDTH  = FULL_TEST_WIDTH;
+            TESTHEIGHT = FULL_TEST_HEIGHT;
+        } else {
+            TESTWIDTH  = REG_TEST_WIDTH;
+            TESTHEIGHT = REG_TEST_HEIGHT;
+        }
+
+        // Prevents premature exit by the WindowAdapter if the user
+        // closes the last visible results window before we've
+        // finished our tests.
+        numframes++;
+
+        makeReferenceImage();
+        testScreen();
+        testVolatileImage();
+        if (!hwonly) {
+            testBufferedImage();
+            testOffscreen();
+            testCompatibleImages();
+        }
+        if (totalfuzzypixels > 0) {
+            System.err.println(totalfuzzypixels+" fuzzy pixels found in "+
+                               numfuzzytests+" tests");
+        }
+        if (totalbadpixels > 0) {
+            throw new RuntimeException(totalbadpixels+" bad pixels found in "+
+                                       numbadtests+" tests");
+        }
+        System.out.println("Test done - no bad pixels found");
+
+        --numframes;
+
+        if (counting || ((showresults || showerrors) && numframes == 0)) {
+            System.exit(0);
+        }
+    }
+
+    public static void makeReferenceImage() {
+        refImg = new BufferedImage(TESTWIDTH, TESTHEIGHT,
+                                   BufferedImage.TYPE_INT_RGB);
+        Graphics g = refImg.getGraphics();
+
+        g.setColor(Color.white);
+        g.fillRect(0, 0, TESTWIDTH, TESTHEIGHT);
+
+        g.setColor(Color.black);
+
+        if (!fulltest) {
+            g.fillRect(5, 5, 1, 1);
+            g.dispose();
+            return;
+        }
+
+        for (int y = 10; y < 50; y += 10) {
+            g.fillRect(10, y, 1, 1);
+            g.fillRect(20, y, 1, 1);
+        }
+        int y = 50;
+        for (int i = 0; i < polypts.length; i++) {
+            int data[][] = polypts[i];
+            g.translate(10, y);
+            if (data.length > 2) {
+                int rectvals[] = data[2];
+                for (int j = 0; j < rectvals.length; j += 4) {
+                    g.fillRect(rectvals[j+0], rectvals[j+1],
+                               rectvals[j+2], rectvals[j+3]);
+                }
+            }
+            g.translate(-10, -y);
+            y += 10;
+        }
+        fuzzystarty = y;
+        for (int i = 0; i < polypts.length; i++) {
+            int data[][] = polypts[i];
+            g.translate(10, y);
+            if (data.length > 2) {
+                int rectvals[] = data.length > 3 ? data[3] : data[2];
+                for (int j = 0; j < rectvals.length; j += 4) {
+                    g.fillRect(rectvals[j+0], rectvals[j+1],
+                               rectvals[j+2], rectvals[j+3]);
+                }
+            }
+            g.translate(-10, -y);
+            y += 10;
+        }
+        g.dispose();
+    }
+
+    public static void initerrorbuf() {
+        if (errorImg == null) {
+            droperrorbuf();
+            errorImg = new BufferedImage(TESTWIDTH, TESTHEIGHT,
+                                         BufferedImage.TYPE_INT_RGB);
+        }
+        if (errorG == null) {
+            errorG = errorImg.getGraphics();
+        }
+        errorG.setColor(Color.green);
+        errorG.fillRect(0, 0, TESTWIDTH, TESTHEIGHT);
+        errorG.setColor(Color.red);
+    }
+
+    public static void droperrorbuf() {
+        errorImg = null;
+        if (errorG != null) {
+            errorG.dispose();
+        }
+        errorG = null;
+    }
+
+    public static void test(Image img, String name) {
+        Graphics2D g2d = (Graphics2D) img.getGraphics();
+        render(g2d);
+        g2d.dispose();
+        verify(img, name);
+    }
+
+    public static void test(BufferedImage bimg, String name) {
+        Graphics2D g2d = bimg.createGraphics();
+        render(g2d);
+        g2d.dispose();
+        verify(bimg, name);
+    }
+
+    public static void verify(Image img, String name) {
+        BufferedImage bimg;
+        if (img instanceof BufferedImage) {
+            bimg = (BufferedImage) img;
+        } else {
+            bimg = new BufferedImage(TESTWIDTH, TESTHEIGHT,
+                                     BufferedImage.TYPE_INT_RGB);
+            Graphics g = bimg.getGraphics();
+            g.drawImage(img, 0, 0, null);
+            g.dispose();
+        }
+        verify(bimg, name);
+    }
+
+    public static boolean isFuzzyPixel(int X, int Y) {
+        int ytrans = fuzzystarty;
+        if (!fulltest || Y < ytrans) {
+            return false;
+        }
+        for (int i = 0; i < polypts.length; i++) {
+            int data[][] = polypts[i];
+            if (data.length > 4) {
+                int rectvals[] = data[4];
+                for (int j = 0; j < rectvals.length; j += 4) {
+                    int rectx = rectvals[j+0] + 10;
+                    int recty = rectvals[j+1] + ytrans;
+                    int rectw = rectvals[j+2];
+                    int recth = rectvals[j+3];
+                    if (X >= rectx && Y >= recty &&
+                        X < rectx + rectw && Y < recty + recth)
+                    {
+                        return true;
+                    }
+                }
+            }
+            ytrans += 10;
+        }
+        return false;
+    }
+
+    public static void verify(BufferedImage bimg, String name) {
+        int numbadpixels = 0;
+        int numfuzzypixels = 0;
+        for (int y = 0; y < TESTHEIGHT; y++) {
+            for (int x = 0; x < TESTWIDTH; x++) {
+                if (refImg.getRGB(x, y) != bimg.getRGB(x, y)) {
+                    boolean isfuzzy = isFuzzyPixel(x, y);
+                    if (showerrors || showresults) {
+                        if (errorG == null) {
+                            initerrorbuf();
+                        }
+                        errorG.setColor(isfuzzy ? Color.blue : Color.red);
+                        errorG.fillRect(x, y, 1, 1);
+                    } else if (!counting && !isfuzzy) {
+                        throw new RuntimeException("Error at "+x+", "+y+
+                                                   " while testing: "+name);
+                    }
+                    if (isfuzzy) {
+                        numfuzzypixels++;
+                    } else {
+                        numbadpixels++;
+                    }
+                }
+            }
+        }
+        if (numbadpixels > 0 || numfuzzypixels > 0) {
+            if (numbadpixels > 0) {
+                totalbadpixels += numbadpixels;
+                numbadtests++;
+            }
+            if (numfuzzypixels > 0) {
+                totalfuzzypixels += numfuzzypixels;
+                numfuzzytests++;
+            }
+            System.out.println(numbadpixels+" bad pixels and "+
+                               numfuzzypixels+" questionable pixels "+
+                               "found while testing "+name);
+            if (showerrors || showresults) {
+                displaydiffs(bimg, name);
+            }
+        } else if (showresults) {
+            if (errorG == null) {
+                initerrorbuf();
+            }
+            displaydiffs(bimg, name);
+        }
+    }
+
+    public static void displaydiffs(BufferedImage bimg, String name) {
+        if (fringe) {
+            errorG.setColor(Color.yellow);
+            for (int y = 0; y < TESTHEIGHT; y++) {
+                for (int x = 0; x < TESTWIDTH; x++) {
+                    if (errorImg.getRGB(x, y) == RED) {
+                        for (int iy = y-FRINGE; iy <= y+FRINGE; iy++) {
+                            for (int ix = x-FRINGE; ix <= x+FRINGE; ix++) {
+                                if (ix >= 0 && ix < TESTWIDTH &&
+                                    iy >= 0 && iy < TESTHEIGHT &&
+                                    errorImg.getRGB(ix, iy) == GREEN)
+                                {
+                                    errorG.fillRect(ix, iy, 1, 1);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        Frame f = new Frame("Results for "+name);
+        f.setLayout(new BorderLayout());
+        f.addWindowListener(windowCloser);
+        ++numframes;
+        Panel p = new Panel();
+        p.add(new ImageCanvas(bimg));
+        p.add(new ImageCanvas(errorImg));
+        p.add(new ImageCanvas(refImg));
+        f.add(p, "Center");
+        droperrorbuf();
+        f.pack();
+        f.show();
+    }
+
+    public static void testBufferedImage() {
+        testBufferedImage(BufferedImage.TYPE_INT_RGB,        "IntXrgb");
+        testBufferedImage(BufferedImage.TYPE_INT_ARGB,       "IntArgb");
+        testBufferedImage(BufferedImage.TYPE_3BYTE_BGR,      "ThreeByte");
+        testBufferedImage(BufferedImage.TYPE_4BYTE_ABGR,     "FourByte");
+        testBufferedImage(BufferedImage.TYPE_USHORT_555_RGB, "UShort555");
+        testBufferedImage(BufferedImage.TYPE_BYTE_GRAY,      "ByteGray");
+        testBufferedImage(BufferedImage.TYPE_BYTE_INDEXED,   "Indexed");
+    }
+
+    public static void testBufferedImage(int type, String name) {
+        BufferedImage bimg = new BufferedImage(TESTWIDTH, TESTHEIGHT, type);
+        test(bimg, name);
+    }
+
+    public static void testScreen() {
+        Frame f = new Frame("PolyVertTest");
+        TestCanvas child = new TestCanvas();
+        testCanvas = child;
+        f.add(child);
+        f.pack();
+        f.show();
+        BufferedImage bimg = child.getImage();
+        f.hide();
+        verify(bimg, "Screen");
+    }
+
+    public static void testOffscreen() {
+        Image img = testCanvas.createImage(TESTWIDTH, TESTHEIGHT);
+        test(img, "Offscreen");
+    }
+
+    public static void testCompatibleImages() {
+        GraphicsEnvironment genv =
+            GraphicsEnvironment.getLocalGraphicsEnvironment();
+        GraphicsDevice gdevs[] = genv.getScreenDevices();
+        for (int i = 0; i < gdevs.length; i++) {
+            testCompatibleImages(gdevs[i]);
+        }
+    }
+
+    public static void testCompatibleImages(GraphicsDevice gdev) {
+        GraphicsConfiguration gconfigs[] = gdev.getConfigurations();
+        for (int i = 0; i < gconfigs.length; i++) {
+            testCompatibleImages(gconfigs[i]);
+        }
+    }
+
+    public static void testCompatibleImages(GraphicsConfiguration gconfig) {
+        test(gconfig.createCompatibleImage(TESTWIDTH, TESTHEIGHT),
+             gconfig+".createCompat()");
+        test(gconfig.createCompatibleImage(TESTWIDTH, TESTHEIGHT,
+                                           Transparency.OPAQUE),
+             gconfig+".createCompat(OPAQUE)");
+        test(gconfig.createCompatibleImage(TESTWIDTH, TESTHEIGHT,
+                                           Transparency.BITMASK),
+             gconfig+".createCompat(BITMASK)");
+        test(gconfig.createCompatibleImage(TESTWIDTH, TESTHEIGHT,
+                                           Transparency.TRANSLUCENT),
+             gconfig+".createCompat(TRANSLUCENT)");
+        test(gconfig.createCompatibleVolatileImage(TESTWIDTH, TESTHEIGHT),
+             gconfig+".createCompatVolatile()");
+    }
+
+    public static void testVolatileImage() {
+        Image img = testCanvas.createVolatileImage(TESTWIDTH, TESTHEIGHT);
+        test(img, "Volatile");
+    }
+
+    public static class ImageCanvas extends Canvas {
+        BufferedImage bimg;
+
+        public ImageCanvas(BufferedImage bimg) {
+            this.bimg = bimg;
+        }
+
+        public Dimension getPreferredSize() {
+            return new Dimension(bimg.getWidth(), bimg.getHeight());
+        }
+
+        public void paint(Graphics g) {
+            g.drawImage(bimg, 0, 0, null);
+        }
+    }
+
+    public static class TestCanvas extends Canvas {
+        BufferedImage bimg;
+
+        public Dimension getPreferredSize() {
+            return new Dimension(TESTWIDTH, TESTHEIGHT);
+        }
+
+        public void paint(Graphics g) {
+            if (bimg != null ||
+                getWidth() < TESTWIDTH ||
+                getHeight() < TESTHEIGHT)
+            {
+                return;
+            }
+            render((Graphics2D) g);
+            Toolkit.getDefaultToolkit().sync();
+            Point p = getLocationOnScreen();
+            Rectangle r = new Rectangle(p.x, p.y, TESTWIDTH, TESTHEIGHT);
+            try {
+                bimg = new Robot().createScreenCapture(r);
+            } catch (AWTException e) {
+                e.printStackTrace();
+            }
+            synchronized (this) {
+                notifyAll();
+            }
+        }
+
+        public synchronized BufferedImage getImage() {
+            while (bimg == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    return null;
+                }
+            }
+            return bimg;
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/SunGraphics2D/SimplePrimQuality.java openjdk/jdk/test/sun/java2d/SunGraphics2D/SimplePrimQuality.java
--- openjdk.orig/jdk/test/sun/java2d/SunGraphics2D/SimplePrimQuality.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/SunGraphics2D/SimplePrimQuality.java	2011-01-08 01:26:50.499202515 +0000
@@ -0,0 +1,281 @@
+/*
+ * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 4832224 6322584 6328478 6328481 6322580 6588884 6587863
+ * @summary Verifies that the pixelization of simple primitives (drawLine,
+ * fillRect, drawRect, fill, draw) with the OGL pipeline enabled
+ * matches that produced by our software loops.  (The primitives tested here
+ * are simple enough that the OGL results should match the software results
+ * exactly.)  There is some overlap with PolyVertTest as we test both
+ * solid and XOR rendering here, but this testcase is a bit simpler and
+ * more appropriate for quick OGL testing.  This test is also useful for
+ * comparing quality between our X11/GDI and software pipelines.
+ * @run main/othervm SimplePrimQuality
+ * @run main/othervm -Dsun.java2d.opengl=True SimplePrimQuality
+ * @author campbelc
+ */
+
+import java.awt.*;
+import java.awt.geom.*;
+import java.awt.image.*;
+import java.io.File;
+import java.io.IOException;
+import javax.imageio.ImageIO;
+
+public class SimplePrimQuality extends Canvas {
+
+    private static final int SIZE = 300;
+    private static boolean done;
+    private static boolean testVI;
+    private static volatile BufferedImage capture;
+    private static void doCapture(Component test) {
+        // Grab the screen region
+        try {
+            Robot robot = new Robot();
+            Point pt1 = test.getLocationOnScreen();
+            Rectangle rect =
+                new Rectangle(pt1.x, pt1.y, test.getWidth(), test.getHeight());
+            capture = robot.createScreenCapture(rect);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static final int[][] rpts = {
+        {2, 0, 0, 0},
+        {12, 0, 1, 0},
+        {22, 0, 0, 1},
+        {32, 0, 1, 1},
+        {42, 0, 2, 1},
+        {52, 0, 1, 2},
+        {62, 0, 2, 2},
+        {72, 0, 5, 5},
+        {82, 0, 10, 10},
+        {97, 0, 15, 15},
+    };
+
+    private void drawLine(Graphics2D g, int x, int y, int dx, int dy) {
+        g.drawLine(x, y, x + dx, y + dy);
+    }
+
+    private void drawLines(Graphics2D g, int s) {
+        drawLine(g, 2, 0, 0, 0);
+        drawLine(g, 12, 0, 0, s);
+        drawLine(g, 22, 0, s, 0);
+        drawLine(g, 32, 0, s, s);
+        drawLine(g, 42, 0, 0, -s);
+        drawLine(g, 52, 0, -s, 0);
+        drawLine(g, 62, 0, -s, -s);
+        drawLine(g, 72, 0, -s, s);
+        drawLine(g, 82, 0, s, -s);
+    }
+
+    private void fillRects(Graphics2D g) {
+        for (int i = 0; i < rpts.length; i++) {
+            g.fillRect(rpts[i][0], rpts[i][1], rpts[i][2], rpts[i][3]);
+        }
+    }
+
+    private void drawRects(Graphics2D g) {
+        for (int i = 0; i < rpts.length; i++) {
+            g.drawRect(rpts[i][0], rpts[i][1], rpts[i][2], rpts[i][3]);
+        }
+    }
+
+    private void fillOvals(Graphics2D g) {
+        for (int i = 0; i < rpts.length; i++) {
+            // use fill() instead of fillOval(), since the former is more
+            // likely to be consistent with our software loops when the
+            // OGL pipeline cannot be enabled
+            g.fill(new Ellipse2D.Float(rpts[i][0], rpts[i][1],
+                                       rpts[i][2], rpts[i][3]));
+        }
+    }
+
+    private void drawOvals(Graphics2D g) {
+        for (int i = 0; i < rpts.length; i++) {
+            // use draw() instead of drawOval(), since the former is more
+            // likely to be consistent with our software loops when the
+            // OGL pipeline cannot be enabled
+            g.draw(new Ellipse2D.Float(rpts[i][0], rpts[i][1],
+                                       rpts[i][2], rpts[i][3]));
+        }
+    }
+
+    private void renderShapes(Graphics2D g) {
+        // drawLine tests...
+        g.translate(0, 5);
+        drawLines(g, 1);
+        g.translate(0, 10);
+        drawLines(g, 4);
+
+        // fillRect tests...
+        g.translate(0, 10);
+        fillRects(g);
+
+        // drawRect tests...
+        g.translate(0, 20);
+        drawRects(g);
+
+        // fillOval tests...
+        g.translate(0, 20);
+        fillOvals(g);
+
+        // drawOval tests...
+        g.translate(0, 20);
+        drawOvals(g);
+    }
+
+    private void renderTest(Graphics2D g, int w, int h) {
+        // on the left side, render the shapes in solid mode
+        g.setColor(Color.black);
+        g.fillRect(0, 0, w, h);
+        g.setColor(Color.green);
+        renderShapes(g);
+
+        // on the right side, render the shapes in XOR mode
+        g.setTransform(AffineTransform.getTranslateInstance(SIZE/2, 0));
+        g.setXORMode(Color.black);
+        renderShapes(g);
+        g.setTransform(AffineTransform.getTranslateInstance(SIZE/2, 0));
+        renderShapes(g);
+    }
+
+    public void paint(Graphics g) {
+
+        Graphics2D g2d = (Graphics2D)g;
+        renderTest(g2d, SIZE, SIZE);
+
+        Toolkit.getDefaultToolkit().sync();
+
+        synchronized (this) {
+            if (!done) {
+                doCapture(this);
+                done = true;
+            }
+            notifyAll();
+        }
+    }
+
+    public Dimension getPreferredSize() {
+        return new Dimension(SIZE, SIZE);
+    }
+
+    public static void main(String[] args) {
+        boolean show = false;
+        for (String arg : args) {
+            if (arg.equals("-testvi")) {
+                System.out.println("Testing VolatileImage, not screen");
+                testVI = true;
+            } else if (arg.equals("-show")) {
+                show = true;
+            }
+        }
+
+        SimplePrimQuality test = new SimplePrimQuality();
+        Frame frame = new Frame();
+        frame.add(test);
+        frame.pack();
+        frame.setVisible(true);
+
+        // Wait until the component's been painted
+        synchronized (test) {
+            while (!done) {
+                try {
+                    test.wait();
+                } catch (InterruptedException e) {
+                    throw new RuntimeException("Failed: Interrupted");
+                }
+            }
+        }
+
+        // REMIND: We will allow this test to pass silently on Windows
+        // (when OGL is not enabled) until we fix the GDI pipeline so that
+        // its stroked/filled GeneralPaths match our software loops (see
+        // 6322554).  This check should be removed when 6322554 is fixed.
+        GraphicsConfiguration gc = frame.getGraphicsConfiguration();
+        if (gc.getClass().getSimpleName().startsWith("Win")) {
+            System.out.println("GDI pipeline detected: " +
+                               "test considered PASSED");
+            frame.dispose();
+            return;
+        }
+
+
+        if (testVI) {
+            // render to a VI instead of the screen
+            VolatileImage vi = frame.createVolatileImage(SIZE, SIZE);
+            do {
+                vi.validate(frame.getGraphicsConfiguration());
+                Graphics2D g1 = vi.createGraphics();
+                test.renderTest(g1, SIZE, SIZE);
+                g1.dispose();
+                capture = vi.getSnapshot();
+            } while (vi.contentsLost());
+            frame.dispose();
+        }
+
+        if (!show) {
+            frame.dispose();
+        }
+        if (capture == null) {
+            throw new RuntimeException("Error capturing the rendering");
+        }
+
+        // Create reference image
+        int w = SIZE, h = SIZE;
+        BufferedImage refimg = new BufferedImage(w, h,
+                                                 BufferedImage.TYPE_INT_RGB);
+        Graphics2D g = refimg.createGraphics();
+        test.renderTest(g, w, h);
+        g.dispose();
+
+        // Test pixels
+        for (int y = 0; y < h; y++) {
+            for (int x = 0; x < w; x++) {
+                int actual = capture.getRGB(x, y);
+                int expected = refimg.getRGB(x, y);
+                if (actual != expected) {
+                    String expectedName = "SimplePrimQuality_expected.png";
+                    String actualName = "SimplePrimQuality_actual.png";
+                    try {
+                        System.out.println("Writing expected image to: "+
+                                           expectedName);
+                        ImageIO.write(refimg, "png", new File(expectedName));
+                        System.out.println("Writing actual image   to: "+
+                                           actualName);
+                        ImageIO.write(capture, "png", new File(actualName));
+                    } catch (IOException ex) {}
+                    throw new RuntimeException("Test failed at x="+x+" y="+y+
+                                               " (expected="+
+                                               Integer.toHexString(expected) +
+                                               " actual="+
+                                               Integer.toHexString(actual) +
+                                               ")");
+                }
+            }
+        }
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/SunGraphics2D/SourceClippingBlitTest/SourceClippingBlitTest.java openjdk/jdk/test/sun/java2d/SunGraphics2D/SourceClippingBlitTest/SourceClippingBlitTest.java
--- openjdk.orig/jdk/test/sun/java2d/SunGraphics2D/SourceClippingBlitTest/SourceClippingBlitTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/SunGraphics2D/SourceClippingBlitTest/SourceClippingBlitTest.java	2011-01-08 01:26:50.499202515 +0000
@@ -0,0 +1,295 @@
+/*
+ * Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+  @test
+  @bug 6244574
+  @bug 6258142
+  @bug 6395165
+  @bug 6588884
+  @summary Tests that source is clipped correctly when blitting
+  different types of images to the screen
+  @author Dmitri.Trembovetski: area=Graphics2D
+  @run main SourceClippingBlitTest
+*/
+
+import java.awt.AWTException;
+import java.awt.Canvas;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.GraphicsConfiguration;
+import java.awt.Image;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.Robot;
+import java.awt.Toolkit;
+import java.awt.Transparency;
+import java.awt.event.ComponentAdapter;
+import java.awt.event.ComponentEvent;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.image.BufferedImage;
+import java.awt.image.VolatileImage;
+
+public class SourceClippingBlitTest extends Canvas {
+    static final int TESTW = 300;
+    static final int TESTH = 300;
+    static final int IMAGEW = 50;
+    static final int IMAGEH = 50;
+
+    static final Rectangle IMAGE_BOUNDS = new Rectangle(0, 0, IMAGEW, IMAGEH);
+    static Robot robot;
+    static private boolean showErrors;
+
+    private static final Object lock = new Object();
+    private static volatile boolean done = false;
+
+    BufferedImage grabbedBI;
+
+    public static void main(String[] args) {
+        // allow user to override the properties if needed
+        if (System.getProperty("sun.java2d.pmoffscreen") == null) {
+            System.setProperty("sun.java2d.pmoffscreen", "true");
+        }
+
+        if (args.length > 0 && args[0].equals("-showerrors")) {
+            showErrors = true;
+        }
+
+        try {
+            robot = new Robot();
+        } catch (AWTException e) {
+            throw new RuntimeException(e);
+        }
+
+        Frame f = new Frame(SourceClippingBlitTest.class.getName());
+        final SourceClippingBlitTest test = new SourceClippingBlitTest();
+        f.add(test);
+        f.addWindowListener(new WindowAdapter() {
+            public void windowActivated(WindowEvent e) {
+                if (!done) {
+                    test.runTests();
+                }
+            }
+
+        });
+        f.pack();
+        f.setLocation(100, 100);
+        f.setVisible(true);
+        synchronized (lock) {
+            while (!done) {
+                try {
+                    lock.wait();
+                } catch (InterruptedException ex) {
+                    ex.printStackTrace();
+                }
+            }
+        }
+        if (!showErrors) {
+            f.dispose();
+        }
+    }
+
+    public Dimension getPreferredSize() {
+        return new Dimension(TESTW, TESTH);
+    }
+
+    public void paint(Graphics g) {
+        if (showErrors && done && grabbedBI != null) {
+            g.drawImage(grabbedBI, 0, 0, null);
+        }
+    }
+
+    public void runTests() {
+        GraphicsConfiguration gc = getGraphicsConfiguration();
+        for (Image srcIm :
+            new Image[] {
+                getBufferedImage(gc, IMAGEW, IMAGEH,
+                        BufferedImage.TYPE_INT_RGB, true),
+                getBufferedImage(gc, IMAGEW, IMAGEH,
+                        BufferedImage.TYPE_INT_RGB, false),
+                // commented out due to 6593406
+//                getBMImage(gc, IMAGEW, IMAGEH),
+//                getBufferedImage(gc, IMAGEW, IMAGEH,
+//                        BufferedImage.TYPE_INT_ARGB, true),
+//                getBufferedImage(gc, IMAGEW, IMAGEH,
+//                        BufferedImage.TYPE_INT_ARGB, false),
+                getVImage(gc, IMAGEW, IMAGEH),
+            })
+        {
+            System.out.println("Testing source: " + srcIm);
+            // wiggle the source and dest rectangles
+            try {
+                for (int locationVar = -10; locationVar < 20; locationVar += 10)
+                {
+                    for (int sizeVar = -10; sizeVar < 20; sizeVar += 10) {
+                        Rectangle srcRect = (Rectangle)IMAGE_BOUNDS.clone();
+                        srcRect.translate(locationVar, locationVar);
+                        srcRect.grow(sizeVar, sizeVar);
+
+                        Rectangle dstRect =
+                                new Rectangle(sizeVar, sizeVar,
+                                srcRect.width, srcRect.height);
+                        System.out.println("testing blit rect src: " + srcRect);
+                        System.out.println("                  dst: " + dstRect);
+                        render(getGraphics(), srcIm, srcRect, dstRect);
+                        test(srcRect, dstRect);
+                    }
+                }
+                System.out.println("Test passed.");
+            } finally {
+                synchronized (lock) {
+                    done = true;
+                    lock.notifyAll();
+                }
+            }
+        }
+    }
+
+    public void render(Graphics g, Image image,
+                       Rectangle srcRect, Rectangle dstRect)
+    {
+        int w = getWidth();
+        int h = getHeight();
+        g.setColor(Color.green);
+        g.fillRect(0, 0, w, h);
+
+        int bltWidth = srcRect.width;
+        int bltHeight = srcRect.height;
+        VolatileImage vi = null;
+        if (image instanceof VolatileImage) {
+            vi = (VolatileImage)image;
+        }
+        do {
+            if (vi != null) {
+                GraphicsConfiguration gc = getGraphicsConfiguration();
+                if (vi.validate(gc) != VolatileImage.IMAGE_OK) {
+                    initImage(gc, vi);
+                }
+            }
+            g.drawImage(image,
+                    dstRect.x, dstRect.y,
+                    dstRect.x + bltWidth, dstRect.y + bltHeight,
+                    srcRect.x, srcRect.y,
+                    srcRect.x + bltWidth, srcRect.y + bltHeight,
+                    Color.red,
+                    null);
+        } while (vi != null && vi.contentsLost());
+    }
+
+
+    public void test(Rectangle srcRect, Rectangle dstRect) {
+        int w = getWidth();
+        int h = getHeight();
+        Toolkit.getDefaultToolkit().sync();
+        Point p = getLocationOnScreen();
+        grabbedBI = robot.createScreenCapture(new Rectangle(p.x, p.y, w, h));
+
+        // calculate the destination rectangle
+        Rectangle srcBounds = srcRect.intersection(IMAGE_BOUNDS);
+        int trX = dstRect.x - srcRect.x;
+        int trY = dstRect.y - srcRect.y;
+        Rectangle newDstRect = (Rectangle)dstRect.clone();
+        newDstRect.translate(-trX, -trY);
+        Rectangle.intersect(newDstRect, srcBounds, newDstRect);
+        newDstRect.translate(trX, trY);
+        Rectangle.intersect(newDstRect, new Rectangle(0, 0, w, h), newDstRect);
+
+        System.out.println("calculated dest rect:" + newDstRect);
+
+        // we do implicit clipping of the destination surface
+        // by only checking pixels within its bounds
+        for (int y = 0; y < h; y++) {
+            for (int x = 0; x < w; x++) {
+                int rgb = 0;
+                if (newDstRect.contains(x, y)) {
+                    rgb = Color.red.getRGB();
+                } else {
+                    rgb = Color.green.getRGB();
+                }
+                if (grabbedBI.getRGB(x, y) != rgb) {
+                    String msg1 = "Test failed at x="+x+" y="+y;
+                    System.out.println(msg1);
+                    System.out.println(" expected: "+Integer.toHexString(rgb)+
+                            " got:"+Integer.toHexString(grabbedBI.getRGB(x, y)));
+                    throw new RuntimeException(msg1);
+                }
+            }
+        }
+        System.out.println("subtest passed");
+    }
+
+    static VolatileImage dstImage;
+    static void initImage(GraphicsConfiguration gc, Image image) {
+        Graphics g = image.getGraphics();
+        g.setColor(Color.RED);
+        int w = image.getWidth(null);
+        int h = image.getHeight(null);
+        g.fillRect(0, 0, w, h);
+        g.dispose();
+
+        // need to 'accelerate' the image
+        if (dstImage == null) {
+            dstImage =
+                gc.createCompatibleVolatileImage(TESTW, TESTH,
+                                                 Transparency.OPAQUE);
+        }
+        dstImage.validate(gc);
+        g = dstImage.getGraphics();
+        g.drawImage(image, 0, 0, null);
+        g.drawImage(image, 0, 0, null);
+        g.drawImage(image, 0, 0, null);
+    }
+
+    static VolatileImage getVImage(GraphicsConfiguration gc,
+                                   int w, int h)
+    {
+        VolatileImage image =
+            gc.createCompatibleVolatileImage(w, h, Transparency.OPAQUE);
+        image.validate(gc);
+        initImage(gc, image);
+        return image;
+    }
+
+    static Image getBMImage(GraphicsConfiguration gc,
+                            int w, int h)
+    {
+        Image image =
+            gc.createCompatibleImage(w, h, Transparency.BITMASK);
+        initImage(gc, image);
+        return image;
+    }
+
+    static Image getBufferedImage(GraphicsConfiguration gc,
+                                  int w, int h, int type, boolean acceleratable)
+    {
+        BufferedImage image = new BufferedImage(w, h, type);
+        if (!acceleratable) {
+            image.setAccelerationPriority(0.0f);
+        }
+        initImage(gc, image);
+        return image;
+    }
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/X11SurfaceData/SharedMemoryPixmapsTest/SharedMemoryPixmapsTest.java openjdk/jdk/test/sun/java2d/X11SurfaceData/SharedMemoryPixmapsTest/SharedMemoryPixmapsTest.java
--- openjdk.orig/jdk/test/sun/java2d/X11SurfaceData/SharedMemoryPixmapsTest/SharedMemoryPixmapsTest.java	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/X11SurfaceData/SharedMemoryPixmapsTest/SharedMemoryPixmapsTest.java	2011-01-08 01:26:50.499202515 +0000
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.awt.AWTException;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Dimension;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.Robot;
+import java.awt.Toolkit;
+import java.awt.image.BufferedImage;
+import java.awt.image.VolatileImage;
+
+/*
+ *
+ *
+ * Tests that the use of shared memory pixmaps isn't broken:
+ * create a VolatileImage, fill it with red color, copy it to the screen
+ * make sure the pixels on the screen are red.
+ *
+ * Note that we force the use of shared memory pixmaps in the shell script.
+ *
+ * @author Dmitri.Trembovetski
+ */
+
+public class SharedMemoryPixmapsTest {
+    static final int IMAGE_SIZE = 100;
+    static boolean show = false;
+    final Frame testFrame;
+    /** Creates a new instance of SharedMemoryPixmapsTest */
+    public SharedMemoryPixmapsTest() {
+        testFrame = new Frame("SharedMemoryPixmapsTest");
+        testFrame.add(new TestComponent());
+        testFrame.pack();
+        testFrame.setVisible(true);
+    }
+
+    public static void main(String[] args) {
+        for (String s : args) {
+            if ("-show".equals(s)) {
+                show = true;
+            } else {
+                System.err.println("Usage: SharedMemoryPixmapsTest [-show]");
+            }
+        }
+        new SharedMemoryPixmapsTest();
+    }
+
+    private class TestComponent extends Component {
+        VolatileImage vi = null;
+        boolean tested = false;
+
+        void initVI() {
+            int res;
+            if (vi == null) {
+                res = VolatileImage.IMAGE_INCOMPATIBLE;
+            } else {
+                res = vi.validate(getGraphicsConfiguration());
+            }
+            if (res == VolatileImage.IMAGE_INCOMPATIBLE) {
+                if (vi != null) vi.flush();
+                vi = createVolatileImage(IMAGE_SIZE, IMAGE_SIZE);
+                vi.validate(getGraphicsConfiguration());
+                res = VolatileImage.IMAGE_RESTORED;
+            }
+            if (res == VolatileImage.IMAGE_RESTORED) {
+                Graphics vig = vi.getGraphics();
+                vig.setColor(Color.red);
+                vig.fillRect(0, 0, vi.getWidth(), vi.getHeight());
+                vig.dispose();
+            }
+        }
+
+        @Override
+        public synchronized void paint(Graphics g) {
+            do {
+                g.setColor(Color.green);
+                g.fillRect(0, 0, getWidth(), getHeight());
+
+                initVI();
+                g.drawImage(vi, 0, 0, null);
+            } while (vi.contentsLost());
+
+            Toolkit.getDefaultToolkit().sync();
+            if (!tested) {
+                if (testRendering()) {
+                    System.err.println("Test Passed");
+                } else {
+                    System.err.println("Test Failed");
+                }
+                tested = true;
+            }
+            if (!show) {
+                testFrame.setVisible(false);
+                testFrame.dispose();
+            }
+        }
+
+        private boolean testRendering() throws RuntimeException {
+            Robot r = null;
+            try {
+                r = new Robot();
+            } catch (AWTException ex) {
+                ex.printStackTrace();
+                throw new RuntimeException("Can't create Robot");
+            }
+            Point p = getLocationOnScreen();
+            BufferedImage b =
+                r.createScreenCapture(new Rectangle(p, getPreferredSize()));
+            for (int y = 0; y < b.getHeight(); y++) {
+                for (int x = 0; x < b.getWidth(); x++) {
+                    if (b.getRGB(x, y) != Color.red.getRGB()) {
+                        System.err.println("Incorrect pixel" + " at "
+                            + x + "x" + y + " : " +
+                            Integer.toHexString(b.getRGB(x, y)));
+                        if (show) {
+                            return false;
+                        }
+                        System.err.println("Test Failed");
+                        System.exit(1);
+                    }
+                }
+            }
+            return true;
+        }
+
+        @Override
+        public Dimension getPreferredSize() {
+            return new Dimension(IMAGE_SIZE, IMAGE_SIZE);
+        }
+    }
+
+}
diff -Nru openjdk.orig/jdk/test/sun/java2d/X11SurfaceData/SharedMemoryPixmapsTest/SharedMemoryPixmapsTest.sh openjdk/jdk/test/sun/java2d/X11SurfaceData/SharedMemoryPixmapsTest/SharedMemoryPixmapsTest.sh
--- openjdk.orig/jdk/test/sun/java2d/X11SurfaceData/SharedMemoryPixmapsTest/SharedMemoryPixmapsTest.sh	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/sun/java2d/X11SurfaceData/SharedMemoryPixmapsTest/SharedMemoryPixmapsTest.sh	2011-01-08 01:26:50.499202515 +0000
@@ -0,0 +1,51 @@
+#
+# Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+# CA 95054 USA or visit www.sun.com if you need additional information or
+# have any questions.
+#
+
+#!/bin/sh
+# @test
+# @bug 6363434 6588884
+# @summary Verify that shared memory pixmaps are not broken
+# by filling a VolatileImage with red color and copying it
+# to the screen.
+# Note that we force the use of shared memory pixmaps.
+# @author Dmitri.Trembovetski
+
+echo "TESTJAVA=${TESTJAVA}"
+echo "TESTSRC=${TESTSRC}"
+echo "TESTCLASSES=${TESTCLASSES}"
+cd ${TESTSRC}
+${TESTJAVA}/bin/javac -d ${TESTCLASSES} SharedMemoryPixmapsTest.java
+cd ${TESTCLASSES}
+
+NO_J2D_DGA=true
+J2D_PIXMAPS=shared
+export NO_J2D_DGA J2D_PIXMAPS
+
+${TESTJAVA}/bin/java SharedMemoryPixmapsTest
+
+if [ $? -ne 0 ]; then
+  echo "Test failed!"
+  exit 1
+fi
+
+exit 0

--- openjdk/hotspot/src/os/linux/vm/os_linux.cpp.orig	2008-07-27 08:37:02.000000000 +0000
+++ openjdk/hotspot/src/os/linux/vm/os_linux.cpp	2008-07-27 08:43:41.000000000 +0000
@@ -159,7 +159,9 @@
 #endif
 
 // Cpu architecture string
-#if   defined(IA64)
+#if   defined(ZERO)
+static char cpu_arch[] = ZERO_LIBARCH;
+#elif defined(IA64)
 static char cpu_arch[] = "ia64";
 #elif defined(IA32)
 static char cpu_arch[] = "i386";
@@ -1665,7 +1667,14 @@
     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)"Sparc 32"},
     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)"Sparc v9 64"},
     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)"Power PC 32"},
-    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)"Power PC 64"}
+    {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)"Power PC 64"},
+    {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)"ARM"},
+    {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)"IBM System/390"},
+    {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)"Alpha"},
+    {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)"MIPSel"},
+    {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)"MIPS"},
+    {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)"PARISC"},
+    {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)"M68k"}
   };
 
   #if  (defined IA32)
@@ -1682,9 +1691,23 @@
     static  Elf32_Half running_arch_code=EM_PPC64; 
   #elif  (defined __powerpc__)  
     static  Elf32_Half running_arch_code=EM_PPC; 
+  #elif  (defined ARM)
+    static  Elf32_Half running_arch_code=EM_ARM;
+  #elif  (defined S390)
+    static  Elf32_Half running_arch_code=EM_S390;
+  #elif  (defined ALPHA)
+    static  Elf32_Half running_arch_code=EM_ALPHA;
+  #elif  (defined MIPSEL)
+    static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;
+  #elif  (defined PARISC)
+    static  Elf32_Half running_arch_code=EM_PARISC;
+  #elif  (defined MIPS)
+    static  Elf32_Half running_arch_code=EM_MIPS;
+  #elif  (defined M68K)
+    static  Elf32_Half running_arch_code=EM_68K;
   #else
     #error Method os::dll_load requires that one of following is defined:\
-         IA32, AMD64, IA64, __sparc, __powerpc__
+         IA32, AMD64, IA64, __sparc, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K
   #endif
 
   // Identify compatability class for VM's architecture and library's architecture
@@ -1716,10 +1739,12 @@
     return NULL; 
   }
 
+#ifndef S390
   if (lib_arch.elf_class != arch_array[running_arch_index].elf_class) {
     ::snprintf(diag_msg_buf, diag_msg_max_length-1," (Possible cause: architecture word width mismatch)");
     return NULL; 
   }
+#endif // !S390
 
   if (lib_arch.compat_class != arch_array[running_arch_index].compat_class) {
     if ( lib_arch.name!=NULL ) {
@@ -2354,7 +2379,9 @@
     // format has been changed), we'll use the largest page size supported by
     // the processor.
 
+#ifndef ZERO
     _large_page_size = IA32_ONLY(4 * M) AMD64_ONLY(2 * M) IA64_ONLY(256 * M) SPARC_ONLY(4 * M);
+#endif
 
     FILE *fp = fopen("/proc/meminfo", "r");
     if (fp) {
--- openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp.orig	2008-07-27 08:37:03.000000000 +0000
+++ openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp	2008-07-27 08:38:13.000000000 +0000
@@ -424,7 +421,9 @@
 #ifdef ASSERT
   if (istate->_msg != initialize) {
     assert(abs(istate->_stack_base - istate->_stack_limit) == (istate->_method->max_stack() + 1), "bad stack limit");
-   IA32_ONLY(assert(istate->_stack_limit == istate->_thread->last_Java_sp() + 1, "wrong"));
+#if defined(IA32) && !defined(ZERO)
+    assert(istate->_stack_limit == istate->_thread->last_Java_sp() + 1, "wrong");
+#endif // IA32 && !ZERO
   }
   // Verify linkages.
   interpreterState l = istate;
@@ -3030,9 +3030,9 @@
   tty->print_cr("&native_fresult: " INTPTR_FORMAT, (uintptr_t) &this->_native_fresult);
   tty->print_cr("native_lresult: " INTPTR_FORMAT, (uintptr_t) this->_native_lresult);
 #endif
-#ifdef IA64
+#if defined(IA64) && !defined(ZERO)
   tty->print_cr("last_Java_fp: " INTPTR_FORMAT, (uintptr_t) this->_last_Java_fp);
-#endif // IA64
+#endif // IA64 && !ZERO
   tty->print_cr("self_link: " INTPTR_FORMAT, (uintptr_t) this->_self_link);
 }
 
--- openjdk/hotspot/src/share/vm/runtime/mutex.hpp.orig	2008-07-27 08:37:02.000000000 +0000
+++ openjdk/hotspot/src/share/vm/runtime/mutex.hpp	2008-07-27 08:38:13.000000000 +0000
@@ -61,18 +61,10 @@
 } ;
 
 // Endian-ness ... index of least-significant byte in SplitWord.Bytes[]
-#ifdef AMD64        // little
+#ifdef VM_LITTLE_ENDIAN
  #define _LSBINDEX 0
 #else
-#if IA32            // little
- #define _LSBINDEX 0
-#else
-#ifdef SPARC        // big
  #define _LSBINDEX (sizeof(intptr_t)-1)
-#else
- #error "unknown architecture"
-#endif
-#endif
 #endif
 
 class ParkEvent ;
--- openjdk/hotspot/src/share/vm/runtime/jniHandles.hpp.orig	2008-07-27 08:37:02.000000000 +0000
+++ openjdk/hotspot/src/share/vm/runtime/jniHandles.hpp	2008-07-27 08:38:13.000000000 +0000
@@ -126,9 +126,17 @@
   // Fill block with bad_handle values
   void zap();
 
+#ifdef ZERO
+ protected:
+  friend class CppInterpreter;
+#endif // ZERO
+
   // No more handles in the both the current and following blocks
   void clear() { _top = 0; }
 
+#ifdef ZERO
+ private:
+#endif // ZERO
   // Free list computation
   void rebuild_free_list();
 
--- openjdk/hotspot/src/share/vm/utilities/vmError.cpp.orig	2008-07-27 08:37:02.000000000 +0000
+++ openjdk/hotspot/src/share/vm/utilities/vmError.cpp	2008-07-27 08:38:13.000000000 +0000
@@ -462,6 +462,40 @@
 
      if (_verbose && _thread && _thread->is_Java_thread()) {
        JavaThread* jt = (JavaThread*)_thread;
+#ifdef ZERO
+       if (jt->zero_stack()->sp() && jt->top_zero_frame()) {
+         // StackFrameStream uses the frame anchor, which may not have
+         // been set up.  This can be done at any time in Zero, however,
+         // so if it hasn't been set up then we just set it up now and
+         // clear it again when we're done.
+         bool has_last_Java_frame = jt->has_last_Java_frame();
+         if (!has_last_Java_frame)
+           jt->set_last_Java_frame();
+         st->print("Java frames:");
+  
+         // If the top frame is a Shark frame and the frame anchor isn't
+         // set up then it's possible that the information in the frame
+         // is garbage: it could be from a previous decache, or it could
+         // simply have never been written.  So we print a warning...
+         StackFrameStream sfs(jt);
+         if (!has_last_Java_frame && !sfs.is_done()) {
+           if (sfs.current()->zeroframe()->is_shark_frame()) {
+             st->print(" (TOP FRAME MAY BE JUNK)");
+           }
+         }
+         st->cr();
+  
+         // Print the frames
+         for(int i = 0; !sfs.is_done(); sfs.next(), i++) {
+           sfs.current()->zero_print_on_error(i, st, buf, sizeof(buf));
+           st->cr();
+         }
+  
+         // Reset the frame anchor if necessary
+         if (!has_last_Java_frame)
+           jt->reset_last_Java_frame();
+       }
+#else
        if (jt->has_last_Java_frame()) {
          st->print_cr("Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)");
          for(StackFrameStream sfs(jt); !sfs.is_done(); sfs.next()) {
@@ -469,6 +503,7 @@
            st->cr();
          }
        }
+#endif // ZERO
      }
 
   STEP(140, "(printing VM operation)" )

Index: openjdk/hotspot/src/share/vm/runtime/jniHandles.cpp
===================================================================
--- openjdk/hotspot/src/share/vm/runtime/jniHandles.cpp.orig	2009-06-10 11:30:46.000000000 +0200
+++ openjdk/hotspot/src/share/vm/runtime/jniHandles.cpp	2009-06-10 11:37:07.000000000 +0200
@@ -173,7 +173,11 @@
   // is not permitted.
   return (thr->has_last_Java_frame() &&
          (void*)obj < (void*)thr->stack_base() &&
+#ifdef ZERO
+         (void*)obj >= (void*)os::current_stack_pointer());
+#else
          (void*)obj >= (void*)thr->last_Java_sp());
+#endif // ZERO
 }
 
 
--- openjdk/hotspot/src/share/vm/includeDB_core	2009-09-08 13:22:25.000000000 +0100
+++ openjdk/hotspot/src/share/vm/includeDB_core	2009-09-08 13:41:57.000000000 +0100
@@ -1655,12 +1655,14 @@
 frame_<arch>.cpp                        frame.inline.hpp
 frame_<arch>.cpp                        handles.inline.hpp
 frame_<arch>.cpp                        interpreter.hpp
+frame_<arch>.cpp                        interpreterRuntime.hpp
 frame_<arch>.cpp                        javaCalls.hpp
 frame_<arch>.cpp                        markOop.hpp
 frame_<arch>.cpp                        methodOop.hpp
 frame_<arch>.cpp                        monitorChunk.hpp
 frame_<arch>.cpp                        oop.inline.hpp
 frame_<arch>.cpp                        resourceArea.hpp
+frame_<arch>.cpp                        scopeDesc.hpp
 frame_<arch>.cpp                        signature.hpp
 frame_<arch>.cpp                        stubCodeGenerator.hpp
 frame_<arch>.cpp                        stubRoutines.hpp

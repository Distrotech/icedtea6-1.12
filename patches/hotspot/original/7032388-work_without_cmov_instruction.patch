diff -Nru openjdk.orig/hotspot/src/cpu/x86/vm/assembler_x86.cpp openjdk/hotspot/src/cpu/x86/vm/assembler_x86.cpp
--- openjdk.orig/hotspot/src/cpu/x86/vm/assembler_x86.cpp	2011-02-28 16:03:14.000000000 +0000
+++ openjdk/hotspot/src/cpu/x86/vm/assembler_x86.cpp	2011-03-31 03:28:54.031901634 +0100
@@ -7643,6 +7643,28 @@
   }
 }
 
+void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
+  if (VM_Version::supports_cmov()) {
+    cmovl(cc, dst, src);
+  } else {
+    Label L;
+    jccb(negate_condition(cc), L);
+    movl(dst, src);
+    bind(L);
+  }
+}
+
+void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
+  if (VM_Version::supports_cmov()) {
+    cmovl(cc, dst, src);
+  } else {
+    Label L;
+    jccb(negate_condition(cc), L);
+    movl(dst, src);
+    bind(L);
+  }
+}
+
 void MacroAssembler::verify_oop(Register reg, const char* s) {
   if (!VerifyOops) return;
 
@@ -8559,14 +8581,7 @@
   movl(result, cnt1);
   subl(cnt1, cnt2);
   push(cnt1);
-  if (VM_Version::supports_cmov()) {
-    cmovl(Assembler::lessEqual, cnt2, result);
-  } else {
-    Label GT_LABEL;
-    jccb(Assembler::greater, GT_LABEL);
-    movl(cnt2, result);
-    bind(GT_LABEL);
-  }
+  cmov32(Assembler::lessEqual, cnt2, result);
 
   // Is the minimum length zero?
   testl(cnt2, cnt2);
diff -Nru openjdk.orig/hotspot/src/cpu/x86/vm/assembler_x86.hpp openjdk/hotspot/src/cpu/x86/vm/assembler_x86.hpp
--- openjdk.orig/hotspot/src/cpu/x86/vm/assembler_x86.hpp	2011-02-28 16:03:14.000000000 +0000
+++ openjdk/hotspot/src/cpu/x86/vm/assembler_x86.hpp	2011-03-31 03:28:54.031901634 +0100
@@ -2174,10 +2174,13 @@
 
   // Data
 
-  void cmov(Condition cc, Register dst, Register src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmovl(cc, dst, src)); }
+  void cmov32( Condition cc, Register dst, Address  src);
+  void cmov32( Condition cc, Register dst, Register src);
 
-  void cmovptr(Condition cc, Register dst, Address src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmovl(cc, dst, src)); }
-  void cmovptr(Condition cc, Register dst, Register src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmovl(cc, dst, src)); }
+  void cmov(   Condition cc, Register dst, Register src) { cmovptr(cc, dst, src); }
+
+  void cmovptr(Condition cc, Register dst, Address  src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
+  void cmovptr(Condition cc, Register dst, Register src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
 
   void movoop(Register dst, jobject obj);
   void movoop(Address dst, jobject obj);
diff -Nru openjdk.orig/hotspot/src/cpu/x86/vm/c1_LIRAssembler_x86.cpp openjdk/hotspot/src/cpu/x86/vm/c1_LIRAssembler_x86.cpp
--- openjdk.orig/hotspot/src/cpu/x86/vm/c1_LIRAssembler_x86.cpp	2011-02-28 16:03:14.000000000 +0000
+++ openjdk/hotspot/src/cpu/x86/vm/c1_LIRAssembler_x86.cpp	2011-03-31 03:28:54.035901697 +0100
@@ -559,24 +559,13 @@
   __ lea    (rdi, Address(rdi, rcx, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)));
 
   // compute minimum length (in rax) and difference of lengths (on top of stack)
-  if (VM_Version::supports_cmov()) {
-    __ movl     (rbx, Address(rbx, java_lang_String::count_offset_in_bytes()));
-    __ movl     (rax, Address(rax, java_lang_String::count_offset_in_bytes()));
-    __ mov      (rcx, rbx);
-    __ subptr   (rbx, rax); // subtract lengths
-    __ push     (rbx);      // result
-    __ cmov     (Assembler::lessEqual, rax, rcx);
-  } else {
-    Label L;
-    __ movl     (rbx, Address(rbx, java_lang_String::count_offset_in_bytes()));
-    __ movl     (rcx, Address(rax, java_lang_String::count_offset_in_bytes()));
-    __ mov      (rax, rbx);
-    __ subptr   (rbx, rcx);
-    __ push     (rbx);
-    __ jcc      (Assembler::lessEqual, L);
-    __ mov      (rax, rcx);
-    __ bind (L);
-  }
+  __ movl  (rbx, Address(rbx, java_lang_String::count_offset_in_bytes()));
+  __ movl  (rax, Address(rax, java_lang_String::count_offset_in_bytes()));
+  __ mov   (rcx, rbx);
+  __ subptr(rbx, rax); // subtract lengths
+  __ push  (rbx);      // result
+  __ cmov  (Assembler::lessEqual, rax, rcx);
+
   // is minimum length 0?
   Label noLoop, haveResult;
   __ testptr (rax, rax);
diff -Nru openjdk.orig/hotspot/src/cpu/x86/vm/templateTable_x86_32.cpp openjdk/hotspot/src/cpu/x86/vm/templateTable_x86_32.cpp
--- openjdk.orig/hotspot/src/cpu/x86/vm/templateTable_x86_32.cpp	2011-02-28 16:03:14.000000000 +0000
+++ openjdk/hotspot/src/cpu/x86/vm/templateTable_x86_32.cpp	2011-03-31 03:28:54.035901697 +0100
@@ -1931,18 +1931,10 @@
     __ movl(temp, Address(array, h, Address::times_8, 0*wordSize));
     __ bswapl(temp);
     __ cmpl(key, temp);
-    if (VM_Version::supports_cmov()) {
-      __ cmovl(Assembler::less        , j, h);   // j = h if (key <  array[h].fast_match())
-      __ cmovl(Assembler::greaterEqual, i, h);   // i = h if (key >= array[h].fast_match())
-    } else {
-      Label set_i, end_of_if;
-      __ jccb(Assembler::greaterEqual, set_i);     // {
-      __ mov(j, h);                                //   j = h;
-      __ jmp(end_of_if);                           // }
-      __ bind(set_i);                              // else {
-      __ mov(i, h);                                //   i = h;
-      __ bind(end_of_if);                          // }
-    }
+    // j = h if (key <  array[h].fast_match())
+    __ cmov32(Assembler::less        , j, h);
+    // i = h if (key >= array[h].fast_match())
+    __ cmov32(Assembler::greaterEqual, i, h);
     // while (i+1 < j)
     __ bind(entry);
     __ leal(h, Address(i, 1));                   // i+1
@@ -3463,22 +3455,14 @@
 
   // find a free slot in the monitor block (result in rdx)
   { Label entry, loop, exit;
-    __ movptr(rcx, monitor_block_top);            // points to current entry, starting with top-most entry
-    __ lea(rbx, monitor_block_bot);               // points to word before bottom of monitor block
+    __ movptr(rcx, monitor_block_top);           // points to current entry, starting with top-most entry
+
+    __ lea(rbx, monitor_block_bot);              // points to word before bottom of monitor block
     __ jmpb(entry);
 
     __ bind(loop);
     __ cmpptr(Address(rcx, BasicObjectLock::obj_offset_in_bytes()), (int32_t)NULL_WORD);  // check if current entry is used
-
-// TODO - need new func here - kbt
-    if (VM_Version::supports_cmov()) {
-      __ cmov(Assembler::equal, rdx, rcx);       // if not used then remember entry in rdx
-    } else {
-      Label L;
-      __ jccb(Assembler::notEqual, L);
-      __ mov(rdx, rcx);                          // if not used then remember entry in rdx
-      __ bind(L);
-    }
+    __ cmovptr(Assembler::equal, rdx, rcx);      // if not used then remember entry in rdx
     __ cmpptr(rax, Address(rcx, BasicObjectLock::obj_offset_in_bytes()));   // check if current entry is for same object
     __ jccb(Assembler::equal, exit);             // if same object then stop searching
     __ addptr(rcx, entry_size);                  // otherwise advance to next entry

diff -r de44705e6b33 -r 8e7adf982378 src/share/vm/interpreter/bytecodeInterpreter.cpp
--- openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp	Tue Nov 24 11:49:42 2009 -0800
+++ openjdk/hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp	Fri Nov 27 07:56:58 2009 -0800
@@ -281,7 +281,7 @@
 
 #define DO_BACKEDGE_CHECKS(skip, branch_pc)                                                         \
     if ((skip) <= 0) {                                                                              \
-      if (UseCompiler && UseLoopCounter) {                                                          \
+      if (UseLoopCounter) {                                                                         \
         bool do_OSR = UseOnStackReplacement;                                                        \
         BACKEDGE_COUNT->increment();                                                                \
         if (do_OSR) do_OSR = BACKEDGE_COUNT->reached_InvocationLimit();                             \
@@ -289,16 +289,12 @@
           nmethod*  osr_nmethod;                                                                    \
           OSR_REQUEST(osr_nmethod, branch_pc);                                                      \
           if (osr_nmethod != NULL && osr_nmethod->osr_entry_bci() != InvalidOSREntryBci) {          \
-            intptr_t* buf;                                                                          \
-            CALL_VM(buf=SharedRuntime::OSR_migration_begin(THREAD), handle_exception);              \
+            intptr_t* buf = SharedRuntime::OSR_migration_begin(THREAD);                             \
             istate->set_msg(do_osr);                                                                \
             istate->set_osr_buf((address)buf);                                                      \
             istate->set_osr_entry(osr_nmethod->osr_entry());                                        \
             return;                                                                                 \
           }                                                                                         \
-        } else {                                                                                    \
-          INCR_INVOCATION_COUNT;                                                                    \
-          SAFEPOINT;                                                                                \
         }                                                                                           \
       }  /* UseCompiler ... */                                                                      \
       INCR_INVOCATION_COUNT;                                                                        \
@@ -1281,12 +1277,7 @@
           jfloat f;
           jdouble r;
           f = STACK_FLOAT(-1);
-#ifdef IA64
-          // IA64 gcc bug
-          r = ( f == 0.0f ) ? (jdouble) f : (jdouble) f + ia64_double_zero;
-#else
           r = (jdouble) f;
-#endif
           MORE_STACK(-1); // POP
           SET_STACK_DOUBLE(r, 1);
           UPDATE_PC_AND_TOS_AND_CONTINUE(1, 2);
diff -r de44705e6b33 -r 8e7adf982378 src/share/vm/prims/jni.cpp
--- openjdk/hotspot/src/share/vm/prims/jni.cpp	Tue Nov 24 11:49:42 2009 -0800
+++ openjdk/hotspot/src/share/vm/prims/jni.cpp	Fri Nov 27 07:56:58 2009 -0800
@@ -3231,6 +3231,21 @@
   jint result = JNI_ERR;
   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&)result);
 
+  // We're about to use Atomic::xchg for synchronization.  Some Zero
+  // platforms use the GCC builtin __sync_lock_test_and_set for this,
+  // but __sync_lock_test_and_set is not guaranteed to do what we want
+  // on all architectures.  So we check it works before relying on it.
+#if defined(ZERO) && defined(ASSERT)
+  {
+    jint a = 0xcafebabe;
+    jint b = Atomic::xchg(0xdeadbeef, &a);
+    void *c = &a;
+    void *d = Atomic::xchg_ptr(&b, &c);
+    assert(a == 0xdeadbeef && b == (jint) 0xcafebabe, "Atomic::xchg() works");
+    assert(c == &b && d == &a, "Atomic::xchg_ptr() works");
+  }
+#endif // ZERO && ASSERT
+
   // At the moment it's only possible to have one Java VM,
   // since some of the runtime state is in global variables.
 
diff -r de44705e6b33 -r 8e7adf982378 src/share/vm/prims/jvmtiManageCapabilities.cpp
--- openjdk/hotspot/src/share/vm/prims/jvmtiManageCapabilities.cpp	Tue Nov 24 11:49:42 2009 -0800
+++ openjdk/hotspot/src/share/vm/prims/jvmtiManageCapabilities.cpp	Fri Nov 27 07:56:58 2009 -0800
@@ -115,8 +115,10 @@
   jvmtiCapabilities jc;
 
   memset(&jc, 0, sizeof(jc));
+#ifndef CC_INTERP
   jc.can_pop_frame = 1;
   jc.can_force_early_return = 1;
+#endif // !CC_INTERP
   jc.can_get_source_debug_extension = 1;
   jc.can_access_local_variables = 1;
   jc.can_maintain_original_method_order = 1;
diff -r de44705e6b33 -r 8e7adf982378 src/share/vm/runtime/os.hpp
--- openjdk/hotspot/src/share/vm/runtime/os.hpp	Tue Nov 24 11:49:42 2009 -0800
+++ openjdk/hotspot/src/share/vm/runtime/os.hpp	Fri Nov 27 07:56:58 2009 -0800
@@ -294,19 +294,16 @@
   }
 
   static bool    is_memory_serialize_page(JavaThread *thread, address addr) {
-    address thr_addr;
     if (UseMembar) return false;
-    // Calculate thread specific address
+    // Previously this function calculated the exact address of this
+    // thread's serialize page, and checked if the faulting address
+    // was equal.  However, some platforms mask off faulting addresses
+    // to the page size, so now we just check that the address is
+    // within the page.  This makes the thread argument unnecessary,
+    // but we retain the NULL check to preserve existing behaviour.
     if (thread == NULL) return false;
-    // TODO-FIXME: some platforms mask off faulting addresses to the base pagesize.
-    // Instead of using a test for equality we should probably use something
-    // of the form:
-    // return ((_mem_serialize_page ^ addr) & -pagesize) == 0
-    //
-    thr_addr  = (address)(((uintptr_t)thread >>
-                get_serialize_page_shift_count()) &
-                get_serialize_page_mask()) + (uintptr_t)_mem_serialize_page;
-    return  (thr_addr == addr);
+    address page = (address) _mem_serialize_page;
+    return addr >= page && addr < (page + os::vm_page_size());
   }
 
   static void block_on_serialize_page_trap();

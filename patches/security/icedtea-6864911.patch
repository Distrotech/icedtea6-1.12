--- old/src/share/classes/com/sun/jndi/ldap/Connection.java	2009-08-18 09:35:56.595709900 +0800
+++ openjdk/jdk/src/share/classes/com/sun/jndi/ldap/Connection.java	2009-08-18 09:35:56.087195700 +0800
@@ -32,12 +32,8 @@
 import java.io.OutputStream;
 import java.io.InputStream;
 import java.net.Socket;
-import java.util.Vector;
-import java.util.Hashtable;
 
 import javax.naming.CommunicationException;
-import javax.naming.AuthenticationException;
-import javax.naming.AuthenticationNotSupportedException;
 import javax.naming.ServiceUnavailableException;
 import javax.naming.NamingException;
 import javax.naming.InterruptedNamingException;
@@ -47,6 +43,8 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+import sun.misc.IOUtils;
 //import javax.net.SocketFactory;
 
 /**
@@ -799,7 +797,6 @@
         byte inbuf[];   // Buffer for reading incoming bytes
         int inMsgId;    // Message id of incoming response
         int bytesread;  // Number of bytes in inbuf
-        int bytesleft;  // Number of bytes that need to read for completing resp
         int br;         // Temp; number of bytes read from stream
         int offset;     // Offset of where to store bytes in inbuf
         int seqlen;     // Length of ASN sequence
@@ -811,7 +808,7 @@
         try {
             while (true) {
                 try {
-                    inbuf = new byte[2048];
+                    inbuf = new byte[10];
 
                     offset = 0;
                     seqlen = 0;
@@ -871,19 +868,10 @@
                     }
 
                     // read in seqlen bytes
-                    bytesleft = seqlen;
-                    if ((offset + bytesleft) > inbuf.length) {
-                        byte nbuf[] = new byte[offset + bytesleft];
-                        System.arraycopy(inbuf, 0, nbuf, 0, offset);
-                        inbuf = nbuf;
-                    }
-                    while (bytesleft > 0) {
-                        bytesread = in.read(inbuf, offset, bytesleft);
-                        if (bytesread < 0)
-                            break; // EOF
-                        offset += bytesread;
-                        bytesleft -= bytesread;
-                    }
+                    byte[] left = IOUtils.readFully(in, seqlen, false);
+                    inbuf = Arrays.copyOf(inbuf, offset + left.length);
+                    System.arraycopy(left, 0, inbuf, offset, left.length);
+                    offset += left.length;
 /*
 if (dump > 0) {
 System.err.println("seqlen: " + seqlen);
--- old/src/share/classes/sun/applet/AppletClassLoader.java	2009-08-18 09:36:00.901075900 +0800
+++ openjdk/jdk/src/share/classes/sun/applet/AppletClassLoader.java	2009-08-18 09:35:59.999916100 +0800
@@ -51,6 +51,7 @@
 import java.security.PermissionCollection;
 import sun.awt.AppContext;
 import sun.awt.SunToolkit;
+import sun.misc.IOUtils;
 import sun.net.www.ParseUtil;
 import sun.security.util.SecurityConstants;
 
@@ -314,36 +315,7 @@
 
         byte[] b;
         try {
-            if (len != -1) {
-                // Read exactly len bytes from the input stream
-                b = new byte[len];
-                while (len > 0) {
-                    int n = in.read(b, b.length - len, len);
-                    if (n == -1) {
-                        throw new IOException("unexpected EOF");
-                    }
-                    len -= n;
-                }
-            } else {
-                // Read until end of stream is reached - use 8K buffer
-                // to speed up performance [stanleyh]
-                b = new byte[8192];
-                int total = 0;
-                while ((len = in.read(b, total, b.length - total)) != -1) {
-                    total += len;
-                    if (total >= b.length) {
-                        byte[] tmp = new byte[total * 2];
-                        System.arraycopy(b, 0, tmp, 0, total);
-                        b = tmp;
-                    }
-                }
-                // Trim array to correct size, if necessary
-                if (total != b.length) {
-                    byte[] tmp = new byte[total];
-                    System.arraycopy(b, 0, tmp, 0, total);
-                    b = tmp;
-                }
-            }
+            b = IOUtils.readFully(in, len, true);
         } finally {
             in.close();
         }
--- old/src/share/classes/sun/misc/Resource.java	2009-08-18 09:36:03.965921700 +0800
+++ openjdk/jdk/src/share/classes/sun/misc/Resource.java	2009-08-18 09:36:03.449689900 +0800
@@ -25,14 +25,15 @@
 
 package sun.misc;
 
+import java.io.EOFException;
 import java.net.URL;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.io.InputStream;
 import java.security.CodeSigner;
 import java.util.jar.Manifest;
-import java.util.jar.Attributes;
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 import sun.nio.ByteBuffered;
 
 /**
@@ -105,49 +106,37 @@
         }
 
         try {
-            if (len != -1) {
-                // Read exactly len bytes from the input stream
-                b = new byte[len];
-                while (len > 0) {
-                    int n = 0;
-                    try {
-                        n = in.read(b, b.length - len, len);
-                    } catch (InterruptedIOException iioe) {
-                        Thread.interrupted();
-                        isInterrupted = true;
+            b = new byte[0];
+            if (len == -1) len = Integer.MAX_VALUE;
+            int pos = 0;
+            while (pos < len) {
+                int bytesToRead;
+                if (pos >= b.length) { // Only expand when there's no room
+                    bytesToRead = Math.min(len - pos, b.length + 1024);
+                    if (b.length < pos + bytesToRead) {
+                        b = Arrays.copyOf(b, pos + bytesToRead);
                     }
-                    if (n == -1) {
-                        throw new IOException("unexpected EOF");
-                    }
-                    len -= n;
+                } else {
+                    bytesToRead = b.length - pos;
                 }
-            } else {
-                // Read until end of stream is reached
-                b = new byte[1024];
-                int total = 0;
-                for (;;) {
-                    len = 0;
-                    try {
-                        len = in.read(b, total, b.length - total);
-                        if (len == -1)
-                            break;
-                    } catch (InterruptedIOException iioe) {
-                        Thread.interrupted();
-                        isInterrupted = true;
-                    }
-                    total += len;
-                    if (total >= b.length) {
-                        byte[] tmp = new byte[total * 2];
-                        System.arraycopy(b, 0, tmp, 0, total);
-                        b = tmp;
-                    }
+                int cc = 0;
+                try {
+                    cc = in.read(b, pos, bytesToRead);
+                } catch (InterruptedIOException iioe) {
+                    Thread.interrupted();
+                    isInterrupted = true;
                 }
-                // Trim array to correct size, if necessary
-                if (total != b.length) {
-                    byte[] tmp = new byte[total];
-                    System.arraycopy(b, 0, tmp, 0, total);
-                    b = tmp;
+                if (cc < 0) {
+                    if (len != Integer.MAX_VALUE) {
+                        throw new EOFException("Detect premature EOF");
+                    } else {
+                        if (b.length != pos) {
+                            b = Arrays.copyOf(b, pos);
+                        }
+                        break;
+                    }
                 }
+                pos += cc;
             }
         } finally {
             try {
--- old/src/share/classes/sun/reflect/misc/MethodUtil.java	2009-08-18 09:36:07.067128400 +0800
+++ openjdk/jdk/src/share/classes/sun/reflect/misc/MethodUtil.java	2009-08-18 09:36:06.464179700 +0800
@@ -44,6 +44,7 @@
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
+import sun.misc.IOUtils;
 import sun.net.www.ParseUtil;
 import sun.security.util.SecurityConstants;
 
@@ -375,34 +376,7 @@
 
         byte[] b;
         try {
-            if (len != -1) {
-                // Read exactly len bytes from the input stream
-                b = new byte[len];
-                while (len > 0) {
-                    int n = in.read(b, b.length - len, len);
-                    if (n == -1) {
-                        throw new IOException("unexpected EOF");
-                    }
-                    len -= n;
-                }
-            } else {
-                b = new byte[8192];
-                int total = 0;
-                while ((len = in.read(b, total, b.length - total)) != -1) {
-                    total += len;
-                    if (total >= b.length) {
-                        byte[] tmp = new byte[total * 2];
-                        System.arraycopy(b, 0, tmp, 0, total);
-                        b = tmp;
-                    }
-                }
-                // Trim array to correct size, if necessary
-                if (total != b.length) {
-                    byte[] tmp = new byte[total];
-                    System.arraycopy(b, 0, tmp, 0, total);
-                    b = tmp;
-                }
-            }
+            b = IOUtils.readFully(in, len, true);
         } finally {
             in.close();
         }
--- old/src/share/classes/sun/security/provider/certpath/OCSPChecker.java	2009-08-18 09:36:10.684391400 +0800
+++ openjdk/jdk/src/share/classes/sun/security/provider/certpath/OCSPChecker.java	2009-08-18 09:36:10.088986300 +0800
@@ -36,6 +36,7 @@
 import java.net.*;
 import javax.security.auth.x500.X500Principal;
 
+import sun.misc.IOUtils;
 import sun.security.util.*;
 import sun.security.x509.*;
 
@@ -344,17 +345,7 @@
             in = con.getInputStream();
 
             int contentLength = con.getContentLength();
-            if (contentLength == -1) {
-                contentLength = Integer.MAX_VALUE;
-            }
-
-            byte[] response = new byte[contentLength];
-            int total = 0;
-            int count = 0;
-            while (count != -1 && total < contentLength) {
-                count = in.read(response, total, response.length - total);
-                total += count;
-            }
+            byte[] response = IOUtils.readFully(in, contentLength, false);
 
             OCSPResponse ocspResponse = new OCSPResponse(response, pkixParams,
                 responderCert);
--- old/src/share/classes/sun/security/timestamp/HttpTimestamper.java	2009-08-18 09:36:13.859436200 +0800
+++ openjdk/jdk/src/share/classes/sun/security/timestamp/HttpTimestamper.java	2009-08-18 09:36:13.165978900 +0800
@@ -33,6 +33,7 @@
 import java.util.Iterator;
 import java.util.Set;
 
+import sun.misc.IOUtils;
 import sun.security.pkcs.*;
 
 /**
@@ -138,19 +139,9 @@
                 System.out.println();
             }
             int contentLength = connection.getContentLength();
-            if (contentLength == -1) {
-                contentLength = Integer.MAX_VALUE;
-            }
             verifyMimeType(connection.getContentType());
+            replyBuffer = IOUtils.readFully(input, contentLength, false);
 
-            replyBuffer = new byte[contentLength];
-            int total = 0;
-            int count = 0;
-            while (count != -1 && total < contentLength) {
-                count = input.read(replyBuffer, total,
-                                        replyBuffer.length - total);
-                total += count;
-            }
             if (DEBUG) {
                 System.out.println("received timestamp response (length=" +
                         replyBuffer.length + ")");
--- old/src/share/classes/sun/security/util/DerValue.java	2009-08-18 09:36:18.392602400 +0800
+++ openjdk/jdk/src/share/classes/sun/security/util/DerValue.java	2009-08-18 09:36:17.617711400 +0800
@@ -28,6 +28,7 @@
 import java.io.*;
 import java.math.BigInteger;
 import java.util.Date;
+import sun.misc.IOUtils;
 
 /**
  * Represents a single DER-encoded value.  DER encoding rules are a subset
@@ -384,12 +385,8 @@
         if (fullyBuffered && in.available() != length)
             throw new IOException("extra data given to DerValue constructor");
 
-        byte[] bytes = new byte[length];
+        byte[] bytes = IOUtils.readFully(in, length, true);
 
-        // n.b. readFully not needed in normal fullyBuffered case
-        DataInputStream dis = new DataInputStream(in);
-
-        dis.readFully(bytes);
         buffer = new DerInputBuffer(bytes);
         return new DerInputStream(buffer);
     }
--- /dev/null	2009-07-23 00:25:50.000000000 +0800
+++ openjdk/jdk/src/share/classes/sun/misc/IOUtils.java	2009-08-18 09:36:21.385422200 +0800
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/**
+ * IOUtils: A collection of IO-related public static methods.
+ */
+
+package sun.misc;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+
+public class IOUtils {
+
+    /**
+     * Read up to <code>length</code> of bytes from <code>in</code>
+     * until EOF is detected.
+     * @param in input stream, must not be null
+     * @param length number of bytes to read, -1 or Integer.MAX_VALUE means
+     *        read as much as possible
+     * @param readAll if true, an EOFException will be thrown if not enough
+     *        bytes are read. Ignored when length is -1 or Integer.MAX_VALUE
+     * @return bytes read
+     * @throws IOException Any IO error or a premature EOF is detected
+     */
+    public static byte[] readFully(InputStream is, int length, boolean readAll)
+            throws IOException {
+        byte[] output = {};
+        if (length == -1) length = Integer.MAX_VALUE;
+        int pos = 0;
+        while (pos < length) {
+            int bytesToRead;
+            if (pos >= output.length) { // Only expand when there's no room
+                bytesToRead = Math.min(length - pos, output.length + 1024);
+                if (output.length < pos + bytesToRead) {
+                    output = Arrays.copyOf(output, pos + bytesToRead);
+                }
+            } else {
+                bytesToRead = output.length - pos;
+            }
+            int cc = is.read(output, pos, bytesToRead);
+            if (cc < 0) {
+                if (readAll && length != Integer.MAX_VALUE) {
+                    throw new EOFException("Detect premature EOF");
+                } else {
+                    if (output.length != pos) {
+                        output = Arrays.copyOf(output, pos);
+                    }
+                    break;
+                }
+            }
+            pos += cc;
+        }
+        return output;
+    }
+}

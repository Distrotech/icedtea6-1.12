# HG changeset patch
# User kvn
# Date 1259879213 28800
# Node ID 75e095764f403b7425e30711b00cc038554a1ae9
# Parent  324e583cecd8d5886f99f759a19fd2776793c053
6892265: System.arraycopy unable to reference elements beyond Integer.MAX_VALUE bytes
Summary: Use size_t type cast to widen int values in typeArrayKlass::copy_array().
Reviewed-by: never, jcoomes

diff --gitopenjdk.orig/hotspot/src/share/vm/oops/typeArrayKlass.cpp openjdk/hotspot/src/share/vm/oops/typeArrayKlass.cpp
---openjdk.orig/hotspot/src/share/vm/oops/typeArrayKlass.cpp
+++ openjdk/hotspot/src/share/vm/oops/typeArrayKlass.cpp
@@ -124,16 +124,16 @@ void typeArrayKlass::copy_array(arrayOop
      || (((unsigned int) length + (unsigned int) dst_pos) > (unsigned int) d->length()) ) {
     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
   }
+  // Check zero copy
+  if (length == 0)
+    return;
 
   // This is an attempt to make the copy_array fast.
-  // NB: memmove takes care of overlapping memory segments.
-  // Potential problem: memmove is not guaranteed to be word atomic
-  // Revisit in Merlin
   int l2es = log2_element_size();
   int ihs = array_header_in_bytes() / wordSize;
-  char* src = (char*) ((oop*)s + ihs) + (src_pos << l2es);
-  char* dst = (char*) ((oop*)d + ihs) + (dst_pos << l2es);
-  memmove(dst, src, length << l2es);
+  char* src = (char*) ((oop*)s + ihs) + ((size_t)src_pos << l2es);
+  char* dst = (char*) ((oop*)d + ihs) + ((size_t)dst_pos << l2es);
+  Copy::conjoint_memory_atomic(src, dst, (size_t)length << l2es);
 }
 
 

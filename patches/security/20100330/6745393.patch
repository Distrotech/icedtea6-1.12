--- openjdk.orig/jdk/src/share/classes/java/util/zip/Deflater.java	Tue Nov 24 12:11:14 2009
+++ openjdk/jdk/src/share/classes/java/util/zip/Deflater.java	Tue Nov 24 12:11:13 2009
@@ -1,5 +1,5 @@
 /*
- * Copyright 1996-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 1996-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -71,7 +71,8 @@
  */
 public
 class Deflater {
-    private long strm;
+
+    private final ZStreamRef zsRef;
     private byte[] buf = new byte[0];
     private int off, len;
     private int level, strategy;
@@ -137,7 +138,7 @@
     public Deflater(int level, boolean nowrap) {
         this.level = level;
         this.strategy = DEFAULT_STRATEGY;
-        strm = init(level, DEFAULT_STRATEGY, nowrap);
+        this.zsRef = new ZStreamRef(init(level, DEFAULT_STRATEGY, nowrap));
     }
 
     /**
@@ -165,7 +166,7 @@
      * @param len the length of the data
      * @see Deflater#needsInput
      */
-    public synchronized void setInput(byte[] b, int off, int len) {
+    public void setInput(byte[] b, int off, int len) {
         if (b== null) {
             throw new NullPointerException();
         }
@@ -172,9 +173,11 @@
         if (off < 0 || len < 0 || off > b.length - len) {
             throw new ArrayIndexOutOfBoundsException();
         }
-        this.buf = b;
-        this.off = off;
-        this.len = len;
+        synchronized (zsRef) {
+            this.buf = b;
+            this.off = off;
+            this.len = len;
+        }
     }
 
     /**
@@ -199,14 +202,17 @@
      * @see Inflater#inflate
      * @see Inflater#getAdler
      */
-    public synchronized void setDictionary(byte[] b, int off, int len) {
-        if (strm == 0 || b == null) {
+    public void setDictionary(byte[] b, int off, int len) {
+        if (b == null) {
             throw new NullPointerException();
         }
         if (off < 0 || len < 0 || off > b.length - len) {
             throw new ArrayIndexOutOfBoundsException();
         }
-        setDictionary(strm, b, off, len);
+        synchronized (zsRef) {
+            ensureOpen();
+            setDictionary(zsRef.address(), b, off, len);
+        }
     }
 
     /**
@@ -229,7 +235,7 @@
      * @exception IllegalArgumentException if the compression strategy is
      *                                     invalid
      */
-    public synchronized void setStrategy(int strategy) {
+    public void setStrategy(int strategy) {
         switch (strategy) {
           case DEFAULT_STRATEGY:
           case FILTERED:
@@ -238,9 +244,11 @@
           default:
             throw new IllegalArgumentException();
         }
-        if (this.strategy != strategy) {
-            this.strategy = strategy;
-            setParams = true;
+        synchronized (zsRef) {
+            if (this.strategy != strategy) {
+                this.strategy = strategy;
+                setParams = true;
+            }
         }
     }
 
@@ -249,13 +257,15 @@
      * @param level the new compression level (0-9)
      * @exception IllegalArgumentException if the compression level is invalid
      */
-    public synchronized void setLevel(int level) {
+    public void setLevel(int level) {
         if ((level < 0 || level > 9) && level != DEFAULT_COMPRESSION) {
             throw new IllegalArgumentException("invalid compression level");
         }
-        if (this.level != level) {
-            this.level = level;
-            setParams = true;
+        synchronized (zsRef) {
+            if (this.level != level) {
+                this.level = level;
+                setParams = true;
+            }
         }
     }
 
@@ -273,8 +283,10 @@
      * When called, indicates that compression should end with the current
      * contents of the input buffer.
      */
-    public synchronized void finish() {
-        finish = true;
+    public void finish() {
+        synchronized (zsRef) {
+            finish = true;
+        }
     }
 
     /**
@@ -283,8 +295,10 @@
      * @return true if the end of the compressed data output stream has
      * been reached
      */
-    public synchronized boolean finished() {
-        return finished;
+    public boolean finished() {
+        synchronized (zsRef) {
+            return finished;
+        }
     }
 
     /**
@@ -297,7 +311,7 @@
      * @param len the maximum number of bytes of compressed data
      * @return the actual number of bytes of compressed data
      */
-    public synchronized int deflate(byte[] b, int off, int len) {
+    public int deflate(byte[] b, int off, int len) {
         if (b == null) {
             throw new NullPointerException();
         }
@@ -304,7 +318,9 @@
         if (off < 0 || len < 0 || off > b.length - len) {
             throw new ArrayIndexOutOfBoundsException();
         }
-        return deflateBytes(b, off, len);
+        synchronized (zsRef) {
+            return deflateBytes(zsRef.address(), b, off, len);
+        }
     }
 
     /**
@@ -323,9 +339,11 @@
      * Returns the ADLER-32 value of the uncompressed data.
      * @return the ADLER-32 value of the uncompressed data
      */
-    public synchronized int getAdler() {
-        ensureOpen();
-        return getAdler(strm);
+    public int getAdler() {
+        synchronized (zsRef) {
+            ensureOpen();
+            return getAdler(zsRef.address());
+        }
     }
 
     /**
@@ -347,9 +365,11 @@
      * @return the total (non-negative) number of uncompressed bytes input so far
      * @since 1.5
      */
-    public synchronized long getBytesRead() {
-        ensureOpen();
-        return getBytesRead(strm);
+    public long getBytesRead() {
+        synchronized (zsRef) {
+            ensureOpen();
+            return getBytesRead(zsRef.address());
+        }
     }
 
     /**
@@ -371,9 +391,11 @@
      * @return the total (non-negative) number of compressed bytes output so far
      * @since 1.5
      */
-    public synchronized long getBytesWritten() {
-        ensureOpen();
-        return getBytesWritten(strm);
+    public long getBytesWritten() {
+        synchronized (zsRef) {
+            ensureOpen();
+            return getBytesWritten(zsRef.address());
+        }
     }
 
     /**
@@ -380,12 +402,14 @@
      * Resets deflater so that a new set of input data can be processed.
      * Keeps current compression level and strategy settings.
      */
-    public synchronized void reset() {
-        ensureOpen();
-        reset(strm);
-        finish = false;
-        finished = false;
-        off = len = 0;
+    public void reset() {
+        synchronized (zsRef) {
+            ensureOpen();
+            reset(zsRef.address());
+            finish = false;
+            finished = false;
+            off = len = 0;
+        }
     }
 
     /**
@@ -395,11 +419,14 @@
      * finalize() method. Once this method is called, the behavior
      * of the Deflater object is undefined.
      */
-    public synchronized void end() {
-        if (strm != 0) {
-            end(strm);
-            strm = 0;
-            buf = null;
+    public void end() {
+        synchronized (zsRef) {
+            long addr = zsRef.address();
+            zsRef.clear();
+            if (addr != 0) {
+                end(addr);
+                buf = null;
+            }
         }
     }
 
@@ -411,18 +438,19 @@
     }
 
     private void ensureOpen() {
-        if (strm == 0)
-            throw new NullPointerException();
+        assert Thread.holdsLock(zsRef);
+        if (zsRef.address() == 0)
+            throw new NullPointerException("Deflater has been closed");
     }
 
     private static native void initIDs();
     private native static long init(int level, int strategy, boolean nowrap);
-    private native static void setDictionary(long strm, byte[] b, int off,
+    private native static void setDictionary(long addr, byte[] b, int off,
                                              int len);
-    private native int deflateBytes(byte[] b, int off, int len);
-    private native static int getAdler(long strm);
-    private native static long getBytesRead(long strm);
-    private native static long getBytesWritten(long strm);
-    private native static void reset(long strm);
-    private native static void end(long strm);
+    private native int deflateBytes(long addr, byte[] b, int off, int len);
+    private native static int getAdler(long addr);
+    private native static long getBytesRead(long addr);
+    private native static long getBytesWritten(long addr);
+    private native static void reset(long addr);
+    private native static void end(long addr);
 }
--- openjdk.orig/jdk/src/share/classes/java/util/zip/Inflater.java	Tue Nov 24 12:11:26 2009
+++ openjdk/jdk/src/share/classes/java/util/zip/Inflater.java	Tue Nov 24 12:11:25 2009
@@ -1,5 +1,5 @@
 /*
- * Copyright 1996-2006 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 1996-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -72,12 +72,14 @@
  */
 public
 class Inflater {
-    private long strm;
-    private byte[] buf = new byte[0];
+    private final ZStreamRef zsRef;
+    private byte[] buf = emptyBuf;
     private int off, len;
     private boolean finished;
     private boolean needDict;
 
+    private static byte[] emptyBuf = new byte[0];
+
     static {
         /* Zip library is loaded from System.initializeSystemClass */
         initIDs();
@@ -95,7 +97,7 @@
      * @param nowrap if true then support GZIP compatible compression
      */
     public Inflater(boolean nowrap) {
-        strm = init(nowrap);
+        zsRef = new ZStreamRef(init(nowrap));
     }
 
     /**
@@ -114,7 +116,7 @@
      * @param len the length of the input data
      * @see Inflater#needsInput
      */
-    public synchronized void setInput(byte[] b, int off, int len) {
+    public void setInput(byte[] b, int off, int len) {
         if (b == null) {
             throw new NullPointerException();
         }
@@ -121,9 +123,11 @@
         if (off < 0 || len < 0 || off > b.length - len) {
             throw new ArrayIndexOutOfBoundsException();
         }
-        this.buf = b;
-        this.off = off;
-        this.len = len;
+        synchronized (zsRef) {
+            this.buf = b;
+            this.off = off;
+            this.len = len;
+        }
     }
 
     /**
@@ -148,15 +152,18 @@
      * @see Inflater#needsDictionary
      * @see Inflater#getAdler
      */
-    public synchronized void setDictionary(byte[] b, int off, int len) {
-        if (strm == 0 || b == null) {
+    public void setDictionary(byte[] b, int off, int len) {
+        if (b == null) {
             throw new NullPointerException();
         }
         if (off < 0 || len < 0 || off > b.length - len) {
             throw new ArrayIndexOutOfBoundsException();
         }
-        setDictionary(strm, b, off, len);
-        needDict = false;
+        synchronized (zsRef) {
+            ensureOpen();
+            setDictionary(zsRef.address(), b, off, len);
+            needDict = false;
+        }
     }
 
     /**
@@ -178,8 +185,10 @@
      * buffer after decompression has finished.
      * @return the total number of bytes remaining in the input buffer
      */
-    public synchronized int getRemaining() {
-        return len;
+    public int getRemaining() {
+        synchronized (zsRef) {
+            return len;
+        }
     }
 
     /**
@@ -188,8 +197,10 @@
      * to provide more input.
      * @return true if no data remains in the input buffer
      */
-    public synchronized boolean needsInput() {
-        return len <= 0;
+    public boolean needsInput() {
+        synchronized (zsRef) {
+            return len <= 0;
+        }
     }
 
     /**
@@ -197,8 +208,10 @@
      * @return true if a preset dictionary is needed for decompression
      * @see Inflater#setDictionary
      */
-    public synchronized boolean needsDictionary() {
-        return needDict;
+    public boolean needsDictionary() {
+        synchronized (zsRef) {
+            return needDict;
+        }
     }
 
     /**
@@ -207,8 +220,10 @@
      * @return true if the end of the compressed data stream has been
      * reached
      */
-    public synchronized boolean finished() {
-        return finished;
+    public boolean finished() {
+        synchronized (zsRef) {
+            return finished;
+        }
     }
 
     /**
@@ -226,7 +241,7 @@
      * @see Inflater#needsInput
      * @see Inflater#needsDictionary
      */
-    public synchronized int inflate(byte[] b, int off, int len)
+    public int inflate(byte[] b, int off, int len)
         throws DataFormatException
     {
         if (b == null) {
@@ -235,7 +250,10 @@
         if (off < 0 || len < 0 || off > b.length - len) {
             throw new ArrayIndexOutOfBoundsException();
         }
-        return inflateBytes(b, off, len);
+        synchronized (zsRef) {
+            ensureOpen();
+            return inflateBytes(zsRef.address(), b, off, len);
+        }
     }
 
     /**
@@ -259,9 +277,11 @@
      * Returns the ADLER-32 value of the uncompressed data.
      * @return the ADLER-32 value of the uncompressed data
      */
-    public synchronized int getAdler() {
-        ensureOpen();
-        return getAdler(strm);
+    public int getAdler() {
+        synchronized (zsRef) {
+            ensureOpen();
+            return getAdler(zsRef.address());
+        }
     }
 
     /**
@@ -283,9 +303,11 @@
      * @return the total (non-negative) number of compressed bytes input so far
      * @since 1.5
      */
-    public synchronized long getBytesRead() {
-        ensureOpen();
-        return getBytesRead(strm);
+    public long getBytesRead() {
+        synchronized (zsRef) {
+            ensureOpen();
+            return getBytesRead(zsRef.address());
+        }
     }
 
     /**
@@ -307,20 +329,25 @@
      * @return the total (non-negative) number of uncompressed bytes output so far
      * @since 1.5
      */
-    public synchronized long getBytesWritten() {
-        ensureOpen();
-        return getBytesWritten(strm);
+    public long getBytesWritten() {
+        synchronized (zsRef) {
+            ensureOpen();
+            return getBytesWritten(zsRef.address());
+        }
     }
 
     /**
      * Resets inflater so that a new set of input data can be processed.
      */
-    public synchronized void reset() {
-        ensureOpen();
-        reset(strm);
-        finished = false;
-        needDict = false;
-        off = len = 0;
+    public void reset() {
+        synchronized (zsRef) {
+            ensureOpen();
+            reset(zsRef.address());
+            buf = emptyBuf;
+            finished = false;
+            needDict = false;
+            off = len = 0;
+        }
     }
 
     /**
@@ -330,11 +357,14 @@
      * method. Once this method is called, the behavior of the Inflater
      * object is undefined.
      */
-    public synchronized void end() {
-        if (strm != 0) {
-            end(strm);
-            strm = 0;
-            buf = null;
+    public void end() {
+        synchronized (zsRef) {
+            long addr = zsRef.address();
+            zsRef.clear();
+            if (addr != 0) {
+                end(addr);
+                buf = null;
+            }
         }
     }
 
@@ -346,19 +376,24 @@
     }
 
     private void ensureOpen () {
-        if (strm == 0)
-            throw new NullPointerException();
+        assert Thread.holdsLock(zsRef);
+        if (zsRef.address() == 0)
+            throw new NullPointerException("Inflater has been closed");
     }
 
+    private static class NativeStrm {
+        long strm;
+    }
+
     private native static void initIDs();
     private native static long init(boolean nowrap);
-    private native static void setDictionary(long strm, byte[] b, int off,
+    private native static void setDictionary(long addr, byte[] b, int off,
                                              int len);
-    private native int inflateBytes(byte[] b, int off, int len)
+    private native int inflateBytes(long addr, byte[] b, int off, int len)
             throws DataFormatException;
-    private native static int getAdler(long strm);
-    private native static long getBytesRead(long strm);
-    private native static long getBytesWritten(long strm);
-    private native static void reset(long strm);
-    private native static void end(long strm);
+    private native static int getAdler(long addr);
+    private native static long getBytesRead(long addr);
+    private native static long getBytesWritten(long addr);
+    private native static void reset(long addr);
+    private native static void end(long addr);
 }
--- /dev/null	Tue Nov 24 12:11:34 2009
+++ openjdk/jdk/src/share/classes/java/util/zip/ZStreamRef.java	Tue Nov 24 12:11:33 2009
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.util.zip;
+
+/**
+ * A reference to the native zlib's z_stream structure.
+ */
+
+class ZStreamRef {
+
+    private long address;
+    ZStreamRef (long address) {
+        this.address = address;
+    }
+
+    long address() {
+        return address;
+    }
+
+    void clear() {
+        address = 0;
+    }
+}
--- openjdk.orig/jdk/src/share/native/java/util/zip/Deflater.c	Tue Nov 24 12:11:38 2009
+++ openjdk/jdk/src/share/native/java/util/zip/Deflater.c	Tue Nov 24 12:11:37 2009
@@ -1,5 +1,5 @@
 /*
- * Copyright 1997-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 1996-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -38,7 +38,6 @@
 
 #define DEF_MEM_LEVEL 8
 
-static jfieldID strmID;
 static jfieldID levelID;
 static jfieldID strategyID;
 static jfieldID setParamsID;
@@ -49,7 +48,6 @@
 JNIEXPORT void JNICALL
 Java_java_util_zip_Deflater_initIDs(JNIEnv *env, jclass cls)
 {
-    strmID = (*env)->GetFieldID(env, cls, "strm", "J");
     levelID = (*env)->GetFieldID(env, cls, "level", "I");
     strategyID = (*env)->GetFieldID(env, cls, "strategy", "I");
     setParamsID = (*env)->GetFieldID(env, cls, "setParams", "Z");
@@ -62,40 +60,40 @@
 
 JNIEXPORT jlong JNICALL
 Java_java_util_zip_Deflater_init(JNIEnv *env, jclass cls, jint level,
-                                 jint strategy, jboolean nowrap)
+				 jint strategy, jboolean nowrap)
 {
     z_stream *strm = calloc(1, sizeof(z_stream));
 
     if (strm == 0) {
-        JNU_ThrowOutOfMemoryError(env, 0);
-        return jlong_zero;
+	JNU_ThrowOutOfMemoryError(env, 0);
+	return jlong_zero;
     } else {
-        char *msg;
-        switch (deflateInit2(strm, level, Z_DEFLATED,
-                             nowrap ? -MAX_WBITS : MAX_WBITS,
-                             DEF_MEM_LEVEL, strategy)) {
-          case Z_OK:
-            return ptr_to_jlong(strm);
-          case Z_MEM_ERROR:
-            free(strm);
-            JNU_ThrowOutOfMemoryError(env, 0);
-            return jlong_zero;
-          case Z_STREAM_ERROR:
-            free(strm);
-            JNU_ThrowIllegalArgumentException(env, 0);
-            return jlong_zero;
-          default:
-            msg = strm->msg;
-            free(strm);
-            JNU_ThrowInternalError(env, msg);
-            return jlong_zero;
-        }
+	char *msg;
+	switch (deflateInit2(strm, level, Z_DEFLATED,
+			     nowrap ? -MAX_WBITS : MAX_WBITS,
+			     DEF_MEM_LEVEL, strategy)) {
+	  case Z_OK:
+	    return ptr_to_jlong(strm);
+	  case Z_MEM_ERROR:
+	    free(strm);
+	    JNU_ThrowOutOfMemoryError(env, 0);
+	    return jlong_zero;
+	  case Z_STREAM_ERROR:
+	    free(strm);
+	    JNU_ThrowIllegalArgumentException(env, 0);
+	    return jlong_zero;
+	  default:
+	    msg = strm->msg;
+	    free(strm);
+	    JNU_ThrowInternalError(env, msg);
+	    return jlong_zero;
+	}
     }
 }
 
 JNIEXPORT void JNICALL
-Java_java_util_zip_Deflater_setDictionary(JNIEnv *env, jclass cls, jlong strm,
-                                          jarray b, jint off, jint len)
+Java_java_util_zip_Deflater_setDictionary(JNIEnv *env, jclass cls, jlong addr,
+					  jarray b, jint off, jint len)
 {
     Bytef *buf = (*env)->GetPrimitiveArrayCritical(env, b, 0);
     int res;
@@ -102,156 +100,155 @@
     if (buf == 0) {/* out of memory */
         return;
     }
-    res = deflateSetDictionary((z_stream *)jlong_to_ptr(strm), buf + off, len);
+    res = deflateSetDictionary((z_stream *)jlong_to_ptr(addr), buf + off, len);
     (*env)->ReleasePrimitiveArrayCritical(env, b, buf, 0);
     switch (res) {
     case Z_OK:
-        break;
+	break;
     case Z_STREAM_ERROR:
-        JNU_ThrowIllegalArgumentException(env, 0);
-        break;
+	JNU_ThrowIllegalArgumentException(env, 0);
+	break;
     default:
-        JNU_ThrowInternalError(env, ((z_stream *)jlong_to_ptr(strm))->msg);
-        break;
+	JNU_ThrowInternalError(env, ((z_stream *)jlong_to_ptr(addr))->msg);
+	break;
     }
 }
 
 JNIEXPORT jint JNICALL
-Java_java_util_zip_Deflater_deflateBytes(JNIEnv *env, jobject this,
-                                         jarray b, jint off, jint len)
+Java_java_util_zip_Deflater_deflateBytes(JNIEnv *env, jobject this, jlong addr,
+					 jarray b, jint off, jint len)
 {
-    z_stream *strm = jlong_to_ptr((*env)->GetLongField(env, this, strmID));
+    z_stream *strm = jlong_to_ptr(addr);
 
-    if (strm == 0) {
-        JNU_ThrowNullPointerException(env, 0);
-        return 0;
-    } else {
-        jarray this_buf = (*env)->GetObjectField(env, this, bufID);
-        jint this_off = (*env)->GetIntField(env, this, offID);
-        jint this_len = (*env)->GetIntField(env, this, lenID);
-        jbyte *in_buf;
-        jbyte *out_buf;
-        int res;
-        if ((*env)->GetBooleanField(env, this, setParamsID)) {
-            int level = (*env)->GetIntField(env, this, levelID);
-            int strategy = (*env)->GetIntField(env, this, strategyID);
+    jarray this_buf = (*env)->GetObjectField(env, this, bufID);
+    jint this_off = (*env)->GetIntField(env, this, offID);
+    jint this_len = (*env)->GetIntField(env, this, lenID);
+    jbyte *in_buf;
+    jbyte *out_buf;
+    int res;
+    if ((*env)->GetBooleanField(env, this, setParamsID)) {
+        int level = (*env)->GetIntField(env, this, levelID);
+	int strategy = (*env)->GetIntField(env, this, strategyID);
 
-            in_buf = (jbyte *) malloc(this_len);
-            if (in_buf == 0) {
-                return 0;
-            }
-            (*env)->GetByteArrayRegion(env, this_buf, this_off, this_len, in_buf);
+	in_buf = (jbyte *) malloc(this_len);
+	if (in_buf == 0) {
+	    JNU_ThrowOutOfMemoryError(env, 0);
+	    return 0;
+	}
+	(*env)->GetByteArrayRegion(env, this_buf, this_off, this_len, in_buf);
 
-            out_buf = (jbyte *) malloc(len);
-            if (out_buf == 0) {
-                free(in_buf);
-                return 0;
-            }
+	out_buf = (jbyte *) malloc(len);
+	if (out_buf == 0) {
+            free(in_buf);
+	    JNU_ThrowOutOfMemoryError(env, 0);
+	    return 0;
+	}
 
-            strm->next_in = (Bytef *) in_buf;
-            strm->next_out = (Bytef *) out_buf;
-            strm->avail_in = this_len;
-            strm->avail_out = len;
-            res = deflateParams(strm, level, strategy);
+	strm->next_in = (Bytef *) in_buf;
+	strm->next_out = (Bytef *) out_buf;
+	strm->avail_in = this_len;
+	strm->avail_out = len;
+	res = deflateParams(strm, level, strategy);
 
-            if (res == Z_OK) {
-                (*env)->SetByteArrayRegion(env, b, off, len - strm->avail_out, out_buf);
-            }
-            free(out_buf);
-            free(in_buf);
+	if (res == Z_OK) {
+	    (*env)->SetByteArrayRegion(env, b, off, len - strm->avail_out, out_buf);
+	}
+	free(out_buf);
+	free(in_buf);
 
-            switch (res) {
-            case Z_OK:
-                (*env)->SetBooleanField(env, this, setParamsID, JNI_FALSE);
-                this_off += this_len - strm->avail_in;
-                (*env)->SetIntField(env, this, offID, this_off);
-                (*env)->SetIntField(env, this, lenID, strm->avail_in);
-                return len - strm->avail_out;
-            case Z_BUF_ERROR:
-                (*env)->SetBooleanField(env, this, setParamsID, JNI_FALSE);
-                return 0;
-            default:
-                JNU_ThrowInternalError(env, strm->msg);
-                return 0;
-            }
-        } else {
-            jboolean finish = (*env)->GetBooleanField(env, this, finishID);
+	switch (res) {
+	case Z_OK:
+	    (*env)->SetBooleanField(env, this, setParamsID, JNI_FALSE);
+	    this_off += this_len - strm->avail_in;
+	    (*env)->SetIntField(env, this, offID, this_off);
+	    (*env)->SetIntField(env, this, lenID, strm->avail_in);
+	    return len - strm->avail_out;
+	case Z_BUF_ERROR:
+	    (*env)->SetBooleanField(env, this, setParamsID, JNI_FALSE);
+	    return 0;
+	default:
+	    JNU_ThrowInternalError(env, strm->msg);
+	    return 0;
+	}
+    } else {
+        jboolean finish = (*env)->GetBooleanField(env, this, finishID);
 
-            in_buf = (jbyte *) malloc(this_len);
-            if (in_buf == 0) {
-                return 0;
-            }
-            (*env)->GetByteArrayRegion(env, this_buf, this_off, this_len, in_buf);
+	in_buf = (jbyte *) malloc(this_len);
+	if (in_buf == 0) {
+	    JNU_ThrowOutOfMemoryError(env, 0);
+	    return 0;
+	}
+	(*env)->GetByteArrayRegion(env, this_buf, this_off, this_len, in_buf);
 
-            out_buf = (jbyte *) malloc(len);
-            if (out_buf == 0) {
-                free(in_buf);
-                return 0;
-            }
+	out_buf = (jbyte *) malloc(len);
+	if (out_buf == 0) {
+	    free(in_buf);
+	    JNU_ThrowOutOfMemoryError(env, 0);
+	    return 0;
+	}
 
-            strm->next_in = (Bytef *) in_buf;
-            strm->next_out = (Bytef *) out_buf;
-            strm->avail_in = this_len;
-            strm->avail_out = len;
-            res = deflate(strm, finish ? Z_FINISH : Z_NO_FLUSH);
+	strm->next_in = (Bytef *) in_buf;
+	strm->next_out = (Bytef *) out_buf;
+	strm->avail_in = this_len;
+	strm->avail_out = len;
+	res = deflate(strm, finish ? Z_FINISH : Z_NO_FLUSH);
 
-            if (res == Z_STREAM_END || res == Z_OK) {
-                (*env)->SetByteArrayRegion(env, b, off, len - strm->avail_out, out_buf);
-            }
-            free(out_buf);
-            free(in_buf);
+	if (res == Z_STREAM_END || res == Z_OK) {
+	    (*env)->SetByteArrayRegion(env, b, off, len - strm->avail_out, out_buf);
+	}
+	free(out_buf);
+	free(in_buf);
 
-            switch (res) {
-            case Z_STREAM_END:
-                (*env)->SetBooleanField(env, this, finishedID, JNI_TRUE);
-                /* fall through */
-            case Z_OK:
-                this_off += this_len - strm->avail_in;
-                (*env)->SetIntField(env, this, offID, this_off);
-                (*env)->SetIntField(env, this, lenID, strm->avail_in);
-                return len - strm->avail_out;
-            case Z_BUF_ERROR:
-                return 0;
-            default:
-                JNU_ThrowInternalError(env, strm->msg);
-                return 0;
-            }
-        }
+	switch (res) {
+	case Z_STREAM_END:
+	    (*env)->SetBooleanField(env, this, finishedID, JNI_TRUE);
+	    /* fall through */
+	case Z_OK:
+	    this_off += this_len - strm->avail_in;
+	    (*env)->SetIntField(env, this, offID, this_off);
+	    (*env)->SetIntField(env, this, lenID, strm->avail_in);
+	    return len - strm->avail_out;
+	case Z_BUF_ERROR:
+	    return 0;
+	default:
+	    JNU_ThrowInternalError(env, strm->msg);
+	    return 0;
+	}
     }
 }
 
 JNIEXPORT jint JNICALL
-Java_java_util_zip_Deflater_getAdler(JNIEnv *env, jclass cls, jlong strm)
+Java_java_util_zip_Deflater_getAdler(JNIEnv *env, jclass cls, jlong addr)
 {
-    return ((z_stream *)jlong_to_ptr(strm))->adler;
+    return ((z_stream *)jlong_to_ptr(addr))->adler;
 }
 
 JNIEXPORT jlong JNICALL
-Java_java_util_zip_Deflater_getBytesRead(JNIEnv *env, jclass cls, jlong strm)
+Java_java_util_zip_Deflater_getBytesRead(JNIEnv *env, jclass cls, jlong addr)
 {
-    return ((z_stream *)jlong_to_ptr(strm))->total_in;
+    return ((z_stream *)jlong_to_ptr(addr))->total_in;
 }
 
 JNIEXPORT jlong JNICALL
-Java_java_util_zip_Deflater_getBytesWritten(JNIEnv *env, jclass cls, jlong strm)
+Java_java_util_zip_Deflater_getBytesWritten(JNIEnv *env, jclass cls, jlong addr)
 {
-    return ((z_stream *)jlong_to_ptr(strm))->total_out;
+    return ((z_stream *)jlong_to_ptr(addr))->total_out;
 }
 
 JNIEXPORT void JNICALL
-Java_java_util_zip_Deflater_reset(JNIEnv *env, jclass cls, jlong strm)
+Java_java_util_zip_Deflater_reset(JNIEnv *env, jclass cls, jlong addr)
 {
-    if (deflateReset((z_stream *)jlong_to_ptr(strm)) != Z_OK) {
-        JNU_ThrowInternalError(env, 0);
+    if (deflateReset((z_stream *)jlong_to_ptr(addr)) != Z_OK) {
+	JNU_ThrowInternalError(env, 0);
     }
 }
 
 JNIEXPORT void JNICALL
-Java_java_util_zip_Deflater_end(JNIEnv *env, jclass cls, jlong strm)
+Java_java_util_zip_Deflater_end(JNIEnv *env, jclass cls, jlong addr)
 {
-    if (deflateEnd((z_stream *)jlong_to_ptr(strm)) == Z_STREAM_ERROR) {
-        JNU_ThrowInternalError(env, 0);
+    if (deflateEnd((z_stream *)jlong_to_ptr(addr)) == Z_STREAM_ERROR) {
+	JNU_ThrowInternalError(env, 0);
     } else {
-        free((z_stream *)jlong_to_ptr(strm));
+	free((z_stream *)jlong_to_ptr(addr));
     }
 }
--- openjdk.orig/jdk/src/share/native/java/util/zip/Inflater.c	Tue Nov 24 12:11:47 2009
+++ openjdk/jdk/src/share/native/java/util/zip/Inflater.c	Tue Nov 24 12:11:45 2009
@@ -1,5 +1,5 @@
 /*
- * Copyright 1997-2005 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 1996-2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,9 +39,8 @@
 #include "java_util_zip_Inflater.h"
 
 #define ThrowDataFormatException(env, msg) \
-        JNU_ThrowByName(env, "java/util/zip/DataFormatException", msg)
+	JNU_ThrowByName(env, "java/util/zip/DataFormatException", msg)
 
-static jfieldID strmID;
 static jfieldID needDictID;
 static jfieldID finishedID;
 static jfieldID bufID, offID, lenID;
@@ -49,7 +48,6 @@
 JNIEXPORT void JNICALL
 Java_java_util_zip_Inflater_initIDs(JNIEnv *env, jclass cls)
 {
-    strmID = (*env)->GetFieldID(env, cls, "strm", "J");
     needDictID = (*env)->GetFieldID(env, cls, "needDict", "Z");
     finishedID = (*env)->GetFieldID(env, cls, "finished", "Z");
     bufID = (*env)->GetFieldID(env, cls, "buf", "[B");
@@ -63,153 +61,151 @@
     z_stream *strm = calloc(1, sizeof(z_stream));
 
     if (strm == 0) {
-        JNU_ThrowOutOfMemoryError(env, 0);
-        return jlong_zero;
+	JNU_ThrowOutOfMemoryError(env, 0);
+	return jlong_zero;
     } else {
-        char *msg;
-        switch (inflateInit2(strm, nowrap ? -MAX_WBITS : MAX_WBITS)) {
-          case Z_OK:
-            return ptr_to_jlong(strm);
-          case Z_MEM_ERROR:
-            free(strm);
-            JNU_ThrowOutOfMemoryError(env, 0);
-            return jlong_zero;
-          default:
-            msg = strm->msg;
-            free(strm);
-            JNU_ThrowInternalError(env, msg);
-            return jlong_zero;
-        }
+	char *msg;
+	switch (inflateInit2(strm, nowrap ? -MAX_WBITS : MAX_WBITS)) {
+	  case Z_OK:
+	    return ptr_to_jlong(strm);
+	  case Z_MEM_ERROR:
+	    free(strm);
+	    JNU_ThrowOutOfMemoryError(env, 0);
+	    return jlong_zero;
+	  default:
+	    msg = strm->msg;
+	    free(strm);
+	    JNU_ThrowInternalError(env, msg);
+	    return jlong_zero;
+	}
     }
 }
 
 JNIEXPORT void JNICALL
-Java_java_util_zip_Inflater_setDictionary(JNIEnv *env, jclass cls, jlong strm,
-                                          jarray b, jint off, jint len)
+Java_java_util_zip_Inflater_setDictionary(JNIEnv *env, jclass cls, jlong addr,
+					  jarray b, jint off, jint len)
 {
     Bytef *buf = (*env)->GetPrimitiveArrayCritical(env, b, 0);
     int res;
     if (buf == 0) /* out of memory */
         return;
-    res = inflateSetDictionary(jlong_to_ptr(strm), buf + off, len);
+    res = inflateSetDictionary(jlong_to_ptr(addr), buf + off, len);
     (*env)->ReleasePrimitiveArrayCritical(env, b, buf, 0);
     switch (res) {
     case Z_OK:
-        break;
+	break;
     case Z_STREAM_ERROR:
     case Z_DATA_ERROR:
-        JNU_ThrowIllegalArgumentException(env, ((z_stream *)jlong_to_ptr(strm))->msg);
-        break;
+	JNU_ThrowIllegalArgumentException(env, ((z_stream *)jlong_to_ptr(addr))->msg);
+	break;
     default:
-        JNU_ThrowInternalError(env, ((z_stream *)jlong_to_ptr(strm))->msg);
-        break;
+	JNU_ThrowInternalError(env, ((z_stream *)jlong_to_ptr(addr))->msg);
+	break;
     }
 }
 
 JNIEXPORT jint JNICALL
-Java_java_util_zip_Inflater_inflateBytes(JNIEnv *env, jobject this,
-                                         jarray b, jint off, jint len)
+Java_java_util_zip_Inflater_inflateBytes(JNIEnv *env, jobject this, jlong addr,
+					 jarray b, jint off, jint len)
 {
-    z_stream *strm = jlong_to_ptr((*env)->GetLongField(env, this, strmID));
+    z_stream *strm = jlong_to_ptr(addr);
 
-    if (strm == 0) {
-        JNU_ThrowNullPointerException(env, 0);
-        return 0;
-    } else {
-        jarray this_buf = (jarray)(*env)->GetObjectField(env, this, bufID);
-        jint this_off = (*env)->GetIntField(env, this, offID);
-        jint this_len = (*env)->GetIntField(env, this, lenID);
-        jbyte *in_buf;
-        jbyte *out_buf;
-        int ret;
+    jarray this_buf = (jarray)(*env)->GetObjectField(env, this, bufID);
+    jint this_off = (*env)->GetIntField(env, this, offID);
+    jint this_len = (*env)->GetIntField(env, this, lenID);
+    jbyte *in_buf;
+    jbyte *out_buf;
+    int ret;
 
-        in_buf = (jbyte *) malloc(this_len);
-        if (in_buf == 0) {
-            return 0;
-        }
-        (*env)->GetByteArrayRegion(env, this_buf, this_off, this_len, in_buf);
+    in_buf = (jbyte *) malloc(this_len);
+    if (in_buf == 0) {
+        JNU_ThrowOutOfMemoryError(env, 0);	
+	return 0;
+    }
+    (*env)->GetByteArrayRegion(env, this_buf, this_off, this_len, in_buf);
 
-        out_buf = (jbyte *) malloc(len);
-        if (out_buf == 0) {
-            free(in_buf);
-            return 0;
-        }
+    out_buf = (jbyte *) malloc(len);
+    if (out_buf == 0) {
+        free(in_buf);
+	JNU_ThrowOutOfMemoryError(env, 0);
+	return 0;
+    }
 
-        strm->next_in  = (Bytef *) in_buf;
-        strm->next_out = (Bytef *) out_buf;
-        strm->avail_in  = this_len;
-        strm->avail_out = len;
-        ret = inflate(strm, Z_PARTIAL_FLUSH);
+    strm->next_in  = (Bytef *) in_buf;
+    strm->next_out = (Bytef *) out_buf;
+    strm->avail_in  = this_len;
+    strm->avail_out = len;
+    ret = inflate(strm, Z_PARTIAL_FLUSH);
 
-        if (ret == Z_STREAM_END || ret == Z_OK) {
-            (*env)->SetByteArrayRegion(env, b, off, len - strm->avail_out, out_buf);
-        }
-        free(out_buf);
-        free(in_buf);
+    if (ret == Z_STREAM_END || ret == Z_OK) {
+        (*env)->SetByteArrayRegion(env, b, off, len - strm->avail_out, out_buf);
+    }
+    free(out_buf);
+    free(in_buf);
 
-        switch (ret) {
-        case Z_STREAM_END:
-            (*env)->SetBooleanField(env, this, finishedID, JNI_TRUE);
-            /* fall through */
-        case Z_OK:
-            this_off += this_len - strm->avail_in;
-            (*env)->SetIntField(env, this, offID, this_off);
-            (*env)->SetIntField(env, this, lenID, strm->avail_in);
-            return len - strm->avail_out;
-        case Z_NEED_DICT:
-            (*env)->SetBooleanField(env, this, needDictID, JNI_TRUE);
-            /* Might have consumed some input here! */
-            this_off += this_len - strm->avail_in;
-            (*env)->SetIntField(env, this, offID, this_off);
-            (*env)->SetIntField(env, this, lenID, strm->avail_in);
-            return 0;
-        case Z_BUF_ERROR:
-            return 0;
-        case Z_DATA_ERROR:
-            ThrowDataFormatException(env, strm->msg);
-            return 0;
-        case Z_MEM_ERROR:
-            JNU_ThrowOutOfMemoryError(env, 0);
-            return 0;
-        default:
-            JNU_ThrowInternalError(env, strm->msg);
-            return 0;
-        }
+    switch (ret) {
+    case Z_STREAM_END:
+        (*env)->SetBooleanField(env, this, finishedID, JNI_TRUE);
+	/* fall through */
+    case Z_OK:
+        this_off += this_len - strm->avail_in;
+	(*env)->SetIntField(env, this, offID, this_off);
+	(*env)->SetIntField(env, this, lenID, strm->avail_in);
+	return len - strm->avail_out;
+    case Z_NEED_DICT:
+        (*env)->SetBooleanField(env, this, needDictID, JNI_TRUE);
+	/* Might have consumed some input here! */
+	this_off += this_len - strm->avail_in;
+	(*env)->SetIntField(env, this, offID, this_off);
+	(*env)->SetIntField(env, this, lenID, strm->avail_in);
+	return 0;
+    case Z_BUF_ERROR:
+        return 0;
+    case Z_DATA_ERROR:
+        ThrowDataFormatException(env, strm->msg);
+	return 0;
+    case Z_MEM_ERROR:
+        JNU_ThrowOutOfMemoryError(env, 0);
+	return 0;
+    default:
+        JNU_ThrowInternalError(env, strm->msg);
+	return 0;
     }
 }
 
 JNIEXPORT jint JNICALL
-Java_java_util_zip_Inflater_getAdler(JNIEnv *env, jclass cls, jlong strm)
+Java_java_util_zip_Inflater_getAdler(JNIEnv *env, jclass cls, jlong addr)
 {
-    return ((z_stream *)jlong_to_ptr(strm))->adler;
+    return ((z_stream *)jlong_to_ptr(addr))->adler;
 }
 
 JNIEXPORT jlong JNICALL
-Java_java_util_zip_Inflater_getBytesRead(JNIEnv *env, jclass cls, jlong strm)
+Java_java_util_zip_Inflater_getBytesRead(JNIEnv *env, jclass cls, jlong addr)
 {
-    return ((z_stream *)jlong_to_ptr(strm))->total_in;
+    return ((z_stream *)jlong_to_ptr(addr))->total_in;
 }
 
 JNIEXPORT jlong JNICALL
-Java_java_util_zip_Inflater_getBytesWritten(JNIEnv *env, jclass cls, jlong strm)
+Java_java_util_zip_Inflater_getBytesWritten(JNIEnv *env, jclass cls, jlong addr)
 {
-    return ((z_stream *)jlong_to_ptr(strm))->total_out;
+    return ((z_stream *)jlong_to_ptr(addr))->total_out;
 }
 
 JNIEXPORT void JNICALL
-Java_java_util_zip_Inflater_reset(JNIEnv *env, jclass cls, jlong strm)
+Java_java_util_zip_Inflater_reset(JNIEnv *env, jclass cls, jlong addr)
 {
-    if (inflateReset(jlong_to_ptr(strm)) != Z_OK) {
-        JNU_ThrowInternalError(env, 0);
+    if (inflateReset(jlong_to_ptr(addr)) != Z_OK) {
+	JNU_ThrowInternalError(env, 0);
     }
 }
 
 JNIEXPORT void JNICALL
-Java_java_util_zip_Inflater_end(JNIEnv *env, jclass cls, jlong strm)
+Java_java_util_zip_Inflater_end(JNIEnv *env, jclass cls, jlong addr)
 {
-    if (inflateEnd(jlong_to_ptr(strm)) == Z_STREAM_ERROR) {
-        JNU_ThrowInternalError(env, 0);
+    if (inflateEnd(jlong_to_ptr(addr)) == Z_STREAM_ERROR) {
+	JNU_ThrowInternalError(env, 0);
     } else {
-        free(jlong_to_ptr(strm));
+	free(jlong_to_ptr(addr));
     }
 }
+
